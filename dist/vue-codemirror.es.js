var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop2 in b || (b = {}))
    if (__hasOwnProp.call(b, prop2))
      __defNormalProp(a, prop2, b[prop2]);
  if (__getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop2))
        __defNormalProp(a, prop2, b[prop2]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { openBlock, createElementBlock, createElementVNode, defineComponent, computed, onMounted, resolveComponent, normalizeStyle, toDisplayString, createVNode, renderSlot, createCommentVNode, ref, withDirectives, vModelText, createTextVNode, nextTick, Fragment, renderList, pushScopeId, popScopeId, watch, normalizeClass, withCtx } from "vue";
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i$2 = 0; i$2 < 256; ++i$2) {
  byteToHex.push((i$2 + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify(rnds);
}
const _hoisted_1$a = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$8 = /* @__PURE__ */ createElementVNode("path", {
  d: "m580.88 509.583 373.309-373.31c18.867-18.871 18.867-49.847 0-68.72l-2.048-2.048c-18.867-18.867-49.843-18.867-68.71 0L510.11 439.296 136.806 65.352c-18.872-18.868-49.848-18.868-68.72 0L66.043 67.4a47.944 47.944 0 0 0 0 68.71l373.31 373.473-373.305 373.31c-18.867 18.867-18.867 49.848 0 68.715l2.048 2.048c18.867 18.868 49.843 18.868 68.71 0l373.315-373.314 373.31 373.314c18.872 18.868 49.848 18.868 68.72 0l2.043-2.048c18.872-18.867 18.872-49.848 0-68.715l-373.31-373.31z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$7 = [
  _hoisted_2$8
];
function render$4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_3$7);
}
var IconRemove = { render: render$4 };
var dialog_vue_vue_type_style_index_0_scoped_true_lang = "";
var dialog_vue_vue_type_style_index_1_lang = "";
var _export_sfc = (sfc, props) => {
  const target2 = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target2[key] = val;
  }
  return target2;
};
const _sfc_main$5 = defineComponent({
  components: {
    IconRemove
  },
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: ""
    },
    width: {
      type: String,
      default: ""
    }
  },
  setup(props, ctx) {
    const style = computed(() => {
      return props.width ? {
        width: "100%",
        maxWidth: props.width
      } : {
        width: "100%",
        maxWidth: "400px"
      };
    });
    const keyupHandler = (e) => {
      if (e.key === "Escape") {
        ctx.emit("update:modelValue", false);
      }
    };
    onMounted(() => {
      document.addEventListener("keyup", keyupHandler);
    });
    return {
      style
    };
  }
});
const _hoisted_1$9 = {
  key: 0,
  class: "editor-dialog"
};
const _hoisted_2$7 = { class: "title" };
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconRemove = resolveComponent("IconRemove");
  return _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$9, [
    createElementVNode("div", {
      class: "content",
      style: normalizeStyle(_ctx.style)
    }, [
      createElementVNode("div", _hoisted_2$7, [
        createElementVNode("span", null, toDisplayString(_ctx.title), 1),
        createElementVNode("button", {
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", !_ctx.modelValue)),
          class: "btn-close"
        }, [
          createVNode(_component_IconRemove)
        ])
      ]),
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ], 4)
  ])) : createCommentVNode("", true);
}
var EditorDialog = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-5a443ff8"]]);
const _hoisted_1$8 = {
  viewBox: "0 0 48 48",
  width: "16",
  height: "16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  stroke: "currentColor",
  "stroke-width": "4"
};
const _hoisted_2$6 = /* @__PURE__ */ createElementVNode("path", { d: "M14.93 17.071 24.001 8l9.071 9.071m-9.07 16.071v-25M40 35v6H8v-6" }, null, -1);
const _hoisted_3$6 = [
  _hoisted_2$6
];
function render$3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$8, _hoisted_3$6);
}
var IconUpload = { render: render$3 };
const _sfc_main$4 = defineComponent({
  components: {
    IconUpload
  },
  props: {
    uploadUrl: {
      type: String,
      default: "/file/upload"
    },
    uploadSuccess: {
      type: Function,
      default: () => {
        return (result) => {
          return result.data.domain + result.data.filepath;
        };
      }
    },
    uploadFail: {
      type: Function,
      default: () => {
        return (error) => {
          console.error(error);
        };
      }
    }
  },
  setup(props, ctx) {
    const url = ref("");
    const desc = ref("");
    const fileId = "toolbar-media-file";
    return {
      url,
      desc,
      triggerClick() {
        const fileField = document.querySelector("input#" + fileId);
        if (fileField) {
          fileField.click();
        }
      },
      upload() {
        const formData = new FormData();
        const fileField = document.querySelector("input#" + fileId);
        if (fileField && fileField.files && fileField.files[0]) {
          formData.append("file", fileField.files[0]);
          fetch(props.uploadUrl, {
            method: "post",
            body: formData
          }).then((response) => response.json()).then((result) => {
            url.value = props.uploadSuccess()(result);
          }).catch((error) => {
            props.uploadFail()(error);
          }).then(() => {
            fileField.value = "";
          });
        }
      },
      handler() {
        ctx.emit("done", url.value, desc.value);
      }
    };
  }
});
const _hoisted_1$7 = { class: "editor-dialog-form" };
const _hoisted_2$5 = { class: "form-item" };
const _hoisted_3$5 = /* @__PURE__ */ createElementVNode("label", { for: "toolbar-media-url" }, "\u5730\u5740", -1);
const _hoisted_4$3 = { class: "upload-btn" };
const _hoisted_5$2 = /* @__PURE__ */ createTextVNode(" \u672C\u5730\u4E0A\u4F20 ");
const _hoisted_6$1 = { class: "form-item" };
const _hoisted_7 = /* @__PURE__ */ createElementVNode("label", { for: "toolbar-media-desc" }, "\u63CF\u8FF0", -1);
const _hoisted_8 = { class: "form-item form-item-submit" };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconUpload = resolveComponent("IconUpload");
  return openBlock(), createElementBlock("div", _hoisted_1$7, [
    createElementVNode("div", _hoisted_2$5, [
      _hoisted_3$5,
      withDirectives(createElementVNode("input", {
        type: "text",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.url = $event),
        id: "toolbar-media-url"
      }, null, 512), [
        [vModelText, _ctx.url]
      ]),
      createElementVNode("div", _hoisted_4$3, [
        createElementVNode("input", {
          type: "file",
          name: "file",
          ref: "fileField",
          id: "toolbar-media-file",
          onChange: _cache[1] || (_cache[1] = (...args) => _ctx.upload && _ctx.upload(...args))
        }, null, 544),
        createElementVNode("button", {
          type: "button",
          class: "upload-btn",
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.triggerClick && _ctx.triggerClick(...args))
        }, [
          createVNode(_component_IconUpload),
          _hoisted_5$2
        ])
      ])
    ]),
    createElementVNode("div", _hoisted_6$1, [
      _hoisted_7,
      withDirectives(createElementVNode("input", {
        type: "text",
        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.desc = $event),
        id: "toolbar-media-desc"
      }, null, 512), [
        [vModelText, _ctx.desc]
      ])
    ]),
    createElementVNode("div", _hoisted_8, [
      createElementVNode("button", {
        type: "button",
        class: "submit-btn",
        onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handler && _ctx.handler(...args))
      }, "\u786E\u5B9A")
    ])
  ]);
}
var EditorUpload = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
const _sfc_main$3 = defineComponent({
  setup(props, ctx) {
    const cols = ref(1);
    const rows = ref(1);
    return {
      cols,
      rows,
      handler() {
        ctx.emit("done", cols.value, rows.value);
      }
    };
  }
});
const _hoisted_1$6 = { class: "editor-dialog-form" };
const _hoisted_2$4 = { class: "form-item" };
const _hoisted_3$4 = /* @__PURE__ */ createElementVNode("label", { for: "toolbar-col" }, "\u5217\u6570", -1);
const _hoisted_4$2 = { class: "form-item" };
const _hoisted_5$1 = /* @__PURE__ */ createElementVNode("label", { for: "toolbar-row" }, "\u884C\u6570", -1);
const _hoisted_6 = { class: "form-item form-item-submit" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$6, [
    createElementVNode("div", _hoisted_2$4, [
      _hoisted_3$4,
      withDirectives(createElementVNode("input", {
        type: "number",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.cols = $event),
        id: "toolbar-col"
      }, null, 512), [
        [vModelText, _ctx.cols]
      ])
    ]),
    createElementVNode("div", _hoisted_4$2, [
      _hoisted_5$1,
      withDirectives(createElementVNode("input", {
        type: "number",
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.rows = $event),
        id: "toolbar-row"
      }, null, 512), [
        [vModelText, _ctx.rows]
      ])
    ]),
    createElementVNode("div", _hoisted_6, [
      createElementVNode("button", {
        type: "button",
        class: "submit-btn",
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handler && _ctx.handler(...args))
      }, "\u786E\u5B9A")
    ])
  ]);
}
var EditorTable = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var utils$1 = {};
const Aacute = "\xC1";
const aacute = "\xE1";
const Abreve = "\u0102";
const abreve = "\u0103";
const ac = "\u223E";
const acd = "\u223F";
const acE = "\u223E\u0333";
const Acirc = "\xC2";
const acirc = "\xE2";
const acute = "\xB4";
const Acy = "\u0410";
const acy = "\u0430";
const AElig = "\xC6";
const aelig = "\xE6";
const af = "\u2061";
const Afr = "\u{1D504}";
const afr = "\u{1D51E}";
const Agrave = "\xC0";
const agrave = "\xE0";
const alefsym = "\u2135";
const aleph = "\u2135";
const Alpha = "\u0391";
const alpha = "\u03B1";
const Amacr = "\u0100";
const amacr = "\u0101";
const amalg = "\u2A3F";
const amp = "&";
const AMP = "&";
const andand = "\u2A55";
const And = "\u2A53";
const and = "\u2227";
const andd = "\u2A5C";
const andslope = "\u2A58";
const andv = "\u2A5A";
const ang = "\u2220";
const ange = "\u29A4";
const angle = "\u2220";
const angmsdaa = "\u29A8";
const angmsdab = "\u29A9";
const angmsdac = "\u29AA";
const angmsdad = "\u29AB";
const angmsdae = "\u29AC";
const angmsdaf = "\u29AD";
const angmsdag = "\u29AE";
const angmsdah = "\u29AF";
const angmsd = "\u2221";
const angrt = "\u221F";
const angrtvb = "\u22BE";
const angrtvbd = "\u299D";
const angsph = "\u2222";
const angst = "\xC5";
const angzarr = "\u237C";
const Aogon = "\u0104";
const aogon = "\u0105";
const Aopf = "\u{1D538}";
const aopf = "\u{1D552}";
const apacir = "\u2A6F";
const ap = "\u2248";
const apE = "\u2A70";
const ape = "\u224A";
const apid = "\u224B";
const apos = "'";
const ApplyFunction = "\u2061";
const approx = "\u2248";
const approxeq = "\u224A";
const Aring = "\xC5";
const aring = "\xE5";
const Ascr = "\u{1D49C}";
const ascr = "\u{1D4B6}";
const Assign = "\u2254";
const ast = "*";
const asymp = "\u2248";
const asympeq = "\u224D";
const Atilde = "\xC3";
const atilde = "\xE3";
const Auml = "\xC4";
const auml = "\xE4";
const awconint = "\u2233";
const awint = "\u2A11";
const backcong = "\u224C";
const backepsilon = "\u03F6";
const backprime = "\u2035";
const backsim = "\u223D";
const backsimeq = "\u22CD";
const Backslash = "\u2216";
const Barv = "\u2AE7";
const barvee = "\u22BD";
const barwed = "\u2305";
const Barwed = "\u2306";
const barwedge = "\u2305";
const bbrk = "\u23B5";
const bbrktbrk = "\u23B6";
const bcong = "\u224C";
const Bcy = "\u0411";
const bcy = "\u0431";
const bdquo = "\u201E";
const becaus = "\u2235";
const because = "\u2235";
const Because = "\u2235";
const bemptyv = "\u29B0";
const bepsi = "\u03F6";
const bernou = "\u212C";
const Bernoullis = "\u212C";
const Beta = "\u0392";
const beta = "\u03B2";
const beth = "\u2136";
const between = "\u226C";
const Bfr = "\u{1D505}";
const bfr = "\u{1D51F}";
const bigcap = "\u22C2";
const bigcirc = "\u25EF";
const bigcup = "\u22C3";
const bigodot = "\u2A00";
const bigoplus = "\u2A01";
const bigotimes = "\u2A02";
const bigsqcup = "\u2A06";
const bigstar = "\u2605";
const bigtriangledown = "\u25BD";
const bigtriangleup = "\u25B3";
const biguplus = "\u2A04";
const bigvee = "\u22C1";
const bigwedge = "\u22C0";
const bkarow = "\u290D";
const blacklozenge = "\u29EB";
const blacksquare = "\u25AA";
const blacktriangle = "\u25B4";
const blacktriangledown = "\u25BE";
const blacktriangleleft = "\u25C2";
const blacktriangleright = "\u25B8";
const blank = "\u2423";
const blk12 = "\u2592";
const blk14 = "\u2591";
const blk34 = "\u2593";
const block$1 = "\u2588";
const bne = "=\u20E5";
const bnequiv = "\u2261\u20E5";
const bNot = "\u2AED";
const bnot = "\u2310";
const Bopf = "\u{1D539}";
const bopf = "\u{1D553}";
const bot = "\u22A5";
const bottom = "\u22A5";
const bowtie = "\u22C8";
const boxbox = "\u29C9";
const boxdl = "\u2510";
const boxdL = "\u2555";
const boxDl = "\u2556";
const boxDL = "\u2557";
const boxdr = "\u250C";
const boxdR = "\u2552";
const boxDr = "\u2553";
const boxDR = "\u2554";
const boxh = "\u2500";
const boxH = "\u2550";
const boxhd = "\u252C";
const boxHd = "\u2564";
const boxhD = "\u2565";
const boxHD = "\u2566";
const boxhu = "\u2534";
const boxHu = "\u2567";
const boxhU = "\u2568";
const boxHU = "\u2569";
const boxminus = "\u229F";
const boxplus = "\u229E";
const boxtimes = "\u22A0";
const boxul = "\u2518";
const boxuL = "\u255B";
const boxUl = "\u255C";
const boxUL = "\u255D";
const boxur = "\u2514";
const boxuR = "\u2558";
const boxUr = "\u2559";
const boxUR = "\u255A";
const boxv = "\u2502";
const boxV = "\u2551";
const boxvh = "\u253C";
const boxvH = "\u256A";
const boxVh = "\u256B";
const boxVH = "\u256C";
const boxvl = "\u2524";
const boxvL = "\u2561";
const boxVl = "\u2562";
const boxVL = "\u2563";
const boxvr = "\u251C";
const boxvR = "\u255E";
const boxVr = "\u255F";
const boxVR = "\u2560";
const bprime = "\u2035";
const breve = "\u02D8";
const Breve = "\u02D8";
const brvbar = "\xA6";
const bscr = "\u{1D4B7}";
const Bscr = "\u212C";
const bsemi = "\u204F";
const bsim = "\u223D";
const bsime = "\u22CD";
const bsolb = "\u29C5";
const bsol = "\\";
const bsolhsub = "\u27C8";
const bull = "\u2022";
const bullet = "\u2022";
const bump = "\u224E";
const bumpE = "\u2AAE";
const bumpe = "\u224F";
const Bumpeq = "\u224E";
const bumpeq = "\u224F";
const Cacute = "\u0106";
const cacute = "\u0107";
const capand = "\u2A44";
const capbrcup = "\u2A49";
const capcap = "\u2A4B";
const cap = "\u2229";
const Cap = "\u22D2";
const capcup = "\u2A47";
const capdot = "\u2A40";
const CapitalDifferentialD = "\u2145";
const caps = "\u2229\uFE00";
const caret = "\u2041";
const caron = "\u02C7";
const Cayleys = "\u212D";
const ccaps = "\u2A4D";
const Ccaron = "\u010C";
const ccaron = "\u010D";
const Ccedil = "\xC7";
const ccedil = "\xE7";
const Ccirc = "\u0108";
const ccirc = "\u0109";
const Cconint = "\u2230";
const ccups = "\u2A4C";
const ccupssm = "\u2A50";
const Cdot = "\u010A";
const cdot = "\u010B";
const cedil = "\xB8";
const Cedilla = "\xB8";
const cemptyv = "\u29B2";
const cent = "\xA2";
const centerdot = "\xB7";
const CenterDot = "\xB7";
const cfr = "\u{1D520}";
const Cfr = "\u212D";
const CHcy = "\u0427";
const chcy = "\u0447";
const check = "\u2713";
const checkmark = "\u2713";
const Chi = "\u03A7";
const chi = "\u03C7";
const circ = "\u02C6";
const circeq = "\u2257";
const circlearrowleft = "\u21BA";
const circlearrowright = "\u21BB";
const circledast = "\u229B";
const circledcirc = "\u229A";
const circleddash = "\u229D";
const CircleDot = "\u2299";
const circledR = "\xAE";
const circledS = "\u24C8";
const CircleMinus = "\u2296";
const CirclePlus = "\u2295";
const CircleTimes = "\u2297";
const cir = "\u25CB";
const cirE = "\u29C3";
const cire = "\u2257";
const cirfnint = "\u2A10";
const cirmid = "\u2AEF";
const cirscir = "\u29C2";
const ClockwiseContourIntegral = "\u2232";
const CloseCurlyDoubleQuote = "\u201D";
const CloseCurlyQuote = "\u2019";
const clubs = "\u2663";
const clubsuit = "\u2663";
const colon$1 = ":";
const Colon = "\u2237";
const Colone = "\u2A74";
const colone = "\u2254";
const coloneq = "\u2254";
const comma = ",";
const commat = "@";
const comp = "\u2201";
const compfn = "\u2218";
const complement = "\u2201";
const complexes = "\u2102";
const cong = "\u2245";
const congdot = "\u2A6D";
const Congruent = "\u2261";
const conint = "\u222E";
const Conint = "\u222F";
const ContourIntegral = "\u222E";
const copf = "\u{1D554}";
const Copf = "\u2102";
const coprod = "\u2210";
const Coproduct = "\u2210";
const copy = "\xA9";
const COPY = "\xA9";
const copysr = "\u2117";
const CounterClockwiseContourIntegral = "\u2233";
const crarr = "\u21B5";
const cross = "\u2717";
const Cross = "\u2A2F";
const Cscr = "\u{1D49E}";
const cscr = "\u{1D4B8}";
const csub = "\u2ACF";
const csube = "\u2AD1";
const csup = "\u2AD0";
const csupe = "\u2AD2";
const ctdot = "\u22EF";
const cudarrl = "\u2938";
const cudarrr = "\u2935";
const cuepr = "\u22DE";
const cuesc = "\u22DF";
const cularr = "\u21B6";
const cularrp = "\u293D";
const cupbrcap = "\u2A48";
const cupcap = "\u2A46";
const CupCap = "\u224D";
const cup = "\u222A";
const Cup = "\u22D3";
const cupcup = "\u2A4A";
const cupdot = "\u228D";
const cupor = "\u2A45";
const cups = "\u222A\uFE00";
const curarr = "\u21B7";
const curarrm = "\u293C";
const curlyeqprec = "\u22DE";
const curlyeqsucc = "\u22DF";
const curlyvee = "\u22CE";
const curlywedge = "\u22CF";
const curren = "\xA4";
const curvearrowleft = "\u21B6";
const curvearrowright = "\u21B7";
const cuvee = "\u22CE";
const cuwed = "\u22CF";
const cwconint = "\u2232";
const cwint = "\u2231";
const cylcty = "\u232D";
const dagger = "\u2020";
const Dagger = "\u2021";
const daleth = "\u2138";
const darr = "\u2193";
const Darr = "\u21A1";
const dArr = "\u21D3";
const dash$1 = "\u2010";
const Dashv = "\u2AE4";
const dashv = "\u22A3";
const dbkarow = "\u290F";
const dblac = "\u02DD";
const Dcaron = "\u010E";
const dcaron = "\u010F";
const Dcy = "\u0414";
const dcy = "\u0434";
const ddagger = "\u2021";
const ddarr = "\u21CA";
const DD = "\u2145";
const dd = "\u2146";
const DDotrahd = "\u2911";
const ddotseq = "\u2A77";
const deg = "\xB0";
const Del = "\u2207";
const Delta = "\u0394";
const delta = "\u03B4";
const demptyv = "\u29B1";
const dfisht = "\u297F";
const Dfr = "\u{1D507}";
const dfr = "\u{1D521}";
const dHar = "\u2965";
const dharl = "\u21C3";
const dharr = "\u21C2";
const DiacriticalAcute = "\xB4";
const DiacriticalDot = "\u02D9";
const DiacriticalDoubleAcute = "\u02DD";
const DiacriticalGrave = "`";
const DiacriticalTilde = "\u02DC";
const diam = "\u22C4";
const diamond = "\u22C4";
const Diamond = "\u22C4";
const diamondsuit = "\u2666";
const diams = "\u2666";
const die = "\xA8";
const DifferentialD = "\u2146";
const digamma = "\u03DD";
const disin = "\u22F2";
const div = "\xF7";
const divide = "\xF7";
const divideontimes = "\u22C7";
const divonx = "\u22C7";
const DJcy = "\u0402";
const djcy = "\u0452";
const dlcorn = "\u231E";
const dlcrop = "\u230D";
const dollar$1 = "$";
const Dopf = "\u{1D53B}";
const dopf = "\u{1D555}";
const Dot = "\xA8";
const dot = "\u02D9";
const DotDot = "\u20DC";
const doteq = "\u2250";
const doteqdot = "\u2251";
const DotEqual = "\u2250";
const dotminus = "\u2238";
const dotplus = "\u2214";
const dotsquare = "\u22A1";
const doublebarwedge = "\u2306";
const DoubleContourIntegral = "\u222F";
const DoubleDot = "\xA8";
const DoubleDownArrow = "\u21D3";
const DoubleLeftArrow = "\u21D0";
const DoubleLeftRightArrow = "\u21D4";
const DoubleLeftTee = "\u2AE4";
const DoubleLongLeftArrow = "\u27F8";
const DoubleLongLeftRightArrow = "\u27FA";
const DoubleLongRightArrow = "\u27F9";
const DoubleRightArrow = "\u21D2";
const DoubleRightTee = "\u22A8";
const DoubleUpArrow = "\u21D1";
const DoubleUpDownArrow = "\u21D5";
const DoubleVerticalBar = "\u2225";
const DownArrowBar = "\u2913";
const downarrow = "\u2193";
const DownArrow = "\u2193";
const Downarrow = "\u21D3";
const DownArrowUpArrow = "\u21F5";
const DownBreve = "\u0311";
const downdownarrows = "\u21CA";
const downharpoonleft = "\u21C3";
const downharpoonright = "\u21C2";
const DownLeftRightVector = "\u2950";
const DownLeftTeeVector = "\u295E";
const DownLeftVectorBar = "\u2956";
const DownLeftVector = "\u21BD";
const DownRightTeeVector = "\u295F";
const DownRightVectorBar = "\u2957";
const DownRightVector = "\u21C1";
const DownTeeArrow = "\u21A7";
const DownTee = "\u22A4";
const drbkarow = "\u2910";
const drcorn = "\u231F";
const drcrop = "\u230C";
const Dscr = "\u{1D49F}";
const dscr = "\u{1D4B9}";
const DScy = "\u0405";
const dscy = "\u0455";
const dsol = "\u29F6";
const Dstrok = "\u0110";
const dstrok = "\u0111";
const dtdot = "\u22F1";
const dtri = "\u25BF";
const dtrif = "\u25BE";
const duarr = "\u21F5";
const duhar = "\u296F";
const dwangle = "\u29A6";
const DZcy = "\u040F";
const dzcy = "\u045F";
const dzigrarr = "\u27FF";
const Eacute = "\xC9";
const eacute = "\xE9";
const easter = "\u2A6E";
const Ecaron = "\u011A";
const ecaron = "\u011B";
const Ecirc = "\xCA";
const ecirc = "\xEA";
const ecir = "\u2256";
const ecolon = "\u2255";
const Ecy = "\u042D";
const ecy = "\u044D";
const eDDot = "\u2A77";
const Edot = "\u0116";
const edot = "\u0117";
const eDot = "\u2251";
const ee = "\u2147";
const efDot = "\u2252";
const Efr = "\u{1D508}";
const efr = "\u{1D522}";
const eg = "\u2A9A";
const Egrave = "\xC8";
const egrave = "\xE8";
const egs = "\u2A96";
const egsdot = "\u2A98";
const el = "\u2A99";
const Element$3 = "\u2208";
const elinters = "\u23E7";
const ell = "\u2113";
const els = "\u2A95";
const elsdot = "\u2A97";
const Emacr = "\u0112";
const emacr = "\u0113";
const empty$1 = "\u2205";
const emptyset = "\u2205";
const EmptySmallSquare = "\u25FB";
const emptyv = "\u2205";
const EmptyVerySmallSquare = "\u25AB";
const emsp13 = "\u2004";
const emsp14 = "\u2005";
const emsp = "\u2003";
const ENG = "\u014A";
const eng = "\u014B";
const ensp = "\u2002";
const Eogon = "\u0118";
const eogon = "\u0119";
const Eopf = "\u{1D53C}";
const eopf = "\u{1D556}";
const epar = "\u22D5";
const eparsl = "\u29E3";
const eplus = "\u2A71";
const epsi = "\u03B5";
const Epsilon$1 = "\u0395";
const epsilon = "\u03B5";
const epsiv = "\u03F5";
const eqcirc = "\u2256";
const eqcolon = "\u2255";
const eqsim = "\u2242";
const eqslantgtr = "\u2A96";
const eqslantless = "\u2A95";
const Equal = "\u2A75";
const equals = "=";
const EqualTilde = "\u2242";
const equest = "\u225F";
const Equilibrium = "\u21CC";
const equiv = "\u2261";
const equivDD = "\u2A78";
const eqvparsl = "\u29E5";
const erarr = "\u2971";
const erDot = "\u2253";
const escr = "\u212F";
const Escr = "\u2130";
const esdot = "\u2250";
const Esim = "\u2A73";
const esim = "\u2242";
const Eta = "\u0397";
const eta = "\u03B7";
const ETH = "\xD0";
const eth = "\xF0";
const Euml = "\xCB";
const euml = "\xEB";
const euro = "\u20AC";
const excl = "!";
const exist = "\u2203";
const Exists = "\u2203";
const expectation = "\u2130";
const exponentiale = "\u2147";
const ExponentialE = "\u2147";
const fallingdotseq = "\u2252";
const Fcy = "\u0424";
const fcy = "\u0444";
const female = "\u2640";
const ffilig = "\uFB03";
const fflig = "\uFB00";
const ffllig = "\uFB04";
const Ffr = "\u{1D509}";
const ffr = "\u{1D523}";
const filig = "\uFB01";
const FilledSmallSquare = "\u25FC";
const FilledVerySmallSquare = "\u25AA";
const fjlig = "fj";
const flat = "\u266D";
const fllig = "\uFB02";
const fltns = "\u25B1";
const fnof = "\u0192";
const Fopf = "\u{1D53D}";
const fopf = "\u{1D557}";
const forall = "\u2200";
const ForAll = "\u2200";
const fork = "\u22D4";
const forkv = "\u2AD9";
const Fouriertrf = "\u2131";
const fpartint = "\u2A0D";
const frac12 = "\xBD";
const frac13 = "\u2153";
const frac14 = "\xBC";
const frac15 = "\u2155";
const frac16 = "\u2159";
const frac18 = "\u215B";
const frac23 = "\u2154";
const frac25 = "\u2156";
const frac34 = "\xBE";
const frac35 = "\u2157";
const frac38 = "\u215C";
const frac45 = "\u2158";
const frac56 = "\u215A";
const frac58 = "\u215D";
const frac78 = "\u215E";
const frasl = "\u2044";
const frown = "\u2322";
const fscr = "\u{1D4BB}";
const Fscr = "\u2131";
const gacute = "\u01F5";
const Gamma = "\u0393";
const gamma = "\u03B3";
const Gammad = "\u03DC";
const gammad = "\u03DD";
const gap = "\u2A86";
const Gbreve = "\u011E";
const gbreve = "\u011F";
const Gcedil = "\u0122";
const Gcirc = "\u011C";
const gcirc = "\u011D";
const Gcy = "\u0413";
const gcy = "\u0433";
const Gdot = "\u0120";
const gdot = "\u0121";
const ge = "\u2265";
const gE = "\u2267";
const gEl = "\u2A8C";
const gel = "\u22DB";
const geq = "\u2265";
const geqq = "\u2267";
const geqslant = "\u2A7E";
const gescc = "\u2AA9";
const ges = "\u2A7E";
const gesdot = "\u2A80";
const gesdoto = "\u2A82";
const gesdotol = "\u2A84";
const gesl = "\u22DB\uFE00";
const gesles = "\u2A94";
const Gfr = "\u{1D50A}";
const gfr = "\u{1D524}";
const gg = "\u226B";
const Gg = "\u22D9";
const ggg = "\u22D9";
const gimel = "\u2137";
const GJcy = "\u0403";
const gjcy = "\u0453";
const gla = "\u2AA5";
const gl = "\u2277";
const glE = "\u2A92";
const glj = "\u2AA4";
const gnap = "\u2A8A";
const gnapprox = "\u2A8A";
const gne = "\u2A88";
const gnE = "\u2269";
const gneq = "\u2A88";
const gneqq = "\u2269";
const gnsim = "\u22E7";
const Gopf = "\u{1D53E}";
const gopf = "\u{1D558}";
const grave = "`";
const GreaterEqual = "\u2265";
const GreaterEqualLess = "\u22DB";
const GreaterFullEqual = "\u2267";
const GreaterGreater = "\u2AA2";
const GreaterLess = "\u2277";
const GreaterSlantEqual = "\u2A7E";
const GreaterTilde = "\u2273";
const Gscr = "\u{1D4A2}";
const gscr = "\u210A";
const gsim = "\u2273";
const gsime = "\u2A8E";
const gsiml = "\u2A90";
const gtcc = "\u2AA7";
const gtcir = "\u2A7A";
const gt = ">";
const GT = ">";
const Gt = "\u226B";
const gtdot = "\u22D7";
const gtlPar = "\u2995";
const gtquest = "\u2A7C";
const gtrapprox = "\u2A86";
const gtrarr = "\u2978";
const gtrdot = "\u22D7";
const gtreqless = "\u22DB";
const gtreqqless = "\u2A8C";
const gtrless = "\u2277";
const gtrsim = "\u2273";
const gvertneqq = "\u2269\uFE00";
const gvnE = "\u2269\uFE00";
const Hacek = "\u02C7";
const hairsp = "\u200A";
const half = "\xBD";
const hamilt = "\u210B";
const HARDcy = "\u042A";
const hardcy = "\u044A";
const harrcir = "\u2948";
const harr = "\u2194";
const hArr = "\u21D4";
const harrw = "\u21AD";
const Hat = "^";
const hbar = "\u210F";
const Hcirc = "\u0124";
const hcirc = "\u0125";
const hearts = "\u2665";
const heartsuit = "\u2665";
const hellip = "\u2026";
const hercon = "\u22B9";
const hfr = "\u{1D525}";
const Hfr = "\u210C";
const HilbertSpace = "\u210B";
const hksearow = "\u2925";
const hkswarow = "\u2926";
const hoarr = "\u21FF";
const homtht = "\u223B";
const hookleftarrow = "\u21A9";
const hookrightarrow = "\u21AA";
const hopf = "\u{1D559}";
const Hopf = "\u210D";
const horbar = "\u2015";
const HorizontalLine = "\u2500";
const hscr = "\u{1D4BD}";
const Hscr = "\u210B";
const hslash = "\u210F";
const Hstrok = "\u0126";
const hstrok = "\u0127";
const HumpDownHump = "\u224E";
const HumpEqual = "\u224F";
const hybull = "\u2043";
const hyphen = "\u2010";
const Iacute = "\xCD";
const iacute = "\xED";
const ic = "\u2063";
const Icirc = "\xCE";
const icirc = "\xEE";
const Icy = "\u0418";
const icy = "\u0438";
const Idot = "\u0130";
const IEcy = "\u0415";
const iecy = "\u0435";
const iexcl = "\xA1";
const iff = "\u21D4";
const ifr = "\u{1D526}";
const Ifr = "\u2111";
const Igrave = "\xCC";
const igrave = "\xEC";
const ii = "\u2148";
const iiiint = "\u2A0C";
const iiint = "\u222D";
const iinfin = "\u29DC";
const iiota = "\u2129";
const IJlig = "\u0132";
const ijlig = "\u0133";
const Imacr = "\u012A";
const imacr = "\u012B";
const image$1 = "\u2111";
const ImaginaryI = "\u2148";
const imagline = "\u2110";
const imagpart = "\u2111";
const imath = "\u0131";
const Im = "\u2111";
const imof = "\u22B7";
const imped = "\u01B5";
const Implies = "\u21D2";
const incare = "\u2105";
const infin = "\u221E";
const infintie = "\u29DD";
const inodot = "\u0131";
const intcal = "\u22BA";
const int = "\u222B";
const Int = "\u222C";
const integers = "\u2124";
const Integral = "\u222B";
const intercal = "\u22BA";
const Intersection = "\u22C2";
const intlarhk = "\u2A17";
const intprod = "\u2A3C";
const InvisibleComma = "\u2063";
const InvisibleTimes = "\u2062";
const IOcy = "\u0401";
const iocy = "\u0451";
const Iogon = "\u012E";
const iogon = "\u012F";
const Iopf = "\u{1D540}";
const iopf = "\u{1D55A}";
const Iota = "\u0399";
const iota = "\u03B9";
const iprod = "\u2A3C";
const iquest = "\xBF";
const iscr = "\u{1D4BE}";
const Iscr = "\u2110";
const isin = "\u2208";
const isindot = "\u22F5";
const isinE = "\u22F9";
const isins = "\u22F4";
const isinsv = "\u22F3";
const isinv = "\u2208";
const it = "\u2062";
const Itilde = "\u0128";
const itilde = "\u0129";
const Iukcy = "\u0406";
const iukcy = "\u0456";
const Iuml = "\xCF";
const iuml = "\xEF";
const Jcirc = "\u0134";
const jcirc = "\u0135";
const Jcy = "\u0419";
const jcy = "\u0439";
const Jfr = "\u{1D50D}";
const jfr = "\u{1D527}";
const jmath = "\u0237";
const Jopf = "\u{1D541}";
const jopf = "\u{1D55B}";
const Jscr = "\u{1D4A5}";
const jscr = "\u{1D4BF}";
const Jsercy = "\u0408";
const jsercy = "\u0458";
const Jukcy = "\u0404";
const jukcy = "\u0454";
const Kappa = "\u039A";
const kappa = "\u03BA";
const kappav = "\u03F0";
const Kcedil = "\u0136";
const kcedil = "\u0137";
const Kcy = "\u041A";
const kcy = "\u043A";
const Kfr = "\u{1D50E}";
const kfr = "\u{1D528}";
const kgreen = "\u0138";
const KHcy = "\u0425";
const khcy = "\u0445";
const KJcy = "\u040C";
const kjcy = "\u045C";
const Kopf = "\u{1D542}";
const kopf = "\u{1D55C}";
const Kscr = "\u{1D4A6}";
const kscr = "\u{1D4C0}";
const lAarr = "\u21DA";
const Lacute = "\u0139";
const lacute = "\u013A";
const laemptyv = "\u29B4";
const lagran = "\u2112";
const Lambda = "\u039B";
const lambda = "\u03BB";
const lang = "\u27E8";
const Lang = "\u27EA";
const langd = "\u2991";
const langle = "\u27E8";
const lap = "\u2A85";
const Laplacetrf = "\u2112";
const laquo = "\xAB";
const larrb = "\u21E4";
const larrbfs = "\u291F";
const larr = "\u2190";
const Larr = "\u219E";
const lArr = "\u21D0";
const larrfs = "\u291D";
const larrhk = "\u21A9";
const larrlp = "\u21AB";
const larrpl = "\u2939";
const larrsim = "\u2973";
const larrtl = "\u21A2";
const latail = "\u2919";
const lAtail = "\u291B";
const lat = "\u2AAB";
const late = "\u2AAD";
const lates = "\u2AAD\uFE00";
const lbarr = "\u290C";
const lBarr = "\u290E";
const lbbrk = "\u2772";
const lbrace = "{";
const lbrack = "[";
const lbrke = "\u298B";
const lbrksld = "\u298F";
const lbrkslu = "\u298D";
const Lcaron = "\u013D";
const lcaron = "\u013E";
const Lcedil = "\u013B";
const lcedil = "\u013C";
const lceil = "\u2308";
const lcub = "{";
const Lcy = "\u041B";
const lcy = "\u043B";
const ldca = "\u2936";
const ldquo = "\u201C";
const ldquor = "\u201E";
const ldrdhar = "\u2967";
const ldrushar = "\u294B";
const ldsh = "\u21B2";
const le = "\u2264";
const lE = "\u2266";
const LeftAngleBracket = "\u27E8";
const LeftArrowBar = "\u21E4";
const leftarrow = "\u2190";
const LeftArrow = "\u2190";
const Leftarrow = "\u21D0";
const LeftArrowRightArrow = "\u21C6";
const leftarrowtail = "\u21A2";
const LeftCeiling = "\u2308";
const LeftDoubleBracket = "\u27E6";
const LeftDownTeeVector = "\u2961";
const LeftDownVectorBar = "\u2959";
const LeftDownVector = "\u21C3";
const LeftFloor = "\u230A";
const leftharpoondown = "\u21BD";
const leftharpoonup = "\u21BC";
const leftleftarrows = "\u21C7";
const leftrightarrow = "\u2194";
const LeftRightArrow = "\u2194";
const Leftrightarrow = "\u21D4";
const leftrightarrows = "\u21C6";
const leftrightharpoons = "\u21CB";
const leftrightsquigarrow = "\u21AD";
const LeftRightVector = "\u294E";
const LeftTeeArrow = "\u21A4";
const LeftTee = "\u22A3";
const LeftTeeVector = "\u295A";
const leftthreetimes = "\u22CB";
const LeftTriangleBar = "\u29CF";
const LeftTriangle = "\u22B2";
const LeftTriangleEqual = "\u22B4";
const LeftUpDownVector = "\u2951";
const LeftUpTeeVector = "\u2960";
const LeftUpVectorBar = "\u2958";
const LeftUpVector = "\u21BF";
const LeftVectorBar = "\u2952";
const LeftVector = "\u21BC";
const lEg = "\u2A8B";
const leg = "\u22DA";
const leq = "\u2264";
const leqq = "\u2266";
const leqslant = "\u2A7D";
const lescc = "\u2AA8";
const les = "\u2A7D";
const lesdot = "\u2A7F";
const lesdoto = "\u2A81";
const lesdotor = "\u2A83";
const lesg = "\u22DA\uFE00";
const lesges = "\u2A93";
const lessapprox = "\u2A85";
const lessdot = "\u22D6";
const lesseqgtr = "\u22DA";
const lesseqqgtr = "\u2A8B";
const LessEqualGreater = "\u22DA";
const LessFullEqual = "\u2266";
const LessGreater = "\u2276";
const lessgtr = "\u2276";
const LessLess = "\u2AA1";
const lesssim = "\u2272";
const LessSlantEqual = "\u2A7D";
const LessTilde = "\u2272";
const lfisht = "\u297C";
const lfloor = "\u230A";
const Lfr = "\u{1D50F}";
const lfr = "\u{1D529}";
const lg = "\u2276";
const lgE = "\u2A91";
const lHar = "\u2962";
const lhard = "\u21BD";
const lharu = "\u21BC";
const lharul = "\u296A";
const lhblk = "\u2584";
const LJcy = "\u0409";
const ljcy = "\u0459";
const llarr = "\u21C7";
const ll = "\u226A";
const Ll = "\u22D8";
const llcorner = "\u231E";
const Lleftarrow = "\u21DA";
const llhard = "\u296B";
const lltri = "\u25FA";
const Lmidot = "\u013F";
const lmidot = "\u0140";
const lmoustache = "\u23B0";
const lmoust = "\u23B0";
const lnap = "\u2A89";
const lnapprox = "\u2A89";
const lne = "\u2A87";
const lnE = "\u2268";
const lneq = "\u2A87";
const lneqq = "\u2268";
const lnsim = "\u22E6";
const loang = "\u27EC";
const loarr = "\u21FD";
const lobrk = "\u27E6";
const longleftarrow = "\u27F5";
const LongLeftArrow = "\u27F5";
const Longleftarrow = "\u27F8";
const longleftrightarrow = "\u27F7";
const LongLeftRightArrow = "\u27F7";
const Longleftrightarrow = "\u27FA";
const longmapsto = "\u27FC";
const longrightarrow = "\u27F6";
const LongRightArrow = "\u27F6";
const Longrightarrow = "\u27F9";
const looparrowleft = "\u21AB";
const looparrowright = "\u21AC";
const lopar = "\u2985";
const Lopf = "\u{1D543}";
const lopf = "\u{1D55D}";
const loplus = "\u2A2D";
const lotimes = "\u2A34";
const lowast = "\u2217";
const lowbar = "_";
const LowerLeftArrow = "\u2199";
const LowerRightArrow = "\u2198";
const loz = "\u25CA";
const lozenge = "\u25CA";
const lozf = "\u29EB";
const lpar = "(";
const lparlt = "\u2993";
const lrarr = "\u21C6";
const lrcorner = "\u231F";
const lrhar = "\u21CB";
const lrhard = "\u296D";
const lrm = "\u200E";
const lrtri = "\u22BF";
const lsaquo = "\u2039";
const lscr = "\u{1D4C1}";
const Lscr = "\u2112";
const lsh = "\u21B0";
const Lsh = "\u21B0";
const lsim = "\u2272";
const lsime = "\u2A8D";
const lsimg = "\u2A8F";
const lsqb = "[";
const lsquo = "\u2018";
const lsquor = "\u201A";
const Lstrok = "\u0141";
const lstrok = "\u0142";
const ltcc = "\u2AA6";
const ltcir = "\u2A79";
const lt = "<";
const LT = "<";
const Lt = "\u226A";
const ltdot = "\u22D6";
const lthree = "\u22CB";
const ltimes = "\u22C9";
const ltlarr = "\u2976";
const ltquest = "\u2A7B";
const ltri = "\u25C3";
const ltrie = "\u22B4";
const ltrif = "\u25C2";
const ltrPar = "\u2996";
const lurdshar = "\u294A";
const luruhar = "\u2966";
const lvertneqq = "\u2268\uFE00";
const lvnE = "\u2268\uFE00";
const macr = "\xAF";
const male = "\u2642";
const malt = "\u2720";
const maltese = "\u2720";
const map = "\u21A6";
const mapsto = "\u21A6";
const mapstodown = "\u21A7";
const mapstoleft = "\u21A4";
const mapstoup = "\u21A5";
const marker = "\u25AE";
const mcomma = "\u2A29";
const Mcy = "\u041C";
const mcy = "\u043C";
const mdash = "\u2014";
const mDDot = "\u223A";
const measuredangle = "\u2221";
const MediumSpace = "\u205F";
const Mellintrf = "\u2133";
const Mfr = "\u{1D510}";
const mfr = "\u{1D52A}";
const mho = "\u2127";
const micro = "\xB5";
const midast = "*";
const midcir = "\u2AF0";
const mid = "\u2223";
const middot = "\xB7";
const minusb = "\u229F";
const minus$1 = "\u2212";
const minusd = "\u2238";
const minusdu = "\u2A2A";
const MinusPlus = "\u2213";
const mlcp = "\u2ADB";
const mldr = "\u2026";
const mnplus = "\u2213";
const models = "\u22A7";
const Mopf = "\u{1D544}";
const mopf = "\u{1D55E}";
const mp = "\u2213";
const mscr = "\u{1D4C2}";
const Mscr = "\u2133";
const mstpos = "\u223E";
const Mu = "\u039C";
const mu = "\u03BC";
const multimap = "\u22B8";
const mumap = "\u22B8";
const nabla = "\u2207";
const Nacute = "\u0143";
const nacute = "\u0144";
const nang = "\u2220\u20D2";
const nap = "\u2249";
const napE = "\u2A70\u0338";
const napid = "\u224B\u0338";
const napos = "\u0149";
const napprox = "\u2249";
const natural = "\u266E";
const naturals = "\u2115";
const natur = "\u266E";
const nbsp = "\xA0";
const nbump = "\u224E\u0338";
const nbumpe = "\u224F\u0338";
const ncap = "\u2A43";
const Ncaron = "\u0147";
const ncaron = "\u0148";
const Ncedil = "\u0145";
const ncedil = "\u0146";
const ncong = "\u2247";
const ncongdot = "\u2A6D\u0338";
const ncup = "\u2A42";
const Ncy = "\u041D";
const ncy = "\u043D";
const ndash = "\u2013";
const nearhk = "\u2924";
const nearr = "\u2197";
const neArr = "\u21D7";
const nearrow = "\u2197";
const ne = "\u2260";
const nedot = "\u2250\u0338";
const NegativeMediumSpace = "\u200B";
const NegativeThickSpace = "\u200B";
const NegativeThinSpace = "\u200B";
const NegativeVeryThinSpace = "\u200B";
const nequiv = "\u2262";
const nesear = "\u2928";
const nesim = "\u2242\u0338";
const NestedGreaterGreater = "\u226B";
const NestedLessLess = "\u226A";
const NewLine = "\n";
const nexist = "\u2204";
const nexists = "\u2204";
const Nfr = "\u{1D511}";
const nfr = "\u{1D52B}";
const ngE = "\u2267\u0338";
const nge = "\u2271";
const ngeq = "\u2271";
const ngeqq = "\u2267\u0338";
const ngeqslant = "\u2A7E\u0338";
const nges = "\u2A7E\u0338";
const nGg = "\u22D9\u0338";
const ngsim = "\u2275";
const nGt = "\u226B\u20D2";
const ngt = "\u226F";
const ngtr = "\u226F";
const nGtv = "\u226B\u0338";
const nharr = "\u21AE";
const nhArr = "\u21CE";
const nhpar = "\u2AF2";
const ni = "\u220B";
const nis = "\u22FC";
const nisd = "\u22FA";
const niv = "\u220B";
const NJcy = "\u040A";
const njcy = "\u045A";
const nlarr = "\u219A";
const nlArr = "\u21CD";
const nldr = "\u2025";
const nlE = "\u2266\u0338";
const nle = "\u2270";
const nleftarrow = "\u219A";
const nLeftarrow = "\u21CD";
const nleftrightarrow = "\u21AE";
const nLeftrightarrow = "\u21CE";
const nleq = "\u2270";
const nleqq = "\u2266\u0338";
const nleqslant = "\u2A7D\u0338";
const nles = "\u2A7D\u0338";
const nless = "\u226E";
const nLl = "\u22D8\u0338";
const nlsim = "\u2274";
const nLt = "\u226A\u20D2";
const nlt = "\u226E";
const nltri = "\u22EA";
const nltrie = "\u22EC";
const nLtv = "\u226A\u0338";
const nmid = "\u2224";
const NoBreak = "\u2060";
const NonBreakingSpace = "\xA0";
const nopf = "\u{1D55F}";
const Nopf = "\u2115";
const Not = "\u2AEC";
const not = "\xAC";
const NotCongruent = "\u2262";
const NotCupCap = "\u226D";
const NotDoubleVerticalBar = "\u2226";
const NotElement = "\u2209";
const NotEqual = "\u2260";
const NotEqualTilde = "\u2242\u0338";
const NotExists = "\u2204";
const NotGreater = "\u226F";
const NotGreaterEqual = "\u2271";
const NotGreaterFullEqual = "\u2267\u0338";
const NotGreaterGreater = "\u226B\u0338";
const NotGreaterLess = "\u2279";
const NotGreaterSlantEqual = "\u2A7E\u0338";
const NotGreaterTilde = "\u2275";
const NotHumpDownHump = "\u224E\u0338";
const NotHumpEqual = "\u224F\u0338";
const notin = "\u2209";
const notindot = "\u22F5\u0338";
const notinE = "\u22F9\u0338";
const notinva = "\u2209";
const notinvb = "\u22F7";
const notinvc = "\u22F6";
const NotLeftTriangleBar = "\u29CF\u0338";
const NotLeftTriangle = "\u22EA";
const NotLeftTriangleEqual = "\u22EC";
const NotLess = "\u226E";
const NotLessEqual = "\u2270";
const NotLessGreater = "\u2278";
const NotLessLess = "\u226A\u0338";
const NotLessSlantEqual = "\u2A7D\u0338";
const NotLessTilde = "\u2274";
const NotNestedGreaterGreater = "\u2AA2\u0338";
const NotNestedLessLess = "\u2AA1\u0338";
const notni = "\u220C";
const notniva = "\u220C";
const notnivb = "\u22FE";
const notnivc = "\u22FD";
const NotPrecedes = "\u2280";
const NotPrecedesEqual = "\u2AAF\u0338";
const NotPrecedesSlantEqual = "\u22E0";
const NotReverseElement = "\u220C";
const NotRightTriangleBar = "\u29D0\u0338";
const NotRightTriangle = "\u22EB";
const NotRightTriangleEqual = "\u22ED";
const NotSquareSubset = "\u228F\u0338";
const NotSquareSubsetEqual = "\u22E2";
const NotSquareSuperset = "\u2290\u0338";
const NotSquareSupersetEqual = "\u22E3";
const NotSubset = "\u2282\u20D2";
const NotSubsetEqual = "\u2288";
const NotSucceeds = "\u2281";
const NotSucceedsEqual = "\u2AB0\u0338";
const NotSucceedsSlantEqual = "\u22E1";
const NotSucceedsTilde = "\u227F\u0338";
const NotSuperset = "\u2283\u20D2";
const NotSupersetEqual = "\u2289";
const NotTilde = "\u2241";
const NotTildeEqual = "\u2244";
const NotTildeFullEqual = "\u2247";
const NotTildeTilde = "\u2249";
const NotVerticalBar = "\u2224";
const nparallel = "\u2226";
const npar = "\u2226";
const nparsl = "\u2AFD\u20E5";
const npart = "\u2202\u0338";
const npolint = "\u2A14";
const npr = "\u2280";
const nprcue = "\u22E0";
const nprec = "\u2280";
const npreceq = "\u2AAF\u0338";
const npre = "\u2AAF\u0338";
const nrarrc = "\u2933\u0338";
const nrarr = "\u219B";
const nrArr = "\u21CF";
const nrarrw = "\u219D\u0338";
const nrightarrow = "\u219B";
const nRightarrow = "\u21CF";
const nrtri = "\u22EB";
const nrtrie = "\u22ED";
const nsc = "\u2281";
const nsccue = "\u22E1";
const nsce = "\u2AB0\u0338";
const Nscr = "\u{1D4A9}";
const nscr = "\u{1D4C3}";
const nshortmid = "\u2224";
const nshortparallel = "\u2226";
const nsim = "\u2241";
const nsime = "\u2244";
const nsimeq = "\u2244";
const nsmid = "\u2224";
const nspar = "\u2226";
const nsqsube = "\u22E2";
const nsqsupe = "\u22E3";
const nsub = "\u2284";
const nsubE = "\u2AC5\u0338";
const nsube = "\u2288";
const nsubset = "\u2282\u20D2";
const nsubseteq = "\u2288";
const nsubseteqq = "\u2AC5\u0338";
const nsucc = "\u2281";
const nsucceq = "\u2AB0\u0338";
const nsup = "\u2285";
const nsupE = "\u2AC6\u0338";
const nsupe = "\u2289";
const nsupset = "\u2283\u20D2";
const nsupseteq = "\u2289";
const nsupseteqq = "\u2AC6\u0338";
const ntgl = "\u2279";
const Ntilde = "\xD1";
const ntilde = "\xF1";
const ntlg = "\u2278";
const ntriangleleft = "\u22EA";
const ntrianglelefteq = "\u22EC";
const ntriangleright = "\u22EB";
const ntrianglerighteq = "\u22ED";
const Nu = "\u039D";
const nu = "\u03BD";
const num = "#";
const numero = "\u2116";
const numsp = "\u2007";
const nvap = "\u224D\u20D2";
const nvdash = "\u22AC";
const nvDash = "\u22AD";
const nVdash = "\u22AE";
const nVDash = "\u22AF";
const nvge = "\u2265\u20D2";
const nvgt = ">\u20D2";
const nvHarr = "\u2904";
const nvinfin = "\u29DE";
const nvlArr = "\u2902";
const nvle = "\u2264\u20D2";
const nvlt = "<\u20D2";
const nvltrie = "\u22B4\u20D2";
const nvrArr = "\u2903";
const nvrtrie = "\u22B5\u20D2";
const nvsim = "\u223C\u20D2";
const nwarhk = "\u2923";
const nwarr = "\u2196";
const nwArr = "\u21D6";
const nwarrow = "\u2196";
const nwnear = "\u2927";
const Oacute = "\xD3";
const oacute = "\xF3";
const oast = "\u229B";
const Ocirc = "\xD4";
const ocirc = "\xF4";
const ocir = "\u229A";
const Ocy = "\u041E";
const ocy = "\u043E";
const odash = "\u229D";
const Odblac = "\u0150";
const odblac = "\u0151";
const odiv = "\u2A38";
const odot = "\u2299";
const odsold = "\u29BC";
const OElig = "\u0152";
const oelig = "\u0153";
const ofcir = "\u29BF";
const Ofr = "\u{1D512}";
const ofr = "\u{1D52C}";
const ogon = "\u02DB";
const Ograve = "\xD2";
const ograve = "\xF2";
const ogt = "\u29C1";
const ohbar = "\u29B5";
const ohm = "\u03A9";
const oint = "\u222E";
const olarr = "\u21BA";
const olcir = "\u29BE";
const olcross = "\u29BB";
const oline = "\u203E";
const olt = "\u29C0";
const Omacr = "\u014C";
const omacr = "\u014D";
const Omega = "\u03A9";
const omega = "\u03C9";
const Omicron = "\u039F";
const omicron = "\u03BF";
const omid = "\u29B6";
const ominus = "\u2296";
const Oopf = "\u{1D546}";
const oopf = "\u{1D560}";
const opar = "\u29B7";
const OpenCurlyDoubleQuote = "\u201C";
const OpenCurlyQuote = "\u2018";
const operp = "\u29B9";
const oplus = "\u2295";
const orarr = "\u21BB";
const Or = "\u2A54";
const or = "\u2228";
const ord = "\u2A5D";
const order = "\u2134";
const orderof = "\u2134";
const ordf = "\xAA";
const ordm = "\xBA";
const origof = "\u22B6";
const oror = "\u2A56";
const orslope = "\u2A57";
const orv = "\u2A5B";
const oS = "\u24C8";
const Oscr = "\u{1D4AA}";
const oscr = "\u2134";
const Oslash = "\xD8";
const oslash = "\xF8";
const osol = "\u2298";
const Otilde = "\xD5";
const otilde = "\xF5";
const otimesas = "\u2A36";
const Otimes = "\u2A37";
const otimes = "\u2297";
const Ouml = "\xD6";
const ouml = "\xF6";
const ovbar = "\u233D";
const OverBar = "\u203E";
const OverBrace = "\u23DE";
const OverBracket = "\u23B4";
const OverParenthesis = "\u23DC";
const para = "\xB6";
const parallel = "\u2225";
const par = "\u2225";
const parsim = "\u2AF3";
const parsl = "\u2AFD";
const part = "\u2202";
const PartialD = "\u2202";
const Pcy = "\u041F";
const pcy = "\u043F";
const percnt = "%";
const period$1 = ".";
const permil = "\u2030";
const perp = "\u22A5";
const pertenk = "\u2031";
const Pfr = "\u{1D513}";
const pfr = "\u{1D52D}";
const Phi = "\u03A6";
const phi = "\u03C6";
const phiv = "\u03D5";
const phmmat = "\u2133";
const phone = "\u260E";
const Pi = "\u03A0";
const pi = "\u03C0";
const pitchfork = "\u22D4";
const piv = "\u03D6";
const planck = "\u210F";
const planckh = "\u210E";
const plankv = "\u210F";
const plusacir = "\u2A23";
const plusb = "\u229E";
const pluscir = "\u2A22";
const plus$1 = "+";
const plusdo = "\u2214";
const plusdu = "\u2A25";
const pluse = "\u2A72";
const PlusMinus = "\xB1";
const plusmn = "\xB1";
const plussim = "\u2A26";
const plustwo = "\u2A27";
const pm = "\xB1";
const Poincareplane = "\u210C";
const pointint = "\u2A15";
const popf = "\u{1D561}";
const Popf = "\u2119";
const pound = "\xA3";
const prap = "\u2AB7";
const Pr = "\u2ABB";
const pr = "\u227A";
const prcue = "\u227C";
const precapprox = "\u2AB7";
const prec$1 = "\u227A";
const preccurlyeq = "\u227C";
const Precedes = "\u227A";
const PrecedesEqual = "\u2AAF";
const PrecedesSlantEqual = "\u227C";
const PrecedesTilde = "\u227E";
const preceq = "\u2AAF";
const precnapprox = "\u2AB9";
const precneqq = "\u2AB5";
const precnsim = "\u22E8";
const pre = "\u2AAF";
const prE = "\u2AB3";
const precsim = "\u227E";
const prime = "\u2032";
const Prime = "\u2033";
const primes = "\u2119";
const prnap = "\u2AB9";
const prnE = "\u2AB5";
const prnsim = "\u22E8";
const prod = "\u220F";
const Product = "\u220F";
const profalar = "\u232E";
const profline = "\u2312";
const profsurf = "\u2313";
const prop = "\u221D";
const Proportional = "\u221D";
const Proportion = "\u2237";
const propto = "\u221D";
const prsim = "\u227E";
const prurel = "\u22B0";
const Pscr = "\u{1D4AB}";
const pscr = "\u{1D4C5}";
const Psi = "\u03A8";
const psi = "\u03C8";
const puncsp = "\u2008";
const Qfr = "\u{1D514}";
const qfr = "\u{1D52E}";
const qint = "\u2A0C";
const qopf = "\u{1D562}";
const Qopf = "\u211A";
const qprime = "\u2057";
const Qscr = "\u{1D4AC}";
const qscr = "\u{1D4C6}";
const quaternions = "\u210D";
const quatint = "\u2A16";
const quest = "?";
const questeq = "\u225F";
const quot = '"';
const QUOT = '"';
const rAarr = "\u21DB";
const race = "\u223D\u0331";
const Racute = "\u0154";
const racute = "\u0155";
const radic = "\u221A";
const raemptyv = "\u29B3";
const rang = "\u27E9";
const Rang = "\u27EB";
const rangd = "\u2992";
const range = "\u29A5";
const rangle = "\u27E9";
const raquo = "\xBB";
const rarrap = "\u2975";
const rarrb = "\u21E5";
const rarrbfs = "\u2920";
const rarrc = "\u2933";
const rarr = "\u2192";
const Rarr = "\u21A0";
const rArr = "\u21D2";
const rarrfs = "\u291E";
const rarrhk = "\u21AA";
const rarrlp = "\u21AC";
const rarrpl = "\u2945";
const rarrsim = "\u2974";
const Rarrtl = "\u2916";
const rarrtl = "\u21A3";
const rarrw = "\u219D";
const ratail = "\u291A";
const rAtail = "\u291C";
const ratio = "\u2236";
const rationals = "\u211A";
const rbarr = "\u290D";
const rBarr = "\u290F";
const RBarr = "\u2910";
const rbbrk = "\u2773";
const rbrace = "}";
const rbrack = "]";
const rbrke = "\u298C";
const rbrksld = "\u298E";
const rbrkslu = "\u2990";
const Rcaron = "\u0158";
const rcaron = "\u0159";
const Rcedil = "\u0156";
const rcedil = "\u0157";
const rceil = "\u2309";
const rcub = "}";
const Rcy = "\u0420";
const rcy = "\u0440";
const rdca = "\u2937";
const rdldhar = "\u2969";
const rdquo = "\u201D";
const rdquor = "\u201D";
const rdsh = "\u21B3";
const real = "\u211C";
const realine = "\u211B";
const realpart = "\u211C";
const reals = "\u211D";
const Re = "\u211C";
const rect = "\u25AD";
const reg = "\xAE";
const REG = "\xAE";
const ReverseElement = "\u220B";
const ReverseEquilibrium = "\u21CB";
const ReverseUpEquilibrium = "\u296F";
const rfisht = "\u297D";
const rfloor = "\u230B";
const rfr = "\u{1D52F}";
const Rfr = "\u211C";
const rHar = "\u2964";
const rhard = "\u21C1";
const rharu = "\u21C0";
const rharul = "\u296C";
const Rho = "\u03A1";
const rho = "\u03C1";
const rhov = "\u03F1";
const RightAngleBracket = "\u27E9";
const RightArrowBar = "\u21E5";
const rightarrow = "\u2192";
const RightArrow = "\u2192";
const Rightarrow = "\u21D2";
const RightArrowLeftArrow = "\u21C4";
const rightarrowtail = "\u21A3";
const RightCeiling = "\u2309";
const RightDoubleBracket = "\u27E7";
const RightDownTeeVector = "\u295D";
const RightDownVectorBar = "\u2955";
const RightDownVector = "\u21C2";
const RightFloor = "\u230B";
const rightharpoondown = "\u21C1";
const rightharpoonup = "\u21C0";
const rightleftarrows = "\u21C4";
const rightleftharpoons = "\u21CC";
const rightrightarrows = "\u21C9";
const rightsquigarrow = "\u219D";
const RightTeeArrow = "\u21A6";
const RightTee = "\u22A2";
const RightTeeVector = "\u295B";
const rightthreetimes = "\u22CC";
const RightTriangleBar = "\u29D0";
const RightTriangle = "\u22B3";
const RightTriangleEqual = "\u22B5";
const RightUpDownVector = "\u294F";
const RightUpTeeVector = "\u295C";
const RightUpVectorBar = "\u2954";
const RightUpVector = "\u21BE";
const RightVectorBar = "\u2953";
const RightVector = "\u21C0";
const ring = "\u02DA";
const risingdotseq = "\u2253";
const rlarr = "\u21C4";
const rlhar = "\u21CC";
const rlm = "\u200F";
const rmoustache = "\u23B1";
const rmoust = "\u23B1";
const rnmid = "\u2AEE";
const roang = "\u27ED";
const roarr = "\u21FE";
const robrk = "\u27E7";
const ropar = "\u2986";
const ropf = "\u{1D563}";
const Ropf = "\u211D";
const roplus = "\u2A2E";
const rotimes = "\u2A35";
const RoundImplies = "\u2970";
const rpar = ")";
const rpargt = "\u2994";
const rppolint = "\u2A12";
const rrarr = "\u21C9";
const Rrightarrow = "\u21DB";
const rsaquo = "\u203A";
const rscr = "\u{1D4C7}";
const Rscr = "\u211B";
const rsh = "\u21B1";
const Rsh = "\u21B1";
const rsqb = "]";
const rsquo = "\u2019";
const rsquor = "\u2019";
const rthree = "\u22CC";
const rtimes = "\u22CA";
const rtri = "\u25B9";
const rtrie = "\u22B5";
const rtrif = "\u25B8";
const rtriltri = "\u29CE";
const RuleDelayed = "\u29F4";
const ruluhar = "\u2968";
const rx = "\u211E";
const Sacute = "\u015A";
const sacute = "\u015B";
const sbquo = "\u201A";
const scap = "\u2AB8";
const Scaron = "\u0160";
const scaron = "\u0161";
const Sc = "\u2ABC";
const sc = "\u227B";
const sccue = "\u227D";
const sce = "\u2AB0";
const scE = "\u2AB4";
const Scedil = "\u015E";
const scedil = "\u015F";
const Scirc = "\u015C";
const scirc = "\u015D";
const scnap = "\u2ABA";
const scnE = "\u2AB6";
const scnsim = "\u22E9";
const scpolint = "\u2A13";
const scsim = "\u227F";
const Scy = "\u0421";
const scy = "\u0441";
const sdotb = "\u22A1";
const sdot = "\u22C5";
const sdote = "\u2A66";
const searhk = "\u2925";
const searr = "\u2198";
const seArr = "\u21D8";
const searrow = "\u2198";
const sect = "\xA7";
const semi = ";";
const seswar = "\u2929";
const setminus = "\u2216";
const setmn = "\u2216";
const sext = "\u2736";
const Sfr = "\u{1D516}";
const sfr = "\u{1D530}";
const sfrown = "\u2322";
const sharp = "\u266F";
const SHCHcy = "\u0429";
const shchcy = "\u0449";
const SHcy = "\u0428";
const shcy = "\u0448";
const ShortDownArrow = "\u2193";
const ShortLeftArrow = "\u2190";
const shortmid = "\u2223";
const shortparallel = "\u2225";
const ShortRightArrow = "\u2192";
const ShortUpArrow = "\u2191";
const shy = "\xAD";
const Sigma = "\u03A3";
const sigma = "\u03C3";
const sigmaf = "\u03C2";
const sigmav = "\u03C2";
const sim = "\u223C";
const simdot = "\u2A6A";
const sime = "\u2243";
const simeq = "\u2243";
const simg = "\u2A9E";
const simgE = "\u2AA0";
const siml = "\u2A9D";
const simlE = "\u2A9F";
const simne = "\u2246";
const simplus = "\u2A24";
const simrarr = "\u2972";
const slarr = "\u2190";
const SmallCircle = "\u2218";
const smallsetminus = "\u2216";
const smashp = "\u2A33";
const smeparsl = "\u29E4";
const smid = "\u2223";
const smile = "\u2323";
const smt = "\u2AAA";
const smte = "\u2AAC";
const smtes = "\u2AAC\uFE00";
const SOFTcy = "\u042C";
const softcy = "\u044C";
const solbar = "\u233F";
const solb = "\u29C4";
const sol = "/";
const Sopf = "\u{1D54A}";
const sopf = "\u{1D564}";
const spades = "\u2660";
const spadesuit = "\u2660";
const spar = "\u2225";
const sqcap = "\u2293";
const sqcaps = "\u2293\uFE00";
const sqcup = "\u2294";
const sqcups = "\u2294\uFE00";
const Sqrt = "\u221A";
const sqsub = "\u228F";
const sqsube = "\u2291";
const sqsubset = "\u228F";
const sqsubseteq = "\u2291";
const sqsup = "\u2290";
const sqsupe = "\u2292";
const sqsupset = "\u2290";
const sqsupseteq = "\u2292";
const square = "\u25A1";
const Square = "\u25A1";
const SquareIntersection = "\u2293";
const SquareSubset = "\u228F";
const SquareSubsetEqual = "\u2291";
const SquareSuperset = "\u2290";
const SquareSupersetEqual = "\u2292";
const SquareUnion = "\u2294";
const squarf = "\u25AA";
const squ = "\u25A1";
const squf = "\u25AA";
const srarr = "\u2192";
const Sscr = "\u{1D4AE}";
const sscr = "\u{1D4C8}";
const ssetmn = "\u2216";
const ssmile = "\u2323";
const sstarf = "\u22C6";
const Star = "\u22C6";
const star$1 = "\u2606";
const starf = "\u2605";
const straightepsilon = "\u03F5";
const straightphi = "\u03D5";
const strns = "\xAF";
const sub = "\u2282";
const Sub = "\u22D0";
const subdot = "\u2ABD";
const subE = "\u2AC5";
const sube = "\u2286";
const subedot = "\u2AC3";
const submult = "\u2AC1";
const subnE = "\u2ACB";
const subne = "\u228A";
const subplus = "\u2ABF";
const subrarr = "\u2979";
const subset = "\u2282";
const Subset = "\u22D0";
const subseteq = "\u2286";
const subseteqq = "\u2AC5";
const SubsetEqual = "\u2286";
const subsetneq = "\u228A";
const subsetneqq = "\u2ACB";
const subsim = "\u2AC7";
const subsub = "\u2AD5";
const subsup = "\u2AD3";
const succapprox = "\u2AB8";
const succ = "\u227B";
const succcurlyeq = "\u227D";
const Succeeds = "\u227B";
const SucceedsEqual = "\u2AB0";
const SucceedsSlantEqual = "\u227D";
const SucceedsTilde = "\u227F";
const succeq = "\u2AB0";
const succnapprox = "\u2ABA";
const succneqq = "\u2AB6";
const succnsim = "\u22E9";
const succsim = "\u227F";
const SuchThat = "\u220B";
const sum = "\u2211";
const Sum = "\u2211";
const sung = "\u266A";
const sup1 = "\xB9";
const sup2 = "\xB2";
const sup3 = "\xB3";
const sup = "\u2283";
const Sup = "\u22D1";
const supdot = "\u2ABE";
const supdsub = "\u2AD8";
const supE = "\u2AC6";
const supe = "\u2287";
const supedot = "\u2AC4";
const Superset = "\u2283";
const SupersetEqual = "\u2287";
const suphsol = "\u27C9";
const suphsub = "\u2AD7";
const suplarr = "\u297B";
const supmult = "\u2AC2";
const supnE = "\u2ACC";
const supne = "\u228B";
const supplus = "\u2AC0";
const supset = "\u2283";
const Supset = "\u22D1";
const supseteq = "\u2287";
const supseteqq = "\u2AC6";
const supsetneq = "\u228B";
const supsetneqq = "\u2ACC";
const supsim = "\u2AC8";
const supsub = "\u2AD4";
const supsup = "\u2AD6";
const swarhk = "\u2926";
const swarr = "\u2199";
const swArr = "\u21D9";
const swarrow = "\u2199";
const swnwar = "\u292A";
const szlig = "\xDF";
const Tab = "	";
const target = "\u2316";
const Tau = "\u03A4";
const tau = "\u03C4";
const tbrk = "\u23B4";
const Tcaron = "\u0164";
const tcaron = "\u0165";
const Tcedil = "\u0162";
const tcedil = "\u0163";
const Tcy = "\u0422";
const tcy = "\u0442";
const tdot = "\u20DB";
const telrec = "\u2315";
const Tfr = "\u{1D517}";
const tfr = "\u{1D531}";
const there4 = "\u2234";
const therefore = "\u2234";
const Therefore = "\u2234";
const Theta = "\u0398";
const theta = "\u03B8";
const thetasym = "\u03D1";
const thetav = "\u03D1";
const thickapprox = "\u2248";
const thicksim = "\u223C";
const ThickSpace = "\u205F\u200A";
const ThinSpace = "\u2009";
const thinsp = "\u2009";
const thkap = "\u2248";
const thksim = "\u223C";
const THORN = "\xDE";
const thorn = "\xFE";
const tilde = "\u02DC";
const Tilde = "\u223C";
const TildeEqual = "\u2243";
const TildeFullEqual = "\u2245";
const TildeTilde = "\u2248";
const timesbar = "\u2A31";
const timesb = "\u22A0";
const times = "\xD7";
const timesd = "\u2A30";
const tint = "\u222D";
const toea = "\u2928";
const topbot = "\u2336";
const topcir = "\u2AF1";
const top$1 = "\u22A4";
const Topf = "\u{1D54B}";
const topf = "\u{1D565}";
const topfork = "\u2ADA";
const tosa = "\u2929";
const tprime = "\u2034";
const trade = "\u2122";
const TRADE = "\u2122";
const triangle = "\u25B5";
const triangledown = "\u25BF";
const triangleleft = "\u25C3";
const trianglelefteq = "\u22B4";
const triangleq = "\u225C";
const triangleright = "\u25B9";
const trianglerighteq = "\u22B5";
const tridot = "\u25EC";
const trie = "\u225C";
const triminus = "\u2A3A";
const TripleDot = "\u20DB";
const triplus = "\u2A39";
const trisb = "\u29CD";
const tritime = "\u2A3B";
const trpezium = "\u23E2";
const Tscr = "\u{1D4AF}";
const tscr = "\u{1D4C9}";
const TScy = "\u0426";
const tscy = "\u0446";
const TSHcy = "\u040B";
const tshcy = "\u045B";
const Tstrok = "\u0166";
const tstrok = "\u0167";
const twixt = "\u226C";
const twoheadleftarrow = "\u219E";
const twoheadrightarrow = "\u21A0";
const Uacute = "\xDA";
const uacute = "\xFA";
const uarr = "\u2191";
const Uarr = "\u219F";
const uArr = "\u21D1";
const Uarrocir = "\u2949";
const Ubrcy = "\u040E";
const ubrcy = "\u045E";
const Ubreve = "\u016C";
const ubreve = "\u016D";
const Ucirc = "\xDB";
const ucirc = "\xFB";
const Ucy = "\u0423";
const ucy = "\u0443";
const udarr = "\u21C5";
const Udblac = "\u0170";
const udblac = "\u0171";
const udhar = "\u296E";
const ufisht = "\u297E";
const Ufr = "\u{1D518}";
const ufr = "\u{1D532}";
const Ugrave = "\xD9";
const ugrave = "\xF9";
const uHar = "\u2963";
const uharl = "\u21BF";
const uharr = "\u21BE";
const uhblk = "\u2580";
const ulcorn = "\u231C";
const ulcorner = "\u231C";
const ulcrop = "\u230F";
const ultri = "\u25F8";
const Umacr = "\u016A";
const umacr = "\u016B";
const uml = "\xA8";
const UnderBar = "_";
const UnderBrace = "\u23DF";
const UnderBracket = "\u23B5";
const UnderParenthesis = "\u23DD";
const Union = "\u22C3";
const UnionPlus = "\u228E";
const Uogon = "\u0172";
const uogon = "\u0173";
const Uopf = "\u{1D54C}";
const uopf = "\u{1D566}";
const UpArrowBar = "\u2912";
const uparrow = "\u2191";
const UpArrow = "\u2191";
const Uparrow = "\u21D1";
const UpArrowDownArrow = "\u21C5";
const updownarrow = "\u2195";
const UpDownArrow = "\u2195";
const Updownarrow = "\u21D5";
const UpEquilibrium = "\u296E";
const upharpoonleft = "\u21BF";
const upharpoonright = "\u21BE";
const uplus = "\u228E";
const UpperLeftArrow = "\u2196";
const UpperRightArrow = "\u2197";
const upsi = "\u03C5";
const Upsi = "\u03D2";
const upsih = "\u03D2";
const Upsilon = "\u03A5";
const upsilon = "\u03C5";
const UpTeeArrow = "\u21A5";
const UpTee = "\u22A5";
const upuparrows = "\u21C8";
const urcorn = "\u231D";
const urcorner = "\u231D";
const urcrop = "\u230E";
const Uring = "\u016E";
const uring = "\u016F";
const urtri = "\u25F9";
const Uscr = "\u{1D4B0}";
const uscr = "\u{1D4CA}";
const utdot = "\u22F0";
const Utilde = "\u0168";
const utilde = "\u0169";
const utri = "\u25B5";
const utrif = "\u25B4";
const uuarr = "\u21C8";
const Uuml = "\xDC";
const uuml = "\xFC";
const uwangle = "\u29A7";
const vangrt = "\u299C";
const varepsilon = "\u03F5";
const varkappa = "\u03F0";
const varnothing = "\u2205";
const varphi = "\u03D5";
const varpi = "\u03D6";
const varpropto = "\u221D";
const varr = "\u2195";
const vArr = "\u21D5";
const varrho = "\u03F1";
const varsigma = "\u03C2";
const varsubsetneq = "\u228A\uFE00";
const varsubsetneqq = "\u2ACB\uFE00";
const varsupsetneq = "\u228B\uFE00";
const varsupsetneqq = "\u2ACC\uFE00";
const vartheta = "\u03D1";
const vartriangleleft = "\u22B2";
const vartriangleright = "\u22B3";
const vBar = "\u2AE8";
const Vbar = "\u2AEB";
const vBarv = "\u2AE9";
const Vcy = "\u0412";
const vcy = "\u0432";
const vdash = "\u22A2";
const vDash = "\u22A8";
const Vdash = "\u22A9";
const VDash = "\u22AB";
const Vdashl = "\u2AE6";
const veebar = "\u22BB";
const vee = "\u2228";
const Vee = "\u22C1";
const veeeq = "\u225A";
const vellip = "\u22EE";
const verbar = "|";
const Verbar = "\u2016";
const vert = "|";
const Vert = "\u2016";
const VerticalBar = "\u2223";
const VerticalLine = "|";
const VerticalSeparator = "\u2758";
const VerticalTilde = "\u2240";
const VeryThinSpace = "\u200A";
const Vfr = "\u{1D519}";
const vfr = "\u{1D533}";
const vltri = "\u22B2";
const vnsub = "\u2282\u20D2";
const vnsup = "\u2283\u20D2";
const Vopf = "\u{1D54D}";
const vopf = "\u{1D567}";
const vprop = "\u221D";
const vrtri = "\u22B3";
const Vscr = "\u{1D4B1}";
const vscr = "\u{1D4CB}";
const vsubnE = "\u2ACB\uFE00";
const vsubne = "\u228A\uFE00";
const vsupnE = "\u2ACC\uFE00";
const vsupne = "\u228B\uFE00";
const Vvdash = "\u22AA";
const vzigzag = "\u299A";
const Wcirc = "\u0174";
const wcirc = "\u0175";
const wedbar = "\u2A5F";
const wedge = "\u2227";
const Wedge = "\u22C0";
const wedgeq = "\u2259";
const weierp = "\u2118";
const Wfr = "\u{1D51A}";
const wfr = "\u{1D534}";
const Wopf = "\u{1D54E}";
const wopf = "\u{1D568}";
const wp = "\u2118";
const wr = "\u2240";
const wreath = "\u2240";
const Wscr = "\u{1D4B2}";
const wscr = "\u{1D4CC}";
const xcap = "\u22C2";
const xcirc = "\u25EF";
const xcup = "\u22C3";
const xdtri = "\u25BD";
const Xfr = "\u{1D51B}";
const xfr = "\u{1D535}";
const xharr = "\u27F7";
const xhArr = "\u27FA";
const Xi = "\u039E";
const xi = "\u03BE";
const xlarr = "\u27F5";
const xlArr = "\u27F8";
const xmap = "\u27FC";
const xnis = "\u22FB";
const xodot = "\u2A00";
const Xopf = "\u{1D54F}";
const xopf = "\u{1D569}";
const xoplus = "\u2A01";
const xotime = "\u2A02";
const xrarr = "\u27F6";
const xrArr = "\u27F9";
const Xscr = "\u{1D4B3}";
const xscr = "\u{1D4CD}";
const xsqcup = "\u2A06";
const xuplus = "\u2A04";
const xutri = "\u25B3";
const xvee = "\u22C1";
const xwedge = "\u22C0";
const Yacute = "\xDD";
const yacute = "\xFD";
const YAcy = "\u042F";
const yacy = "\u044F";
const Ycirc = "\u0176";
const ycirc = "\u0177";
const Ycy = "\u042B";
const ycy = "\u044B";
const yen = "\xA5";
const Yfr = "\u{1D51C}";
const yfr = "\u{1D536}";
const YIcy = "\u0407";
const yicy = "\u0457";
const Yopf = "\u{1D550}";
const yopf = "\u{1D56A}";
const Yscr = "\u{1D4B4}";
const yscr = "\u{1D4CE}";
const YUcy = "\u042E";
const yucy = "\u044E";
const yuml = "\xFF";
const Yuml = "\u0178";
const Zacute = "\u0179";
const zacute = "\u017A";
const Zcaron = "\u017D";
const zcaron = "\u017E";
const Zcy = "\u0417";
const zcy = "\u0437";
const Zdot = "\u017B";
const zdot = "\u017C";
const zeetrf = "\u2128";
const ZeroWidthSpace = "\u200B";
const Zeta = "\u0396";
const zeta = "\u03B6";
const zfr = "\u{1D537}";
const Zfr = "\u2128";
const ZHcy = "\u0416";
const zhcy = "\u0436";
const zigrarr = "\u21DD";
const zopf = "\u{1D56B}";
const Zopf = "\u2124";
const Zscr = "\u{1D4B5}";
const zscr = "\u{1D4CF}";
const zwj = "\u200D";
const zwnj = "\u200C";
var require$$0 = {
  Aacute,
  aacute,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc,
  acirc,
  acute,
  Acy,
  acy,
  AElig,
  aelig,
  af,
  Afr,
  afr,
  Agrave,
  agrave,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp,
  AMP,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos,
  ApplyFunction,
  approx,
  approxeq,
  Aring,
  aring,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde,
  atilde,
  Auml,
  auml,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block: block$1,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil,
  ccedil,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil,
  Cedilla,
  cemptyv,
  cent,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon: colon$1,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy,
  COPY,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash: dash$1,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar: dollar$1,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute,
  eacute,
  easter,
  Ecaron,
  ecaron,
  Ecirc,
  ecirc,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave,
  egrave,
  egs,
  egsdot,
  el,
  Element: Element$3,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty: empty$1,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon: Epsilon$1,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH,
  eth,
  Euml,
  euml,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12,
  frac13,
  frac14,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt,
  GT,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute,
  iacute,
  ic,
  Icirc,
  icirc,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl,
  iff,
  ifr,
  Ifr,
  Igrave,
  igrave,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image: image$1,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  "in": "\u2208",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml,
  iuml,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt,
  LT,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr,
  male,
  malt,
  maltese,
  "Map": "\u2905",
  map,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro,
  midast,
  midcir,
  mid,
  middot,
  minusb,
  minus: minus$1,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde,
  ntilde,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute,
  oacute,
  oast,
  Ocirc,
  ocirc,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve,
  ograve,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order,
  orderof,
  ordf,
  ordm,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash,
  oslash,
  osol,
  Otilde,
  otilde,
  otimesas,
  Otimes,
  otimes,
  Ouml,
  ouml,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period: period$1,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus: plus$1,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec: prec$1,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot,
  QUOT,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg,
  REG,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star: star$1,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1,
  sup2,
  sup3,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig,
  Tab,
  target,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN,
  thorn,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top: top$1,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute,
  uacute,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc,
  ucirc,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave,
  ugrave,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml,
  uuml,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute,
  yacute,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
};
var entities$1 = require$$0;
var regex$4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
var mdurl$1 = {};
var encodeCache = {};
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
function encode(string2, exclude, keepEscaped) {
  var i, l, code2, nextCode, cache, result = "";
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  cache = getEncodeCache(exclude);
  for (i = 0, l = string2.length; i < l; i++) {
    code2 = string2.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string2.slice(i + 1, i + 3))) {
        result += string2.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
        nextCode = string2.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string2[i] + string2[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string2[i]);
  }
  return result;
}
encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";
var encode_1 = encode;
var decodeCache = {};
function getDecodeCache(exclude) {
  var i, ch, cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode(string2, exclude) {
  var cache;
  if (typeof exclude !== "string") {
    exclude = decode.defaultChars;
  }
  cache = getDecodeCache(exclude);
  return string2.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    var i, l, b1, b2, b3, b4, chr, result = "";
    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l) {
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l) {
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "\uFFFD\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l) {
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "\uFFFD\uFFFD\uFFFD\uFFFD";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result += "\uFFFD";
    }
    return result;
  });
}
decode.defaultChars = ";/?:@&=+$,#";
decode.componentChars = "";
var decode_1 = decode;
var format = function format2(url) {
  var result = "";
  result += url.protocol || "";
  result += url.slashes ? "//" : "";
  result += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result += "[" + url.hostname + "]";
  } else {
    result += url.hostname || "";
  }
  result += url.port ? ":" + url.port : "";
  result += url.pathname || "";
  result += url.search || "";
  result += url.hash || "";
  return result;
};
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, hostlessProtocol = {
  "javascript": true,
  "javascript:": true
}, slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }
  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url, slashesDenoteHost) {
  var i, l, lowerProto, hec, slashes, rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part2 = hostparts[i];
        if (!part2) {
          continue;
        }
        if (!part2.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j = 0, k = part2.length; j < k; j++) {
            if (part2.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part2[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part2.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  var hash2 = rest.indexOf("#");
  if (hash2 !== -1) {
    this.hash = rest.substr(hash2);
    rest = rest.slice(0, hash2);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse = urlParse;
mdurl$1.encode = encode_1;
mdurl$1.decode = decode_1;
mdurl$1.format = format;
mdurl$1.parse = parse;
var uc_micro = {};
var regex$3 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var regex$2 = /[\0-\x1F\x7F-\x9F]/;
var regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
var regex = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
uc_micro.Any = regex$3;
uc_micro.Cc = regex$2;
uc_micro.Cf = regex$1;
uc_micro.P = regex$4;
uc_micro.Z = regex;
(function(exports) {
  function _class2(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isString2(obj) {
    return _class2(obj) === "[object String]";
  }
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function has2(object, key) {
    return _hasOwnProperty.call(object, key);
  }
  function assign2(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source) {
        return;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be object");
      }
      Object.keys(source).forEach(function(key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }
  function arrayReplaceAt2(src, pos, newElements) {
    return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
  }
  function isValidEntityCode2(c) {
    if (c >= 55296 && c <= 57343) {
      return false;
    }
    if (c >= 64976 && c <= 65007) {
      return false;
    }
    if ((c & 65535) === 65535 || (c & 65535) === 65534) {
      return false;
    }
    if (c >= 0 && c <= 8) {
      return false;
    }
    if (c === 11) {
      return false;
    }
    if (c >= 14 && c <= 31) {
      return false;
    }
    if (c >= 127 && c <= 159) {
      return false;
    }
    if (c > 1114111) {
      return false;
    }
    return true;
  }
  function fromCodePoint2(c) {
    if (c > 65535) {
      c -= 65536;
      var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
      return String.fromCharCode(surrogate1, surrogate2);
    }
    return String.fromCharCode(c);
  }
  var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
  var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
  var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
  var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
  var entities2 = entities$1;
  function replaceEntityPattern(match2, name2) {
    var code2 = 0;
    if (has2(entities2, name2)) {
      return entities2[name2];
    }
    if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
      code2 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
      if (isValidEntityCode2(code2)) {
        return fromCodePoint2(code2);
      }
    }
    return match2;
  }
  function unescapeMd(str) {
    if (str.indexOf("\\") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_MD_RE, "$1");
  }
  function unescapeAll2(str) {
    if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity3) {
      if (escaped) {
        return escaped;
      }
      return replaceEntityPattern(match2, entity3);
    });
  }
  var HTML_ESCAPE_TEST_RE = /[&<>"]/;
  var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
  var HTML_REPLACEMENTS = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function replaceUnsafeChar(ch) {
    return HTML_REPLACEMENTS[ch];
  }
  function escapeHtml2(str) {
    if (HTML_ESCAPE_TEST_RE.test(str)) {
      return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
    }
    return str;
  }
  var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
  function escapeRE2(str) {
    return str.replace(REGEXP_ESCAPE_RE, "\\$&");
  }
  function isSpace2(code2) {
    switch (code2) {
      case 9:
      case 32:
        return true;
    }
    return false;
  }
  function isWhiteSpace2(code2) {
    if (code2 >= 8192 && code2 <= 8202) {
      return true;
    }
    switch (code2) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return true;
    }
    return false;
  }
  var UNICODE_PUNCT_RE = regex$4;
  function isPunctChar2(ch) {
    return UNICODE_PUNCT_RE.test(ch);
  }
  function isMdAsciiPunct2(ch) {
    switch (ch) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  function normalizeReference2(str) {
    str = str.trim().replace(/\s+/g, " ");
    if ("\u1E9E".toLowerCase() === "\u1E7E") {
      str = str.replace(//g, "\xDF");
    }
    return str.toLowerCase().toUpperCase();
  }
  exports.lib = {};
  exports.lib.mdurl = mdurl$1;
  exports.lib.ucmicro = uc_micro;
  exports.assign = assign2;
  exports.isString = isString2;
  exports.has = has2;
  exports.unescapeMd = unescapeMd;
  exports.unescapeAll = unescapeAll2;
  exports.isValidEntityCode = isValidEntityCode2;
  exports.fromCodePoint = fromCodePoint2;
  exports.escapeHtml = escapeHtml2;
  exports.arrayReplaceAt = arrayReplaceAt2;
  exports.isSpace = isSpace2;
  exports.isWhiteSpace = isWhiteSpace2;
  exports.isMdAsciiPunct = isMdAsciiPunct2;
  exports.isPunctChar = isPunctChar2;
  exports.escapeRE = escapeRE2;
  exports.normalizeReference = normalizeReference2;
})(utils$1);
var helpers$1 = {};
var parse_link_label = function parseLinkLabel(state, start, disableNested) {
  var level, found, marker2, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
  state.pos = start + 1;
  level = 1;
  while (state.pos < max) {
    marker2 = state.src.charCodeAt(state.pos);
    if (marker2 === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker2 === 91) {
      if (prevPos === state.pos - 1) {
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }
  if (found) {
    labelEnd = state.pos;
  }
  state.pos = oldPos;
  return labelEnd;
};
var unescapeAll$2 = utils$1.unescapeAll;
var parse_link_destination = function parseLinkDestination(str, pos, max) {
  var code2, level, lines = 0, start = pos, result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code2 = str.charCodeAt(pos);
      if (code2 === 10) {
        return result;
      }
      if (code2 === 60) {
        return result;
      }
      if (code2 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll$2(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code2 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  level = 0;
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === 32) {
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code2 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll$2(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};
var unescapeAll$1 = utils$1.unescapeAll;
var parse_link_title = function parseLinkTitle(str, pos, max) {
  var code2, marker2, lines = 0, start = pos, result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (pos >= max) {
    return result;
  }
  marker2 = str.charCodeAt(pos);
  if (marker2 !== 34 && marker2 !== 39 && marker2 !== 40) {
    return result;
  }
  pos++;
  if (marker2 === 40) {
    marker2 = 41;
  }
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === marker2) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll$1(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code2 === 40 && marker2 === 41) {
      return result;
    } else if (code2 === 10) {
      lines++;
    } else if (code2 === 92 && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 10) {
        lines++;
      }
    }
    pos++;
  }
  return result;
};
helpers$1.parseLinkLabel = parse_link_label;
helpers$1.parseLinkDestination = parse_link_destination;
helpers$1.parseLinkTitle = parse_link_title;
var assign$1 = utils$1.assign;
var unescapeAll = utils$1.unescapeAll;
var escapeHtml = utils$1.escapeHtml;
var default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env, slf) {
  var token2 = tokens[idx];
  return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml(tokens[idx].content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env, slf) {
  var token2 = tokens[idx];
  return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env, slf) {
  var token2 = tokens[idx], info = token2.info ? unescapeAll(token2.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
  if (info) {
    arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  if (options.highlight) {
    highlighted = options.highlight(token2.content, langName, langAttrs) || escapeHtml(token2.content);
  } else {
    highlighted = escapeHtml(token2.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    i = token2.attrIndex("class");
    tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options.langPrefix + langName;
    }
    tmpToken = {
      attrs: tmpAttrs
    };
    return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
  }
  return "<pre><code" + slf.renderAttrs(token2) + ">" + highlighted + "</code></pre>\n";
};
default_rules.image = function(tokens, idx, options, env, slf) {
  var token2 = tokens[idx];
  token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options, env);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer$1() {
  this.rules = assign$1({}, default_rules);
}
Renderer$1.prototype.renderAttrs = function renderAttrs(token2) {
  var i, l, result;
  if (!token2.attrs) {
    return "";
  }
  result = "";
  for (i = 0, l = token2.attrs.length; i < l; i++) {
    result += " " + escapeHtml(token2.attrs[i][0]) + '="' + escapeHtml(token2.attrs[i][1]) + '"';
  }
  return result;
};
Renderer$1.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken, result = "", needLf = false, token2 = tokens[idx];
  if (token2.hidden) {
    return "";
  }
  if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token2.nesting === -1 ? "</" : "<") + token2.tag;
  result += this.renderAttrs(token2);
  if (token2.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  if (token2.block) {
    needLf = true;
    if (token2.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer$1.prototype.renderInline = function(tokens, options, env) {
  var type, result = "", rules = this.rules;
  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;
    if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }
  return result;
};
Renderer$1.prototype.renderInlineAsText = function(tokens, options, env) {
  var result = "";
  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === "text") {
      result += tokens[i].content;
    } else if (tokens[i].type === "image") {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    } else if (tokens[i].type === "softbreak") {
      result += "\n";
    }
  }
  return result;
};
Renderer$1.prototype.render = function(tokens, options, env) {
  var i, len, type, result = "", rules = this.rules;
  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;
    if (type === "inline") {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== "undefined") {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }
  return result;
};
var renderer = Renderer$1;
function Ruler$3() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler$3.prototype.__find__ = function(name2) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name2) {
      return i;
    }
  }
  return -1;
};
Ruler$3.prototype.__compile__ = function() {
  var self2 = this;
  var chains = [""];
  self2.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self2.__cache__ = {};
  chains.forEach(function(chain) {
    self2.__cache__[chain] = [];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self2.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler$3.prototype.at = function(name2, fn, options) {
  var index2 = this.__find__(name2);
  var opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + name2);
  }
  this.__rules__[index2].fn = fn;
  this.__rules__[index2].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler$3.prototype.before = function(beforeName, ruleName, fn, options) {
  var index2 = this.__find__(beforeName);
  var opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index2, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.after = function(afterName, ruleName, fn, options) {
  var index2 = this.__find__(afterName);
  var opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index2 + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.push = function(ruleName, fn, options) {
  var opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.enable = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  var result = [];
  list3.forEach(function(name2) {
    var idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = true;
    result.push(name2);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler$3.prototype.enableOnly = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list3, ignoreInvalid);
};
Ruler$3.prototype.disable = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  var result = [];
  list3.forEach(function(name2) {
    var idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = false;
    result.push(name2);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler$3.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
var ruler = Ruler$3;
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
var normalize = function normalize2(state) {
  var str;
  str = state.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "\uFFFD");
  state.src = str;
};
var block = function block2(state) {
  var token2;
  if (state.inlineMode) {
    token2 = new state.Token("inline", "", 0);
    token2.content = state.src;
    token2.map = [0, 1];
    token2.children = [];
    state.tokens.push(token2);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};
var inline = function inline2(state) {
  var tokens = state.tokens, tok, i, l;
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === "inline") {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};
var arrayReplaceAt = utils$1.arrayReplaceAt;
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
var linkify = function linkify2(state) {
  var i, j, l, tokens, token2, currentToken, nodes, ln, text3, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
  if (!state.md.options.linkify) {
    return;
  }
  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }
    tokens = blockTokens[j].children;
    htmlLinkLevel = 0;
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
        text3 = currentToken.content;
        links = state.md.linkify.match(text3);
        nodes = [];
        level = currentToken.level;
        lastPos = 0;
        for (ln = 0; ln < links.length; ln++) {
          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }
          urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }
          pos = links[ln].index;
          if (pos > lastPos) {
            token2 = new state.Token("text", "", 0);
            token2.content = text3.slice(lastPos, pos);
            token2.level = level;
            nodes.push(token2);
          }
          token2 = new state.Token("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.level = level++;
          token2.markup = "linkify";
          token2.info = "auto";
          nodes.push(token2);
          token2 = new state.Token("text", "", 0);
          token2.content = urlText;
          token2.level = level;
          nodes.push(token2);
          token2 = new state.Token("link_close", "a", -1);
          token2.level = --level;
          token2.markup = "linkify";
          token2.info = "auto";
          nodes.push(token2);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text3.length) {
          token2 = new state.Token("text", "", 0);
          token2.content = text3.slice(lastPos);
          token2.level = level;
          nodes.push(token2);
        }
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: "\xA9",
  r: "\xAE",
  p: "\xA7",
  tm: "\u2122"
};
function replaceFn(match2, name2) {
  return SCOPED_ABBR[name2.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  var i, token2, inside_autolink = 0;
  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token2 = inlineTokens[i];
    if (token2.type === "text" && !inside_autolink) {
      token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  var i, token2, inside_autolink = 0;
  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token2 = inlineTokens[i];
    if (token2.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token2.content)) {
        token2.content = token2.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
      }
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
var replacements = function replace(state) {
  var blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};
var isWhiteSpace$1 = utils$1.isWhiteSpace;
var isPunctChar$1 = utils$1.isPunctChar;
var isMdAsciiPunct$1 = utils$1.isMdAsciiPunct;
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = "\u2019";
function replaceAt(str, index2, ch) {
  return str.substr(0, index2) + ch + str.substr(index2 + 1);
}
function process_inlines(tokens, state) {
  var i, token2, text3, t2, pos, max, thisLevel, item, lastChar, nextChar2, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
  stack = [];
  for (i = 0; i < tokens.length; i++) {
    token2 = tokens[i];
    thisLevel = tokens[i].level;
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;
    if (token2.type !== "text") {
      continue;
    }
    text3 = token2.content;
    pos = 0;
    max = text3.length;
    OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        t2 = QUOTE_RE.exec(text3);
        if (!t2) {
          break;
        }
        canOpen = canClose = true;
        pos = t2.index + 1;
        isSingle = t2[0] === "'";
        lastChar = 32;
        if (t2.index - 1 >= 0) {
          lastChar = text3.charCodeAt(t2.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }
        nextChar2 = 32;
        if (pos < max) {
          nextChar2 = text3.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            nextChar2 = tokens[j].content.charCodeAt(0);
            break;
          }
        }
        isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
        isNextPunctChar = isMdAsciiPunct$1(nextChar2) || isPunctChar$1(String.fromCharCode(nextChar2));
        isLastWhiteSpace = isWhiteSpace$1(lastChar);
        isNextWhiteSpace = isWhiteSpace$1(nextChar2);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar2 === 34 && t2[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token2.content = replaceAt(token2.content, t2.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j = stack.length - 1; j >= 0; j--) {
            item = stack[j];
            if (stack[j].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }
              token2.content = replaceAt(token2.content, t2.index, closeQuote);
              tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text3 = token2.content;
              max = text3.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t2.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token2.content = replaceAt(token2.content, t2.index, APOSTROPHE);
        }
      }
  }
}
var smartquotes = function smartquotes2(state) {
  var blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state.tokens[blkIdx].children, state);
  }
};
function Token$3(type, tag, nesting) {
  this.type = type;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token$3.prototype.attrIndex = function attrIndex(name2) {
  var attrs, i, len;
  if (!this.attrs) {
    return -1;
  }
  attrs = this.attrs;
  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name2) {
      return i;
    }
  }
  return -1;
};
Token$3.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token$3.prototype.attrSet = function attrSet(name2, value) {
  var idx = this.attrIndex(name2), attrData = [name2, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token$3.prototype.attrGet = function attrGet(name2) {
  var idx = this.attrIndex(name2), value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token$3.prototype.attrJoin = function attrJoin(name2, value) {
  var idx = this.attrIndex(name2);
  if (idx < 0) {
    this.attrPush([name2, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
var token = Token$3;
var Token$2 = token;
function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md;
}
StateCore.prototype.Token = Token$2;
var state_core = StateCore;
var Ruler$2 = ruler;
var _rules$2 = [
  ["normalize", normalize],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify],
  ["replacements", replacements],
  ["smartquotes", smartquotes]
];
function Core() {
  this.ruler = new Ruler$2();
  for (var i = 0; i < _rules$2.length; i++) {
    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
  }
}
Core.prototype.process = function(state) {
  var i, l, rules;
  rules = this.ruler.getRules("");
  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};
Core.prototype.State = state_core;
var parser_core = Core;
var isSpace$b = utils$1.isSpace;
function getLine(state, line) {
  var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
  return state.src.substr(pos, max - pos);
}
function escapedSplit(str) {
  var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current = "";
  ch = str.charCodeAt(pos);
  while (pos < max) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
var table = function table2(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, l, nextLine, columns, columnCount, token2, aligns, t2, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
  if (startLine + 2 > endLine) {
    return false;
  }
  nextLine = startLine + 1;
  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace$b(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace$b(secondCh)) {
    return false;
  }
  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace$b(ch)) {
      return false;
    }
    pos++;
  }
  lineText = getLine(state, startLine + 1);
  columns = lineText.split("|");
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t2 = columns[i].trim();
    if (!t2) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t2)) {
      return false;
    }
    if (t2.charCodeAt(t2.length - 1) === 58) {
      aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t2.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "")
    columns.shift();
  if (columns.length && columns[columns.length - 1] === "")
    columns.pop();
  columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  oldParentType = state.parentType;
  state.parentType = "table";
  terminatorRules = state.md.block.ruler.getRules("blockquote");
  token2 = state.push("table_open", "table", 1);
  token2.map = tableLines = [startLine, 0];
  token2 = state.push("thead_open", "thead", 1);
  token2.map = [startLine, startLine + 1];
  token2 = state.push("tr_open", "tr", 1);
  token2.map = [startLine, startLine + 1];
  for (i = 0; i < columns.length; i++) {
    token2 = state.push("th_open", "th", 1);
    if (aligns[i]) {
      token2.attrs = [["style", "text-align:" + aligns[i]]];
    }
    token2 = state.push("inline", "", 0);
    token2.content = columns[i].trim();
    token2.children = [];
    token2 = state.push("th_close", "th", -1);
  }
  token2 = state.push("tr_close", "tr", -1);
  token2 = state.push("thead_close", "thead", -1);
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "")
      columns.shift();
    if (columns.length && columns[columns.length - 1] === "")
      columns.pop();
    if (nextLine === startLine + 2) {
      token2 = state.push("tbody_open", "tbody", 1);
      token2.map = tbodyLines = [startLine + 2, 0];
    }
    token2 = state.push("tr_open", "tr", 1);
    token2.map = [nextLine, nextLine + 1];
    for (i = 0; i < columnCount; i++) {
      token2 = state.push("td_open", "td", 1);
      if (aligns[i]) {
        token2.attrs = [["style", "text-align:" + aligns[i]]];
      }
      token2 = state.push("inline", "", 0);
      token2.content = columns[i] ? columns[i].trim() : "";
      token2.children = [];
      token2 = state.push("td_close", "td", -1);
    }
    token2 = state.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    token2 = state.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  token2 = state.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
};
var code$1 = function code(state, startLine, endLine) {
  var nextLine, last, token2;
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }
  last = nextLine = startLine + 1;
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }
  state.line = last;
  token2 = state.push("code_block", "code", 0);
  token2.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
  token2.map = [startLine, state.line];
  return true;
};
var fence = function fence2(state, startLine, endLine, silent) {
  var marker2, len, params, nextLine, mem, token2, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  marker2 = state.src.charCodeAt(pos);
  if (marker2 !== 126 && marker2 !== 96) {
    return false;
  }
  mem = pos;
  pos = state.skipChars(pos, marker2);
  len = pos - mem;
  if (len < 3) {
    return false;
  }
  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);
  if (marker2 === 96) {
    if (params.indexOf(String.fromCharCode(marker2)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  nextLine = startLine;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.src.charCodeAt(pos) !== marker2) {
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      continue;
    }
    pos = state.skipChars(pos, marker2);
    if (pos - mem < len) {
      continue;
    }
    pos = state.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  token2 = state.push("fence", "code", 0);
  token2.info = params;
  token2.content = state.getLines(startLine + 1, nextLine, len, true);
  token2.markup = markup;
  token2.map = [startLine, state.line];
  return true;
};
var isSpace$a = utils$1.isSpace;
var blockquote = function blockquote2(state, startLine, endLine, silent) {
  var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token2, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos++) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  initial = offset = state.sCount[startLine] + 1;
  if (state.src.charCodeAt(pos) === 32) {
    pos++;
    initial++;
    offset++;
    adjustTab = false;
    spaceAfterMarker = true;
  } else if (state.src.charCodeAt(pos) === 9) {
    spaceAfterMarker = true;
    if ((state.bsCount[startLine] + offset) % 4 === 3) {
      pos++;
      initial++;
      offset++;
      adjustTab = false;
    } else {
      adjustTab = true;
    }
  } else {
    spaceAfterMarker = false;
  }
  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;
  while (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (isSpace$a(ch)) {
      if (ch === 9) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }
    pos++;
  }
  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
  lastLineEmpty = pos >= max;
  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;
  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];
  terminatorRules = state.md.block.ruler.getRules("blockquote");
  oldParentType = state.parentType;
  state.parentType = "blockquote";
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    isOutdented = state.sCount[nextLine] < state.blkIndent;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos >= max) {
      break;
    }
    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
      initial = offset = state.sCount[nextLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[nextLine] + offset) % 4 === 3) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (isSpace$a(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state.lineMax = nextLine;
      if (state.blkIndent !== 0) {
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }
      break;
    }
    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);
    state.sCount[nextLine] = -1;
  }
  oldIndent = state.blkIndent;
  state.blkIndent = 0;
  token2 = state.push("blockquote_open", "blockquote", 1);
  token2.markup = ">";
  token2.map = lines = [startLine, 0];
  state.md.block.tokenize(state, startLine, nextLine);
  token2 = state.push("blockquote_close", "blockquote", -1);
  token2.markup = ">";
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;
  return true;
};
var isSpace$9 = utils$1.isSpace;
var hr = function hr2(state, startLine, endLine, silent) {
  var marker2, cnt, ch, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  marker2 = state.src.charCodeAt(pos++);
  if (marker2 !== 42 && marker2 !== 45 && marker2 !== 95) {
    return false;
  }
  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker2 && !isSpace$9(ch)) {
      return false;
    }
    if (ch === marker2) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state.line = startLine + 1;
  token2 = state.push("hr", "hr", 0);
  token2.map = [startLine, state.line];
  token2.markup = Array(cnt + 1).join(String.fromCharCode(marker2));
  return true;
};
var isSpace$8 = utils$1.isSpace;
function skipBulletListMarker(state, startLine) {
  var marker2, pos, max, ch;
  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];
  marker2 = state.src.charCodeAt(pos++);
  if (marker2 !== 42 && marker2 !== 45 && marker2 !== 43) {
    return -1;
  }
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace$8(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state, startLine) {
  var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
  if (pos + 1 >= max) {
    return -1;
  }
  ch = state.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace$8(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state, idx) {
  var i, l, level = state.level + 2;
  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}
var list = function list2(state, startLine, endLine, silent) {
  var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token2, isTerminatingParagraph = false, tight = true;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
    return false;
  }
  if (silent && state.parentType === "paragraph") {
    if (state.sCount[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.slice(start, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1)
      return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
      return false;
  }
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
  if (silent) {
    return true;
  }
  listTokIdx = state.tokens.length;
  if (isOrdered) {
    token2 = state.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token2.attrs = [["start", markerValue]];
    }
  } else {
    token2 = state.push("bullet_list_open", "ul", 1);
  }
  token2.map = listLines = [startLine, 0];
  token2.markup = String.fromCharCode(markerCharCode);
  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules("list");
  oldParentType = state.parentType;
  state.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];
    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
    while (pos < max) {
      ch = state.src.charCodeAt(pos);
      if (ch === 9) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    contentStart = pos;
    if (contentStart >= max) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    indent = initial + indentAfterMarker;
    token2 = state.push("list_item_open", "li", 1);
    token2.markup = String.fromCharCode(markerCharCode);
    token2.map = itemLines = [startLine, 0];
    if (isOrdered) {
      token2.info = state.src.slice(start, posAfterMarker - 1);
    }
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldSCount = state.sCount[startLine];
    oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;
    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldSCount;
    state.tight = oldTight;
    token2 = state.push("list_item_close", "li", -1);
    token2.markup = String.fromCharCode(markerCharCode);
    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];
    if (nextLine >= endLine) {
      break;
    }
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      break;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token2 = state.push("ordered_list_close", "ol", -1);
  } else {
    token2 = state.push("bullet_list_close", "ul", -1);
  }
  token2.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }
  return true;
};
var normalizeReference$2 = utils$1.normalizeReference;
var isSpace$7 = utils$1.isSpace;
var reference = function reference2(state, startLine, _endLine, silent) {
  var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 91) {
    return false;
  }
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
      if (pos + 1 === max) {
        return false;
      }
      if (state.src.charCodeAt(pos + 1) !== 58) {
        return false;
      }
      break;
    }
  }
  endLine = state.lineMax;
  terminatorRules = state.md.block.ruler.getRules("reference");
  oldParentType = state.parentType;
  state.parentType = "reference";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;
  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      lines++;
    } else if (ch === 92) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 10) {
        lines++;
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 10) {
      lines++;
    } else if (isSpace$7(ch))
      ;
    else {
      break;
    }
  }
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }
  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }
  pos = res.pos;
  lines += res.lines;
  destEndPos = pos;
  destEndLineNo = lines;
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 10) {
      lines++;
    } else if (isSpace$7(ch))
      ;
    else {
      break;
    }
  }
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = "";
    pos = destEndPos;
    lines = destEndLineNo;
  }
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace$7(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace$7(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    return false;
  }
  label = normalizeReference$2(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state.env.references === "undefined") {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === "undefined") {
    state.env.references[label] = { title, href };
  }
  state.parentType = oldParentType;
  state.line = startLine + lines + 1;
  return true;
};
var html_blocks = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var html_re = {};
var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment$1 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Z]+\\s+[^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment$1 + "|" + processing + "|" + declaration + "|" + cdata + ")");
var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
html_re.HTML_TAG_RE = HTML_TAG_RE$1;
html_re.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;
var block_names = html_blocks;
var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;
var HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
var html_block = function html_block2(state, startLine, endLine, silent) {
  var i, nextLine, token2, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (!state.md.options.html) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  lineText = state.src.slice(pos, max);
  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i][2];
  }
  nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state.line = nextLine;
  token2 = state.push("html_block", "", 0);
  token2.map = [startLine, nextLine];
  token2.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
};
var isSpace$6 = utils$1.isSpace;
var heading$1 = function heading(state, startLine, endLine, silent) {
  var ch, level, tmp, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  ch = state.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max) {
    return false;
  }
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 35 && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace$6(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 35, pos);
  if (tmp > pos && isSpace$6(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state.line = startLine + 1;
  token2 = state.push("heading_open", "h" + String(level), 1);
  token2.markup = "########".slice(0, level);
  token2.map = [startLine, state.line];
  token2 = state.push("inline", "", 0);
  token2.content = state.src.slice(pos, max).trim();
  token2.map = [startLine, state.line];
  token2.children = [];
  token2 = state.push("heading_close", "h" + String(level), -1);
  token2.markup = "########".slice(0, level);
  return true;
};
var lheading = function lheading2(state, startLine, endLine) {
  var content2, terminate, i, l, token2, pos, max, level, marker2, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  oldParentType = state.parentType;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      if (pos < max) {
        marker2 = state.src.charCodeAt(pos);
        if (marker2 === 45 || marker2 === 61) {
          pos = state.skipChars(pos, marker2);
          pos = state.skipSpaces(pos);
          if (pos >= max) {
            level = marker2 === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  content2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  token2 = state.push("heading_open", "h" + String(level), 1);
  token2.markup = String.fromCharCode(marker2);
  token2.map = [startLine, state.line];
  token2 = state.push("inline", "", 0);
  token2.content = content2;
  token2.map = [startLine, state.line - 1];
  token2.children = [];
  token2 = state.push("heading_close", "h" + String(level), -1);
  token2.markup = String.fromCharCode(marker2);
  state.parentType = oldParentType;
  return true;
};
var paragraph = function paragraph2(state, startLine) {
  var content2, terminate, i, l, token2, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
  oldParentType = state.parentType;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  content2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  token2 = state.push("paragraph_open", "p", 1);
  token2.map = [startLine, state.line];
  token2 = state.push("inline", "", 0);
  token2.content = content2;
  token2.map = [startLine, state.line];
  token2.children = [];
  token2 = state.push("paragraph_close", "p", -1);
  state.parentType = oldParentType;
  return true;
};
var Token$1 = token;
var isSpace$5 = utils$1.isSpace;
function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;
  this.src = src;
  this.md = md;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  this.result = "";
  s = this.src;
  indent_found = false;
  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace$5(ch)) {
        indent++;
        if (ch === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type, tag, nesting) {
  var token2 = new Token$1(type, tag, nesting);
  token2.block = true;
  if (nesting < 0)
    this.level--;
  token2.level = this.level;
  if (nesting > 0)
    this.level++;
  this.tokens.push(token2);
  return token2;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;
  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace$5(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace$5(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code2) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code2 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
  if (begin >= end) {
    return "";
  }
  queue = new Array(end - begin);
  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];
    if (line + 1 < end || keepLastLF) {
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }
    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);
      if (isSpace$5(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first++;
    }
    if (lineIndent > indent) {
      queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }
  return queue.join("");
};
StateBlock.prototype.Token = Token$1;
var state_block = StateBlock;
var Ruler$1 = ruler;
var _rules$1 = [
  ["table", table, ["paragraph", "reference"]],
  ["code", code$1],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading$1, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock$1() {
  this.ruler = new Ruler$1();
  for (var i = 0; i < _rules$1.length; i++) {
    this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });
  }
}
ParserBlock$1.prototype.tokenize = function(state, startLine, endLine) {
  var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state.sCount[line] < state.blkIndent) {
      break;
    }
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }
    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }
    state.tight = !hasEmptyLines;
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }
    line = state.line;
    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};
ParserBlock$1.prototype.parse = function(src, md, env, outTokens) {
  var state;
  if (!src) {
    return;
  }
  state = new this.State(src, md, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};
ParserBlock$1.prototype.State = state_block;
var parser_block = ParserBlock$1;
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
var text = function text2(state, silent) {
  var pos = state.pos;
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state.pos) {
    return false;
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }
  state.pos = pos;
  return true;
};
var isSpace$4 = utils$1.isSpace;
var newline$1 = function newline(state, silent) {
  var pmax, max, ws, pos = state.pos;
  if (state.src.charCodeAt(pos) !== 10) {
    return false;
  }
  pmax = state.pending.length - 1;
  max = state.posMax;
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
          ws--;
        state.pending = state.pending.slice(0, ws);
        state.push("hardbreak", "br", 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push("softbreak", "br", 0);
      }
    } else {
      state.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max && isSpace$4(state.src.charCodeAt(pos))) {
    pos++;
  }
  state.pos = pos;
  return true;
};
var isSpace$3 = utils$1.isSpace;
var ESCAPED = [];
for (var i$1 = 0; i$1 < 256; i$1++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
var _escape = function escape(state, silent) {
  var ch, pos = state.pos, max = state.posMax;
  if (state.src.charCodeAt(pos) !== 92) {
    return false;
  }
  pos++;
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }
    if (ch === 10) {
      if (!silent) {
        state.push("hardbreak", "br", 0);
      }
      pos++;
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace$3(ch)) {
          break;
        }
        pos++;
      }
      state.pos = pos;
      return true;
    }
  }
  if (!silent) {
    state.pending += "\\";
  }
  state.pos++;
  return true;
};
var backticks = function backtick(state, silent) {
  var start, max, marker2, token2, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  start = pos;
  pos++;
  max = state.posMax;
  while (pos < max && state.src.charCodeAt(pos) === 96) {
    pos++;
  }
  marker2 = state.src.slice(start, pos);
  openerLength = marker2.length;
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent)
      state.pending += marker2;
    state.pos += openerLength;
    return true;
  }
  matchStart = matchEnd = pos;
  while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        token2 = state.push("code_inline", "code", 0);
        token2.markup = marker2;
        token2.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state.pos = matchEnd;
      return true;
    }
    state.backticks[closerLength] = matchStart;
  }
  state.backticksScanned = true;
  if (!silent)
    state.pending += marker2;
  state.pos += openerLength;
  return true;
};
var strikethrough = {};
strikethrough.tokenize = function strikethrough2(state, silent) {
  var i, scanned, token2, len, ch, start = state.pos, marker2 = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker2 !== 126) {
    return false;
  }
  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker2);
  if (len < 2) {
    return false;
  }
  if (len % 2) {
    token2 = state.push("text", "", 0);
    token2.content = ch;
    len--;
  }
  for (i = 0; i < len; i += 2) {
    token2 = state.push("text", "", 0);
    token2.content = ch + ch;
    state.delimiters.push({
      marker: marker2,
      length: 0,
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
};
function postProcess$1(state, delimiters) {
  var i, j, startDelim, endDelim, token2, loneMarkers = [], max = delimiters.length;
  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    endDelim = delimiters[startDelim.end];
    token2 = state.tokens[startDelim.token];
    token2.type = "s_open";
    token2.tag = "s";
    token2.nesting = 1;
    token2.markup = "~~";
    token2.content = "";
    token2 = state.tokens[endDelim.token];
    token2.type = "s_close";
    token2.tag = "s";
    token2.nesting = -1;
    token2.markup = "~~";
    token2.content = "";
    if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;
    while (j < state.tokens.length && state.tokens[j].type === "s_close") {
      j++;
    }
    j--;
    if (i !== j) {
      token2 = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token2;
    }
  }
}
strikethrough.postProcess = function strikethrough3(state) {
  var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
  postProcess$1(state, state.delimiters);
  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess$1(state, tokens_meta[curr].delimiters);
    }
  }
};
var emphasis = {};
emphasis.tokenize = function emphasis2(state, silent) {
  var i, scanned, token2, start = state.pos, marker2 = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker2 !== 95 && marker2 !== 42) {
    return false;
  }
  scanned = state.scanDelims(state.pos, marker2 === 42);
  for (i = 0; i < scanned.length; i++) {
    token2 = state.push("text", "", 0);
    token2.content = String.fromCharCode(marker2);
    state.delimiters.push({
      marker: marker2,
      length: scanned.length,
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
};
function postProcess(state, delimiters) {
  var i, startDelim, endDelim, token2, ch, isStrong, max = delimiters.length;
  for (i = max - 1; i >= 0; i--) {
    startDelim = delimiters[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    endDelim = delimiters[startDelim.end];
    isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
    ch = String.fromCharCode(startDelim.marker);
    token2 = state.tokens[startDelim.token];
    token2.type = isStrong ? "strong_open" : "em_open";
    token2.tag = isStrong ? "strong" : "em";
    token2.nesting = 1;
    token2.markup = isStrong ? ch + ch : ch;
    token2.content = "";
    token2 = state.tokens[endDelim.token];
    token2.type = isStrong ? "strong_close" : "em_close";
    token2.tag = isStrong ? "strong" : "em";
    token2.nesting = -1;
    token2.markup = isStrong ? ch + ch : ch;
    token2.content = "";
    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = "";
      state.tokens[delimiters[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
emphasis.postProcess = function emphasis3(state) {
  var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
};
var normalizeReference$1 = utils$1.normalizeReference;
var isSpace$2 = utils$1.isSpace;
var link = function link2(state, silent) {
  var attrs, code2, label, labelEnd, labelStart, pos, res, ref2, token2, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
  if (state.src.charCodeAt(state.pos) !== 91) {
    return false;
  }
  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace$2(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace$2(code2) && code2 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace$2(code2) && code2 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref2 = state.env.references[normalizeReference$1(label)];
    if (!ref2) {
      state.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    token2 = state.push("link_open", "a", 1);
    token2.attrs = attrs = [["href", href]];
    if (title) {
      attrs.push(["title", title]);
    }
    state.md.inline.tokenize(state);
    token2 = state.push("link_close", "a", -1);
  }
  state.pos = pos;
  state.posMax = max;
  return true;
};
var normalizeReference = utils$1.normalizeReference;
var isSpace$1 = utils$1.isSpace;
var image = function image2(state, silent) {
  var attrs, code2, content2, label, labelEnd, labelStart, pos, ref2, res, title, token2, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 33) {
    return false;
  }
  if (state.src.charCodeAt(state.pos + 1) !== 91) {
    return false;
  }
  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace$1(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start = pos;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace$1(code2) && code2 !== 10) {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace$1(code2) && code2 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref2 = state.env.references[normalizeReference(label)];
    if (!ref2) {
      state.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  if (!silent) {
    content2 = state.src.slice(labelStart, labelEnd);
    state.md.inline.parse(content2, state.md, state.env, tokens = []);
    token2 = state.push("image", "img", 0);
    token2.attrs = attrs = [["src", href], ["alt", ""]];
    token2.children = tokens;
    token2.content = content2;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state.pos = pos;
  state.posMax = max;
  return true;
};
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
var autolink = function autolink2(state, silent) {
  var url, fullUrl, token2, ch, start, max, pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  start = state.pos;
  max = state.posMax;
  for (; ; ) {
    if (++pos >= max)
      return false;
    ch = state.src.charCodeAt(pos);
    if (ch === 60)
      return false;
    if (ch === 62)
      break;
  }
  url = state.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token2 = state.push("link_open", "a", 1);
      token2.attrs = [["href", fullUrl]];
      token2.markup = "autolink";
      token2.info = "auto";
      token2 = state.push("text", "", 0);
      token2.content = state.md.normalizeLinkText(url);
      token2 = state.push("link_close", "a", -1);
      token2.markup = "autolink";
      token2.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    fullUrl = state.md.normalizeLink("mailto:" + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token2 = state.push("link_open", "a", 1);
      token2.attrs = [["href", fullUrl]];
      token2.markup = "autolink";
      token2.info = "auto";
      token2 = state.push("text", "", 0);
      token2.content = state.md.normalizeLinkText(url);
      token2 = state.push("link_close", "a", -1);
      token2.markup = "autolink";
      token2.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  return false;
};
var HTML_TAG_RE = html_re.HTML_TAG_RE;
function isLetter(ch) {
  var lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
var html_inline = function html_inline2(state, silent) {
  var ch, match2, max, token2, pos = state.pos;
  if (!state.md.options.html) {
    return false;
  }
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  match2 = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match2) {
    return false;
  }
  if (!silent) {
    token2 = state.push("html_inline", "", 0);
    token2.content = state.src.slice(pos, pos + match2[0].length);
  }
  state.pos += match2[0].length;
  return true;
};
var entities = entities$1;
var has = utils$1.has;
var isValidEntityCode = utils$1.isValidEntityCode;
var fromCodePoint$1 = utils$1.fromCodePoint;
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
var entity = function entity2(state, silent) {
  var ch, code2, match2, pos = state.pos, max = state.posMax;
  if (state.src.charCodeAt(pos) !== 38) {
    return false;
  }
  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);
    if (ch === 35) {
      match2 = state.src.slice(pos).match(DIGITAL_RE);
      if (match2) {
        if (!silent) {
          code2 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
          state.pending += isValidEntityCode(code2) ? fromCodePoint$1(code2) : fromCodePoint$1(65533);
        }
        state.pos += match2[0].length;
        return true;
      }
    } else {
      match2 = state.src.slice(pos).match(NAMED_RE);
      if (match2) {
        if (has(entities, match2[1])) {
          if (!silent) {
            state.pending += entities[match2[1]];
          }
          state.pos += match2[0].length;
          return true;
        }
      }
    }
  }
  if (!silent) {
    state.pending += "&";
  }
  state.pos++;
  return true;
};
function processDelimiters(state, delimiters) {
  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
  if (!max)
    return;
  var headerIdx = 0;
  var lastTokenIdx = -2;
  var jumps = [];
  for (closerIdx = 0; closerIdx < max; closerIdx++) {
    closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close)
      continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    openerIdx = headerIdx - jumps[headerIdx] - 1;
    newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker)
        continue;
      if (opener.open && opener.end < 0) {
        isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
var balance_pairs = function link_pairs(state) {
  var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
  processDelimiters(state, state.delimiters);
  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(state, tokens_meta[curr].delimiters);
    }
  }
};
var text_collapse = function text_collapse2(state) {
  var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
  for (curr = last = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0)
      level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0)
      level++;
    if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }
      last++;
    }
  }
  if (curr !== last) {
    tokens.length = last;
  }
};
var Token = token;
var isWhiteSpace = utils$1.isWhiteSpace;
var isPunctChar = utils$1.isPunctChar;
var isMdAsciiPunct = utils$1.isMdAsciiPunct;
function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
}
StateInline.prototype.pushPending = function() {
  var token2 = new Token("text", "", 0);
  token2.content = this.pending;
  token2.level = this.pendingLevel;
  this.tokens.push(token2);
  this.pending = "";
  return token2;
};
StateInline.prototype.push = function(type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  var token2 = new Token(type, tag, nesting);
  var token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token2.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token2);
  this.tokens_meta.push(token_meta);
  return token2;
};
StateInline.prototype.scanDelims = function(start, canSplitWord) {
  var pos = start, lastChar, nextChar2, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker2 = this.src.charCodeAt(start);
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
  while (pos < max && this.src.charCodeAt(pos) === marker2) {
    pos++;
  }
  count = pos - start;
  nextChar2 = pos < max ? this.src.charCodeAt(pos) : 32;
  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar2) || isPunctChar(String.fromCharCode(nextChar2));
  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar2);
  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }
  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }
  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }
  return {
    can_open,
    can_close,
    length: count
  };
};
StateInline.prototype.Token = Token;
var state_inline = StateInline;
var Ruler = ruler;
var _rules = [
  ["text", text],
  ["newline", newline$1],
  ["escape", _escape],
  ["backticks", backticks],
  ["strikethrough", strikethrough.tokenize],
  ["emphasis", emphasis.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
var _rules2 = [
  ["balance_pairs", balance_pairs],
  ["strikethrough", strikethrough.postProcess],
  ["emphasis", emphasis.postProcess],
  ["text_collapse", text_collapse]
];
function ParserInline$1() {
  var i;
  this.ruler = new Ruler();
  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
  this.ruler2 = new Ruler();
  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}
ParserInline$1.prototype.skipToken = function(state) {
  var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
  if (typeof cache[pos] !== "undefined") {
    state.pos = cache[pos];
    return;
  }
  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      state.level++;
      ok = rules[i](state, true);
      state.level--;
      if (ok) {
        break;
      }
    }
  } else {
    state.pos = state.posMax;
  }
  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};
ParserInline$1.prototype.tokenize = function(state) {
  var ok, i, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
  while (state.pos < end) {
    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }
    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }
    state.pending += state.src[state.pos++];
  }
  if (state.pending) {
    state.pushPending();
  }
};
ParserInline$1.prototype.parse = function(str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);
  this.tokenize(state);
  rules = this.ruler2.getRules("");
  len = rules.length;
  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};
ParserInline$1.prototype.State = state_inline;
var parser_inline = ParserInline$1;
var re = function(opts) {
  var re2 = {};
  re2.src_Any = regex$3.source;
  re2.src_Cc = regex$2.source;
  re2.src_Z = regex.source;
  re2.src_P = regex$4.source;
  re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
  re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
  var text_separators = "[><\uFF5C]";
  re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
  re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
  re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re2.src_ZCc + ").|;(?!" + re2.src_ZCc + ").|\\!+(?!" + re2.src_ZCc + "|[!]).|\\?(?!" + re2.src_ZCc + "|[?]).)+|\\/)?";
  re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re2.src_domain_root = "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
  re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
  re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
  re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
  re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
  re2.src_host_strict = re2.src_host + re2.src_host_terminator;
  re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
  re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
  re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
  re2.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
  re2.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
  return re2;
};
function assign(obj) {
  var sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === "[object String]";
}
function isObject(obj) {
  return _class(obj) === "[object Object]";
}
function isRegExp(obj) {
  return _class(obj) === "[object RegExp]";
}
function isFunction(obj) {
  return _class(obj) === "[object Function]";
}
function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var defaultOptions$1 = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k) {
    return acc || defaultOptions$1.hasOwnProperty(k);
  }, false);
}
var defaultSchemas = {
  "http:": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text3[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text3[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
function createValidator(re2) {
  return function(text3, pos) {
    var tail = text3.slice(pos);
    if (re2.test(tail)) {
      return tail.match(re2)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match2, self2) {
    self2.normalize(match2);
  };
}
function compile(self2) {
  var re$1 = self2.re = re(self2.__opts__);
  var tlds2 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re);
  }
  tlds2.push(re$1.src_xn);
  re$1.src_tlds = tlds2.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re$1.src_tlds);
  }
  re$1.email_fuzzy = RegExp(untpl(re$1.tpl_email_fuzzy), "i");
  re$1.link_fuzzy = RegExp(untpl(re$1.tpl_link_fuzzy), "i");
  re$1.link_no_ip_fuzzy = RegExp(untpl(re$1.tpl_link_no_ip_fuzzy), "i");
  re$1.host_fuzzy_test = RegExp(untpl(re$1.tpl_host_fuzzy_test), "i");
  var aliases = [];
  self2.__compiled__ = {};
  function schemaError(name2, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val);
  }
  Object.keys(self2.__schemas__).forEach(function(name2) {
    var val = self2.__schemas__[name2];
    if (val === null) {
      return;
    }
    var compiled = { validate: null, link: null };
    self2.__compiled__[name2] = compiled;
    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name2, val);
      }
      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name2, val);
      }
      return;
    }
    if (isString(val)) {
      aliases.push(name2);
      return;
    }
    schemaError(name2, val);
  });
  aliases.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  var slist = Object.keys(self2.__compiled__).filter(function(name2) {
    return name2.length > 0 && self2.__compiled__[name2];
  }).map(escapeRE).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re$1.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re$1.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
  resetScanCache(self2);
}
function Match(self2, shift2) {
  var start = self2.__index__, end = self2.__last_index__, text3 = self2.__text_cache__.slice(start, end);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start + shift2;
  this.lastIndex = end + shift2;
  this.raw = text3;
  this.text = text3;
  this.url = text3;
}
function createMatch(self2, shift2) {
  var match2 = new Match(self2, shift2);
  self2.__compiled__[match2.schema].normalize(match2, self2);
  return match2;
}
function LinkifyIt$1(schemas, options) {
  if (!(this instanceof LinkifyIt$1)) {
    return new LinkifyIt$1(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign({}, defaultOptions$1, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
LinkifyIt$1.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};
LinkifyIt$1.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};
LinkifyIt$1.prototype.test = function test(text3) {
  this.__text_cache__ = text3;
  this.__index__ = -1;
  if (!text3.length) {
    return false;
  }
  var m, ml, me, len, shift2, next, re2, tld_pos, at_pos;
  if (this.re.schema_test.test(text3)) {
    re2 = this.re.schema_search;
    re2.lastIndex = 0;
    while ((m = re2.exec(text3)) !== null) {
      len = this.testSchemaAt(text3, m[2], re2.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text3.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text3.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift2 = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift2 < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift2;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text3.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text3.match(this.re.email_fuzzy)) !== null) {
        shift2 = me.index + me[1].length;
        next = me.index + me[0].length;
        if (this.__index__ < 0 || shift2 < this.__index__ || shift2 === this.__index__ && next > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift2;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt$1.prototype.pretest = function pretest(text3) {
  return this.re.pretest.test(text3);
};
LinkifyIt$1.prototype.testSchemaAt = function testSchemaAt(text3, schema, pos) {
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text3, pos, this);
};
LinkifyIt$1.prototype.match = function match(text3) {
  var shift2 = 0, result = [];
  if (this.__index__ >= 0 && this.__text_cache__ === text3) {
    result.push(createMatch(this, shift2));
    shift2 = this.__last_index__;
  }
  var tail = shift2 ? text3.slice(shift2) : text3;
  while (this.test(tail)) {
    result.push(createMatch(this, shift2));
    tail = tail.slice(this.__last_index__);
    shift2 += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt$1.prototype.tlds = function tlds(list3, keepOld) {
  list3 = Array.isArray(list3) ? list3 : [list3];
  if (!keepOld) {
    this.__tlds__ = list3.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list3).sort().filter(function(el2, idx, arr) {
    return el2 !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
LinkifyIt$1.prototype.normalize = function normalize3(match2) {
  if (!match2.schema) {
    match2.url = "http://" + match2.url;
  }
  if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
    match2.url = "mailto:" + match2.url;
  }
};
LinkifyIt$1.prototype.onCompile = function onCompile() {
};
var linkifyIt = LinkifyIt$1;
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": __viteBrowserExternal
});
var require$$8 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var _default = {
  options: {
    html: false,
    xhtmlOut: false,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
var zero = {
  options: {
    html: false,
    xhtmlOut: false,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "text_collapse"
      ]
    }
  }
};
var commonmark$1 = {
  options: {
    html: true,
    xhtmlOut: true,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "text_collapse"
      ]
    }
  }
};
var utils = utils$1;
var helpers = helpers$1;
var Renderer = renderer;
var ParserCore = parser_core;
var ParserBlock = parser_block;
var ParserInline = parser_inline;
var LinkifyIt = linkifyIt;
var mdurl = mdurl$1;
var punycode = require$$8;
var config$1 = {
  default: _default,
  zero,
  commonmark: commonmark$1
};
var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  var str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}
var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return mdurl.encode(mdurl.format(parsed));
}
function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new ParserInline();
  this.block = new ParserBlock();
  this.core = new ParserCore();
  this.renderer = new Renderer();
  this.linkify = new LinkifyIt();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils;
  this.helpers = utils.assign({}, helpers);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  utils.assign(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  var self2 = this, presetName;
  if (utils.isString(presets)) {
    presetName = presets;
    presets = config$1[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self2.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name2) {
      if (presets.components[name2].rules) {
        self2[name2].ruler.enableOnly(presets.components[name2].rules);
      }
      if (presets.components[name2].rules2) {
        self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list3, ignoreInvalid) {
  var result = [];
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list3, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list3, true));
  var missed = list3.filter(function(name2) {
    return result.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list3, ignoreInvalid) {
  var result = [];
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list3, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list3, true));
  var missed = list3.filter(function(name2) {
    return result.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  var state = new this.core.State(src, this, env);
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  var state = new this.core.State(src, this, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
var lib = MarkdownIt;
var markdownIt = lib;
const sourcemap = (md) => {
  const types2 = Object.keys(md.renderer.rules);
  md.core.ruler.push("sourcemap", (state) => {
    const tokens = state.tokens;
    for (const token2 of tokens) {
      if (token2.level === 0 && token2.map !== null && (token2.type.endsWith("_open") || types2.includes(token2.type))) {
        const start = `${token2.map[0] + 1}`;
        const end = `${token2.map[1]}`;
        token2.attrPush(["data-source-start", start]);
        token2.attrPush(["data-source-end", end]);
        token2.attrPush(["data-source-level", "0"]);
      }
    }
  });
};
let disableCheckboxes = true;
let useLabelWrapper = false;
let useLabelAfter = false;
let lineNumber = false;
function attrSet2(token2, name2, value) {
  const index2 = token2.attrIndex(name2);
  const attr = [name2, value];
  if (index2 < 0) {
    token2.attrPush(attr);
  } else {
    if (token2 && token2.attrs) {
      token2.attrs[index2] = attr;
    }
  }
}
function parentToken(tokens, index2) {
  const targetLevel = tokens[index2].level - 1;
  for (let i = index2 - 1; i >= 0; i--) {
    if (tokens[i].level === targetLevel) {
      return i;
    }
  }
  return -1;
}
function isTodoItem(tokens, index2) {
  return isInline(tokens[index2]) && isParagraph(tokens[index2 - 1]) && isListItem(tokens[index2 - 2]) && startsWithTodoMarkdown(tokens[index2]);
}
function todoify(token2) {
  if (token2.children) {
    token2.children.unshift(makeCheckbox(token2));
    token2.children[1].content = token2.children[1].content.slice(3);
    token2.content = token2.content.slice(3);
    if (useLabelWrapper) {
      if (useLabelAfter) {
        token2.children.pop();
        const id2 = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
        token2.children[0].content = token2.children[0].content.slice(0, -1) + ' id="' + id2 + '">';
        token2.children.push(afterLabel(token2.content, id2));
      } else {
        token2.children.unshift(beginLabel());
        token2.children.push(endLabel());
      }
    }
  }
}
function makeCheckbox(token$1) {
  const checkbox = new token("html_inline", "", 0);
  const disabledAttr = disableCheckboxes ? ' disabled="" ' : "";
  const dataLine = lineNumber ? token$1.map ? `data-line="${token$1.map[0]}"` : 'data-line=""' : "";
  if (token$1.content.indexOf("[ ] ") === 0) {
    checkbox.content = '<input class="task-list-item-checkbox"' + disabledAttr + 'type="checkbox" ' + dataLine + ">";
  } else if (token$1.content.indexOf("[x] ") === 0 || token$1.content.indexOf("[X] ") === 0) {
    checkbox.content = '<input class="task-list-item-checkbox" checked=""' + disabledAttr + 'type="checkbox" ' + dataLine + ">";
  }
  return checkbox;
}
function beginLabel() {
  const token$1 = new token("html_inline", "", 0);
  token$1.content = "<label>";
  return token$1;
}
function endLabel() {
  const token$1 = new token("html_inline", "", 0);
  token$1.content = "</label>";
  return token$1;
}
function afterLabel(content2, id2) {
  const token$1 = new token("html_inline", "", 0);
  token$1.content = '<label class="task-list-item-label" for="' + id2 + '">' + content2 + "</label>";
  token$1.attrs = [["for", "id"]];
  return token$1;
}
function isInline(token2) {
  return token2.type === "inline";
}
function isParagraph(token2) {
  return token2.type === "paragraph_open";
}
function isListItem(token2) {
  return token2.type === "list_item_open";
}
function startsWithTodoMarkdown(token2) {
  return token2.content.indexOf("[ ] ") === 0 || token2.content.indexOf("[x] ") === 0 || token2.content.indexOf("[X] ") === 0;
}
function MarkdownItTaskLists(md, options) {
  if (options) {
    disableCheckboxes = !options.enabled;
    useLabelWrapper = !!options.label;
    useLabelAfter = !!options.labelAfter;
    lineNumber = !!options.lineNumber;
  }
  md.core.ruler.after("inline", "github-task-lists", function(state) {
    const tokens = state.tokens;
    for (let i = 2; i < tokens.length; i++) {
      if (isTodoItem(tokens, i)) {
        todoify(tokens[i]);
        attrSet2(tokens[i - 2], "class", "task-list-item" + (!disableCheckboxes ? " enabled" : ""));
        attrSet2(tokens[parentToken(tokens, i - 2)], "class", "totonoo--task-list");
      }
    }
    return false;
  });
}
const validAudioExtensions = ["aac", "m4a", "mp3", "oga", "ogg", "wav"];
const validVideoExtensions = ["mp4", "m4v", "ogv", "webm", "mpg", "mpeg"];
function tokenizeImagesAndMedia(state, silent, md) {
  let attrs, code2, label, pos, ref2, res, title, tokens, start;
  let href = "";
  const oldPos = state.pos, max = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 33 || state.src.charCodeAt(state.pos + 1) !== 91)
    return false;
  const labelStart = state.pos + 2;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
  if (labelEnd < 0)
    return false;
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!md.utils.isSpace(code2) && code2 !== 10)
        break;
    }
    if (pos >= max)
      return false;
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start = pos;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!md.utils.isSpace(code2) && code2 !== 10)
        break;
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!md.utils.isSpace(code2) && code2 !== 10)
          break;
      }
    } else {
      title = "";
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state.env.references === "undefined")
      return false;
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label)
      label = state.src.slice(labelStart, labelEnd);
    ref2 = state.env.references[md.utils.normalizeReference(label)];
    if (!ref2) {
      state.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  state.pos = pos;
  state.posMax = max;
  if (silent)
    return true;
  const content2 = state.src.slice(labelStart, labelEnd);
  state.md.inline.parse(content2, state.md, state.env, tokens = []);
  const mediaType = guessMediaType(href);
  const tag = mediaType == "image" ? "img" : mediaType;
  const token2 = state.push(mediaType, tag, 0);
  token2.attrs = attrs = [];
  attrs.push(["src", href]);
  if (mediaType == "image")
    attrs.push(["alt", ""]);
  token2.children = tokens;
  token2.content = content2;
  if (title)
    attrs.push(["title", title]);
  state.pos = pos;
  state.posMax = max;
  return true;
}
function guessMediaType(url) {
  const extensionMatch = url.match(/\.([^/.]+)$/);
  if (extensionMatch === null)
    return "image";
  const extension = extensionMatch[1];
  if (validAudioExtensions.indexOf(extension.toLowerCase()) != -1)
    return "audio";
  else if (validVideoExtensions.indexOf(extension.toLowerCase()) != -1)
    return "video";
  else
    return "image";
}
function renderMedia(tokens, idx, options, md) {
  const token2 = tokens[idx];
  const type = token2.type;
  if (type !== "video" && type !== "audio")
    return "";
  let attrs = type === "video" ? options.html5Media.videoAttrs : options.html5Media.audioAttrs;
  attrs = attrs.trim();
  if (attrs)
    attrs = " " + attrs;
  const url = token2.attrs ? token2.attrs[token2.attrIndex("src")][1] : "";
  const title = token2.attrIndex("title") != -1 ? ` title="${md.utils.escapeHtml(token2.attrs ? token2.attrs[token2.attrIndex("title")][1] : "")}"` : "";
  const fallbackText = `
     Your browser does not support playing HTML5 ${type}.

     You can <a href="${url}" download>download the file</a> instead.
   `;
  const description = token2.content ? "\n Here is a description of the content: " + md.utils.escapeHtml(token2.content) : "";
  return `<${type} src="${url}"${title}${attrs}>
${fallbackText}${description}
</${type}>`;
}
function html5Media(md, options = {}) {
  const defaultOpts = {
    videoAttrs: 'controls class="html5-video-player"',
    audioAttrs: 'controls class="html5-audio-player"'
  };
  const _options = Object.assign(defaultOpts, options);
  const videoAttrs = _options.videoAttrs;
  const audioAttrs = _options.audioAttrs;
  md.inline.ruler.at("image", (tokens, silent) => tokenizeImagesAndMedia(tokens, silent, md));
  md.renderer.rules.video = md.renderer.rules.audio = (tokens, idx, opt) => {
    const _opt = __spreadProps(__spreadValues({}, opt), {
      html5Media: {
        videoAttrs,
        audioAttrs
      }
    });
    return renderMedia(tokens, idx, _opt, md);
  };
}
const markdownItConfig = {
  html: true,
  xhtmlOut: false,
  breaks: false,
  langPrefix: "language-",
  linkify: false,
  typographer: false,
  quotes: "\u201C\u201D\u2018\u2019"
};
const _markdownIt = new markdownIt(markdownItConfig);
_markdownIt.use(MarkdownItTaskLists);
_markdownIt.use(html5Media);
_markdownIt.use(sourcemap);
var md2html = (md) => {
  const html2 = _markdownIt.render(md);
  return html2;
};
var preview = "";
var preview_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$2 = defineComponent({
  props: {
    modelValue: {
      type: String,
      default: ""
    },
    root: {
      type: Element,
      default: null
    }
  },
  setup(props, ctx) {
    const height = ref(300);
    const previewBox = ref();
    const setHeight = () => {
      var _a, _b, _c;
      if (props.root) {
        const h = props.root.clientHeight;
        const _th = (_c = (_b = (_a = previewBox == null ? void 0 : previewBox.value) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.querySelector(".title")) == null ? void 0 : _c.clientHeight;
        let th = 40;
        if (_th) {
          th = _th;
        }
        height.value = h - th - 32;
      }
    };
    const parser2 = (md) => {
      let html22 = md2html(md);
      html22 = html22.replace(/<pre><code data-source-start="(\d+)" data-source-end="(\d+)" data-source-level="(\d+)"/g, '<pre data-source-start="$1" data-source-end="$2" data-source-level="$3"><code');
      return html22;
    };
    const html2 = computed(() => {
      return parser2(props.modelValue);
    });
    onMounted(() => {
      nextTick(() => {
        setHeight();
      });
    });
    return {
      previewBox,
      height,
      html: html2
    };
  }
});
const _hoisted_1$5 = ["innerHTML"];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "editor-preview",
    ref: "previewBox",
    style: normalizeStyle({
      height: _ctx.height + "px"
    })
  }, [
    createElementVNode("div", {
      class: "editor-preview-content markdown-body",
      innerHTML: _ctx.html
    }, null, 8, _hoisted_1$5)
  ], 4);
}
var EditorPreview = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-e4aecd48"]]);
const _hoisted_1$4 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg",
  width: "128",
  height: "128"
};
const _hoisted_2$3 = /* @__PURE__ */ createElementVNode("path", {
  d: "M794.286 744.571q-30.857 5.143-62.857 5.143-104 0-192.572-51.428t-140-140-51.428-192.572q0-109.714 59.428-204Q292 196 219.143 292.571T146.286 512q0 74.286 29.143 142t78 116.571 116.571 78 142 29.143q82.286 0 156.286-35.143t126-98zm116-48.571q-53.715 116-162 185.429T512 950.857q-89.143 0-170.286-34.857t-140-93.714-93.714-140T73.143 512q0-87.429 32.857-167.143t89.143-138 134.571-94T495.43 73.714Q520.57 72.571 530.286 96q10.285 23.429-8.572 41.143-49.143 44.571-75.143 103.714t-26 124.857q0 84.572 41.715 156t113.143 113.143 156 41.714q67.428 0 130.285-29.142 23.429-10.286 41.143 7.428 8 8 10 19.429T910.286 696z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$3 = [
  _hoisted_2$3
];
function render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4, _hoisted_3$3);
}
var IconMoon = { render: render$2 };
const _hoisted_1$3 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg",
  width: "128",
  height: "128"
};
const _hoisted_2$2 = /* @__PURE__ */ createElementVNode("path", {
  d: "M512 428.9c45.8 0 83.1 37.2 83.1 83.1 0 45.8-37.3 83.1-83.1 83.1s-83.1-37.3-83.1-83.1c0-45.9 37.3-83.1 83.1-83.1m0-83.1c-91.8 0-166.2 74.4-166.2 166.2 0 91.8 74.4 166.2 166.2 166.2 91.8 0 166.2-74.4 166.2-166.2 0-91.8-74.4-166.2-166.2-166.2m0-83.1c-22.9 0-41.5-18.6-41.5-41.5v-83.1c0-23 18.6-41.5 41.5-41.5s41.5 18.6 41.5 41.5v83.1c.1 22.9-18.5 41.5-41.5 41.5m205.7 85.2c-10.6 0-21.3-4-29.4-12.1-16.2-16.3-16.2-42.5 0-58.8l58.8-58.8c16.2-16.2 42.5-16.2 58.8 0 16.3 16.3 16.3 42.5 0 58.8l-58.8 58.8c-8.1 8-18.8 12.1-29.4 12.1M886 553.6h-83.1c-22.9 0-41.5-18.6-41.5-41.5s18.6-41.6 41.5-41.6H886c23 0 41.5 18.6 41.5 41.6 0 22.9-18.6 41.5-41.5 41.5M776.4 818c-10.6 0-21.3-4.1-29.4-12.2L688.2 747c-16.2-16.2-16.2-42.5 0-58.7 16.3-16.2 42.5-16.2 58.8 0l58.8 58.7c16.3 16.3 16.3 42.6 0 58.8-8.1 8.1-18.8 12.2-29.4 12.2M511.9 927.5c-23 0-41.5-18.6-41.5-41.5v-83.1c0-22.9 18.6-41.5 41.5-41.5s41.5 18.6 41.5 41.5V886c.1 22.9-18.6 41.5-41.5 41.5M247.5 817.9c-10.6 0-21.3-4-29.4-12.1-16.2-16.3-16.2-42.6 0-58.8l58.8-58.8c16.2-16.2 42.5-16.2 58.8 0 16.2 16.3 16.2 42.5 0 58.8l-58.8 58.8c-8.1 8.1-18.8 12.1-29.4 12.1m-26.4-264.5H138c-22.9 0-41.5-18.6-41.5-41.5 0-23 18.6-41.5 41.5-41.5h83.1c22.9 0 41.5 18.6 41.5 41.5.1 22.9-18.5 41.5-41.5 41.5m85.3-205.6c-10.6 0-21.3-4.1-29.4-12.2l-58.8-58.7a41.465 41.465 0 0 1 0-58.8c16.3-16.2 42.5-16.2 58.8 0l58.8 58.8c16.3 16.2 16.3 42.5 0 58.7-8.1 8.1-18.8 12.2-29.4 12.2",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$2 = [
  _hoisted_2$2
];
function render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3, _hoisted_3$2);
}
var IconSun = { render: render$1 };
const _hoisted_1$2 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg",
  width: "128",
  height: "128"
};
const _hoisted_2$1 = /* @__PURE__ */ createElementVNode("path", {
  d: "M908.544 156.16H141.056c-30.694 0-57.651 11.06-79.565 32.614-22.016 21.658-33.331 48.384-33.331 78.848v488.781c0 30.464 11.315 57.165 33.331 78.823a110.285 110.285 0 0 0 79.565 32.614h767.488c30.72 0 57.651-11.06 79.565-32.614 22.016-21.658 33.331-48.359 33.331-78.823v-488.78c0-30.465-11.315-57.191-33.331-78.849a110.208 110.208 0 0 0-79.54-32.614zm-767.488 46.08h767.488c18.611 0 33.946 6.298 47.258 19.405 13.235 13.005 19.558 27.904 19.558 45.977v488.781c0 18.048-6.323 32.922-19.558 45.952-13.312 13.107-28.672 19.405-47.232 19.405H141.056a64.256 64.256 0 0 1-47.283-19.405c-13.235-13.03-19.559-27.904-19.559-45.952v-488.78c0-18.049 6.324-32.973 19.559-45.978a64.256 64.256 0 0 1 47.283-19.405z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$1 = /* @__PURE__ */ createElementVNode("path", {
  d: "M281.6 476.16a23.04 23.04 0 0 1 2.893 45.9l-2.893.18h-76.8a23.04 23.04 0 0 1-2.893-45.9l2.893-.18h76.8zM460.8 476.16a23.04 23.04 0 0 1 2.893 45.9l-2.893.18H384a23.04 23.04 0 0 1-2.893-45.9l2.893-.18h76.8zM640 476.16a23.04 23.04 0 0 1 2.893 45.9l-2.893.18h-76.8a23.04 23.04 0 0 1-2.893-45.9l2.893-.18H640zm204.8 153.6a23.04 23.04 0 0 1 2.893 45.9l-2.893.18h-640a23.04 23.04 0 0 1-2.893-45.9l2.893-.18h640zm-25.6-153.6a23.04 23.04 0 0 1 2.893 45.9l-2.893.18h-76.8a23.04 23.04 0 0 1-2.893-45.9l2.893-.18h76.8zm-537.6-128a23.04 23.04 0 0 1 2.893 45.9l-2.893.18h-76.8a23.04 23.04 0 0 1-2.893-45.9l2.893-.18h76.8zm179.2 0a23.04 23.04 0 0 1 2.893 45.9l-2.893.18H384a23.04 23.04 0 0 1-2.893-45.9l2.893-.18h76.8zM640 348.16a23.04 23.04 0 0 1 2.893 45.9l-2.893.18h-76.8a23.04 23.04 0 0 1-2.893-45.9l2.893-.18H640zM819.2 348.16a23.04 23.04 0 0 1 2.893 45.9l-2.893.18h-76.8a23.04 23.04 0 0 1-2.893-45.9l2.893-.18h76.8z",
  fill: "currentColor"
}, null, -1);
const _hoisted_4$1 = [
  _hoisted_2$1,
  _hoisted_3$1
];
function render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2, _hoisted_4$1);
}
var IconKeyboard = { render };
var helper_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$1 = defineComponent({
  components: {
    IconMoon,
    IconSun,
    IconKeyboard
  },
  props: {
    modelValue: {
      type: String,
      default: "light"
    },
    helper: {
      type: Object,
      default: () => {
        return {
          theme: true
        };
      }
    }
  },
  setup(props, ctx) {
    const list3 = {
      "Ctrl-s": "\u4FDD\u5B58",
      "Ctrl-b": "\u7F8E\u5316\u3001\u683C\u5F0F\u5316",
      "Ctrl-1": "\u4E00\u7EA7\u6807\u9898",
      "Ctrl-2": "\u4E8C\u7EA7\u6807\u9898",
      "Ctrl-3": "\u4E09\u7EA7\u6807\u9898",
      "Ctrl-4": "\u56DB\u7EA7\u6807\u9898",
      "Ctrl-5": "\u4E94\u7EA7\u6807\u9898",
      "Ctrl-6": "\u516D\u7EA7\u6807\u9898",
      "Ctrl-Alt-t": "\u63D2\u5165\u8868\u683C",
      "Ctrl-Alt-m": "\u63D2\u5165\u5A92\u4F53",
      "Ctrl-Alt-p": "\u9884\u89C8",
      "Ctrl-Alt-b": "\u52A0\u7C97",
      "Ctrl-Alt-i": "\u659C\u4F53",
      "Ctrl-Alt-l": "\u5220\u9664\u7EBF",
      "Ctrl-Alt-h": "\u5206\u5272\u7EBF",
      "Ctrl-Alt-q": "\u5F15\u7528",
      "Shift-Alt-o": "\u6709\u5E8F\u5217\u8868",
      "Shift-Alt-u": "\u65E0\u5E8F\u5217\u8868",
      "Shift-Alt-t": "TODO\u5217\u8868",
      "Shift-Alt-i": "\u5185\u8054\u4EE3\u7801",
      "Shift-Alt-b": "\u5757\u7EA7\u4EE3\u7801",
      "Shift-Alt-l": "\u94FE\u63A5"
    };
    return {
      list: list3,
      changeTheme(theme2) {
        ctx.emit("update:modelValue", theme2);
        ctx.emit("themeChange", theme2);
      }
    };
  }
});
const _withScopeId = (n) => (pushScopeId("data-v-27d61a90"), n = n(), popScopeId(), n);
const _hoisted_1$1 = { class: "editor-helper" };
const _hoisted_2 = { key: 0 };
const _hoisted_3 = { class: "hotkey-box" };
const _hoisted_4 = { class: "hotkey" };
const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("thead", null, [
  /* @__PURE__ */ createElementVNode("tr", null, [
    /* @__PURE__ */ createElementVNode("th", null, "\u5FEB\u6377\u952E"),
    /* @__PURE__ */ createElementVNode("th", null, "\u8BF4\u660E")
  ])
], -1));
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconMoon = resolveComponent("IconMoon");
  const _component_IconSun = resolveComponent("IconSun");
  const _component_IconKeyboard = resolveComponent("IconKeyboard");
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    renderSlot(_ctx.$slots, "top", {}, void 0, true),
    createElementVNode("ul", null, [
      _ctx.helper.theme ? (openBlock(), createElementBlock("li", _hoisted_2, [
        _ctx.modelValue == "dark" ? (openBlock(), createElementBlock("button", {
          key: 0,
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.changeTheme("light"))
        }, [
          createVNode(_component_IconMoon)
        ])) : (openBlock(), createElementBlock("button", {
          key: 1,
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.changeTheme("dark"))
        }, [
          createVNode(_component_IconSun)
        ]))
      ])) : createCommentVNode("", true),
      createElementVNode("li", _hoisted_3, [
        createElementVNode("button", null, [
          createVNode(_component_IconKeyboard)
        ]),
        createElementVNode("div", _hoisted_4, [
          createElementVNode("table", null, [
            _hoisted_5,
            createElementVNode("tbody", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (val, key) => {
                return openBlock(), createElementBlock("tr", { key }, [
                  createElementVNode("td", null, toDisplayString(key.replace(/\-/g, " + ")), 1),
                  createElementVNode("td", null, toDisplayString(val), 1)
                ]);
              }), 128))
            ])
          ])
        ])
      ])
    ]),
    renderSlot(_ctx.$slots, "bottom", {}, void 0, true)
  ]);
}
var EditorHelper = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-27d61a90"]]);
let extend = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
for (let i = 1; i < extend.length; i++)
  extend[i] += extend[i - 1];
function isExtendingChar(code2) {
  for (let i = 1; i < extend.length; i += 2)
    if (extend[i] > code2)
      return extend[i - 1] <= code2;
  return false;
}
function isRegionalIndicator(code2) {
  return code2 >= 127462 && code2 <= 127487;
}
const ZWJ = 8205;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length)
    return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
    pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i = pos - 2;
      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
        countBefore++;
        i -= 2;
      }
      if (countBefore % 2 == 0)
        break;
      else
        pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos)
      return found;
    pos--;
  }
  return 0;
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code2) {
  if (code2 <= 65535)
    return String.fromCharCode(code2);
  code2 -= 65536;
  return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
}
function codePointSize(code2) {
  return code2 < 65536 ? 1 : 2;
}
function countColumn(string2, tabSize, to = string2.length) {
  let n = 0;
  for (let i = 0; i < to; ) {
    if (string2.charCodeAt(i) == 9) {
      n += tabSize - n % tabSize;
      i++;
    } else {
      n++;
      i = findClusterBreak(string2, i);
    }
  }
  return n;
}
function findColumn(string2, col, tabSize, strict) {
  for (let i = 0, n = 0; ; ) {
    if (n >= col)
      return i;
    if (i == string2.length)
      break;
    n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
    i = findClusterBreak(string2, i);
  }
  return strict === true ? -1 : string2.length;
}
class Text {
  constructor() {
  }
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  line(n) {
    if (n < 1 || n > this.lines)
      throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  replace(from, to, text3) {
    let parts = [];
    this.decompose(0, from, parts, 2);
    if (text3.length)
      text3.decompose(0, text3.length, parts, 1 | 2);
    this.decompose(to, this.length, parts, 1);
    return TextNode.from(parts, this.length - (to - from) + text3.length);
  }
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  slice(from, to = this.length) {
    let parts = [];
    this.decompose(from, to, parts, 0);
    return TextNode.from(parts, to - from);
  }
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
    let a = new RawTextCursor(this), b = new RawTextCursor(other);
    for (let skip = start, pos = start; ; ) {
      a.next(skip);
      b.next(skip);
      skip = 0;
      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
        return false;
      pos += a.value.length;
      if (a.done || pos >= end)
        return true;
    }
  }
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  iterRange(from, to = this.length) {
    return new PartialTextCursor(this, from, to);
  }
  iterLines(from, to) {
    let inner;
    if (from == null) {
      inner = this.iter();
    } else {
      if (to == null)
        to = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
    }
    return new LineCursor(inner);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  static of(text3) {
    if (text3.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text3.length == 1 && !text3[0])
      return Text.empty;
    return text3.length <= 32 ? new TextLeaf(text3) : TextNode.from(TextLeaf.split(text3, []));
  }
}
class TextLeaf extends Text {
  constructor(text3, length = textLength(text3)) {
    super();
    this.text = text3;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target2, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let string2 = this.text[i], end = offset + string2.length;
      if ((isLine ? line : end) >= target2)
        return new Line$1(offset, end, line, string2);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to, target2, open) {
    let text3 = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target2.pop();
      let joined = appendText(text3.text, prev.text.slice(), 0, text3.length);
      if (joined.length <= 32) {
        target2.push(new TextLeaf(joined, prev.length + text3.length));
      } else {
        let mid2 = joined.length >> 1;
        target2.push(new TextLeaf(joined.slice(0, mid2)), new TextLeaf(joined.slice(mid2)));
      }
    } else {
      target2.push(text3);
    }
  }
  replace(from, to, text3) {
    if (!(text3 instanceof TextLeaf))
      return super.replace(from, to, text3);
    let lines = appendText(this.text, appendText(text3.text, sliceText(this.text, 0, from)), to);
    let newLen = this.length + text3.length - (to - from);
    if (lines.length <= 32)
      return new TextLeaf(lines, newLen);
    return TextNode.from(TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    let result = "";
    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
      let line = this.text[i], end = pos + line.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += line.slice(Math.max(0, from - pos), to - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target2) {
    for (let line of this.text)
      target2.push(line);
  }
  scanIdentical() {
    return 0;
  }
  static split(text3, target2) {
    let part2 = [], len = -1;
    for (let line of text3) {
      part2.push(line);
      len += line.length + 1;
      if (part2.length == 32) {
        target2.push(new TextLeaf(part2, len));
        part2 = [];
        len = -1;
      }
    }
    if (len > -1)
      target2.push(new TextLeaf(part2, len));
    return target2;
  }
}
class TextNode extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (let child of children)
      this.lines += child.lines;
  }
  lineInner(target2, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target2)
        return child.lineInner(target2, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to, target2, open) {
    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
        if (pos >= from && end <= to && !childOpen)
          target2.push(child);
        else
          child.decompose(from - pos, to - pos, target2, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to, text3) {
    if (text3.lines < this.lines)
      for (let i = 0, pos = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from >= pos && to <= end) {
          let updated = child.replace(from - pos, to - pos, text3);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy2 = this.children.slice();
            copy2[i] = updated;
            return new TextNode(copy2, this.length - (to - from) + text3.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from, to, text3);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    let result = "";
    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += child.sliceString(from - pos, to - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target2) {
    for (let child of this.children)
      child.flatten(target2);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof TextNode))
      return 0;
    let length = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB)
        return length;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB)
        return length + chA.scanIdentical(chB, dir);
      length += chA.length + 1;
    }
  }
  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children)
      lines += ch.lines;
    if (lines < 32) {
      let flat2 = [];
      for (let ch of children)
        ch.flatten(flat2);
      return new TextLeaf(flat2, length);
    }
    let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add3(child) {
      let last;
      if (child.lines > maxChunk && child instanceof TextNode) {
        for (let node of child.children)
          add3(node);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children)
      add3(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
  }
}
Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
function textLength(text3) {
  let length = -1;
  for (let line of text3)
    length += line.length + 1;
  return length;
}
function appendText(text3, target2, from = 0, to = 1e9) {
  for (let pos = 0, i = 0, first = true; i < text3.length && pos <= to; i++) {
    let line = text3[i], end = pos + line.length;
    if (end >= from) {
      if (end > to)
        line = line.slice(0, to - pos);
      if (pos < from)
        line = line.slice(from - pos);
      if (first) {
        target2[target2.length - 1] += line;
        first = false;
      } else
        target2.push(line);
    }
    pos = end + 1;
  }
  return target2;
}
function sliceText(text3, from, to) {
  return appendText(text3, [""], from, to);
}
class RawTextCursor {
  constructor(text3, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text3];
    this.offsets = [dir > 0 ? 1 : (text3 instanceof TextLeaf ? text3.text.length : text3.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last = this.nodes.length - 1;
      let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0)
            this.offsets[last]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
}
class PartialTextCursor {
  constructor(text3, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text3, start > end ? -1 : 1);
    this.pos = start > end ? text3.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class LineCursor {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip);
    if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
}
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
class Line$1 {
  constructor(from, to, number2, text3) {
    this.from = from;
    this.to = to;
    this.number = number2;
    this.text = text3;
  }
  get length() {
    return this.to - this.from;
  }
}
const DefaultSplit = /\r\n?|\n/;
var MapMode = /* @__PURE__ */ function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
class ChangeDesc {
  constructor(sections) {
    this.sections = sections;
  }
  get length() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2)
      result += this.sections[i];
    return result;
  }
  get newLength() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2) {
      let ins = this.sections[i + 1];
      result += ins < 0 ? this.sections[i] : ins;
    }
    return result;
  }
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  iterGaps(f) {
    for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  get invertedDesc() {
    let sections = [];
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new ChangeDesc(sections);
  }
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  touchesRange(from, to = from) {
    for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
      let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
      if (ins >= 0 && pos <= to && end >= from)
        return pos < from && end > to ? "cover" : true;
      pos = end;
    }
    return false;
  }
  toString() {
    let result = "";
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ChangeDesc(json);
  }
}
class ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text3) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text3), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i = 0, pos = 0; i < sections.length; i += 2) {
      let len = sections[i], ins = sections[i + 1];
      if (ins >= 0) {
        sections[i] = ins;
        sections[i + 1] = len;
        let index2 = i >> 1;
        while (inserted.length < index2)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new ChangeSet(sections, inserted);
  }
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  get desc() {
    return new ChangeDesc(this.sections);
  }
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done:
      for (let i = 0, pos = 0; ; ) {
        let next = i == ranges.length ? 1e9 : ranges[i++];
        while (pos < next || pos == next && iter.len == 0) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, next - pos);
          addSection(filteredSections, len, -1);
          let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
          addSection(resultSections, len, ins);
          if (ins > 0)
            addInsert(resultInserted, resultSections, iter.text);
          iter.forward(len);
          pos += len;
        }
        let end = ranges[i++];
        while (pos < end) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, end - pos);
          addSection(resultSections, len, -1);
          addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
          iter.forward(len);
          pos += len;
        }
      }
    return {
      changes: new ChangeSet(resultSections, resultInserted),
      filtered: new ChangeDesc(filteredSections)
    };
  }
  toJSON() {
    let parts = [];
    for (let i = 0; i < this.sections.length; i += 2) {
      let len = this.sections[i], ins = this.sections[i + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i >> 1].toJSON()));
    }
    return parts;
  }
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length)
        addSection(sections, length - pos, -1);
      let set2 = new ChangeSet(sections, inserted);
      total = total ? total.compose(set2.map(total)) : set2;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub2 of spec)
          process2(sub2);
      } else if (spec instanceof ChangeSet) {
        if (spec.length != length)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from, to = from, insert: insert2 } = spec;
        if (from > to || from < 0 || to > length)
          throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to && insLen == 0)
          return;
        if (from < pos)
          flush();
        if (from > pos)
          addSection(sections, from - pos, -1);
        addSection(sections, to - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  static empty(length) {
    return new ChangeSet(length ? [length, -1] : [], []);
  }
  static fromJSON(json) {
    if (!Array.isArray(json))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i = 0; i < json.length; i++) {
      let part2 = json[i];
      if (typeof part2 == "number") {
        sections.push(part2, -1);
      } else if (!Array.isArray(part2) || typeof part2[0] != "number" || part2.some((e, i2) => i2 && typeof e != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part2.length == 1) {
        sections.push(part2[0], 0);
      } else {
        while (inserted.length < i)
          inserted.push(Text.empty);
        inserted[i] = Text.of(part2.slice(1));
        sections.push(part2[0], inserted[i].length);
      }
    }
    return new ChangeSet(sections, inserted);
  }
}
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1])
    sections[last] += len;
  else if (len == 0 && sections[last] == 0)
    sections[last + 1] += ins;
  else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values2, sections, value) {
  if (value.length == 0)
    return;
  let index2 = sections.length - 2 >> 1;
  if (index2 < values2.length) {
    values2[values2.length - 1] = values2[values2.length - 1].append(value);
  } else {
    while (values2.length < index2)
      values2.push(Text.empty);
    values2.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
    let len = desc.sections[i++], ins = desc.sections[i++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text3 = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text3 = text3.append(inserted[i - 2 >> 1]);
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
          break;
        len = desc.sections[i++];
        ins = desc.sections[i++];
      }
      f(posA, endA, posB, endB, text3);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let posA = 0, posB = 0; ; ) {
    if (a.ins == -1) {
      posA += a.len;
      a.next();
    } else if (b.ins == -1 && posB < posA) {
      let skip = Math.min(b.len, posA - posB);
      b.forward(skip);
      addSection(sections, skip, -1);
      posB += skip;
    } else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {
      addSection(sections, b.ins, -1);
      while (posA > posB && !a.done && posA + a.len < posB + b.len) {
        posA += a.len;
        a.next();
      }
      posB += b.len;
      b.next();
    } else if (a.ins >= 0) {
      let len = 0, end = posA + a.len;
      for (; ; ) {
        if (b.ins >= 0 && posB > posA && posB + b.len < end) {
          len += b.ins;
          posB += b.len;
          b.next();
        } else if (b.ins == -1 && posB < end) {
          let skip = Math.min(b.len, end - posB);
          len += skip;
          b.forward(skip);
          posB += skip;
        } else {
          break;
        }
      }
      addSection(sections, len, a.ins);
      if (insert2)
        addInsert(insert2, sections, a.text);
      posA = end;
      a.next();
    } else if (a.done && b.done) {
      return insert2 ? new ChangeSet(sections, insert2) : new ChangeDesc(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a.done && b.done) {
      return insert2 ? new ChangeSet(sections, insert2) : new ChangeDesc(sections);
    } else if (a.ins == 0) {
      addSection(sections, a.len, 0, open);
      a.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert2)
        addInsert(insert2, sections, b.text);
      b.next();
    } else if (a.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a.len2, b.len), sectionLen = sections.length;
      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a.textBit(len));
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off)
          addInsert(insert2, sections, b.text);
      }
      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a.forward2(len);
      b.forward(len);
    }
  }
}
class SectionIter {
  constructor(set2) {
    this.set = set2;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length ? Text.empty : inserted[index2];
  }
  textBit(len) {
    let { inserted } = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length && !len ? Text.empty : inserted[index2].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
}
class SelectionRange {
  constructor(from, to, flags) {
    this.from = from;
    this.to = to;
    this.flags = flags;
  }
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  get bidiLevel() {
    let level = this.flags & 3;
    return level == 3 ? null : level;
  }
  get goalColumn() {
    let value = this.flags >> 5;
    return value == 33554431 ? void 0 : value;
  }
  map(change, assoc = -1) {
    let from, to;
    if (this.empty) {
      from = to = change.mapPos(this.from, assoc);
    } else {
      from = change.mapPos(this.from, 1);
      to = change.mapPos(this.to, -1);
    }
    return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
  }
  extend(from, to = from) {
    if (from <= this.anchor && to >= this.anchor)
      return EditorSelection.range(from, to);
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
    return EditorSelection.range(this.anchor, head);
  }
  eq(other) {
    return this.anchor == other.anchor && this.head == other.head;
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  static fromJSON(json) {
    if (!json || typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json.anchor, json.head);
  }
}
class EditorSelection {
  constructor(ranges, mainIndex = 0) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
  }
  eq(other) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(other.ranges[i]))
        return false;
    return true;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new EditorSelection([this.main]);
  }
  addRange(range2, main = true) {
    return EditorSelection.create([range2].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  replaceRange(range2, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range2;
    return EditorSelection.create(ranges, this.mainIndex);
  }
  toJSON() {
    return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
  }
  static fromJSON(json) {
    if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
  }
  static single(anchor, head = anchor) {
    return new EditorSelection([EditorSelection.range(anchor, head)], 0);
  }
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i = 0; i < ranges.length; i++) {
      let range2 = ranges[i];
      if (range2.empty ? range2.from <= pos : range2.from < pos)
        return normalized(ranges.slice(), mainIndex);
      pos = range2.to;
    }
    return new EditorSelection(ranges, mainIndex);
  }
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return new SelectionRange(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
  }
  static range(anchor, head, goalColumn) {
    let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;
    return head < anchor ? new SelectionRange(head, anchor, 16 | goal | 8) : new SelectionRange(anchor, head, goal | (head > anchor ? 4 : 0));
  }
}
function normalized(ranges, mainIndex = 0) {
  let main = ranges[mainIndex];
  ranges.sort((a, b) => a.from - b.from);
  mainIndex = ranges.indexOf(main);
  for (let i = 1; i < ranges.length; i++) {
    let range2 = ranges[i], prev = ranges[i - 1];
    if (range2.empty ? range2.from <= prev.to : range2.from < prev.to) {
      let from = prev.from, to = Math.max(range2.to, prev.to);
      if (i <= mainIndex)
        mainIndex--;
      ranges.splice(--i, 2, range2.anchor > range2.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
    }
  }
  return new EditorSelection(ranges, mainIndex);
}
function checkSelection(selection2, docLength) {
  for (let range2 of selection2.ranges)
    if (range2.to > docLength)
      throw new RangeError("Selection points outside of document");
}
let nextID = 0;
class Facet {
  constructor(combine, compareInput, compare2, isStatic, extensions2) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.extensions = extensions2;
    this.id = nextID++;
    this.default = combine([]);
  }
  static define(config2 = {}) {
    return new Facet(config2.combine || ((a) => a), config2.compareInput || ((a, b) => a === b), config2.compare || (!config2.combine ? sameArray$1 : (a, b) => a === b), !!config2.static, config2.enables);
  }
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  compute(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get);
  }
  computeN(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get);
  }
  from(field, get) {
    if (!get)
      get = (x) => x;
    return this.compute([field], (state) => get(state.field(field)));
  }
}
function sameArray$1(a, b) {
  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
class FacetProvider {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr) {
        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || depAddrs.some((addr) => (ensureAddr(state, addr) & 1) > 0)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure(state, oldState) {
        let newVal = getter(state);
        let oldAddr = oldState.config.address[id2];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (multi ? compareArray(newVal, oldVal, compare2) : compare2(newVal, oldVal)) {
            state.values[idx] = oldVal;
            return 0;
          }
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
}
function compareArray(a, b, compare2) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!compare2(a[i], b[i]))
      return false;
  return true;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  function get(state) {
    let values2 = [];
    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i]);
      if (providerTypes[i] == 2)
        for (let val of value)
          values2.push(val);
      else
        values2.push(value);
    }
    return facet.combine(values2);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get(state);
      return 1;
    },
    update(state, tr) {
      if (!dynamic.some((dynAddr) => ensureAddr(state, dynAddr) & 1))
        return 0;
      let value = get(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = providerAddrs.some((addr) => ensureAddr(state, addr) & 1);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray$1(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
const initField = /* @__PURE__ */ Facet.define({ static: true });
class StateField {
  constructor(id2, createF, updateF, compareF, spec) {
    this.id = id2;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  static define(config2) {
    let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a, b) => a === b), config2);
    if (config2.provide)
      field.provides = config2.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i) => i.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  init(create) {
    return [this, initField.of({ field: this, create })];
  }
  get extension() {
    return this;
  }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
const Prec = {
  lowest: /* @__PURE__ */ prec(Prec_.lowest),
  low: /* @__PURE__ */ prec(Prec_.low),
  default: /* @__PURE__ */ prec(Prec_.default),
  high: /* @__PURE__ */ prec(Prec_.high),
  highest: /* @__PURE__ */ prec(Prec_.highest),
  fallback: /* @__PURE__ */ prec(Prec_.lowest),
  extend: /* @__PURE__ */ prec(Prec_.high),
  override: /* @__PURE__ */ prec(Prec_.highest)
};
class PrecExtension {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
}
class Compartment {
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  reconfigure(content2) {
    return Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  get(state) {
    return state.config.compartments.get(this);
  }
}
class CompartmentInstance {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
}
class Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(0);
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a) => field.slot(a));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id2 in facets) {
      let providers = facets[id2], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id2] || [];
      if (providers.every((p) => p.type == 0)) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray$1(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p) => p.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => p.dynamicSlot(a));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f) => f(address));
    return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
}
function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known >= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e of ext)
        inner(e, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, prec2);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
const languageData = /* @__PURE__ */ Facet.define();
const allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.some((v) => v),
  static: true
});
const lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.length ? values2[0] : void 0,
  static: true
});
const changeFilter = /* @__PURE__ */ Facet.define();
const transactionFilter = /* @__PURE__ */ Facet.define();
const transactionExtender = /* @__PURE__ */ Facet.define();
const readOnly = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.length ? values2[0] : false
});
class Annotation {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  static define() {
    return new AnnotationType();
  }
}
class AnnotationType {
  of(value) {
    return new Annotation(this, value);
  }
}
class StateEffectType {
  constructor(map2) {
    this.map = map2;
  }
  of(value) {
    return new StateEffect(this, value);
  }
}
class StateEffect {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
  }
  is(type) {
    return this.type == type;
  }
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
}
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
class Transaction {
  constructor(startState, changes, selection2, effects, annotations, scrollIntoView2) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection2;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView2;
    this._doc = null;
    this._state = null;
    if (selection2)
      checkSelection(selection2, changes.newLength);
    if (!annotations.some((a) => a.type == Transaction.time))
      this.annotations = annotations.concat(Transaction.time.of(Date.now()));
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  isUserEvent(event) {
    let e = this.annotation(Transaction.userEvent);
    return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
  }
}
Transaction.time = /* @__PURE__ */ Annotation.define();
Transaction.userEvent = /* @__PURE__ */ Annotation.define();
Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
Transaction.remote = /* @__PURE__ */ Annotation.define();
function joinRanges(a, b) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from, to;
    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from = a[iA++];
      to = a[iA++];
    } else if (iB < b.length) {
      from = b[iB++];
      to = b[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from)
      result.push(from, to);
    else if (result[result.length - 1] < to)
      result[result.length - 1] = to;
  }
}
function mergeTransaction(a, b, sequential) {
  var _a;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a.changes);
    mapForB = a.changes.mapDesc(b.changes, true);
    changes = a.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray$1(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray$1(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter = false;
  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false)
      filter = false;
    let seq = !!specs[i].sequential;
    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
  }
  let tr = new Transaction(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.invertedDesc;
    }
    tr = new Transaction(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray$1(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension = extenders[i](tr);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(tr, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : new Transaction(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none$4 = [];
function asArray$1(value) {
  return value == null ? none$4 : Array.isArray(value) ? value : [value];
}
var CharCategory = /* @__PURE__ */ function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i = 0; i < wordChars.length; i++)
      if (char.indexOf(wordChars[i]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
class EditorState {
  constructor(config2, doc2, selection2, values2, computeSlot, tr) {
    this.config = config2;
    this.doc = doc2;
    this.selection = selection2;
    this.values = values2;
    this.status = config2.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr)
      tr._state = this;
    for (let i = 0; i < this.config.dynamicSlots.length; i++)
      ensureAddr(this, i << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  applyTransaction(tr) {
    let conf = this.config, { base: base2, compartments } = conf;
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray$1(base2).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this);
      let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr.startState.values.slice();
    }
    new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);
  }
  replaceSelection(text3) {
    if (typeof text3 == "string")
      text3 = this.toText(text3);
    return this.changeByRange((range2) => ({
      changes: { from: range2.from, to: range2.to, insert: text3 },
      range: EditorSelection.cursor(range2.from + text3.length)
    }));
  }
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray$1(result1.effects);
    for (let i = 1; i < sel.ranges.length; i++) {
      let result = f(sel.ranges[i]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i; j++)
        ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray$1(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
  }
  toText(string2) {
    return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
  }
  sliceDoc(from = 0, to = this.doc.length) {
    return this.doc.sliceString(from, to, this.lineBreak);
  }
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop2 in fields) {
        let value = fields[prop2];
        if (value instanceof StateField)
          result[prop2] = value.spec.toJSON(this.field(fields[prop2]), this);
      }
    return result;
  }
  static fromJSON(json, config2 = {}, fields) {
    if (!json || typeof json.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop2 in fields) {
        let field = fields[prop2], value = json[prop2];
        fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
      }
    return EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    });
  }
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
    let selection2 = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
    checkSelection(selection2, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection2 = selection2.asSingle();
    return new EditorState(configuration, doc2, selection2, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  get tabSize() {
    return this.facet(EditorState.tabSize);
  }
  get lineBreak() {
    return this.facet(EditorState.lineSeparator) || "\n";
  }
  get readOnly() {
    return this.facet(readOnly);
  }
  phrase(phrase2) {
    for (let map2 of this.facet(EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map2, phrase2))
        return map2[phrase2];
    return phrase2;
  }
  languageDataAt(name2, pos, side = -1) {
    let values2 = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values2.push(result[name2]);
      }
    }
    return values2;
  }
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  wordAt(pos) {
    let { text: text3, from, length } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from, end = pos - from;
    while (start > 0) {
      let prev = findClusterBreak(text3, start, false);
      if (cat(text3.slice(prev, start)) != CharCategory.Word)
        break;
      start = prev;
    }
    while (end < length) {
      let next = findClusterBreak(text3, end);
      if (cat(text3.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from, end + from);
  }
}
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.length ? values2[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = /* @__PURE__ */ Facet.define();
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
function combineConfig(configs, defaults2, combine = {}) {
  let result = {};
  for (let config2 of configs)
    for (let key of Object.keys(config2)) {
      let value = config2[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0)
        ;
      else if (Object.hasOwnProperty.call(combine, key))
        result[key] = combine[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults2)
    if (result[key] === void 0)
      result[key] = defaults2[key];
  return result;
}
const C = "\u037C";
const COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
class StyleModule {
  constructor(spec, options) {
    this.rules = [];
    let { finish } = options || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render2(selectors, spec2, target2, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null)
        return target2.push(selectors[0] + ";");
      for (let prop2 in spec2) {
        let value = spec2[prop2];
        if (/&/.test(prop2)) {
          render2(prop2.split(/,\s*/).map((part2) => selectors.map((sel) => part2.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target2);
        } else if (value && typeof value == "object") {
          if (!isAt)
            throw new RangeError("The value of a property (" + prop2 + ") should be a primitive value.");
          render2(splitSelector(prop2), value, local, keyframes);
        } else if (value != null) {
          local.push(prop2.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target2.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop2 in spec)
      render2(splitSelector(prop2), spec[prop2], this.rules);
  }
  getRules() {
    return this.rules.join("\n");
  }
  static newName() {
    let id2 = top[COUNT] || 1;
    top[COUNT] = id2 + 1;
    return C + id2.toString(36);
  }
  static mount(root, modules) {
    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
  }
}
let adoptedSet = null;
class StyleSet {
  constructor(root) {
    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
      if (adoptedSet) {
        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
        return root[SET] = adoptedSet;
      }
      this.sheet = new CSSStyleSheet();
      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
      adoptedSet = this;
    } else {
      this.styleTag = (root.ownerDocument || root).createElement("style");
      let target2 = root.head || root;
      target2.insertBefore(this.styleTag, target2.firstChild);
    }
    this.modules = [];
    root[SET] = this;
  }
  mount(modules) {
    let sheet = this.sheet;
    let pos = 0, j = 0;
    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i], index2 = this.modules.indexOf(mod);
      if (index2 < j && index2 > -1) {
        this.modules.splice(index2, 1);
        j--;
        index2 = -1;
      }
      if (index2 == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet)
          for (let k = 0; k < mod.rules.length; k++)
            sheet.insertRule(mod.rules[k], pos++);
      } else {
        while (j < index2)
          pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (!sheet) {
      let text3 = "";
      for (let i = 0; i < this.modules.length; i++)
        text3 += this.modules[i].getRules() + "\n";
      this.styleTag.textContent = text3;
    }
  }
}
class RangeValue {
  eq(other) {
    return this == other;
  }
  range(from, to = from) {
    return new Range$1(from, to, this);
  }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
class Range$1 {
  constructor(from, to, value) {
    this.from = from;
    this.to = to;
    this.value = value;
  }
}
function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide;
}
class Chunk {
  constructor(from, to, value, maxPoint) {
    this.from = from;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid2 = lo + hi >> 1;
      let diff = arr[mid2] - pos || (end ? this.value[mid2].endSide : this.value[mid2].startSide) - side;
      if (mid2 == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid2;
      else
        lo = mid2 + 1;
    }
  }
  between(offset, from, to, f) {
    for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
      if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
    for (let i = 0; i < this.value.length; i++) {
      let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
  }
}
class RangeSet {
  constructor(chunkPos, chunk, nextLayer = RangeSet.empty, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  chunkEnd(index2) {
    return this.chunkPos[index2] + this.chunk[index2].length;
  }
  update(updateSpec) {
    let { add: add3 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter = updateSpec.filter;
    if (add3.length == 0 && !filter)
      return this;
    if (sort)
      add3 = add3.slice().sort(cmpRange);
    if (this.isEmpty)
      return add3.length ? RangeSet.of(add3) : this;
    let cur2 = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur2.value || i < add3.length) {
      if (i < add3.length && (cur2.from - add3[i].from || cur2.startSide - add3[i].value.startSide) >= 0) {
        let range2 = add3[i++];
        if (!builder.addInner(range2.from, range2.to, range2.value))
          spill.push(range2);
      } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i == add3.length || this.chunkEnd(cur2.chunkIndex) < add3[i].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
        cur2.nextChunk();
      } else {
        if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
          if (!builder.addInner(cur2.from, cur2.to, cur2.value))
            spill.push(new Range$1(cur2.from, cur2.to, cur2.value));
        }
        cur2.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
  }
  map(changes) {
    if (changes.length == 0 || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);
  }
  between(from, to, f) {
    if (this.isEmpty)
      return;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false)
        return;
    }
    this.nextLayer.between(from, to, f);
  }
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a = oldSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
    let b = newSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a, b, textDiff);
    let sideA = new SpanCursor(a, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  static eq(oldSets, newSets, from = 0, to) {
    if (to == null)
      to = 1e9;
    let a = oldSets.filter((set2) => !set2.isEmpty && newSets.indexOf(set2) < 0);
    let b = newSets.filter((set2) => !set2.isEmpty && oldSets.indexOf(set2) < 0);
    if (a.length != b.length)
      return false;
    if (!a.length)
      return true;
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
        return false;
      if (sideA.to > to)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  static spans(sets, from, to, iterator, minPointSize = -1) {
    var _a;
    let cursor2 = new SpanCursor(sets, null, minPointSize, (_a = iterator.filterPoint) === null || _a === void 0 ? void 0 : _a.bind(iterator)).goto(from), pos = from;
    let open = cursor2.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor2.to, to);
      if (cursor2.point) {
        iterator.point(pos, curTo, cursor2.point, cursor2.activeForPoint(cursor2.to), open);
        open = cursor2.openEnd(curTo) + (cursor2.to > curTo ? 1 : 0);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor2.active, open);
        open = cursor2.openEnd(curTo);
      }
      if (cursor2.to > to)
        break;
      pos = cursor2.to;
      cursor2.next();
    }
    return open;
  }
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range2 of ranges instanceof Range$1 ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range2.from, range2.to, range2.value);
    return build.finish();
  }
}
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
      let cur2 = ranges[i];
      if (cmpRange(prev, cur2) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur2;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
class RangeSetBuilder {
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  add(from, to, value) {
    if (!this.addInner(from, to, value))
      (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
  }
  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to - from);
    return true;
  }
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from;
    this.lastTo = chunk.to[last] + from;
    return true;
  }
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
}
function findSharedChunks(a, b, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set2 of a)
    for (let i = 0; i < set2.chunk.length; i++)
      if (set2.chunk[i].maxPoint <= 0)
        inA.set(set2.chunk[i], set2.chunkPos[i]);
  let shared = /* @__PURE__ */ new Set();
  for (let set2 of b)
    for (let i = 0; i < set2.chunk.length; i++) {
      let known = inA.get(set2.chunk[i]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set2.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set2.chunk[i].length)))
        shared.add(set2.chunk[i]);
    }
  return shared;
}
class LayerCursor {
  constructor(layer, skip, minPoint, rank = 0) {
    this.layer = layer;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index2) {
    if (index2 == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index2;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;
  }
}
class HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i = 0; i < sets.length; i++) {
      for (let cur2 = sets[i]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur2, skip, minPoint, i));
      }
    }
    return heap.length == 1 ? heap[0] : new HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap)
      cur2.goto(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur2 of this.heap)
      cur2.forward(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
}
function heapBubble(heap, index2) {
  for (let cur2 = heap[index2]; ; ) {
    let childIndex = (index2 << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0)
      break;
    heap[childIndex] = cur2;
    heap[index2] = child;
    index2 = childIndex;
  }
}
class SpanCursor {
  constructor(sets, skip, minPoint, filterPoint = () => true) {
    this.minPoint = minPoint;
    this.filterPoint = filterPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index2) {
    remove(this.active, index2);
    remove(this.activeTo, index2);
    remove(this.activeRank, index2);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i = 0, { value, to, rank } = this.cursor;
    while (i < this.activeRank.length && this.activeRank[i] <= rank)
      i++;
    insert(this.active, i, value);
    insert(this.activeTo, i, to);
    insert(this.activeRank, i, rank);
    if (trackOpen)
      insert(trackOpen, i, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
    for (; ; ) {
      let a = this.minActive;
      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a] > from) {
          this.to = this.activeTo[a];
          this.endSide = this.active[a].endSide;
          break;
        }
        this.removeActive(a);
        if (trackOpen)
          remove(trackOpen, a);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else if (!this.filterPoint(this.cursor.from, this.cursor.to, this.cursor.value, this.cursor.rank)) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          if (this.cursor.from < from)
            trackExtra = 1;
          this.cursor.next();
          if (this.to > from)
            this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      let openStart = 0;
      while (openStart < trackOpen.length && trackOpen[openStart] < from)
        openStart++;
      this.openStart = openStart + trackExtra;
    }
  }
  activeForPoint(to) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i = this.active.length - 1; i >= 0; i--) {
      if (this.activeRank[i] < this.pointRank)
        break;
      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
        active.push(this.active[i]);
    }
    return active.reverse();
  }
  openEnd(to) {
    let open = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
      open++;
    return open;
  }
}
function compare(a, startA, b, startB, length, comparator) {
  a.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let diff = a.to + dPos - b.to || a.endSide - b.endSide;
    let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
    if (a.point || b.point) {
      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))
        comparator.comparePoint(pos, clipEnd, a.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a.active, b.active))
        comparator.compareRange(pos, clipEnd, a.active, b.active);
    }
    if (end > endB)
      break;
    pos = end;
    if (diff <= 0)
      a.next();
    if (diff >= 0)
      b.next();
  }
}
function sameValues(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (a[i] != b[i] && !a[i].eq(b[i]))
      return false;
  return true;
}
function remove(array, index2) {
  for (let i = index2, e = array.length - 1; i < e; i++)
    array[i] = array[i + 1];
  array.pop();
}
function insert(array, index2, value) {
  for (let i = array.length - 1; i >= index2; i--)
    array[i + 1] = array[i];
  array[index2] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i = 0; i < array.length; i++)
    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
      found = i;
      foundPos = array[i];
    }
  return found;
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"',
  229: "Q"
};
var chrome$1 = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari$1 = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko$1 = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie$1 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome$1 && (mac || +chrome$1[1] < 57) || gecko$1 && mac;
for (var i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code2 in base)
  if (!shift.hasOwnProperty(code2))
    shift[code2] = base[code2];
function keyName(event) {
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari$1 || ie$1) && event.shiftKey && event.key && event.key.length == 1;
  var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name2 == "Esc")
    name2 = "Escape";
  if (name2 == "Del")
    name2 = "Delete";
  if (name2 == "Left")
    name2 = "ArrowLeft";
  if (name2 == "Up")
    name2 = "ArrowUp";
  if (name2 == "Right")
    name2 = "ArrowRight";
  if (name2 == "Down")
    name2 = "ArrowDown";
  return name2;
}
function getSelection(root) {
  let target2;
  if (root.nodeType == 11) {
    target2 = root.getSelection ? root : root.ownerDocument;
  } else {
    target2 = root;
  }
  return target2.getSelection();
}
function contains(dom, node) {
  return node ? dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function deepActiveElement() {
  let elt2 = document.activeElement;
  while (elt2 && elt2.shadowRoot)
    elt2 = elt2.shadowRoot.activeElement;
  return elt2;
}
function hasSelection(dom, selection2) {
  if (!selection2.anchorNode)
    return false;
  try {
    return contains(dom, selection2.anchorNode);
  } catch (_) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node)
      return index2;
  }
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV")
        return false;
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.nodeType == 1 && node.contentEditable == "false")
        return false;
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
const Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };
function flattenRect(rect2, left) {
  let x = left ? rect2.left : rect2.right;
  return { left: x, right: x, top: rect2.top, bottom: rect2.bottom };
}
function windowRect(win) {
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function scrollRectIntoView(dom, rect2, side, x, y, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView;
  for (let cur2 = dom; cur2; ) {
    if (cur2.nodeType == 1) {
      let bounding, top2 = cur2 == doc2.body;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.parentNode;
          continue;
        }
        let rect3 = cur2.getBoundingClientRect();
        bounding = {
          left: rect3.left,
          right: rect3.left + cur2.clientWidth,
          top: rect3.top,
          bottom: rect3.top + cur2.clientHeight
        };
      }
      let moveX = 0, moveY = 0;
      if (y == "nearest") {
        if (rect2.top < bounding.top) {
          moveY = -(bounding.top - rect2.top + yMargin);
          if (side > 0 && rect2.bottom > bounding.bottom + moveY)
            moveY = rect2.bottom - bounding.bottom + moveY + yMargin;
        } else if (rect2.bottom > bounding.bottom) {
          moveY = rect2.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect2.top - moveY < bounding.top)
            moveY = -(bounding.top + moveY - rect2.top + yMargin);
        }
      } else {
        let rectHeight = rect2.bottom - rect2.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y == "center" && rectHeight <= boundingHeight ? rect2.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect2.top - yMargin : rect2.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x == "nearest") {
        if (rect2.left < bounding.left) {
          moveX = -(bounding.left - rect2.left + xMargin);
          if (side > 0 && rect2.right > bounding.right + moveX)
            moveX = rect2.right - bounding.right + moveX + xMargin;
        } else if (rect2.right > bounding.right) {
          moveX = rect2.right - bounding.right + xMargin;
          if (side < 0 && rect2.left < bounding.left + moveX)
            moveX = -(bounding.left + moveX - rect2.left + xMargin);
        }
      } else {
        let targetLeft = x == "center" ? rect2.left + (rect2.right - rect2.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect2.left - xMargin : rect2.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          if (moveY) {
            let start = cur2.scrollTop;
            cur2.scrollTop += moveY;
            moveY = cur2.scrollTop - start;
          }
          if (moveX) {
            let start = cur2.scrollLeft;
            cur2.scrollLeft += moveX;
            moveX = cur2.scrollLeft - start;
          }
          rect2 = {
            left: rect2.left - moveX,
            top: rect2.top - moveY,
            right: rect2.right - moveX,
            bottom: rect2.bottom - moveY
          };
        }
      }
      if (top2)
        break;
      cur2 = cur2.assignedSlot || cur2.parentNode;
      x = y = "nearest";
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
}
class DOMSelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range2) {
    this.set(range2.anchorNode, range2.anchorOffset, range2.focusNode, range2.focusOffset);
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
    if (cur2 == cur2.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i = 0; i < stack.length; ) {
      let elt2 = stack[i++], top2 = stack[i++], left = stack[i++];
      if (elt2.scrollTop != top2)
        elt2.scrollTop = top2;
      if (elt2.scrollLeft != left)
        elt2.scrollLeft = left;
    }
  }
}
let scratchRange;
function textRange(node, from, to = from) {
  let range2 = scratchRange || (scratchRange = document.createRange());
  range2.setEnd(node, to);
  range2.setStart(node, from);
  return range2;
}
function dispatchKey(elt2, name2, code2) {
  let options = { key: name2, code: name2, keyCode: code2, which: code2, cancelable: true };
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt2.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options);
  up.synthetic = true;
  elt2.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
  while (node) {
    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
      return node;
    node = node.assignedSlot || node.parentNode;
  }
  return null;
}
function clearAttributes(node) {
  while (node.attributes.length)
    node.removeAttributeNode(node.attributes[0]);
}
class DOMPos {
  constructor(node, offset, precise = true) {
    this.node = node;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
}
const noChildren = [];
class ContentView {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.dirty = 2;
  }
  get editorView() {
    if (!this.parent)
      throw new Error("Accessing view in orphan content view");
    return this.parent.editorView;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (let child of this.children) {
      if (child == view)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  coordsAt(_pos, _side) {
    return null;
  }
  sync(track) {
    if (this.dirty & 2) {
      let parent = this.dom;
      let pos = parent.firstChild;
      for (let child of this.children) {
        if (child.dirty) {
          if (!child.dom && pos) {
            let contentView = ContentView.get(pos);
            if (!contentView || !contentView.parent && contentView.constructor == child.constructor)
              child.reuseDOM(pos);
          }
          child.sync(track);
          child.dirty = 0;
        }
        if (track && !track.written && track.node == parent && pos != child.dom)
          track.written = true;
        if (child.dom.parentNode == parent) {
          while (pos && pos != child.dom)
            pos = rm$1(pos);
          pos = child.dom.nextSibling;
        } else {
          parent.insertBefore(child.dom, pos);
        }
      }
      if (pos && track && track.node == parent)
        track.written = true;
      while (pos)
        pos = rm$1(pos);
    } else if (this.dirty & 1) {
      for (let child of this.children)
        if (child.dirty) {
          child.sync(track);
          child.dirty = 0;
        }
    }
  }
  reuseDOM(_dom) {
  }
  localPosFromDOM(node, offset) {
    let after;
    if (node == this.dom) {
      after = this.dom.childNodes[offset];
    } else {
      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
      for (; ; ) {
        let parent = node.parentNode;
        if (parent == this.dom)
          break;
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node == parent.firstChild)
            bias = -1;
          else
            bias = 1;
        }
        node = parent;
      }
      if (bias < 0)
        after = node;
      else
        after = node.nextSibling;
    }
    if (after == this.dom.firstChild)
      return 0;
    while (after && !ContentView.get(after))
      after = after.nextSibling;
    if (!after)
      return this.length;
    for (let i = 0, pos = 0; ; i++) {
      let child = this.children[i];
      if (child.dom == after)
        return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from, to, offset = 0) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos < from && end > to)
        return child.domBoundsAround(from, to, pos);
      if (end >= from && fromI == -1) {
        fromI = i;
        fromStart = pos;
      }
      if (pos > to && child.dom.parentNode == this.dom) {
        toI = i;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }
  markDirty(andParent = false) {
    this.dirty |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList)
        parent.dirty |= 2;
      if (parent.dirty & 1)
        return;
      parent.dirty |= 1;
      childList = false;
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.dirty)
        this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    if (this.dom)
      this.dom.cmView = null;
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v = this; ; ) {
      let parent = v.parent;
      if (!parent)
        return v;
      v = parent;
    }
  }
  replaceChildren(from, to, children = noChildren) {
    this.markDirty();
    for (let i = from; i < to; i++) {
      let child = this.children[i];
      if (child.parent == this)
        child.destroy();
    }
    this.children.splice(from, to - from, ...children);
    for (let i = 0; i < children.length; i++)
      children[i].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name2 = this.constructor.name.replace("View", "");
    return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node) {
    return node.cmView;
  }
  get isEditable() {
    return true;
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    return false;
  }
  become(other) {
    return false;
  }
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
ContentView.prototype.breakAfter = 0;
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
class ChildCursor {
  constructor(children, pos, i) {
    this.children = children;
    this.pos = pos;
    this.i = i;
    this.off = 0;
  }
  findPos(pos, bias = 1) {
    for (; ; ) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next = this.children[--this.i];
      this.pos -= next.length + next.breakAfter;
    }
  }
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
  let { children } = parent;
  let before = children.length ? children[fromI] : null;
  let last = insert2.length ? insert2[insert2.length - 1] : null;
  let breakAtEnd = last ? last.breakAfter : breakAtStart;
  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd))
    return;
  if (toI < children.length) {
    let after = children[toI];
    if (after && toOff < after.length) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
        insert2[insert2.length - 1] = after;
      } else {
        if (toOff)
          after.merge(0, toOff, null, false, 0, openEnd);
        insert2.push(after);
      }
    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
      if (last)
        last.breakAfter = 1;
      else
        breakAtStart = 1;
    }
    toI++;
  }
  if (before) {
    before.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
        before.breakAfter = insert2.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }
      fromI++;
    }
  }
  while (fromI < toI && insert2.length) {
    if (children[toI - 1].become(insert2[insert2.length - 1])) {
      toI--;
      insert2.pop();
      openEnd = insert2.length ? 0 : openStart;
    } else if (children[fromI].become(insert2[0])) {
      fromI++;
      insert2.shift();
      openStart = insert2.length ? 0 : openEnd;
    } else {
      break;
    }
  }
  if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
    fromI--;
  if (fromI < toI || insert2.length)
    parent.replaceChildren(fromI, toI, insert2);
}
function mergeChildrenInto(parent, from, to, insert2, openStart, openEnd) {
  let cur2 = parent.childCursor();
  let { i: toI, off: toOff } = cur2.findPos(to, 1);
  let { i: fromI, off: fromOff } = cur2.findPos(from, -1);
  let dLen = from - to;
  for (let view of insert2)
    dLen += view.length;
  parent.length += dLen;
  replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
}
let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
const ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !ie && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !ie && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !ie && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
const ios$1 = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios$1 || /* @__PURE__ */ /Mac/.test(nav.platform),
  windows: /* @__PURE__ */ /Win/.test(nav.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
  ie,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios: ios$1,
  android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const MaxJoinLen = 256;
class TextView extends ContentView {
  constructor(text3) {
    super();
    this.text = text3;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(track) {
    if (!this.dom)
      this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType == 3)
      this.createDOM(dom);
  }
  merge(from, to, source) {
    if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))
      return false;
    this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = new TextView(this.text.slice(from));
    this.text = this.text.slice(0, from);
    this.markDirty();
    return result;
  }
  localPosFromDOM(node, offset) {
    return node == this.dom ? offset : offset ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset) {
    return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
}
class MarkView extends ContentView {
  constructor(mark, children = [], length = 0) {
    super();
    this.mark = mark;
    this.children = children;
    this.length = length;
    for (let ch of children)
      ch.setParent(this);
  }
  setAttrs(dom) {
    clearAttributes(dom);
    if (this.mark.class)
      dom.className = this.mark.class;
    if (this.mark.attrs)
      for (let name2 in this.mark.attrs)
        dom.setAttribute(name2, this.mark.attrs[name2]);
    return dom;
  }
  reuseDOM(node) {
    if (node.nodeName == this.mark.tagName.toUpperCase()) {
      this.setDOM(node);
      this.dirty |= 4 | 2;
    }
  }
  sync(track) {
    if (!this.dom)
      this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
    else if (this.dirty & 4)
      this.setAttrs(this.dom);
    super.sync(track);
  }
  merge(from, to, source, _hasStart, openStart, openEnd) {
    if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = [], off = 0, detachFrom = -1, i = 0;
    for (let elt2 of this.children) {
      let end = off + elt2.length;
      if (end > from)
        result.push(off < from ? elt2.split(from - off) : elt2);
      if (detachFrom < 0 && off >= from)
        detachFrom = i;
      off = end;
      i++;
    }
    let length = this.length - from;
    this.length = from;
    if (detachFrom > -1) {
      this.children.length = detachFrom;
      this.markDirty();
    }
    return new MarkView(this.mark, result, length);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this.dom, this.children, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
}
function textCoords(text3, pos, side) {
  let length = text3.nodeValue.length;
  if (pos > length)
    pos = length;
  let from = pos, to = pos, flatten2 = 0;
  if (pos == 0 && side < 0 || pos == length && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from--;
        flatten2 = 1;
      } else {
        to++;
        flatten2 = -1;
      }
    }
  } else {
    if (side < 0)
      from--;
    else
      to++;
  }
  let rects = textRange(text3, from, to).getClientRects();
  if (!rects.length)
    return Rect0;
  let rect2 = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten2 && rect2.width == 0)
    rect2 = Array.prototype.find.call(rects, (r) => r.width) || rect2;
  return flatten2 ? flattenRect(rect2, flatten2 < 0) : rect2 || null;
}
class WidgetView extends ContentView {
  constructor(widget, length, side) {
    super();
    this.widget = widget;
    this.length = length;
    this.side = side;
  }
  static create(widget, length, side) {
    return new (widget.customView || WidgetView)(widget, length, side);
  }
  split(from) {
    let result = WidgetView.create(this.widget, this.length - from, this.side);
    this.length -= from;
    return result;
  }
  sync() {
    if (!this.dom || !this.widget.updateDOM(this.dom)) {
      this.setDOM(this.widget.toDOM(this.editorView));
      this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  become(other) {
    if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
      if (this.widget.constructor == other.widget.constructor) {
        if (!this.widget.eq(other.widget))
          this.markDirty(true);
        this.widget = other.widget;
        return true;
      }
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Text.empty;
    let top2 = this;
    while (top2.parent)
      top2 = top2.parent;
    let view = top2.editorView, text3 = view && view.state.doc, start = this.posAtStart;
    return text3 ? text3.slice(start, start + this.length) : Text.empty;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let rects = this.dom.getClientRects(), rect2 = null;
    if (!rects.length)
      return Rect0;
    for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
      rect2 = rects[i];
      if (pos > 0 ? i == 0 : i == rects.length - 1 || rect2.top < rect2.bottom)
        break;
    }
    return pos == 0 && side > 0 || pos == this.length && side <= 0 ? rect2 : flattenRect(rect2, pos == 0);
  }
  get isEditable() {
    return false;
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
}
class CompositionView extends WidgetView {
  domAtPos(pos) {
    return new DOMPos(this.widget.text, pos);
  }
  sync() {
    this.setDOM(this.widget.toDOM());
  }
  localPosFromDOM(node, offset) {
    return !offset ? 0 : node.nodeType == 3 ? Math.min(offset, this.length) : this.length;
  }
  ignoreMutation() {
    return false;
  }
  get overrideDOMText() {
    return null;
  }
  coordsAt(pos, side) {
    return textCoords(this.widget.text, pos, side);
  }
  get isEditable() {
    return true;
  }
}
class WidgetBufferView extends ContentView {
  constructor(side) {
    super();
    this.side = side;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(other) {
    return other instanceof WidgetBufferView && other.side == this.side;
  }
  split() {
    return new WidgetBufferView(this.side);
  }
  sync() {
    if (!this.dom) {
      let dom = document.createElement("img");
      dom.className = "cm-widgetBuffer";
      this.setDOM(dom);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(pos) {
    return DOMPos.before(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Text.empty;
  }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(dom, children, pos) {
  let i = 0;
  for (let off = 0; i < children.length; i++) {
    let child = children[i], end = off + child.length;
    if (end == off && child.getSide() <= 0)
      continue;
    if (pos > off && pos < end && child.dom.parentNode == dom)
      return child.domAtPos(pos - off);
    if (pos <= off)
      break;
    off = end;
  }
  for (; i > 0; i--) {
    let before = children[i - 1].dom;
    if (before.parentNode == dom)
      return DOMPos.after(before);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last, { children } = parent;
  if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
    joinInlineInto(last, view.children[0], open - 1);
  } else {
    children.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  for (let off = 0, i = 0; i < view.children.length; i++) {
    let child = view.children[i], end = off + child.length, next;
    if ((side <= 0 || end == view.length || child.getSide() > 0 ? end >= pos : end > pos) && (pos < end || i + 1 == view.children.length || (next = view.children[i + 1]).length || next.getSide() > 0)) {
      let flatten2 = 0;
      if (end == off) {
        if (child.getSide() <= 0)
          continue;
        flatten2 = side = -child.getSide();
      }
      let rect2 = child.coordsAt(Math.max(0, pos - off), side);
      return flatten2 && rect2 ? flattenRect(rect2, side < 0) : rect2;
    }
    off = end;
  }
  let last = view.dom.lastChild;
  if (!last)
    return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1] || null;
}
function combineAttrs(source, target2) {
  for (let name2 in source) {
    if (name2 == "class" && target2.class)
      target2.class += " " + source.class;
    else if (name2 == "style" && target2.style)
      target2.style += ";" + source.style;
    else
      target2[name2] = source[name2];
  }
  return target2;
}
function attrsEq(a, b) {
  if (a == b)
    return true;
  if (!a || !b)
    return false;
  let keysA = Object.keys(a), keysB = Object.keys(b);
  if (keysA.length != keysB.length)
    return false;
  for (let key of keysA) {
    if (keysB.indexOf(key) == -1 || a[key] !== b[key])
      return false;
  }
  return true;
}
function updateAttrs(dom, prev, attrs) {
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs))
        dom.removeAttribute(name2);
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2]))
        dom.setAttribute(name2, attrs[name2]);
  }
}
class WidgetType {
  eq(_widget) {
    return false;
  }
  updateDOM(_dom) {
    return false;
  }
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent(_event) {
    return true;
  }
  get customView() {
    return null;
  }
  destroy(_dom) {
  }
}
var BlockType = /* @__PURE__ */ function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
class Decoration extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  get heightRelevant() {
    return false;
  }
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  static widget(spec) {
    let side = spec.side || 0, block3 = !!spec.block;
    side += block3 ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block3, spec.widget || null, false);
  }
  static replace(spec) {
    let block3 = !!spec.block;
    let { start, end } = getInclusive(spec, block3);
    let startSide = (start ? block3 ? -3e8 : -1 : 4e8) - 1;
    let endSide = (end ? block3 ? 2e8 : 1 : -5e8) + 1;
    return new PointDecoration(spec, startSide, endSide, block3, spec.widget || null, true);
  }
  static line(spec) {
    return new LineDecoration(spec);
  }
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
}
Decoration.none = RangeSet.empty;
class MarkDecoration extends Decoration {
  constructor(spec) {
    let { start, end } = getInclusive(spec);
    super(start ? -1 : 4e8, end ? 1 : -5e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
  }
  range(from, to = from) {
    if (from >= to)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to);
  }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to = from) {
    if (to != from)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to);
  }
}
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block3, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block3;
    this.isReplace = isReplace;
    this.mapMode = !block3 ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  get type() {
    return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
  }
  eq(other) {
    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to = from) {
    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to);
  }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block3 = false) {
  let { inclusiveStart: start, inclusiveEnd: end } = spec;
  if (start == null)
    start = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return { start: start !== null && start !== void 0 ? start : block3, end: end !== null && end !== void 0 ? end : block3 };
}
function widgetsEq(a, b) {
  return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
  let last = ranges.length - 1;
  if (last >= 0 && ranges[last] + margin >= from)
    ranges[last] = Math.max(ranges[last], to);
  else
    ranges.push(from, to);
}
class LineView extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = void 0;
    this.attrs = null;
    this.breakAfter = 0;
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    if (source) {
      if (!(source instanceof LineView))
        return false;
      if (!this.dom)
        source.transferDOM(this);
    }
    if (hasStart)
      this.setDeco(source ? source.attrs : null);
    mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);
    return true;
  }
  split(at) {
    let end = new LineView();
    end.breakAfter = this.breakAfter;
    if (this.length == 0)
      return end;
    let { i, off } = this.childPos(at);
    if (off) {
      end.append(this.children[i].split(off), 0);
      this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
      i++;
    }
    for (let j = i; j < this.children.length; j++)
      end.append(this.children[j], 0);
    while (i > 0 && this.children[i - 1].length == 0)
      this.children[--i].destroy();
    this.children.length = i;
    this.markDirty();
    this.length = at;
    return end;
  }
  transferDOM(other) {
    if (!this.dom)
      return;
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
    this.prevAttrs = void 0;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  addLineDeco(deco) {
    let attrs = deco.spec.attributes, cls = deco.spec.class;
    if (attrs)
      this.attrs = combineAttrs(attrs, this.attrs || {});
    if (cls)
      this.attrs = combineAttrs({ class: cls }, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this.dom, this.children, pos);
  }
  reuseDOM(node) {
    if (node.nodeName == "DIV") {
      this.setDOM(node);
      this.dirty |= 4 | 2;
    }
  }
  sync(track) {
    var _a;
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    } else if (this.dirty & 4) {
      clearAttributes(this.dom);
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = void 0;
    }
    super.sync(track);
    let last = this.dom.lastChild;
    while (last && ContentView.get(last) instanceof MarkView)
      last = last.lastChild;
    if (!last || last.nodeName != "BR" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let totalWidth = 0;
    for (let child of this.children) {
      if (!(child instanceof TextView))
        return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1)
        return null;
      totalWidth += rects[0].width;
    }
    return {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length
    };
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
  become(_other) {
    return false;
  }
  get type() {
    return BlockType.Text;
  }
  static find(docView, pos) {
    for (let i = 0, off = 0; i < docView.children.length; i++) {
      let block3 = docView.children[i], end = off + block3.length;
      if (end >= pos) {
        if (block3 instanceof LineView)
          return block3;
        if (end > pos)
          break;
      }
      off = end + block3.breakAfter;
    }
    return null;
  }
}
class BlockWidgetView extends ContentView {
  constructor(widget, length, type) {
    super();
    this.widget = widget;
    this.length = length;
    this.type = type;
    this.breakAfter = 0;
  }
  merge(from, to, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at) {
    let len = this.length - at;
    this.length = at;
    let end = new BlockWidgetView(this.widget, len, this.type);
    end.breakAfter = this.breakAfter;
    return end;
  }
  get children() {
    return noChildren;
  }
  sync() {
    if (!this.dom || !this.widget.updateDOM(this.dom)) {
      this.setDOM(this.widget.toDOM(this.editorView));
      this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(other) {
    if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.eq(this.widget))
        this.markDirty(true);
      this.widget = other.widget;
      this.length = other.length;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
}
class ContentBuilder {
  constructor(doc2, pos, end, disallowBlockEffectsBelow) {
    this.doc = doc2;
    this.pos = pos;
    this.end = end;
    this.disallowBlockEffectsBelow = disallowBlockEffectsBelow;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.pendingBuffer = 0;
    this.atCursorPos = true;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last = this.content[this.content.length - 1];
    return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
  }
  getLine() {
    if (!this.curLine) {
      this.content.push(this.curLine = new LineView());
      this.atCursorPos = true;
    }
    return this.curLine;
  }
  flushBuffer(active) {
    if (this.pendingBuffer) {
      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
      this.pendingBuffer = 0;
    }
  }
  addBlockWidget(view) {
    this.flushBuffer([]);
    this.curLine = null;
    this.content.push(view);
  }
  finish(openEnd) {
    if (!openEnd)
      this.flushBuffer([]);
    else
      this.pendingBuffer = 0;
    if (!this.posCovered())
      this.getLine();
  }
  buildText(length, active, openStart) {
    while (length > 0) {
      if (this.textOff == this.text.length) {
        let { value, lineBreak, done } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done)
          throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered())
            this.getLine();
          if (this.content.length)
            this.content[this.content.length - 1].breakAfter = 1;
          else
            this.breakAtStart = 1;
          this.flushBuffer([]);
          this.curLine = null;
          length--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take = Math.min(this.text.length - this.textOff, length, 512);
      this.flushBuffer(active.slice(0, openStart));
      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
      this.atCursorPos = true;
      this.textOff += take;
      length -= take;
      openStart = 0;
    }
  }
  span(from, to, active, openStart) {
    this.buildText(to - from, active, openStart);
    this.pos = to;
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  point(from, to, deco, active, openStart) {
    let len = to - from;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        let { type } = deco;
        if (type == BlockType.WidgetAfter && !this.posCovered())
          this.getLine();
        this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
      } else {
        let view = WidgetView.create(deco.widget || new NullWidget("span"), len, deco.startSide);
        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
        let cursorAfter = !view.isEditable && (from < to || deco.startSide <= 0);
        let line = this.getLine();
        if (this.pendingBuffer == 2 && !cursorBefore)
          this.pendingBuffer = 0;
        this.flushBuffer(active);
        if (cursorBefore) {
          line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
          openStart = active.length + Math.max(0, openStart - active.length);
        }
        line.append(wrapMarks(view, active), openStart);
        this.atCursorPos = cursorAfter;
        this.pendingBuffer = !cursorAfter ? 0 : from < to ? 1 : 2;
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to;
    }
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  filterPoint(from, to, value, index2) {
    if (index2 < this.disallowBlockEffectsBelow && value instanceof PointDecoration) {
      if (value.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (to > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    return true;
  }
  static build(text3, from, to, decorations2, pluginDecorationLength) {
    let builder = new ContentBuilder(text3, from, to, pluginDecorationLength);
    builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
    if (builder.openStart < 0)
      builder.openStart = builder.openEnd;
    builder.finish(builder.openEnd);
    return builder;
  }
}
function wrapMarks(view, active) {
  for (let mark of active)
    view = new MarkView(mark, [view], view.length);
  return view;
}
class NullWidget extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt2) {
    return elt2.nodeName.toLowerCase() == this.tag;
  }
}
const none$3 = [];
const clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
const dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
const mouseSelectionStyle = /* @__PURE__ */ Facet.define();
const exceptionSink = /* @__PURE__ */ Facet.define();
const updateListener = /* @__PURE__ */ Facet.define();
const inputHandler$1 = /* @__PURE__ */ Facet.define();
const scrollTo = /* @__PURE__ */ StateEffect.define({
  map: (range2, changes) => range2.map(changes)
});
const centerOn = /* @__PURE__ */ StateEffect.define({
  map: (range2, changes) => range2.map(changes)
});
class ScrollTarget {
  constructor(range2, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5) {
    this.range = range2;
    this.y = y;
    this.x = x;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
  }
  map(changes) {
    return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const scrollIntoView$1 = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror)
    window.onerror(String(exception), context, void 0, void 0, exception);
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
const editable = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.length ? values2[0] : true });
class PluginFieldProvider {
  constructor(field, get) {
    this.field = field;
    this.get = get;
  }
}
class PluginField {
  from(get) {
    return new PluginFieldProvider(this, get);
  }
  static define() {
    return new PluginField();
  }
}
PluginField.decorations = /* @__PURE__ */ PluginField.define();
PluginField.atomicRanges = /* @__PURE__ */ PluginField.define();
PluginField.scrollMargins = /* @__PURE__ */ PluginField.define();
let nextPluginID = 0;
const viewPlugin = /* @__PURE__ */ Facet.define();
class ViewPlugin {
  constructor(id2, create, fields) {
    this.id = id2;
    this.create = create;
    this.fields = fields;
    this.extension = viewPlugin.of(this);
  }
  static define(create, spec) {
    let { eventHandlers, provide, decorations: decorations2 } = spec || {};
    let fields = [];
    if (provide)
      for (let provider of Array.isArray(provide) ? provide : [provide])
        fields.push(provider);
    if (eventHandlers)
      fields.push(domEventHandlers.from((value) => ({ plugin: value, handlers: eventHandlers })));
    if (decorations2)
      fields.push(PluginField.decorations.from(decorations2));
    return new ViewPlugin(nextPluginID++, create, fields);
  }
  static fromClass(cls, spec) {
    return ViewPlugin.define((view) => new cls(view), spec);
  }
}
const domEventHandlers = /* @__PURE__ */ PluginField.define();
class PluginInstance {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  takeField(type, target2) {
    if (this.spec) {
      for (let { field, get } of this.spec.fields)
        if (field == type)
          target2.push(get(this.value));
    }
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.create(view);
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e) {
          logException(update.state, e, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_) {
            }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a;
    if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
      try {
        this.value.destroy();
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const editorAttributes = /* @__PURE__ */ Facet.define();
const contentAttributes = /* @__PURE__ */ Facet.define();
const decorations = /* @__PURE__ */ Facet.define();
const styleModule = /* @__PURE__ */ Facet.define();
class ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set2) {
    let i = set2.length, me = this;
    for (; i > 0; i--) {
      let range2 = set2[i - 1];
      if (range2.fromA > me.toA)
        continue;
      if (range2.toA < me.fromA)
        break;
      me = me.join(range2);
      set2.splice(i - 1, 1);
    }
    set2.splice(i, 0, me);
    return set2;
  }
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0)
      return diff;
    let result = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next = dI == diff.length ? null : diff[dI], off = posA - posB;
      let end = next ? next.fromB : 1e9;
      while (rI < ranges.length && ranges[rI] < end) {
        let from = ranges[rI], to = ranges[rI + 1];
        let fromB = Math.max(posB, from), toB = Math.min(end, to);
        if (fromB <= toB)
          new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
        if (to > end)
          break;
        else
          rI += 2;
      }
      if (!next)
        return result;
      new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
      posA = next.toA;
      posB = next.toB;
    }
  }
}
class ViewUpdate {
  constructor(view, state, transactions = none$3) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr of transactions)
      this.changes = this.changes.compose(tr.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      view.inputState.notifiedFocused = focus;
      this.flags |= 1;
    }
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & (8 | 2)) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((tr) => tr.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var Direction = /* @__PURE__ */ function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
const LTR = Direction.LTR, RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i = 0; i < str.length; i++)
    result.push(1 << +str[i]);
  return result;
}
const LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
const ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = /* @__PURE__ */ Object.create(null), BracketStack = [];
for (let p of ["()", "[]", "{}"]) {
  let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
  Brackets[l] = r;
  Brackets[r] = -l;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : ch == 8204 ? 256 : 1;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
class BidiSpan {
  constructor(from, to, level) {
    this.from = from;
    this.to = to;
    this.level = level;
  }
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  static find(order2, index2, level, assoc) {
    let maybe = -1;
    for (let i = 0; i < order2.length; i++) {
      let span2 = order2[i];
      if (span2.from <= index2 && span2.to >= index2) {
        if (span2.level == level)
          return i;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span2.from < index2 : span2.to > index2 : order2[maybe].level > span2.level))
          maybe = i;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
}
const types = [];
function computeOrder(line, direction) {
  let len = line.length, outerType = direction == LTR ? 1 : 2, oppositeType = direction == LTR ? 2 : 1;
  if (!line || outerType == 1 && !BidiRE.test(line))
    return trivialOrder(len);
  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
    let type = charType(line.charCodeAt(i));
    if (type == 512)
      type = prev;
    else if (type == 8 && prevStrong == 4)
      type = 16;
    types[i] = type == 4 ? 2 : type;
    if (type & 7)
      prevStrong = type;
    prev = type;
  }
  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
    let type = types[i];
    if (type == 128) {
      if (i < len - 1 && prev == types[i + 1] && prev & 24)
        type = types[i] = prev;
      else
        types[i] = 256;
    } else if (type == 64) {
      let end = i + 1;
      while (end < len && types[end] == 64)
        end++;
      let replace2 = i && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
      for (let j = i; j < end; j++)
        types[j] = replace2;
      i = end - 1;
    } else if (type == 8 && prevStrong == 1) {
      types[i] = 1;
    }
    prev = type;
    if (type & 7)
      prevStrong = type;
  }
  for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {
    if (br = Brackets[ch = line.charCodeAt(i)]) {
      if (br < 0) {
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          if (BracketStack[sJ + 1] == -br) {
            let flags = BracketStack[sJ + 2];
            let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
            if (type2)
              types[i] = types[BracketStack[sJ]] = type2;
            sI = sJ;
            break;
          }
        }
      } else if (BracketStack.length == 189) {
        break;
      } else {
        BracketStack[sI++] = i;
        BracketStack[sI++] = ch;
        BracketStack[sI++] = context;
      }
    } else if ((type = types[i]) == 2 || type == 1) {
      let embed = type == outerType;
      context = embed ? 0 : 1;
      for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
        let cur2 = BracketStack[sJ + 2];
        if (cur2 & 2)
          break;
        if (embed) {
          BracketStack[sJ + 2] |= 2;
        } else {
          if (cur2 & 4)
            break;
          BracketStack[sJ + 2] |= 4;
        }
      }
    }
  }
  for (let i = 0; i < len; i++) {
    if (types[i] == 256) {
      let end = i + 1;
      while (end < len && types[end] == 256)
        end++;
      let beforeL = (i ? types[i - 1] : outerType) == 1;
      let afterL = (end < len ? types[end] : outerType) == 1;
      let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
      for (let j = i; j < end; j++)
        types[j] = replace2;
      i = end - 1;
    }
  }
  let order2 = [];
  if (outerType == 1) {
    for (let i = 0; i < len; ) {
      let start = i, rtl = types[i++] != 1;
      while (i < len && rtl == (types[i] != 1))
        i++;
      if (rtl) {
        for (let j = i; j > start; ) {
          let end = j, l = types[--j] != 2;
          while (j > start && l == (types[j - 1] != 2))
            j--;
          order2.push(new BidiSpan(j, end, l ? 2 : 1));
        }
      } else {
        order2.push(new BidiSpan(start, i, 0));
      }
    }
  } else {
    for (let i = 0; i < len; ) {
      let start = i, rtl = types[i++] == 2;
      while (i < len && rtl == (types[i] == 2))
        i++;
      order2.push(new BidiSpan(start, i, rtl ? 1 : 2));
    }
  }
  return order2;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
let movedOver = "";
function moveVisually(line, order2, dir, start, forward) {
  var _a;
  let startIndex = start.head - line.from, spanI = -1;
  if (startIndex == 0) {
    if (!forward || !line.length)
      return null;
    if (order2[0].level != dir) {
      startIndex = order2[0].side(false, dir);
      spanI = 0;
    }
  } else if (startIndex == line.length) {
    if (forward)
      return null;
    let last = order2[order2.length - 1];
    if (last.level != dir) {
      startIndex = last.side(true, dir);
      spanI = order2.length - 1;
    }
  }
  if (spanI < 0)
    spanI = BidiSpan.find(order2, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
  let span2 = order2[spanI];
  if (startIndex == span2.side(forward, dir)) {
    span2 = order2[spanI += forward ? 1 : -1];
    startIndex = span2.side(!forward, dir);
  }
  let indexForward = forward == (span2.dir == dir);
  let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  if (nextIndex != span2.side(forward, dir))
    return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span2.level);
  let nextSpan = spanI == (forward ? order2.length - 1 : 0) ? null : order2[spanI + (forward ? 1 : -1)];
  if (!nextSpan && span2.level != dir)
    return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
  if (nextSpan && nextSpan.level < span2.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span2.level);
}
const LineBreakPlaceholder = "\uFFFF";
class DOMReader {
  constructor(points, state) {
    this.points = points;
    this.text = "";
    this.lineSeparator = state.facet(EditorState.lineSeparator);
  }
  append(text3) {
    this.text += text3;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start, end) {
    if (!start)
      return this;
    let parent = start.parentNode;
    for (let cur2 = start; ; ) {
      this.findPointBefore(parent, cur2);
      this.readNode(cur2);
      let next = cur2.nextSibling;
      if (next == end)
        break;
      let view = ContentView.get(cur2), nextView = ContentView.get(next);
      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore))
        this.lineBreak();
      cur2 = next;
    }
    this.findPointBefore(parent, end);
    return this;
  }
  readTextNode(node) {
    let text3 = node.nodeValue;
    for (let point of this.points)
      if (point.node == node)
        point.pos = this.text.length + Math.min(point.offset, text3.length);
    for (let off = 0, re2 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m;
      if (this.lineSeparator) {
        nextBreak = text3.indexOf(this.lineSeparator, off);
        breakSize = this.lineSeparator.length;
      } else if (m = re2.exec(text3)) {
        nextBreak = m.index;
        breakSize = m[0].length;
      }
      this.append(text3.slice(off, nextBreak < 0 ? text3.length : nextBreak));
      if (nextBreak < 0)
        break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point of this.points)
          if (point.node == node && point.pos > this.text.length)
            point.pos -= breakSize - 1;
      }
      off = nextBreak + breakSize;
    }
  }
  readNode(node) {
    if (node.cmIgnore)
      return;
    let view = ContentView.get(node);
    let fromView = view && view.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node, fromView.length);
      for (let i = fromView.iter(); !i.next().done; ) {
        if (i.lineBreak)
          this.lineBreak();
        else
          this.append(i.value);
      }
    } else if (node.nodeType == 3) {
      this.readTextNode(node);
    } else if (node.nodeName == "BR") {
      if (node.nextSibling)
        this.lineBreak();
    } else if (node.nodeType == 1) {
      this.readRange(node.firstChild, null);
    }
  }
  findPointBefore(node, next) {
    for (let point of this.points)
      if (point.node == node && node.childNodes[point.offset] == next)
        point.pos = this.text.length;
  }
  findPointInside(node, maxLen) {
    for (let point of this.points)
      if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
        point.pos = this.text.length + Math.min(maxLen, point.offset);
  }
}
function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
class DOMPoint {
  constructor(node, offset) {
    this.node = node;
    this.offset = offset;
    this.pos = -1;
  }
}
class DocView extends ContentView {
  constructor(view) {
    super();
    this.view = view;
    this.compositionDeco = Decoration.none;
    this.decorations = [];
    this.pluginDecorationLength = 0;
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateDeco();
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);
  }
  get root() {
    return this.view.root;
  }
  get editorView() {
    return this.view;
  }
  get length() {
    return this.view.state.doc.length;
  }
  update(update) {
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    if (this.view.inputState.composing < 0)
      this.compositionDeco = Decoration.none;
    else if (update.transactions.length || this.dirty)
      this.compositionDeco = computeCompositionDeco(this.view, update.changes);
    if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines)
      this.forceSelection = true;
    let prevDeco = this.decorations, deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    if (this.dirty == 0 && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, update.startState.doc.length);
      if (update.transactions.length)
        this.lastUpdate = Date.now();
      return true;
    }
  }
  updateInner(changes, oldLength) {
    this.view.viewState.mustMeasureContent = true;
    this.updateChildren(changes, oldLength);
    let { observer } = this.view;
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px";
      this.dom.style.minWidth = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
      this.sync(track);
      this.dirty = 0;
      if (track && (track.written || observer.selectionRange.focusNode != track.node))
        this.forceSelection = true;
      this.dom.style.height = "";
    });
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.children)
        if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom);
    }
    observer.updateGaps(gaps);
  }
  updateChildren(changes, oldLength) {
    let cursor2 = this.childCursor(oldLength);
    for (let i = changes.length - 1; ; i--) {
      let next = i >= 0 ? changes[i] : null;
      if (!next)
        break;
      let { fromA, toA, fromB, toB } = next;
      let { content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.pluginDecorationLength);
      let { i: toI, off: toOff } = cursor2.findPos(toA, 1);
      let { i: fromI, off: fromOff } = cursor2.findPos(fromA, -1);
      replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
    }
  }
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead)
      this.view.observer.readSelectionRange();
    if (!(fromPointer || this.mayControlSelection()) || browser.ios && this.view.inputState.rapidCompositionStart)
      return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main = this.view.state.selection.main;
    let anchor = this.domAtPos(main.anchor);
    let head = main.empty ? anchor : this.domAtPos(main.head);
    if (browser.gecko && main.empty && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
      this.view.observer.ignore(() => {
        if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
          this.dom.blur();
          this.dom.focus({ preventScroll: true });
        }
        let rawSel = getSelection(this.root);
        if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text3 = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
              if (text3)
                anchor = new DOMPos(text3, nextTo == 1 ? 0 : text3.nodeValue.length);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
            domSel.cursorBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          rawSel.extend(head.node, head.offset);
        } else {
          let range2 = document.createRange();
          if (main.anchor > main.head)
            [anchor, head] = [head, anchor];
          range2.setEnd(head.node, head.offset);
          range2.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range2);
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.compositionDeco.size)
      return;
    let cursor2 = this.view.state.selection.main;
    let sel = getSelection(this.root);
    if (!cursor2.empty || !cursor2.assoc || !sel.modify)
      return;
    let line = LineView.find(this, cursor2.head);
    if (!line)
      return;
    let lineStart = line.posAtStart;
    if (cursor2.head == lineStart || cursor2.head == lineStart + line.length)
      return;
    let before = this.coordsAt(cursor2.head, -1), after = this.coordsAt(cursor2.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor2.head + cursor2.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor2.assoc < 0 ? "forward" : "backward", "lineboundary");
  }
  mayControlSelection() {
    return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, this.view.observer.selectionRange);
  }
  nearest(dom) {
    for (let cur2 = dom; cur2; ) {
      let domView = ContentView.get(cur2);
      if (domView && domView.rootView == this)
        return domView;
      cur2 = cur2.parentNode;
    }
    return null;
  }
  posFromDOM(node, offset) {
    let view = this.nearest(node);
    if (!view)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node, offset) + view.posAtStart;
  }
  domAtPos(pos) {
    let { i, off } = this.childCursor().findPos(pos, -1);
    for (; i < this.children.length - 1; ) {
      let child = this.children[i];
      if (off < child.length || child instanceof LineView)
        break;
      i++;
      off = 0;
    }
    return this.children[i].domAtPos(off);
  }
  coordsAt(pos, side) {
    for (let off = this.length, i = this.children.length - 1; ; i--) {
      let child = this.children[i], start = off - child.breakAfter - child.length;
      if (pos > start || pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2))
        return child.coordsAt(pos - start, side);
      off = start;
    }
  }
  measureVisibleLineHeights() {
    let result = [], { from, to } = this.view.viewState.viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1;
    for (let pos = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (end > to)
        break;
      if (pos >= from) {
        let childRect = child.dom.getBoundingClientRect();
        result.push(childRect.height);
        if (isWider) {
          let last = child.dom.lastChild;
          let rects = last ? clientRectsFor(last) : [];
          if (rects.length) {
            let rect2 = rects[rects.length - 1];
            let width = this.view.textDirection == Direction.LTR ? rect2.right - childRect.left : childRect.right - rect2.left;
            if (width > widest) {
              widest = width;
              this.minWidth = contentWidth;
              this.minWidthFrom = pos;
              this.minWidthTo = end;
            }
          }
        }
      }
      pos = end + child.breakAfter;
    }
    return result;
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure)
          return measure;
      }
    }
    let dummy = document.createElement("div"), lineHeight, charWidth;
    dummy.className = "cm-line";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect2 = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect2 ? rect2.width / 27 : 7;
      dummy.remove();
    });
    return { lineHeight, charWidth };
  }
  childCursor(pos = this.length) {
    let i = this.children.length;
    if (i)
      pos -= this.children[--i].length;
    return new ChildCursor(this.children, pos, i);
  }
  computeBlockGapDeco() {
    let deco = [], vs = this.view.viewState;
    for (let pos = 0, i = 0; ; i++) {
      let next = i == vs.viewports.length ? null : vs.viewports[i];
      let end = next ? next.from - 1 : this.length;
      if (end > pos) {
        let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
        deco.push(Decoration.replace({ widget: new BlockGapWidget(height), block: true, inclusive: true }).range(pos, end));
      }
      if (!next)
        break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let pluginDecorations = this.view.pluginField(PluginField.decorations);
    this.pluginDecorationLength = pluginDecorations.length;
    return this.decorations = [
      ...pluginDecorations,
      ...this.view.state.facet(decorations),
      this.compositionDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(target2) {
    let { range: range2 } = target2;
    let rect2 = this.coordsAt(range2.head, range2.empty ? range2.assoc : range2.head > range2.anchor ? -1 : 1), other;
    if (!rect2)
      return;
    if (!range2.empty && (other = this.coordsAt(range2.anchor, range2.anchor > range2.head ? -1 : 1)))
      rect2 = {
        left: Math.min(rect2.left, other.left),
        top: Math.min(rect2.top, other.top),
        right: Math.max(rect2.right, other.right),
        bottom: Math.max(rect2.bottom, other.bottom)
      };
    let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
    for (let margins of this.view.pluginField(PluginField.scrollMargins))
      if (margins) {
        let { left, right, top: top2, bottom: bottom2 } = margins;
        if (left != null)
          mLeft = Math.max(mLeft, left);
        if (right != null)
          mRight = Math.max(mRight, right);
        if (top2 != null)
          mTop = Math.max(mTop, top2);
        if (bottom2 != null)
          mBottom = Math.max(mBottom, bottom2);
      }
    let targetRect = {
      left: rect2.left - mLeft,
      top: rect2.top - mTop,
      right: rect2.right + mRight,
      bottom: rect2.bottom + mBottom
    };
    scrollRectIntoView(this.view.scrollDOM, targetRect, range2.head < range2.anchor ? -1 : 1, target2.x, target2.y, target2.xMargin, target2.yMargin, this.view.textDirection == Direction.LTR);
  }
}
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
class BlockGapWidget extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt2 = document.createElement("div");
    this.updateDOM(elt2);
    return elt2;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt2) {
    elt2.style.height = this.height + "px";
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function compositionSurroundingNode(view) {
  let sel = view.observer.selectionRange;
  let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
  if (!textNode)
    return null;
  let cView = view.docView.nearest(textNode);
  if (!cView)
    return null;
  if (cView instanceof LineView) {
    let topNode = textNode;
    while (topNode.parentNode != cView.dom)
      topNode = topNode.parentNode;
    let prev = topNode.previousSibling;
    while (prev && !ContentView.get(prev))
      prev = prev.previousSibling;
    let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
    return { from: pos, to: pos, node: topNode, text: textNode };
  } else {
    for (; ; ) {
      let { parent } = cView;
      if (!parent)
        return null;
      if (parent instanceof LineView)
        break;
      cView = parent;
    }
    let from = cView.posAtStart;
    return { from, to: from + cView.length, node: cView.dom, text: textNode };
  }
}
function computeCompositionDeco(view, changes) {
  let surrounding = compositionSurroundingNode(view);
  if (!surrounding)
    return Decoration.none;
  let { from, to, node, text: textNode } = surrounding;
  let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
  let { state } = view, text3 = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state).readRange(node.firstChild, null).text;
  if (newTo - newFrom < text3.length) {
    if (state.doc.sliceString(newFrom, Math.min(state.doc.length, newFrom + text3.length), LineBreakPlaceholder) == text3)
      newTo = newFrom + text3.length;
    else if (state.doc.sliceString(Math.max(0, newTo - text3.length), newTo, LineBreakPlaceholder) == text3)
      newFrom = newTo - text3.length;
    else
      return Decoration.none;
  } else if (state.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text3) {
    return Decoration.none;
  }
  return Decoration.set(Decoration.replace({ widget: new CompositionWidget(node, textNode) }).range(newFrom, newTo));
}
class CompositionWidget extends WidgetType {
  constructor(top2, text3) {
    super();
    this.top = top2;
    this.text = text3;
  }
  eq(other) {
    return this.top == other.top && this.text == other.text;
  }
  toDOM() {
    return this.top;
  }
  ignoreEvent() {
    return false;
  }
  get customView() {
    return CompositionView;
  }
}
function nearbyTextNode(node, offset, side) {
  for (; ; ) {
    if (node.nodeType == 3)
      return node;
    if (node.nodeType == 1 && offset > 0 && side <= 0) {
      node = node.childNodes[offset - 1];
      offset = maxOffset(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null;
    }
  }
}
function nextToUneditable(node, offset) {
  if (node.nodeType != 1)
    return 0;
  return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
class DecorationComparator$1 {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint(from, to) {
    addRange(from, to, this.changes);
  }
}
function findChangedDeco(a, b, diff) {
  let comp2 = new DecorationComparator$1();
  RangeSet.compare(a, b, diff, comp2);
  return comp2.changes;
}
function inUneditable(node, inside2) {
  for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
    if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from = linePos, to = linePos;
  if (bias < 0)
    from = findClusterBreak(line.text, linePos, false);
  else
    to = findClusterBreak(line.text, linePos);
  let cat = categorize(line.text.slice(from, to));
  while (from > 0) {
    let prev = findClusterBreak(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat)
      break;
    from = prev;
  }
  while (to < line.length) {
    let next = findClusterBreak(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat)
      break;
    to = next;
  }
  return EditorSelection.range(from + line.from, to + line.from);
}
function getdx(x, rect2) {
  return rect2.left > x ? rect2.left - x : Math.max(0, x - rect2.right);
}
function getdy(y, rect2) {
  return rect2.top > y ? rect2.top - y : Math.max(0, y - rect2.bottom);
}
function yOverlap(a, b) {
  return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect2, top2) {
  return top2 < rect2.top ? { top: top2, left: rect2.left, right: rect2.right, bottom: rect2.bottom } : rect2;
}
function upBot(rect2, bottom2) {
  return bottom2 > rect2.bottom ? { top: rect2.top, left: rect2.left, right: rect2.right, bottom: bottom2 } : rect2;
}
function domPosAtCoords(parent, x, y) {
  let closest, closestRect, closestX, closestY;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i = 0; i < rects.length; i++) {
      let rect2 = rects[i];
      if (closestRect && yOverlap(closestRect, rect2))
        rect2 = upTop(upBot(rect2, closestRect.bottom), closestRect.top);
      let dx = getdx(x, rect2), dy = getdy(y, rect2);
      if (dx == 0 && dy == 0)
        return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect2;
        closestX = dx;
        closestY = dy;
      }
      if (dx == 0) {
        if (y > rect2.bottom && (!aboveRect || aboveRect.bottom < rect2.bottom)) {
          above = child;
          aboveRect = rect2;
        } else if (y < rect2.top && (!belowRect || belowRect.top > rect2.top)) {
          below = child;
          belowRect = rect2;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect2)) {
        aboveRect = upBot(aboveRect, rect2.bottom);
      } else if (belowRect && yOverlap(belowRect, rect2)) {
        belowRect = upTop(belowRect, rect2.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest)
    return { node: parent, offset: 0 };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
  if (closest.nodeType == 3)
    return domPosInText(closest, clipX, y);
  if (!closestX && closest.contentEditable == "true")
    return domPosAtCoords(closest, clipX, y);
  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return { node: parent, offset };
}
function domPosInText(node, x, y) {
  let len = node.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i = 0; i < len; i++) {
    let rects = textRange(node, i, i + 1).getClientRects();
    for (let j = 0; j < rects.length; j++) {
      let rect2 = rects[j];
      if (rect2.top == rect2.bottom)
        continue;
      if (!generalSide)
        generalSide = x - rect2.left;
      let dy = (rect2.top > y ? rect2.top - y : y - rect2.bottom) - 1;
      if (rect2.left - 1 <= x && rect2.right + 1 >= x && dy < closestDY) {
        let right = x >= (rect2.left + rect2.right) / 2, after = right;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node, i).getBoundingClientRect();
          if (rectBefore.left == rect2.right)
            after = !right;
        }
        if (dy <= 0)
          return { node, offset: i + (after ? 1 : 0) };
        closestOffset = i + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, { x, y }, precise, bias = -1) {
  var _a;
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let block3, { docHeight } = view.viewState;
  let yOffset = y - docTop;
  if (yOffset < 0)
    return 0;
  if (yOffset > docHeight)
    return view.state.doc.length;
  for (let halfLine = view.defaultLineHeight / 2, bounced = false; ; ) {
    block3 = view.elementAtHeight(yOffset);
    if (block3.type == BlockType.Text)
      break;
    for (; ; ) {
      yOffset = bias > 0 ? block3.bottom + halfLine : block3.top - halfLine;
      if (yOffset >= 0 && yOffset <= docHeight)
        break;
      if (bounced)
        return precise ? null : 0;
      bounced = true;
      bias = -bias;
    }
  }
  y = docTop + yOffset;
  let lineStart = block3.from;
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block3, x, y);
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block3, x, y);
  let doc2 = view.dom.ownerDocument;
  let root = view.root.elementFromPoint ? view.root : doc2;
  let element = root.elementFromPoint(x, y);
  if (element && !view.contentDOM.contains(element))
    element = null;
  if (!element) {
    x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
    element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
      element = null;
  }
  let node, offset = -1;
  if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
    if (doc2.caretPositionFromPoint) {
      let pos = doc2.caretPositionFromPoint(x, y);
      if (pos)
        ({ offsetNode: node, offset } = pos);
    } else if (doc2.caretRangeFromPoint) {
      let range2 = doc2.caretRangeFromPoint(x, y);
      if (range2) {
        ({ startContainer: node, startOffset: offset } = range2);
        if (browser.safari && isSuspiciousCaretResult(node, offset, x))
          node = void 0;
      }
    }
  }
  if (!node || !view.docView.dom.contains(node)) {
    let line = LineView.find(view.docView, lineStart);
    if (!line)
      return yOffset > block3.top + block3.height / 2 ? block3.to : block3.from;
    ({ node, offset } = domPosAtCoords(line.dom, x, y));
  }
  return view.docView.posFromDOM(node, offset);
}
function posAtCoordsImprecise(view, contentRect, block3, x, y) {
  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block3.height > view.defaultLineHeight * 1.5) {
    let line = Math.floor((y - block3.top) / view.defaultLineHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block3.from, block3.to);
  return block3.from + findColumn(content2, into, view.state.tabSize);
}
function isSuspiciousCaretResult(node, offset, x) {
  let len;
  if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
    return false;
  for (let next = node.nextSibling; next; next = next.nextSibling)
    if (next.nodeType != 1 || next.nodeName != "BR")
      return false;
  return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = view.state.doc.lineAt(start.head);
  let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let pos = view.posAtCoords({
      x: forward == (view.textDirection == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  let lineView = LineView.find(view.docView, start.head);
  let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
  return EditorSelection.cursor(end, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  for (let cur2 = start, check2 = null; ; ) {
    let next = moveVisually(line, spans, view.textDirection, cur2, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur2;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = EditorSelection.cursor(forward ? line.from : line.to);
    }
    if (!check2) {
      if (!by)
        return next;
      check2 = by(char);
    } else if (!check2(char)) {
      return cur2;
    }
    cur2 = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start.assoc);
  let goal = start.goalColumn, startY;
  let rect2 = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect2.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos - docTop);
    if (goal == null)
      goal = Math.min(rect2.right - rect2.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect2.left + goal;
  let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist + extra) * dir;
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
    if (curY < rect2.top || curY > rect2.bottom || (dir < 0 ? pos < startPos : pos > startPos))
      return EditorSelection.cursor(pos, start.assoc, void 0, goal);
  }
}
function skipAtoms(view, oldPos, pos) {
  let atoms = view.pluginField(PluginField.atomicRanges);
  for (; ; ) {
    let moved = false;
    for (let set2 of atoms) {
      set2.between(pos.from - 1, pos.from + 1, (from, to, value) => {
        if (pos.from > from && pos.from < to) {
          pos = oldPos.from > pos.from ? EditorSelection.cursor(from, 1) : EditorSelection.cursor(to, -1);
          moved = true;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
class InputState {
  constructor(view) {
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.pendingIOSKey = void 0;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastEscPress = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.registeredEvents = [];
    this.customHandlers = [];
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.rapidCompositionStart = false;
    this.mouseSelection = null;
    for (let type in handlers) {
      let handler = handlers[type];
      view.contentDOM.addEventListener(type, (event) => {
        if (type == "keydown" && this.keydown(view, event))
          return;
        if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))
          return;
        if (this.mustFlushObserver(event))
          view.observer.forceFlush();
        if (this.runCustomHandlers(type, view, event))
          event.preventDefault();
        else
          handler(view, event);
      });
      this.registeredEvents.push(type);
    }
    this.notifiedFocused = view.hasFocus;
    this.ensureHandlers(view);
    if (browser.safari)
      view.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  ensureHandlers(view) {
    let handlers2 = this.customHandlers = view.pluginField(domEventHandlers);
    for (let set2 of handlers2) {
      for (let type in set2.handlers)
        if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
          this.registeredEvents.push(type);
          view.contentDOM.addEventListener(type, (event) => {
            if (!eventBelongsToEditor(view, event))
              return;
            if (this.runCustomHandlers(type, view, event))
              event.preventDefault();
          });
        }
    }
  }
  runCustomHandlers(type, view, event) {
    for (let set2 of this.customHandlers) {
      let handler = set2.handlers[type];
      if (handler) {
        try {
          if (handler.call(set2.plugin, event, view) || event.defaultPrevented)
            return true;
        } catch (e) {
          logException(view.state, e);
        }
      }
    }
    return false;
  }
  runScrollHandlers(view, event) {
    for (let set2 of this.customHandlers) {
      let handler = set2.handlers.scroll;
      if (handler) {
        try {
          handler.call(set2.plugin, event, view);
        } catch (e) {
          logException(view.state, e);
        }
      }
    }
  }
  keydown(view, event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (this.screenKeyEvent(view, event))
      return true;
    if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
      view.observer.delayAndroidKey(event.key, event.keyCode);
      return true;
    }
    let pending;
    if (browser.ios && (pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !(event.ctrlKey || event.altKey || event.metaKey) && !event.synthetic) {
      this.pendingIOSKey = pending;
      setTimeout(() => this.flushIOSKey(view), 250);
      return true;
    }
    return false;
  }
  flushIOSKey(view) {
    let key = this.pendingIOSKey;
    if (!key)
      return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(view.contentDOM, key.key, key.keyCode);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type))
      return false;
    if (this.composing > 0)
      return true;
    if (browser.safari && Date.now() - this.compositionEndedAt < 500) {
      this.compositionEndedAt = 0;
      return true;
    }
    return false;
  }
  screenKeyEvent(view, event) {
    let protectedTab = event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3;
    if (event.keyCode == 27)
      this.lastEscPress = Date.now();
    else if (modifierCodes.indexOf(event.keyCode) < 0)
      this.lastEscPress = 0;
    return protectedTab;
  }
  mustFlushObserver(event) {
    return event.type == "keydown" && event.keyCode != 229 || event.type == "compositionend" && !browser.ios;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
}
const PendingKeys = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
class MouseSelection {
  constructor(view, startEvent, style, mustSelect) {
    this.view = view;
    this.style = style;
    this.mustSelect = mustSelect;
    this.lastEvent = startEvent;
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragMove = dragMovesSelection(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
    if (this.dragging === false) {
      startEvent.preventDefault();
      this.select(startEvent);
    }
  }
  move(event) {
    if (event.buttons == 0)
      return this.destroy();
    if (this.dragging !== false)
      return;
    this.select(this.lastEvent = event);
  }
  up(event) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event.preventDefault();
    this.destroy();
  }
  destroy() {
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = null;
  }
  select(event) {
    let selection2 = this.style.get(event, this.extend, this.multiple);
    if (this.mustSelect || !selection2.eq(this.view.state.selection) || selection2.main.assoc != this.view.state.selection.main.assoc)
      this.view.dispatch({
        selection: selection2,
        userEvent: "select.pointer",
        scrollIntoView: true
      });
    this.mustSelect = false;
  }
  update(update) {
    if (update.docChanged && this.dragging)
      this.dragging = this.dragging.map(update.changes);
    if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let { main } = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i = 0; i < rects.length; i++) {
    let rect2 = rects[i];
    if (rect2.left <= event.clientX && rect2.right >= event.clientX && rect2.top <= event.clientY && rect2.bottom >= event.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
    if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
      return false;
  return true;
}
const handlers = /* @__PURE__ */ Object.create(null);
const brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target2 = parent.appendChild(document.createElement("textarea"));
  target2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target2.focus();
  setTimeout(() => {
    view.focus();
    target2.remove();
    doPaste(view, target2.value);
  }, 50);
}
function doPaste(view, input) {
  let { state } = view, changes, i = 1, text3 = state.toText(input);
  let byLine = text3.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text3.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range2) => {
      let line = state.doc.lineAt(range2.from);
      if (line.from == lastLine)
        return { range: range2 };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text3.line(i++).text : input) + state.lineBreak);
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range2.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range2) => {
      let line = text3.line(i++);
      return {
        changes: { from: range2.from, to: range2.to, insert: line.text },
        range: EditorSelection.cursor(range2.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text3);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("select");
};
let lastTouch = 0;
handlers.touchstart = (view, e) => {
  lastTouch = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (lastTouch > Date.now() - 2e3 && getClickType(event) == 1)
    return;
  let style = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event);
    if (style)
      break;
  }
  if (!style && event.button == 0)
    style = basicMouseSelection(view, event);
  if (style) {
    let mustFocus = view.root.activeElement != view.contentDOM;
    if (mustFocus)
      view.observer.ignore(() => focusPreventScroll(view.contentDOM));
    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
  }
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to)
      to++;
    return EditorSelection.range(from, to);
  }
}
let insideY = (y, rect2) => y >= rect2.top && y <= rect2.bottom;
let inside = (x, y, rect2) => insideY(y, rect2) && x >= rect2.left && x <= rect2.right;
function findPositionSide(view, pos, x, y) {
  let line = LineView.find(view.docView, pos);
  if (!line)
    return 1;
  let off = pos - line.posAtStart;
  if (off == 0)
    return 1;
  if (off == line.length)
    return -1;
  let before = line.coordsAt(off, -1);
  if (before && inside(x, y, before))
    return -1;
  let after = line.coordsAt(off, 1);
  if (after && inside(x, y, after))
    return 1;
  return before && insideY(y, before) ? -1 : 1;
}
function queryPos(view, event) {
  let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail)
    return event.detail;
  let last = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start = queryPos(view, event), type = getClickType(event);
  let startSel = view.state.selection;
  let last = start, lastEvent = event;
  return {
    update(update) {
      if (update.docChanged) {
        if (start)
          start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
        lastEvent = null;
      }
    },
    get(event2, extend2, multiple) {
      let cur2;
      if (lastEvent && event2.clientX == lastEvent.clientX && event2.clientY == lastEvent.clientY)
        cur2 = last;
      else {
        cur2 = last = queryPos(view, event2);
        lastEvent = event2;
      }
      if (!cur2 || !start)
        return startSel;
      let range2 = rangeForClick(view, cur2.pos, cur2.bias, type);
      if (start.pos != cur2.pos && !extend2) {
        let startRange = rangeForClick(view, start.pos, start.bias, type);
        let from = Math.min(startRange.from, range2.from), to = Math.max(startRange.to, range2.to);
        range2 = from < range2.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
      }
      if (extend2)
        return startSel.replaceRange(startSel.main.extend(range2.from, range2.to));
      else if (multiple)
        return startSel.addRange(range2);
      else
        return EditorSelection.create([range2]);
    }
  };
}
handlers.dragstart = (view, event) => {
  let { selection: { main } } = view.state;
  let { mouseSelection } = view.inputState;
  if (mouseSelection)
    mouseSelection.dragging = main;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
    event.dataTransfer.effectAllowed = "copyMove";
  }
};
function dropText(view, event, text3, direct) {
  if (!text3)
    return;
  let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  event.preventDefault();
  let { mouseSelection } = view.inputState;
  let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
  let ins = { from: dropPos, insert: text3 };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer)
    return;
  if (view.state.readOnly)
    return event.preventDefault();
  let files = event.dataTransfer.files;
  if (files && files.length) {
    event.preventDefault();
    let text3 = Array(files.length), read = 0;
    let finishFile = () => {
      if (++read == files.length)
        dropText(view, event, text3.filter((s) => s != null).join(view.state.lineBreak), false);
    };
    for (let i = 0; i < files.length; i++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text3[i] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i]);
    }
  } else {
    dropText(view, event, event.dataTransfer.getData("Text"), true);
  }
};
handlers.paste = (view, event) => {
  if (view.state.readOnly)
    return event.preventDefault();
  view.observer.flush();
  let data2 = brokenClipboardAPI ? null : event.clipboardData;
  if (data2) {
    doPaste(view, data2.getData("text/plain"));
    event.preventDefault();
  } else {
    capturePaste(view);
  }
};
function captureCopy(view, text3) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target2 = parent.appendChild(document.createElement("textarea"));
  target2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target2.value = text3;
  target2.focus();
  target2.selectionEnd = text3.length;
  target2.selectionStart = 0;
  setTimeout(() => {
    target2.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range2 of state.selection.ranges)
    if (!range2.empty) {
      content2.push(state.sliceDoc(range2.from, range2.to));
      ranges.push(range2);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from } of state.selection.ranges) {
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return { text: content2.join(state.lineBreak), ranges, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let { text: text3, ranges, linewise } = copiedRange(view.state);
  if (!text3 && !linewise)
    return;
  lastLinewiseCopy = linewise ? text3 : null;
  let data2 = brokenClipboardAPI ? null : event.clipboardData;
  if (data2) {
    event.preventDefault();
    data2.clearData();
    data2.setData("text/plain", text3);
  } else {
    captureCopy(view, text3);
  }
  if (event.type == "cut" && !view.state.readOnly)
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
};
handlers.focus = handlers.blur = (view) => {
  setTimeout(() => {
    if (view.hasFocus != view.inputState.notifiedFocused)
      view.update([]);
  }, 10);
};
handlers.beforeprint = (view) => {
  view.viewState.printing = true;
  view.requestMeasure();
  setTimeout(() => {
    view.viewState.printing = false;
    view.requestMeasure();
  }, 2e3);
};
function forceClearComposition(view, rapid) {
  if (view.docView.compositionDeco.size) {
    view.inputState.rapidCompositionStart = rapid;
    try {
      view.update([]);
    } finally {
      view.inputState.rapidCompositionStart = false;
    }
  }
}
handlers.compositionstart = handlers.compositionupdate = (view) => {
  if (view.inputState.compositionFirstChange == null)
    view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
    if (view.docView.compositionDeco.size) {
      view.observer.flush();
      forceClearComposition(view, true);
    }
  }
};
handlers.compositionend = (view) => {
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionFirstChange = null;
  setTimeout(() => {
    if (view.inputState.composing < 0)
      forceClearComposition(view, false);
  }, 50);
};
handlers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
  var _a;
  let pending;
  if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;
      setTimeout(() => {
        var _a2;
        if ((((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
};
const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class HeightOracle {
  constructor() {
    this.doc = Text.empty;
    this.lineWrapping = false;
    this.direction = Direction.LTR;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.lineLength = 30;
    this.heightChanged = false;
  }
  heightForGap(from, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping)
      lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForStyle(whiteSpace, direction) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping || this.direction != direction;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i = 0; i < lineHeights.length; i++) {
      let h = lineHeights[i];
      if (h < 0) {
        i++;
      } else if (!this.heightSamples[Math.floor(h * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping || this.direction != direction;
    this.lineWrapping = lineWrapping;
    this.direction = direction;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i = 0; i < knownHeights.length; i++) {
        let h = knownHeights[i];
        if (h < 0)
          i++;
        else
          this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return changed;
  }
}
class MeasuredHeights {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class BlockInfo {
  constructor(from, length, top2, height, type) {
    this.from = from;
    this.length = length;
    this.top = top2;
    this.height = height;
    this.type = type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  join(other) {
    let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
  }
  moveY(offset) {
    return !offset ? this : new BlockInfo(this.from, this.length, this.top + offset, this.height, Array.isArray(this.type) ? this.type.map((b) => b.moveY(offset)) : this.type);
  }
}
var QueryType$1 = /* @__PURE__ */ function(QueryType2) {
  QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
  QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
  QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType2;
}(QueryType$1 || (QueryType$1 = {}));
const Epsilon = 1e-3;
class HeightMap {
  constructor(length, height, flags = 2) {
    this.length = length;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(oracle, height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        oracle.heightChanged = true;
      this.height = height;
    }
  }
  replace(_from, _to, nodes) {
    return HeightMap.of(nodes);
  }
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this;
    for (let i = changes.length - 1; i >= 0; i--) {
      let { fromA, toA, fromB, toB } = changes[i];
      let start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oldDoc, 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType$1.ByPosNoHeight, oldDoc, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i > 0 && start.from <= changes[i - 1].toA) {
        fromA = changes[i - 1].fromA;
        fromB = changes[i - 1].fromB;
        i--;
        if (fromA < start.from)
          start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oldDoc, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle, decorations2, fromB, toB);
      me = me.replace(fromA, toA, nodes);
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i = 0, j = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i == j) {
        if (before > after * 2) {
          let split = nodes[i - 1];
          if (split.break)
            nodes.splice(--i, 1, split.left, null, split.right);
          else
            nodes.splice(--i, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break)
            nodes.splice(j, 1, split.left, null, split.right);
          else
            nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i++];
        if (next)
          before += next.size;
      } else {
        let next = nodes[--j];
        if (next)
          after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i - 1] == null) {
      brk = 1;
      i--;
    } else if (nodes[i] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
  }
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
  constructor(length, height, type) {
    super(length, height);
    this.type = type;
  }
  blockAt(_height, _doc, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.type);
  }
  lineAt(_value, _type, doc2, top2, offset) {
    return this.blockAt(0, doc2, top2, offset);
  }
  forEachLine(_from, _to, doc2, top2, offset, f) {
    f(this.blockAt(0, doc2, top2, offset));
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class HeightMapText extends HeightMapBlock {
  constructor(length, height) {
    super(length, height, BlockType.Text);
    this.collapsed = 0;
    this.widgetHeight = 0;
  }
  replace(_from, _to, nodes) {
    let node = nodes[0];
    if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
      if (node instanceof HeightMapGap)
        node = new HeightMapText(node.length, this.height);
      else
        node.height = this.height;
      if (!this.outdated)
        node.outdated = false;
      return node;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    else if (force || this.outdated)
      this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  lines(doc2, offset) {
    let firstLine = doc2.lineAt(offset).number, lastLine = doc2.lineAt(offset + this.length).number;
    return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };
  }
  blockAt(height, doc2, top2, offset) {
    let { firstLine, lastLine, lineHeight } = this.lines(doc2, offset);
    let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / lineHeight)));
    let { from, length } = doc2.line(firstLine + line);
    return new BlockInfo(from, length, top2 + lineHeight * line, lineHeight, BlockType.Text);
  }
  lineAt(value, type, doc2, top2, offset) {
    if (type == QueryType$1.ByHeight)
      return this.blockAt(value, doc2, top2, offset);
    if (type == QueryType$1.ByPosNoHeight) {
      let { from: from2, to } = doc2.lineAt(value);
      return new BlockInfo(from2, to - from2, 0, 0, BlockType.Text);
    }
    let { firstLine, lineHeight } = this.lines(doc2, offset);
    let { from, length, number: number2 } = doc2.lineAt(value);
    return new BlockInfo(from, length, top2 + lineHeight * (number2 - firstLine), lineHeight, BlockType.Text);
  }
  forEachLine(from, to, doc2, top2, offset, f) {
    let { firstLine, lineHeight } = this.lines(doc2, offset);
    for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end; ) {
      let line = doc2.lineAt(pos);
      if (pos == from)
        top2 += lineHeight * (line.number - firstLine);
      f(new BlockInfo(line.from, line.length, top2, lineHeight, BlockType.Text));
      top2 += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to, nodes) {
    let after = this.length - to;
    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof HeightMapGap)
        nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
      else
        nodes.push(null, new HeightMapGap(after - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof HeightMapGap)
        nodes[0] = new HeightMapGap(from + first.length);
      else
        nodes.unshift(new HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to, result) {
    result.push(new HeightMapGap(to - 1), null);
  }
  decomposeRight(from, result) {
    result.push(null, new HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
      let wasChanged = oracle.heightChanged;
      if (measured.from > offset)
        nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let height = measured.heights[measured.index++];
        if (singleHeight == -1)
          singleHeight = height;
        else if (Math.abs(height - singleHeight) >= Epsilon)
          singleHeight = -2;
        let line = new HeightMapText(len, height);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end)
        nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
      let result = HeightMap.of(nodes);
      oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;
      return result;
    } else if (force || this.outdated) {
      this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class HeightMapBranch extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, doc2, top2, offset) {
    let mid2 = top2 + this.left.height;
    return height < mid2 ? this.left.blockAt(height, doc2, top2, offset) : this.right.blockAt(height, doc2, mid2, offset + this.left.length + this.break);
  }
  lineAt(value, type, doc2, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType$1.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type, doc2, top2, offset) : this.right.lineAt(value, type, doc2, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type == QueryType$1.ByPosNoHeight ? QueryType$1.ByPosNoHeight : QueryType$1.ByPos;
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, doc2, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, doc2, top2, offset).join(base2);
  }
  forEachLine(from, to, doc2, top2, offset, f) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset)
        this.left.forEachLine(from, to, doc2, top2, offset, f);
      if (to >= rightOffset)
        this.right.forEachLine(from, to, doc2, rightTop, rightOffset, f);
    } else {
      let mid2 = this.lineAt(rightOffset, QueryType$1.ByPos, doc2, top2, offset);
      if (from < mid2.from)
        this.left.forEachLine(from, mid2.from - 1, doc2, top2, offset, f);
      if (mid2.to >= from && mid2.from <= to)
        f(mid2);
      if (to > mid2.to)
        this.right.forEachLine(mid2.to + 1, to, doc2, rightTop, rightOffset, f);
    }
  }
  replace(from, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart)
      return this.balanced(this.left.replace(from, to, nodes), this.right);
    if (from > this.left.length)
      return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
    let result = [];
    if (from > 0)
      this.decomposeLeft(from, result);
    let left = result.length;
    for (let node of nodes)
      result.push(node);
    if (from > 0)
      mergeGaps(result, left - 1);
    if (to < this.length) {
      let right = result.length;
      this.decomposeRight(to, result);
      mergeGaps(result, right);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to, result) {
    let left = this.left.length;
    if (to <= left)
      return this.left.decomposeLeft(to, result);
    result.push(this.left);
    if (this.break) {
      left++;
      if (to >= left)
        result.push(null);
    }
    if (to > left)
      this.right.decomposeLeft(to - left, result);
  }
  decomposeRight(from, result) {
    let left = this.left.length, right = left + this.break;
    if (from >= right)
      return this.right.decomposeRight(from - right, result);
    if (from < left)
      this.left.decomposeRight(from, result);
    if (this.break && from < right)
      result.push(null);
    result.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = left;
    this.right = right;
    this.height = left.height + right.height;
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset, force, measured);
    else
      left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else
      right.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText)
        last.length += end - this.pos;
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1));
      this.writtenTo = end;
      if (to > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to;
  }
  point(from, to, deco) {
    if (from < to || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      if (height < 0)
        height = this.oracle.lineHeight;
      let len = to - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco.type));
      } else if (len || height >= relevantWidgetHeight) {
        this.addLineDeco(height, len);
      }
    } else if (to > from) {
      this.span(from, to);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from, to } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from)
      this.nodes.push(new HeightMapText(this.pos - from, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from, to) {
    let gap2 = new HeightMapGap(to - from);
    if (this.oracle.doc.lineAt(from).to == to)
      gap2.flags |= 4;
    return gap2;
  }
  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText)
      return last;
    let line = new HeightMapText(0, -1);
    this.nodes.push(line);
    return line;
  }
  addBlock(block3) {
    this.enterLine();
    if (block3.type == BlockType.WidgetAfter && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block3);
    this.writtenTo = this.pos = this.pos + block3.length;
    if (block3.type != BlockType.WidgetBefore)
      this.covering = block3;
  }
  addLineDeco(height, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1));
    else if (this.writtenTo < this.pos || last == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (let node of this.nodes) {
      if (node instanceof HeightMapText)
        node.updateHeight(this.oracle, pos);
      pos += node ? node.length : 1;
    }
    return this.nodes;
  }
  static build(oracle, decorations2, from, to) {
    let builder = new NodeBuilder(from, oracle);
    RangeSet.spans(decorations2, from, to, builder, 0);
    return builder.finish(from);
  }
}
function heightRelevantDecoChanges(a, b, diff) {
  let comp2 = new DecorationComparator();
  RangeSet.compare(a, b, diff, comp2, 0);
  return comp2.changes;
}
class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from, to, a, b) {
    if (from < to || a && a.heightRelevant || b && b.heightRelevant)
      addRange(from, to, this.changes, 5);
  }
}
function visiblePixelRange(dom, paddingTop) {
  let rect2 = dom.getBoundingClientRect();
  let left = Math.max(0, rect2.left), right = Math.min(innerWidth, rect2.right);
  let top2 = Math.max(0, rect2.top), bottom2 = Math.min(innerHeight, rect2.bottom);
  let body = dom.ownerDocument.body;
  for (let parent = dom.parentNode; parent && parent != body; ) {
    if (parent.nodeType == 1) {
      let elt2 = parent;
      let style = window.getComputedStyle(elt2);
      if ((elt2.scrollHeight > elt2.clientHeight || elt2.scrollWidth > elt2.clientWidth) && style.overflow != "visible") {
        let parentRect = elt2.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom2 = Math.min(bottom2, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? elt2.offsetParent : elt2.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect2.left,
    right: Math.max(left, right) - rect2.left,
    top: top2 - (rect2.top + paddingTop),
    bottom: Math.max(top2, bottom2) - (rect2.top + paddingTop)
  };
}
class LineGap {
  constructor(from, to, size) {
    this.from = from;
    this.to = to;
    this.size = size;
  }
  static same(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      let gA = a[i], gB = b[i];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(wrapping) {
    return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);
  }
}
class LineGapWidget extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt2 = document.createElement("div");
    if (this.vertical) {
      elt2.style.height = this.size + "px";
    } else {
      elt2.style.width = this.size + "px";
      elt2.style.height = "2px";
      elt2.style.display = "inline-block";
    }
    return elt2;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class ViewState {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.heightOracle = new HeightOracle();
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    this.heightMap = HeightMap.empty().applyChanges(state.facet(decorations), Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    this.viewport = this.getViewport(0, null);
    this.updateViewportLines();
    this.updateForViewport();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap2) => gap2.draw(false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let pos = i ? main.head : main.anchor;
      if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
        let { from, to } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from, to));
      }
    }
    this.viewports = viewports.sort((a, b) => a.from - b.from);
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (block3) => {
      this.viewportLines.push(this.scaler.scale == 1 ? block3 : scaleBlock(block3, this.scaler));
    });
  }
  update(update, scrollTarget = null) {
    let prev = this.state;
    this.state = update.state;
    let newDeco = this.state.facet(decorations);
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(update.startState.facet(decorations), newDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight)
      update.flags |= 2;
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTarget);
    let updateLines = !update.changes.empty || update.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    this.updateForViewport();
    if (updateLines)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges();
    if (scrollTarget)
      this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc)
      this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style.whiteSpace, direction = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForStyle(whiteSpace, direction);
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;
    let result = 0, bias = 0;
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping)
        measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result |= 8;
    }
    if (measureContent) {
      this.mustMeasureContent = false;
      this.contentDOMHeight = dom.clientHeight;
      let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        result |= 8;
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
      }
    }
    let pixelViewport = this.printing ? { top: -1e8, bottom: 1e8, left: -1e8, right: 1e8 } : visiblePixelRange(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView)
        measureContent = true;
    }
    if (!this.inView)
      return 0;
    let contentWidth = dom.clientWidth;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = contentWidth;
      this.editorHeight = view.scrollDOM.clientHeight;
      result |= 8;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights();
      if (oracle.mustRefreshForHeights(lineHeights))
        refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let { lineHeight, charWidth } = view.docView.measureTextSize();
        refresh = oracle.refresh(whiteSpace, direction, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result |= 8;
        }
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
      oracle.heightChanged = false;
      this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));
      if (oracle.heightChanged)
        result |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange)
      this.viewport = this.getViewport(bias, this.scrollTarget);
    this.updateForViewport();
    if (result & 2 || viewportChange)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));
    result |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map2 = this.heightMap, doc2 = this.state.doc, { visibleTop, visibleBottom } = this;
    let viewport = new Viewport(map2.lineAt(visibleTop - marginTop * 1e3, QueryType$1.ByHeight, doc2, 0, 0).from, map2.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType$1.ByHeight, doc2, 0, 0).to);
    if (scrollTarget) {
      let { head } = scrollTarget.range;
      if (head < viewport.from || head > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block3 = map2.lineAt(head, QueryType$1.ByPos, doc2, 0, 0), topPos;
        if (scrollTarget.y == "center")
          topPos = (block3.top + block3.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
          topPos = block3.top;
        else
          topPos = block3.bottom - viewHeight;
        viewport = new Viewport(map2.lineAt(topPos - 1e3 / 2, QueryType$1.ByHeight, doc2, 0, 0).from, map2.lineAt(topPos + viewHeight + 1e3 / 2, QueryType$1.ByHeight, doc2, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType$1.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType$1.ByPos, this.state.doc, 0, 0).to);
  }
  viewportIsAppropriate({ from, to }, bias = 0) {
    if (!this.inView)
      return true;
    let { top: top2 } = this.heightMap.lineAt(from, QueryType$1.ByPos, this.state.doc, 0, 0);
    let { bottom: bottom2 } = this.heightMap.lineAt(to, QueryType$1.ByPos, this.state.doc, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom2 >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top2 > visibleTop - 2 * 1e3 && bottom2 < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap2 of gaps)
      if (!changes.touchesRange(gap2.from, gap2.to))
        mapped.push(new LineGap(changes.mapPos(gap2.from), changes.mapPos(gap2.to), gap2.size));
    return mapped;
  }
  ensureLineGaps(current) {
    let gaps = [];
    if (this.heightOracle.direction != Direction.LTR)
      return gaps;
    for (let line of this.viewportLines) {
      if (line.length < 4e3)
        continue;
      let structure = lineStructure(line.from, line.to, this.state);
      if (structure.total < 4e3)
        continue;
      let viewFrom, viewTo;
      if (this.heightOracle.lineWrapping) {
        let marginHeight = 2e3 / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        viewFrom = findPosition(structure, (this.visibleTop - line.top - marginHeight) / line.height);
        viewTo = findPosition(structure, (this.visibleBottom - line.top + marginHeight) / line.height);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = 2e3 * this.heightOracle.charWidth;
        viewFrom = findPosition(structure, (this.pixelViewport.left - marginWidth) / totalWidth);
        viewTo = findPosition(structure, (this.pixelViewport.right + marginWidth) / totalWidth);
      }
      let outside = [];
      if (viewFrom > line.from)
        outside.push({ from: line.from, to: viewFrom });
      if (viewTo < line.to)
        outside.push({ from: viewTo, to: line.to });
      let sel = this.state.selection.main;
      if (sel.from >= line.from && sel.from <= line.to)
        cutRange(outside, sel.from - 10, sel.from + 10);
      if (!sel.empty && sel.to >= line.from && sel.to <= line.to)
        cutRange(outside, sel.to - 10, sel.to + 10);
      for (let { from, to } of outside)
        if (to - from > 1e3) {
          gaps.push(find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < 1e3 && Math.abs(gap2.to - to) < 1e3) || new LineGap(from, to, this.gapSize(line, from, to, structure)));
        }
    }
    return gaps;
  }
  gapSize(line, from, to, structure) {
    let fraction = findFraction(structure, to) - findFraction(structure, from);
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap2) => gap2.draw(this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges() {
    let deco = this.state.facet(decorations);
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to) {
        ranges.push({ from, to });
      },
      point() {
      }
    }, 20);
    let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
    this.visibleRanges = ranges;
    return changed ? 4 : 0;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType$1.ByPos, this.state.doc, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType$1.ByHeight, this.state.doc, 0, 0), this.scaler);
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Viewport {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
}
function lineStructure(from, to, state) {
  let ranges = [], pos = from, total = 0;
  RangeSet.spans(state.facet(decorations), from, to, {
    span() {
    },
    point(from2, to2) {
      if (from2 > pos) {
        ranges.push({ from: pos, to: from2 });
        total += from2 - pos;
      }
      pos = to2;
    }
  }, 20);
  if (pos < to) {
    ranges.push({ from: pos, to });
    total += to - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio2) {
  if (ratio2 <= 0)
    return ranges[0].from;
  if (ratio2 >= 1)
    return ranges[ranges.length - 1].to;
  let dist = Math.floor(total * ratio2);
  for (let i = 0; ; i++) {
    let { from, to } = ranges[i], size = to - from;
    if (dist <= size)
      return from + dist;
    dist -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from, to } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from;
      break;
    }
    counted += to - from;
  }
  return counted / structure.total;
}
function cutRange(ranges, from, to) {
  for (let i = 0; i < ranges.length; i++) {
    let r = ranges[i];
    if (r.from < to && r.to > from) {
      let pieces = [];
      if (r.from < from)
        pieces.push({ from: r.from, to: from });
      if (r.to > to)
        pieces.push({ from: to, to: r.to });
      ranges.splice(i, 1, ...pieces);
      i += pieces.length - 1;
    }
  }
}
function find(array, f) {
  for (let val of array)
    if (f(val))
      return val;
  return void 0;
}
const IdScaler = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1
};
class BigScaler {
  constructor(doc2, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from, to }) => {
      let top2 = heightMap.lineAt(from, QueryType$1.ByPos, doc2, 0, 0).top;
      let bottom2 = heightMap.lineAt(to, QueryType$1.ByPos, doc2, 0, 0).bottom;
      vpHeight += bottom2 - top2;
      return { from, to, top: top2, bottom: bottom2, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.top)
        return domBase + (n - base2) * this.scale;
      if (n <= vp.bottom)
        return vp.domTop + (n - vp.top);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.domTop)
        return base2 + (n - domBase) / this.scale;
      if (n <= vp.domBottom)
        return vp.top + (n - vp.domTop);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
}
function scaleBlock(block3, scaler) {
  if (scaler.scale == 1)
    return block3;
  let bTop = scaler.toDOM(block3.top), bBottom = scaler.toDOM(block3.bottom);
  return new BlockInfo(block3.from, block3.length, bTop, bBottom - bTop, Array.isArray(block3.type) ? block3.type.map((b) => scaleBlock(b, scaler)) : block3.type);
}
const theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
const darkTheme = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.indexOf(true) > -1 });
const baseThemeID = /* @__PURE__ */ StyleModule.newName(), baseLightID = /* @__PURE__ */ StyleModule.newName(), baseDarkID = /* @__PURE__ */ StyleModule.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
        if (m == "&")
          return main;
        if (!scopes || !scopes[m])
          throw new RangeError(`Unsupported selector: ${m}`);
        return scopes[m];
      }) : main + " " + sel;
    }
  });
}
const baseTheme$9 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
  "&.cm-editor": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    minHeight: "100%",
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere"
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 4px"
  },
  ".cm-selectionLayer": {
    zIndex: -1,
    contain: "size style"
  },
  ".cm-selectionBackground": {
    position: "absolute"
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    zIndex: 100,
    contain: "size style",
    pointerEvents: "none"
  },
  "&.cm-focused .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  "@keyframes cm-blink": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    position: "absolute",
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  "&.cm-focused .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#f3f9ff" },
  "&dark .cm-activeLine": { backgroundColor: "#223039" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-bottom",
    height: "1em"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
const observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
  constructor(view, onChange, onScrollChanged) {
    this.view = view;
    this.onChange = onChange;
    this.onScrollChanged = onScrollChanged;
    this.active = false;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.scrollTargets = [];
    this.intersection = null;
    this.resize = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData)
      this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    if (typeof ResizeObserver == "function") {
      this.resize = new ResizeObserver(() => {
        if (this.view.docView.lastUpdate < Date.now() - 75 && this.resizeTimeout < 0)
          this.resizeTimeout = setTimeout(() => {
            this.resizeTimeout = -1;
            this.view.requestMeasure();
          }, 50);
      });
      this.resize.observe(view.scrollDOM);
    }
    this.start();
    this.onScroll = this.onScroll.bind(this);
    window.addEventListener("scroll", this.onScroll);
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, {});
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries) => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
    this.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  onScroll(e) {
    if (this.intersecting)
      this.flush(false);
    this.onScrollChanged(e);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
      this.gapIntersection.disconnect();
      for (let gap2 of gaps)
        this.gapIntersection.observe(gap2);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event) {
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event))
      return;
    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush(false);
  }
  readSelectionRange() {
    let { root } = this.view, domSel = getSelection(root);
    let range2 = browser.safari && root.nodeType == 11 && deepActiveElement() == this.view.contentDOM && safariSelectionRangeHack(this.view) || domSel;
    if (this.selectionRange.eq(range2))
      return false;
    this.selectionRange.setRange(range2);
    return this.selectionChanged = true;
  }
  setSelectionRange(anchor, head) {
    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
    this.selectionChanged = false;
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
          i++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f) {
    if (!this.active)
      return f();
    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  delayAndroidKey(key, keyCode) {
    if (!this.delayedAndroidKey)
      requestAnimationFrame(() => {
        let key2 = this.delayedAndroidKey;
        this.delayedAndroidKey = null;
        let startState = this.view.state;
        if (dispatchKey(this.view.contentDOM, key2.key, key2.keyCode))
          this.processRecords();
        else
          this.flush();
        if (this.view.state == startState)
          this.view.update([]);
      });
    if (!this.delayedAndroidKey || key == "Enter")
      this.delayedAndroidKey = { key, keyCode };
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = window.setTimeout(() => {
        this.delayedFlush = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      window.clearTimeout(this.delayedFlush);
      this.delayedFlush = -1;
      this.flush();
    }
  }
  processRecords() {
    let records = this.queue;
    for (let mut of this.observer.takeRecords())
      records.push(mut);
    if (records.length)
      this.queue = [];
    let from = -1, to = -1, typeOver = false;
    for (let record of records) {
      let range2 = this.readMutation(record);
      if (!range2)
        continue;
      if (range2.typeOver)
        typeOver = true;
      if (from == -1) {
        ({ from, to } = range2);
      } else {
        from = Math.min(range2.from, from);
        to = Math.max(range2.to, to);
      }
    }
    return { from, to, typeOver };
  }
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return;
    if (readSelection)
      this.readSelectionRange();
    let { from, to, typeOver } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from < 0 && !newSel)
      return;
    this.selectionChanged = false;
    let startState = this.view.state;
    this.onChange(from, to, typeOver);
    if (this.view.state == startState)
      this.view.update([]);
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec))
      return null;
    cView.markDirty(rec.type == "attributes");
    if (rec.type == "attributes")
      cView.dirty |= 4;
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    } else {
      return null;
    }
  }
  destroy() {
    var _a, _b, _c;
    this.stop();
    (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.resize) === null || _c === void 0 ? void 0 : _c.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    window.removeEventListener("scroll", this.onScroll);
    this.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
  }
}
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView)
      return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function safariSelectionRangeHack(view) {
  let found = null;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  if (!found)
    return null;
  let anchorNode = found.startContainer, anchorOffset = found.startOffset;
  let focusNode = found.endContainer, focusOffset = found.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function applyDOMChange(view, start, end, typeOver) {
  let change, newSel;
  let sel = view.state.selection.main;
  if (start > -1) {
    let bounds = view.docView.domBoundsAround(start, end, 0);
    if (!bounds || view.state.readOnly)
      return;
    let { from, to } = bounds;
    let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view);
    let reader = new DOMReader(selPoints, view.state);
    reader.readRange(bounds.startDOM, bounds.endDOM);
    let preferredPos = sel.from, preferredSide = null;
    if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && reader.text.length < to - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), reader.text, preferredPos - from, preferredSide);
    if (diff) {
      if (browser.chrome && view.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && reader.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff.toB--;
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: Text.of(reader.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
    newSel = selectionFromPoints(selPoints, from);
  } else if (view.hasFocus || !view.state.facet(editable)) {
    let domSel = view.observer.selectionRange;
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
    let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (head != sel.head || anchor != sel.anchor)
      newSel = EditorSelection.single(anchor, head);
  }
  if (!change && !newSel)
    return;
  if (!change && typeOver && !sel.empty && newSel && newSel.main.empty)
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4)
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  if (change) {
    let startState = view.state;
    if (browser.ios && view.inputState.flushIOSKey(view))
      return;
    if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
      return;
    let text3 = change.insert.toString();
    if (view.state.facet(inputHandler$1).some((h) => h(view, change.from, change.to, text3)))
      return;
    if (view.inputState.composing >= 0)
      view.inputState.composing++;
    let tr;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
      let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
      let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
      tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
    } else {
      let changes = startState.changes(change);
      let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : void 0;
      if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
        let replaced = view.state.sliceDoc(change.from, change.to);
        let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);
        let offset = sel.to - change.to, size = sel.to - sel.from;
        tr = startState.changeByRange((range2) => {
          if (range2.from == sel.from && range2.to == sel.to)
            return { changes, range: mainSel || range2.map(changes) };
          let to = range2.to - offset, from = to - replaced.length;
          if (range2.to - range2.from != size || view.state.sliceDoc(from, to) != replaced || compositionRange && range2.to >= compositionRange.from && range2.from <= compositionRange.to)
            return { range: range2 };
          let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range2.to - sel.to;
          return {
            changes: rangeChanges,
            range: !mainSel ? range2.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
          };
        });
      } else {
        tr = {
          changes,
          selection: mainSel && startState.selection.replaceRange(mainSel)
        };
      }
    }
    let userEvent = "input.type";
    if (view.composing) {
      userEvent += ".compose";
      if (view.inputState.compositionFirstChange) {
        userEvent += ".start";
        view.inputState.compositionFirstChange = false;
      }
    }
    view.dispatch(tr, { scrollIntoView: true, userEvent });
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView2 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView2 = true;
      userEvent = view.inputState.lastSelectionOrigin;
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
  }
}
function findDiff(a, b, preferredPos, preferredSide) {
  let minLen = Math.min(a.length, b.length);
  let from = 0;
  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
    from++;
  if (from == minLen && a.length == b.length)
    return null;
  let toA = a.length, toB = b.length;
  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a.length < b.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move;
    toA = from + (toA - toB);
    toB = from;
  }
  return { from, toA, toB };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
class EditorView {
  constructor(config2 = {}) {
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.style.cssText = "position: absolute; top: -10000px";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    this._dispatch = config2.dispatch || ((tr) => this.update([tr]));
    this.dispatch = this.dispatch.bind(this);
    this.root = config2.root || getRoot(config2.parent) || document;
    this.viewState = new ViewState(config2.state || EditorState.create());
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin of this.plugins)
      plugin.update(this);
    this.observer = new DOMObserver(this, (from, to, typeOver) => {
      applyDOMChange(this, from, to, typeOver);
    }, (event) => {
      this.inputState.runScrollHandlers(this, event);
      if (this.observer.intersecting)
        this.measure();
    });
    this.inputState = new InputState(this);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    ensureGlobalHandler();
    this.requestMeasure();
    if (config2.parent)
      config2.parent.appendChild(this.dom);
  }
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  dispatch(...input) {
    this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
  }
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, update;
    let state = this.state;
    for (let tr of transactions) {
      if (tr.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = new ViewUpdate(this, state, transactions);
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr of transactions) {
        if (scrollTarget)
          scrollTarget = scrollTarget.map(tr.changes);
        if (tr.scrollIntoView) {
          let { main } = tr.state.selection;
          scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
        }
        for (let e of tr.effects) {
          if (e.is(scrollTo))
            scrollTarget = new ScrollTarget(e.value);
          else if (e.is(centerOn))
            scrollTarget = new ScrollTarget(e.value, "center");
          else if (e.is(scrollIntoView$1))
            scrollTarget = e.value;
        }
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme) != update.state.facet(theme))
      this.viewState.mustMeasureContent = true;
    if (redrawn || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
      this.requestMeasure();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener))
        listener(update);
  }
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin of this.plugins)
        plugin.update(this);
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus)
      this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin = this.plugins[found];
          plugin.mustUpdate = update;
          newPlugins.push(plugin);
        }
      }
      for (let plugin of this.plugins)
        if (plugin.mustUpdate != update)
          plugin.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
      this.inputState.ensureHandlers(this);
    } else {
      for (let p of this.plugins)
        p.mustUpdate = update;
    }
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
  }
  measure(flush = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1)
      cancelAnimationFrame(this.measureScheduled);
    this.measureScheduled = 0;
    if (flush)
      this.observer.flush();
    let updated = null;
    try {
      for (let i = 0; ; i++) {
        this.updateState = 1;
        let oldViewport = this.viewport;
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4))
          [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m) => {
          try {
            return m.read(this);
          } catch (e) {
            logException(this.state, e);
            return BadMeasure;
          }
        });
        let update = new ViewUpdate(this, this.state), redrawn = false, scrolled = false;
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
        }
        for (let i2 = 0; i2 < measuring.length; i2++)
          if (measured[i2] != BadMeasure) {
            try {
              let m = measuring[i2];
              if (m.write)
                m.write(measured[i2], this);
            } catch (e) {
              logException(this.state, e);
            }
          }
        if (this.viewState.scrollTarget) {
          this.docView.scrollIntoView(this.viewState.scrollTarget);
          this.viewState.scrollTarget = null;
          scrolled = true;
        }
        if (redrawn)
          this.docView.updateSelection(true);
        if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0)
          break;
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly)
      contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    this.observer.ignore(() => {
      updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      updateAttrs(this.dom, this.editorAttrs, editorAttrs);
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr of trs)
      for (let effect of tr.effects)
        if (effect.is(EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div2 = this.announceDOM.appendChild(document.createElement("div"));
          div2.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$9).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = requestAnimationFrame(() => this.measure());
    if (request) {
      if (request.key != null)
        for (let i = 0; i < this.measureRequests.length; i++) {
          if (this.measureRequests[i].key === request.key) {
            this.measureRequests[i] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  pluginField(field) {
    let result = [];
    for (let plugin of this.plugins)
      plugin.update(this).takeField(field, result);
    return result;
  }
  plugin(plugin) {
    let known = this.pluginMap.get(plugin);
    if (known === void 0 || known && known.spec != plugin)
      this.pluginMap.set(plugin, known = this.plugins.find((p) => p.spec == plugin) || null);
    return known && known.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  blockAtHeight(height, docTop) {
    let top2 = ensureTop(docTop, this);
    return this.elementAtHeight(height - top2).moveY(top2);
  }
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  visualLineAtHeight(height, docTop) {
    let top2 = ensureTop(docTop, this);
    return this.lineBlockAtHeight(height - top2).moveY(top2);
  }
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  viewportLines(f, docTop) {
    let top2 = ensureTop(docTop, this);
    for (let line of this.viewportLineBlocks)
      f(line.moveY(top2));
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  visualLineAt(pos, docTop = 0) {
    return this.lineBlockAt(pos).moveY(docTop + this.viewState.paddingTop);
  }
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by));
  }
  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
  }
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  scrollPosIntoView(pos) {
    this.dispatch({ effects: scrollTo.of(EditorSelection.cursor(pos)) });
  }
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  posAtDOM(node, offset = 0) {
    return this.docView.posFromDOM(node, offset);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect2 = this.docView.coordsAt(pos, side);
    if (!rect2 || rect2.left == rect2.right)
      return rect2;
    let line = this.state.doc.lineAt(pos), order2 = this.bidiSpans(line);
    let span2 = order2[BidiSpan.find(order2, pos - line.from, -1, side)];
    return flattenRect(rect2, span2.dir == Direction.LTR == side > 0);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.heightOracle.direction;
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(line) {
    if (line.length > MaxBidiLine)
      return trivialOrder(line.length);
    let dir = this.textDirection;
    for (let entry of this.bidiCache)
      if (entry.from == line.from && entry.dir == dir)
        return entry.order;
    let order2 = computeOrder(line.text, this.textDirection);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order2));
    return order2;
  }
  get hasFocus() {
    var _a;
    return (document.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  destroy() {
    for (let plugin of this.plugins)
      plugin.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  static scrollIntoView(pos, options = {}) {
    return scrollIntoView$1.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
  }
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  static theme(spec, options) {
    let prefix = StyleModule.newName();
    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
}
EditorView.scrollTo = scrollTo;
EditorView.centerOn = centerOn;
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler$1;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.darkTheme = darkTheme;
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = /* @__PURE__ */ StateEffect.define();
const MaxBidiLine = 4096;
function ensureTop(given, view) {
  return (given == null ? view.contentDOM.getBoundingClientRect().top : given) + view.viewState.paddingTop;
}
let resizeDebounce = -1;
function ensureGlobalHandler() {
  window.addEventListener("resize", () => {
    if (resizeDebounce == -1)
      resizeDebounce = setTimeout(handleResize, 50);
  });
}
function handleResize() {
  resizeDebounce = -1;
  let found = document.querySelectorAll(".cm-content");
  for (let i = 0; i < found.length; i++) {
    let docView = ContentView.get(found[i]);
    if (docView)
      docView.editorView.requestMeasure();
  }
}
const BadMeasure = {};
class CachedOrder {
  constructor(from, to, dir, order2) {
    this.from = from;
    this.to = to;
    this.dir = dir;
    this.order = order2;
  }
  static update(cache, changes) {
    if (changes.empty)
      return cache;
    let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
    for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
      let entry = cache[i];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
    }
    return result;
  }
}
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
    let source = sources[i], value = typeof source == "function" ? source(view) : source;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name2, platform) {
  const parts = name2.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta2;
  for (let i = 0; i < parts.length - 1; ++i) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta2 = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform == "mac")
        meta2 = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta2)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function modifiers(name2, event, shift2) {
  if (event.altKey)
    name2 = "Alt-" + name2;
  if (event.ctrlKey)
    name2 = "Ctrl-" + name2;
  if (event.metaKey)
    name2 = "Meta-" + name2;
  if (shift2 !== false && event.shiftKey)
    name2 = "Shift-" + name2;
  return name2;
}
const handleKeyEvents = /* @__PURE__ */ EditorView.domEventHandlers({
  keydown(event, view) {
    return runHandlers(getKeymap(view.state), event, view, "editor");
  }
});
const keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
const Keymaps = /* @__PURE__ */ new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map2 = Keymaps.get(bindings);
  if (!map2)
    Keymaps.set(bindings, map2 = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
  return map2;
}
function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope);
}
let storedPrefix = null;
const PrefixTimeout = 4e3;
function buildKeymap(bindings, platform = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null);
  let isPrefix = /* @__PURE__ */ Object.create(null);
  let checkPrefix = (name2, is) => {
    let current = isPrefix[name2];
    if (current == null)
      isPrefix[name2] = is;
    else if (current != is)
      throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add3 = (scope, key, command2, preventDefault) => {
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
    let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
    for (let i = 1; i < parts.length; i++) {
      let prefix = parts.slice(0, i).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix])
        scopeObj[prefix] = {
          preventDefault: true,
          commands: [(view) => {
            let ourObj = storedPrefix = { view, prefix, scope };
            setTimeout(() => {
              if (storedPrefix == ourObj)
                storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, commands: [] });
    binding.commands.push(command2);
    if (preventDefault)
      binding.preventDefault = true;
  };
  for (let b of bindings) {
    let name2 = b[platform] || b.key;
    if (!name2)
      continue;
    for (let scope of b.scope ? b.scope.split(" ") : ["editor"]) {
      add3(scope, name2, b.run, b.preventDefault);
      if (b.shift)
        add3(scope, "Shift-" + name2, b.shift, b.preventDefault);
    }
  }
  return bound;
}
function runHandlers(map2, event, view, scope) {
  let name2 = keyName(event), isChar = name2.length == 1 && name2 != " ";
  let prefix = "", fallthrough = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
      storedPrefix = null;
  }
  let runFor = (binding) => {
    if (binding) {
      for (let cmd2 of binding.commands)
        if (cmd2(view))
          return true;
      if (binding.preventDefault)
        fallthrough = true;
    }
    return false;
  };
  let scopeObj = map2[scope], baseName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)]))
      return true;
    if (isChar && (event.shiftKey || event.altKey || event.metaKey) && (baseName = base[event.keyCode]) && baseName != name2) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))
        return true;
    } else if (isChar && event.shiftKey) {
      if (runFor(scopeObj[prefix + modifiers(name2, event, true)]))
        return true;
    }
  }
  return fallthrough;
}
const CanHidePrimary = !browser.ios;
const selectionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a, b) => Math.min(a, b),
      drawRangeCursor: (a, b) => a || b
    });
  }
});
function drawSelection(config2 = {}) {
  return [
    selectionConfig.of(config2),
    drawSelectionPlugin,
    hideNativeSelection
  ];
}
class Piece {
  constructor(left, top2, width, height, className) {
    this.left = left;
    this.top = top2;
    this.width = width;
    this.height = height;
    this.className = className;
  }
  draw() {
    let elt2 = document.createElement("div");
    elt2.className = this.className;
    this.adjust(elt2);
    return elt2;
  }
  adjust(elt2) {
    elt2.style.left = this.left + "px";
    elt2.style.top = this.top + "px";
    if (this.width >= 0)
      elt2.style.width = this.width + "px";
    elt2.style.height = this.height + "px";
  }
  eq(p) {
    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
  }
}
const drawSelectionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.rangePieces = [];
    this.cursors = [];
    this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };
    this.selectionLayer = view.scrollDOM.appendChild(document.createElement("div"));
    this.selectionLayer.className = "cm-selectionLayer";
    this.selectionLayer.setAttribute("aria-hidden", "true");
    this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
    this.cursorLayer.className = "cm-cursorLayer";
    this.cursorLayer.setAttribute("aria-hidden", "true");
    view.requestMeasure(this.measureReq);
    this.setBlinkRate();
  }
  setBlinkRate() {
    this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + "ms";
  }
  update(update) {
    let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
    if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged)
      this.view.requestMeasure(this.measureReq);
    if (update.transactions.some((tr) => tr.scrollIntoView))
      this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    if (confChanged)
      this.setBlinkRate();
  }
  readPos() {
    let { state } = this.view, conf = state.facet(selectionConfig);
    let rangePieces = state.selection.ranges.map((r) => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));
    let cursors = [];
    for (let r of state.selection.ranges) {
      let prim = r == state.selection.main;
      if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
        let piece = measureCursor(this.view, r, prim);
        if (piece)
          cursors.push(piece);
      }
    }
    return { rangePieces, cursors };
  }
  drawSel({ rangePieces, cursors }) {
    if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {
      this.selectionLayer.textContent = "";
      for (let p of rangePieces)
        this.selectionLayer.appendChild(p.draw());
      this.rangePieces = rangePieces;
    }
    if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {
      let oldCursors = this.cursorLayer.children;
      if (oldCursors.length !== cursors.length) {
        this.cursorLayer.textContent = "";
        for (const c of cursors)
          this.cursorLayer.appendChild(c.draw());
      } else {
        cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
      }
      this.cursors = cursors;
    }
  }
  destroy() {
    this.selectionLayer.remove();
    this.cursorLayer.remove();
  }
});
const themeSpec = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
if (CanHidePrimary)
  themeSpec[".cm-line"].caretColor = "transparent !important";
const hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme(themeSpec));
function getBase(view) {
  let rect2 = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect2.left : rect2.right - view.scrollDOM.clientWidth;
  return { left: left - view.scrollDOM.scrollLeft, top: rect2.top - view.scrollDOM.scrollTop };
}
function wrappedLine(view, pos, inside2) {
  let range2 = EditorSelection.cursor(pos);
  return {
    from: Math.max(inside2.from, view.moveToLineBoundary(range2, false, true).from),
    to: Math.min(inside2.to, view.moveToLineBoundary(range2, true, true).from),
    type: BlockType.Text
  };
}
function blockAt(view, pos) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type))
    for (let l of line.type) {
      if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
        return l;
    }
  return line;
}
function measureRange(view, range2) {
  if (range2.to <= view.viewport.from || range2.from >= view.viewport.to)
    return [];
  let from = Math.max(range2.from, view.viewport.from), to = Math.min(range2.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
  let lineStyle = window.getComputedStyle(content2.firstChild);
  let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));
  let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
  let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
  if (view.lineWrapping) {
    if (visualStart)
      visualStart = wrappedLine(view, from, visualStart);
    if (visualEnd)
      visualEnd = wrappedLine(view, to, visualEnd);
  }
  if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
    return pieces(drawForLine(range2.from, range2.to, visualStart));
  } else {
    let top2 = visualStart ? drawForLine(range2.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom2 = visualEnd ? drawForLine(null, range2.to, visualEnd) : drawForWidget(endBlock, true);
    let between2 = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)
      between2.push(piece(leftSide, top2.bottom, rightSide, bottom2.top));
    else if (top2.bottom < bottom2.top && view.elementAtHeight((top2.bottom + bottom2.top) / 2).type == BlockType.Text)
      top2.bottom = bottom2.top = (top2.bottom + bottom2.top) / 2;
    return pieces(top2).concat(between2).concat(pieces(bottom2));
  }
  function piece(left, top2, right, bottom2) {
    return new Piece(left - base2.left, top2 - base2.top - 0.01, right - left, bottom2 - top2 + 0.01, "cm-selectionBackground");
  }
  function pieces({ top: top2, bottom: bottom2, horizontal }) {
    let pieces2 = [];
    for (let i = 0; i < horizontal.length; i += 2)
      pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom2));
    return pieces2;
  }
  function drawForLine(from2, to2, line) {
    let top2 = 1e9, bottom2 = -1e9, horizontal = [];
    function addSpan(from3, fromOpen, to3, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
      top2 = Math.min(fromCoords.top, toCoords.top, top2);
      bottom2 = Math.max(fromCoords.bottom, toCoords.bottom, bottom2);
      if (dir == Direction.LTR)
        horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
      else
        horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
    for (let r of view.visibleRanges)
      if (r.to > start && r.from < end) {
        for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
          let docLine = view.state.doc.lineAt(pos);
          for (let span2 of view.bidiSpans(docLine)) {
            let spanFrom = span2.from + docLine.from, spanTo = span2.to + docLine.from;
            if (spanFrom >= endPos)
              break;
            if (spanTo > pos)
              addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span2.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos)
            break;
        }
      }
    if (horizontal.length == 0)
      addSpan(start, from2 == null, end, to2 == null, view.textDirection);
    return { top: top2, bottom: bottom2, horizontal };
  }
  function drawForWidget(block3, top2) {
    let y = contentRect.top + (top2 ? block3.top : block3.bottom);
    return { top: y, bottom: y, horizontal: [] };
  }
}
function measureCursor(view, cursor2, primary) {
  let pos = view.coordsAtPos(cursor2.head, cursor2.assoc || 1);
  if (!pos)
    return null;
  let base2 = getBase(view);
  return new Piece(pos.left - base2.left, pos.top - base2.top, -1, pos.bottom - pos.top, primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
}
function iterMatches(doc2, re2, from, to, f) {
  re2.lastIndex = 0;
  for (let cursor2 = doc2.iterRange(from, to), pos = from, m; !cursor2.next().done; pos += cursor2.value.length) {
    if (!cursor2.lineBreak)
      while (m = re2.exec(cursor2.value))
        f(pos + m.index, pos + m.index + m[0].length, m);
  }
}
function matchRanges(view, maxLength) {
  let visible = view.visibleRanges;
  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
    return visible;
  let result = [];
  for (let { from, to } of visible) {
    from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
    to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
    if (result.length && result[result.length - 1].to >= from)
      result[result.length - 1].to = to;
    else
      result.push({ from, to });
  }
  return result;
}
class MatchDecorator {
  constructor(config2) {
    let { regexp, decoration, boundary, maxLength = 1e3 } = config2;
    if (!regexp.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    this.getDeco = typeof decoration == "function" ? decoration : () => decoration;
    this.boundary = boundary;
    this.maxLength = maxLength;
  }
  createDeco(view) {
    let build = new RangeSetBuilder();
    for (let { from, to } of matchRanges(view, this.maxLength))
      iterMatches(view.state.doc, this.regexp, from, to, (a, b, m) => build.add(a, b, this.getDeco(m, view, a)));
    return build.finish();
  }
  updateDeco(update, deco) {
    let changeFrom = 1e9, changeTo = -1;
    if (update.docChanged)
      update.changes.iterChanges((_f, _t, from, to) => {
        if (to > update.view.viewport.from && from < update.view.viewport.to) {
          changeFrom = Math.min(from, changeFrom);
          changeTo = Math.max(to, changeTo);
        }
      });
    if (update.viewportChanged || changeTo - changeFrom > 1e3)
      return this.createDeco(update.view);
    if (changeTo > -1)
      return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
    return deco;
  }
  updateRange(view, deco, updateFrom, updateTo) {
    for (let r of view.visibleRanges) {
      let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
      if (to > from) {
        let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
        let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
        if (this.boundary) {
          for (; from > fromLine.from; from--)
            if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
              start = from;
              break;
            }
          for (; to < toLine.to; to++)
            if (this.boundary.test(toLine.text[to - toLine.from])) {
              end = to;
              break;
            }
        }
        let ranges = [], m;
        if (fromLine == toLine) {
          this.regexp.lastIndex = start - fromLine.from;
          while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) {
            let pos = m.index + fromLine.from;
            ranges.push(this.getDeco(m, view, pos).range(pos, pos + m[0].length));
          }
        } else {
          iterMatches(view.state.doc, this.regexp, start, end, (from2, to2, m2) => ranges.push(this.getDeco(m2, view, from2).range(from2, to2)));
        }
        deco = deco.update({ filterFrom: start, filterTo: end, filter: (from2, to2) => from2 < start || to2 > end, add: ranges });
      }
    }
    return deco;
  }
}
const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
const Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
const Names = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let _supportsTabSize = null;
function supportsTabSize() {
  var _a;
  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles = document.body.style;
    _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
  }
  return _supportsTabSize || false;
}
const specialCharConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let config2 = combineConfig(configs, {
      render: null,
      specialChars: Specials,
      addSpecialChars: null
    });
    if (config2.replaceTabs = !supportsTabSize())
      config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
    if (config2.addSpecialChars)
      config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
    return config2;
  }
});
function highlightSpecialChars(config2 = {}) {
  return [specialCharConfig.of(config2), specialCharPlugin()];
}
let _plugin = null;
function specialCharPlugin() {
  return _plugin || (_plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = Decoration.none;
      this.decorationCache = /* @__PURE__ */ Object.create(null);
      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
      this.decorations = this.decorator.createDeco(view);
    }
    makeDecorator(conf) {
      return new MatchDecorator({
        regexp: conf.specialChars,
        decoration: (m, view, pos) => {
          let { doc: doc2 } = view.state;
          let code2 = codePointAt(m[0], 0);
          if (code2 == 9) {
            let line = doc2.lineAt(pos);
            let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
            return Decoration.replace({ widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth) });
          }
          return this.decorationCache[code2] || (this.decorationCache[code2] = Decoration.replace({ widget: new SpecialCharWidget(conf, code2) }));
        },
        boundary: conf.replaceTabs ? void 0 : /[^]/
      });
    }
    update(update) {
      let conf = update.state.facet(specialCharConfig);
      if (update.startState.facet(specialCharConfig) != conf) {
        this.decorator = this.makeDecorator(conf);
        this.decorations = this.decorator.createDeco(update.view);
      } else {
        this.decorations = this.decorator.updateDeco(update, this.decorations);
      }
    }
  }, {
    decorations: (v) => v.decorations
  }));
}
const DefaultPlaceholder = "\u2022";
function placeholder$1(code2) {
  if (code2 >= 32)
    return DefaultPlaceholder;
  if (code2 == 10)
    return "\u2424";
  return String.fromCharCode(9216 + code2);
}
class SpecialCharWidget extends WidgetType {
  constructor(options, code2) {
    super();
    this.options = options;
    this.code = code2;
  }
  eq(other) {
    return other.code == this.code;
  }
  toDOM(view) {
    let ph = placeholder$1(this.code);
    let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
    let custom = this.options.render && this.options.render(this.code, desc, ph);
    if (custom)
      return custom;
    let span2 = document.createElement("span");
    span2.textContent = ph;
    span2.title = desc;
    span2.setAttribute("aria-label", desc);
    span2.className = "cm-specialChar";
    return span2;
  }
  ignoreEvent() {
    return false;
  }
}
class TabWidget extends WidgetType {
  constructor(width) {
    super();
    this.width = width;
  }
  eq(other) {
    return other.width == this.width;
  }
  toDOM() {
    let span2 = document.createElement("span");
    span2.textContent = "	";
    span2.className = "cm-tab";
    span2.style.width = this.width + "px";
    return span2;
  }
  ignoreEvent() {
    return false;
  }
}
function highlightActiveLine() {
  return activeLineHighlighter;
}
const lineDeco = /* @__PURE__ */ Decoration.line({ class: "cm-activeLine" });
const activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.docChanged || update.selectionSet)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let lastLineStart = -1, deco = [];
    for (let r of view.state.selection.ranges) {
      if (!r.empty)
        return Decoration.none;
      let line = view.lineBlockAt(r.head);
      if (line.from > lastLineStart) {
        deco.push(lineDeco.range(line.from));
        lastLineStart = line.from;
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
const fromHistory = /* @__PURE__ */ Annotation.define();
const isolateHistory = /* @__PURE__ */ Annotation.define();
const invertedEffects = /* @__PURE__ */ Facet.define();
const historyConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500
    }, { minDepth: Math.max, newGroupDelay: Math.min });
  }
});
function changeEnd(changes) {
  let end = 0;
  changes.iterChangedRanges((_, to) => end = to);
  return end;
}
const historyField_ = /* @__PURE__ */ StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config2 = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let selection2 = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : void 0;
      let item = HistEvent.fromTransaction(tr, selection2), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config2.minDepth, item);
      else
        other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr);
    let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
    if (event)
      state = state.addChanges(event, time, userEvent, config2.newGroupDelay, config2.minDepth);
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return { done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON()) };
  },
  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
  }
});
function history(config2 = {}) {
  return [
    historyField_,
    historyConfig.of(config2),
    EditorView.domEventHandlers({
      beforeinput(e, view) {
        let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
        if (!command2)
          return false;
        e.preventDefault();
        return command2(view);
      }
    })
  ];
}
function cmd(side, selection2) {
  return function({ state, dispatch }) {
    if (!selection2 && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection2);
    if (!tr)
      return false;
    dispatch(tr);
    return true;
  };
}
const undo = /* @__PURE__ */ cmd(0, false);
const redo = /* @__PURE__ */ cmd(1, false);
const undoSelection = /* @__PURE__ */ cmd(0, true);
const redoSelection = /* @__PURE__ */ cmd(1, true);
class HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a, _b, _c;
    return {
      changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(json) {
    return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
  }
  static fromTransaction(tr, selection2) {
    let effects = none$2;
    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty)
      return null;
    return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection2 || tr.startState.selection, none$2);
  }
  static selection(selections) {
    return new HistEvent(void 0, none$2, void 0, void 0, selections);
  }
}
function updateBranch(branch, to, maxLen, newEvent) {
  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a, b) {
  let ranges = [], isAdjacent2 = false;
  a.iterChangedRanges((f, t2) => ranges.push(f, t2));
  b.iterChangedRanges((_f, _t, f, t2) => {
    for (let i = 0; i < ranges.length; ) {
      let from = ranges[i++], to = ranges[i++];
      if (t2 >= from && f <= to)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a, b) {
  return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
  return !a.length ? b : !b.length ? a : a.concat(b);
}
const none$2 = [];
const MaxSelectionsPerEvent = 200;
function addSelection(branch, selection2) {
  if (!branch.length) {
    return [HistEvent.selection([selection2])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection2))
      return branch;
    sels.push(selection2);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none$2;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none$2;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none$2, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
const joinableUserEvent = /^(input\.type|delete)($|\.)/;
class HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, newGroupDelay, maxLen) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes) || userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none$2));
    } else {
      done = updateBranch(done, done.length, maxLen, event);
    }
    return new HistoryState(done, none$2, time, userEvent);
  }
  addSelection(selection2, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none$2;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection2))
      return this;
    return new HistoryState(addSelection(this.done, selection2), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, selection2) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event = branch[branch.length - 1];
    if (selection2 && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch) }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none$2 : branch.slice(0, branch.length - 1);
      if (event.mapped)
        rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({ side, rest }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
}
HistoryState.empty = /* @__PURE__ */ new HistoryState(none$2, none$2);
const historyKeymap = [
  { key: "Mod-z", run: undo, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
  { key: "Mod-u", run: undoSelection, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
}
class NodeProp {
  constructor(config2 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config2.perNode;
    this.deserialize = config2.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  add(match2) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match2 != "function")
      match2 = NodeType.match(match2);
    return (type) => {
      let result = match2(type);
      return result === void 0 ? null : [this, result];
    };
  }
}
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
class MountedTree {
  constructor(tree, overlay, parser2) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser2;
  }
}
const noProps = /* @__PURE__ */ Object.create(null);
class NodeType {
  constructor(name2, props, id2, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  prop(prop2) {
    return this.props[prop2.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  static match(map2) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop2 in map2)
      for (let name2 of prop2.split(" "))
        direct[name2] = map2[prop2];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
}
NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
class NodeSet {
  constructor(types2) {
    this.types = types2;
    for (let i = 0; i < types2.length; i++)
      if (types2[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add3 = source(type);
        if (add3) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          newProps[add3[0].id] = add3[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new NodeSet(newTypes);
  }
}
const CachedNode = /* @__PURE__ */ new WeakMap(), CachedInnerNode = /* @__PURE__ */ new WeakMap();
class Tree {
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop2, value] of props)
        this.props[typeof prop2 == "number" ? prop2 : prop2.id] = value;
    }
  }
  toString() {
    let mounted = this.prop(NodeProp.mounted);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  cursor(pos, side = 0) {
    let scope = pos != null && CachedNode.get(this) || this.topNode;
    let cursor2 = new TreeCursor(scope);
    if (pos != null) {
      cursor2.moveTo(pos, side);
      CachedNode.set(this, cursor2._tree);
    }
    return cursor2;
  }
  fullCursor() {
    return new TreeCursor(this.topNode, 1);
  }
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    for (let c = this.cursor(), get = () => c.node; ; ) {
      let mustLeave = false;
      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {
        if (c.firstChild())
          continue;
        if (!c.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(c.type, c.from, c.to, get);
        mustLeave = c.type.isAnonymous;
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        mustLeave = true;
      }
    }
  }
  prop(prop2) {
    return !prop2.perNode ? this.type.prop(prop2) : this.props ? this.props[prop2.id] : void 0;
  }
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  balance(config2 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
  }
  static build(data2) {
    return buildTree(data2);
  }
}
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
  constructor(buffer, index2) {
    this.buffer = buffer;
    this.index = index2;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
}
class TreeBuffer {
  constructor(buffer, length, set2) {
    this.buffer = buffer;
    this.length = length;
    this.set = set2;
  }
  get type() {
    return NodeType.none;
  }
  toString() {
    let result = [];
    for (let index2 = 0; index2 < this.buffer.length; ) {
      result.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result.join(",");
  }
  childString(index2) {
    let id2 = this.buffer[index2], endIndex = this.buffer[index2 + 3];
    let type = this.set.types[id2], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index2 += 4;
    if (endIndex == index2)
      return result;
    let children = [];
    while (index2 < endIndex) {
      children.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  slice(startI, endI, from, to) {
    let b = this.buffer;
    let copy2 = new Uint16Array(endI - startI);
    for (let i = startI, j = 0; i < endI; ) {
      copy2[j++] = b[i++];
      copy2[j++] = b[i++] - from;
      copy2[j++] = b[i++] - from;
      copy2[j++] = b[i++] - startI;
    }
    return new TreeBuffer(copy2, to - from, this.set);
  }
}
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function enterUnfinishedNodesBefore(node, pos) {
  let scan = node.childBefore(pos);
  while (scan) {
    let last = scan.lastChild;
    if (!last || last.to != scan.to)
      break;
    if (last.type.isError && last.from == last.to) {
      node = scan;
      scan = last.prevSibling;
    } else {
      scan = last;
    }
  }
  return node;
}
function resolveNode(node, pos, side, overlays) {
  var _a;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, true)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, overlays);
    if (!inner)
      return node;
    node = inner;
  }
}
class TreeNode {
  constructor(node, _from, index2, _parent) {
    this.node = node;
    this._from = _from;
    this.index = index2;
    this._parent = _parent;
  }
  get type() {
    return this.node.type;
  }
  get name() {
    return this.node.type.name;
  }
  get from() {
    return this._from;
  }
  get to() {
    return this._from + this.node.length;
  }
  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start = positions[i] + parent._from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & 2)
            continue;
          let index2 = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index2 > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index2);
        } else if (mode & 1 || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & 1) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
            return new TreeNode(mounted.tree, start, i, parent);
          let inner = new TreeNode(next, start, i, parent);
          return mode & 1 || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & 1 || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i = parent.index + dir;
      else
        i = dir < 0 ? -1 : parent._parent.node.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this.node.children.length - 1, -1, 0, 4);
  }
  childAfter(pos) {
    return this.nextChild(0, 1, pos, 2);
  }
  childBefore(pos) {
    return this.nextChild(this.node.children.length - 1, -1, pos, -2);
  }
  enter(pos, side, overlays = true, buffers = true) {
    let mounted;
    if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, buffers ? 0 : 2);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  get cursor() {
    return new TreeCursor(this);
  }
  get tree() {
    return this.node;
  }
  toTree() {
    return this.node;
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  enterUnfinishedNodesBefore(pos) {
    return enterUnfinishedNodesBefore(this, pos);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  toString() {
    return this.node.toString();
  }
}
function getChildren(node, type, before, after) {
  let cur2 = node.cursor, result = [];
  if (!cur2.firstChild())
    return result;
  if (before != null) {
    while (!cur2.type.is(before))
      if (!cur2.nextSibling())
        return result;
  }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
class BufferContext {
  constructor(parent, buffer, index2, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index2;
    this.start = start;
  }
}
class BufferNode {
  constructor(context, _parent, index2) {
    this.context = context;
    this._parent = _parent;
    this.index = index2;
    this.type = context.buffer.set.types[context.buffer.buffer[index2]];
  }
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index2 < 0 ? null : new BufferNode(this.context, this, index2);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(pos) {
    return this.child(1, pos, 2);
  }
  childBefore(pos) {
    return this.child(-1, pos, -2);
  }
  enter(pos, side, overlays, buffers = true) {
    if (!buffers)
      return null;
    let { buffer } = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index2 < 0 ? null : new BufferNode(this.context, this, index2);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
  }
  get cursor() {
    return new TreeCursor(this);
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
      children.push(buffer.slice(startI, endI, from, to));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  enterUnfinishedNodesBefore(pos) {
    return enterUnfinishedNodesBefore(this, pos);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
}
class TreeCursor {
  constructor(node, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  get name() {
    return this.type.name;
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index2, type) {
    this.index = index2;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index2]];
    this.from = start + buffer.buffer[index2 + 1];
    this.to = start + buffer.buffer[index2 + 2];
    return true;
  }
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index2 < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index2);
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(pos) {
    return this.enterChild(1, pos, 2);
  }
  childBefore(pos) {
    return this.enterChild(-1, pos, -2);
  }
  enter(pos, side, overlays = true, buffers = true) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, overlays && !(this.mode & 1), buffers));
    return buffers ? this.enterChild(1, pos, side) : false;
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & 1 ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & 1 ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index2, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index: index2, parent } = buffer);
    } else {
      ({ index: index2, _parent: parent } = this._tree);
    }
    for (; parent; { index: index2, _parent: parent } = parent) {
      if (index2 > -1)
        for (let i = index2 + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
          let child = parent.node.children[i];
          if (this.mode & 1 || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(dir, 0, 4))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  next(enter = true) {
    return this.move(1, enter);
  }
  prev(enter = true) {
    return this.move(-1, enter);
  }
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth = 0;
    if (cache && cache.context == this.buffer) {
      scan:
        for (let index2 = this.index, d = this.stack.length; d >= 0; ) {
          for (let c = cache; c; c = c._parent)
            if (c.index == index2) {
              if (index2 == this.index)
                return c;
              result = c;
              depth = d + 1;
              break scan;
            }
          index2 = this.stack[--d];
        }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree.node;
  }
}
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data2) {
  var _a;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data2;
  let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
    let { id: id2, start, end, size } = cursor2;
    let lookAheadAtStart = lookAhead;
    while (size < 0) {
      cursor2.next();
      if (size == -1) {
        let node2 = reused[id2];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types2[id2], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))) {
      let data3 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor2.pos - buffer2.size, index2 = data3.length;
      while (cursor2.pos > endPos)
        index2 = copyToBuffer(buffer2.start, data3, index2);
      node = new TreeBuffer(data3, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor2.pos - size;
      cursor2.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor2.pos > endPos) {
        if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
          if (cursor2.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor2.end, lastEnd, localInRepeat, lookAheadAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor2.end;
          }
          cursor2.next();
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function makeBalanced(type) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base2, i, from, to, type, lookAhead2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base2 - from);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to));
    positions2.push(from - base2);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2 = 0, props) {
    if (contextHash) {
      let pair2 = [NodeProp.contextHash, contextHash];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork2 = cursor2.fork();
    let size = 0, start = 0, skip = 0, minStart = fork2.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan:
      for (let minPos = fork2.pos - maxSize; fork2.pos > minPos; ) {
        let nodeSize2 = fork2.size;
        if (fork2.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork2.next();
          continue;
        }
        let startPos = fork2.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork2.start < minStart)
          break;
        let localSkipped = fork2.id >= minRepeatType ? 4 : 0;
        let nodeStart2 = fork2.start;
        fork2.next();
        while (fork2.pos > startPos) {
          if (fork2.size < 0) {
            if (fork2.size == -3)
              localSkipped += 4;
            else
              break scan;
          } else if (fork2.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork2.next();
        }
        start = nodeStart2;
        size += nodeSize2;
        skip += localSkipped;
      }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index2) {
    let { id: id2, start, end, size } = cursor2;
    cursor2.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index2;
      if (size > 4) {
        let endPos = cursor2.pos - (size - 4);
        while (cursor2.pos > endPos)
          index2 = copyToBuffer(bufferStart, buffer2, index2);
      }
      buffer2[--index2] = startIndex;
      buffer2[--index2] = end - bufferStart;
      buffer2[--index2] = start - bufferStart;
      buffer2[--index2] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index2;
  }
  let children = [], positions = [];
  while (cursor2.pos > 0)
    takeNode(data2.start || 0, data2.bufferStart || 0, children, positions, -1);
  let length = (_a = data2.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types2[data2.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from; i < to; i++)
    total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(total * 1.5 / 8);
  let localChildren = [], localPositions = [];
  function divide2(children2, positions2, from2, to2, offset) {
    for (let i = from2; i < to2; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
      i++;
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide2(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide2(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
class TreeFragment {
  constructor(from, to, tree, offset, openStart = false, openEnd = false) {
    this.from = from;
    this.to = to;
    this.tree = tree;
    this.offset = offset;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static addTree(tree, fragments = [], partial = false) {
    let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
    for (let f of fragments)
      if (f.to > tree.length)
        result.push(f);
    return result;
  }
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
            cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result;
  }
}
class Parser {
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map((r) => new Range(r.from, r.to)) : [new Range(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  parse(input, fragments, ranges) {
    let parse2 = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse2.advance();
      if (done)
        return done;
    }
  }
}
class StringInput {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
}
function parseMixed(nest) {
  return (parse2, input, fragments, ranges) => new MixedParse(parse2, nest, input, fragments, ranges);
}
class InnerParse {
  constructor(parser2, parse2, overlay, target2, ranges) {
    this.parser = parser2;
    this.parse = parse2;
    this.overlay = overlay;
    this.target = target2;
    this.ranges = ranges;
  }
}
class ActiveOverlay {
  constructor(parser2, predicate, mounts, index2, start, target2, prev) {
    this.parser = parser2;
    this.predicate = predicate;
    this.mounts = mounts;
    this.index = index2;
    this.start = start;
    this.target = target2;
    this.prev = prev;
    this.depth = 0;
    this.ranges = [];
  }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
  constructor(base2, nest, input, fragments, ranges) {
    this.nest = nest;
    this.input = input;
    this.fragments = fragments;
    this.ranges = ranges;
    this.inner = [];
    this.innerDone = 0;
    this.baseTree = null;
    this.stoppedAt = null;
    this.baseParse = base2;
  }
  advance() {
    if (this.baseParse) {
      let done2 = this.baseParse.advance();
      if (!done2)
        return null;
      this.baseParse = null;
      this.baseTree = done2;
      this.startInner();
      if (this.stoppedAt != null)
        for (let inner2 of this.inner)
          inner2.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let result = this.baseTree;
      if (this.stoppedAt != null)
        result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
      return result;
    }
    let inner = this.inner[this.innerDone], done = inner.parse.advance();
    if (done) {
      this.innerDone++;
      let props = Object.assign(/* @__PURE__ */ Object.create(null), inner.target.props);
      props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
      inner.target.props = props;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let pos = this.input.length;
    for (let i = this.innerDone; i < this.inner.length; i++) {
      if (this.inner[i].ranges[0].from < pos)
        pos = Math.min(pos, this.inner[i].parse.parsedPos);
    }
    return pos;
  }
  stopAt(pos) {
    this.stoppedAt = pos;
    if (this.baseParse)
      this.baseParse.stopAt(pos);
    else
      for (let i = this.innerDone; i < this.inner.length; i++)
        this.inner[i].parse.stopAt(pos);
  }
  startInner() {
    let fragmentCursor = new FragmentCursor$2(this.fragments);
    let overlay = null;
    let covered = null;
    let cursor2 = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), 1);
    scan:
      for (let nest, isCovered; this.stoppedAt == null || cursor2.from < this.stoppedAt; ) {
        let enter = true, range2;
        if (fragmentCursor.hasNode(cursor2)) {
          if (overlay) {
            let match2 = overlay.mounts.find((m) => m.frag.from <= cursor2.from && m.frag.to >= cursor2.to && m.mount.overlay);
            if (match2)
              for (let r of match2.mount.overlay) {
                let from = r.from + match2.pos, to = r.to + match2.pos;
                if (from >= cursor2.from && to <= cursor2.to)
                  overlay.ranges.push({ from, to });
              }
          }
          enter = false;
        } else if (covered && (isCovered = checkCover(covered.ranges, cursor2.from, cursor2.to))) {
          enter = isCovered != 2;
        } else if (!cursor2.type.isAnonymous && cursor2.from < cursor2.to && (nest = this.nest(cursor2, this.input))) {
          if (!cursor2.tree)
            materialize(cursor2);
          let oldMounts = fragmentCursor.findMounts(cursor2.from, nest.parser);
          if (typeof nest.overlay == "function") {
            overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor2.from, cursor2.tree, overlay);
          } else {
            let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor2.from, cursor2.to)]);
            if (ranges.length)
              this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map((r) => new Range(r.from - cursor2.from, r.to - cursor2.from)) : null, cursor2.tree, ranges));
            if (!nest.overlay)
              enter = false;
            else if (ranges.length)
              covered = { ranges, depth: 0, prev: covered };
          }
        } else if (overlay && (range2 = overlay.predicate(cursor2))) {
          if (range2 === true)
            range2 = new Range(cursor2.from, cursor2.to);
          if (range2.from < range2.to)
            overlay.ranges.push(range2);
        }
        if (enter && cursor2.firstChild()) {
          if (overlay)
            overlay.depth++;
          if (covered)
            covered.depth++;
        } else {
          for (; ; ) {
            if (cursor2.nextSibling())
              break;
            if (!cursor2.parent())
              break scan;
            if (overlay && !--overlay.depth) {
              let ranges = punchRanges(this.ranges, overlay.ranges);
              if (ranges.length)
                this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r) => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
              overlay = overlay.prev;
            }
            if (covered && !--covered.depth)
              covered = covered.prev;
          }
        }
      }
  }
}
function checkCover(covered, from, to) {
  for (let range2 of covered) {
    if (range2.from >= to)
      break;
    if (range2.to > from)
      return range2.from <= from && range2.to >= to ? 2 : 1;
  }
  return 0;
}
function sliceBuf(buf, startI, endI, nodes, positions, off) {
  if (startI < endI) {
    let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];
    nodes.push(buf.slice(startI, endI, from, to));
    positions.push(from - off);
  }
}
function materialize(cursor2) {
  let { node } = cursor2, depth = 0;
  do {
    cursor2.parent();
    depth++;
  } while (!cursor2.tree);
  let i = 0, base2 = cursor2.tree, off = 0;
  for (; ; i++) {
    off = base2.positions[i] + cursor2.from;
    if (off <= node.from && off + base2.children[i].length >= node.to)
      break;
  }
  let buf = base2.children[i], b = buf.buffer;
  function split(startI, endI, type, innerOffset, length) {
    let i2 = startI;
    while (b[i2 + 2] + off <= node.from)
      i2 = b[i2 + 3];
    let children = [], positions = [];
    sliceBuf(buf, startI, i2, children, positions, innerOffset);
    let from = b[i2 + 1], to = b[i2 + 2];
    let isTarget = from + off == node.from && to + off == node.to && b[i2] == node.type.id;
    children.push(isTarget ? node.toTree() : split(i2 + 4, b[i2 + 3], buf.set.types[b[i2]], from, to - from));
    positions.push(from - innerOffset);
    sliceBuf(buf, b[i2 + 3], endI, children, positions, innerOffset);
    return new Tree(type, children, positions, length);
  }
  base2.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
  for (let d = 0; d <= depth; d++)
    cursor2.childAfter(node.from);
}
class StructureCursor {
  constructor(root, offset) {
    this.offset = offset;
    this.done = false;
    this.cursor = root.fullCursor();
  }
  moveTo(pos) {
    let { cursor: cursor2 } = this, p = pos - this.offset;
    while (!this.done && cursor2.from < p) {
      if (cursor2.to >= pos && cursor2.enter(p, 1, false, false))
        ;
      else if (!cursor2.next(false))
        this.done = true;
    }
  }
  hasNode(cursor2) {
    this.moveTo(cursor2.from);
    if (!this.done && this.cursor.from + this.offset == cursor2.from && this.cursor.tree) {
      for (let tree = this.cursor.tree; ; ) {
        if (tree == cursor2.tree)
          return true;
        if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
          tree = tree.children[0];
        else
          break;
      }
    }
    return false;
  }
}
class FragmentCursor$2 {
  constructor(fragments) {
    var _a;
    this.fragments = fragments;
    this.curTo = 0;
    this.fragI = 0;
    if (fragments.length) {
      let first = this.curFrag = fragments[0];
      this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
      this.inner = new StructureCursor(first.tree, -first.offset);
    } else {
      this.curFrag = this.inner = null;
    }
  }
  hasNode(node) {
    while (this.curFrag && node.from >= this.curTo)
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
  }
  nextFrag() {
    var _a;
    this.fragI++;
    if (this.fragI == this.fragments.length) {
      this.curFrag = this.inner = null;
    } else {
      let frag = this.curFrag = this.fragments[this.fragI];
      this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
      this.inner = new StructureCursor(frag.tree, -frag.offset);
    }
  }
  findMounts(pos, parser2) {
    var _a;
    let result = [];
    if (this.inner) {
      this.inner.cursor.moveTo(pos, 1);
      for (let pos2 = this.inner.cursor.node; pos2; pos2 = pos2.parent) {
        let mount = (_a = pos2.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
        if (mount && mount.parser == parser2) {
          for (let i = this.fragI; i < this.fragments.length; i++) {
            let frag = this.fragments[i];
            if (frag.from >= pos2.to)
              break;
            if (frag.tree == this.curFrag.tree)
              result.push({
                frag,
                pos: pos2.from - frag.offset,
                mount
              });
          }
        }
      }
    }
    return result;
  }
}
function punchRanges(outer, ranges) {
  let copy2 = null, current = ranges;
  for (let i = 1, j = 0; i < outer.length; i++) {
    let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
    for (; j < current.length; j++) {
      let r = current[j];
      if (r.from >= gapTo)
        break;
      if (r.to <= gapFrom)
        continue;
      if (!copy2)
        current = copy2 = ranges.slice();
      if (r.from < gapFrom) {
        copy2[j] = new Range(r.from, gapFrom);
        if (r.to > gapTo)
          copy2.splice(j + 1, 0, new Range(gapTo, r.to));
      } else if (r.to > gapTo) {
        copy2[j--] = new Range(gapTo, r.to);
      } else {
        copy2.splice(j--, 1);
      }
    }
  }
  return current;
}
function findCoverChanges(a, b, from, to) {
  let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
  let result = [];
  for (; ; ) {
    let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
    let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
    if (inA != inB) {
      let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
      if (start < end)
        result.push(new Range(start, end));
    }
    pos = Math.min(nextA, nextB);
    if (pos == 1e9)
      break;
    if (nextA == pos) {
      if (!inA)
        inA = true;
      else {
        inA = false;
        iA++;
      }
    }
    if (nextB == pos) {
      if (!inB)
        inB = true;
      else {
        inB = false;
        iB++;
      }
    }
  }
  return result;
}
function enterFragments(mounts, ranges) {
  let result = [];
  for (let { pos, mount, frag } of mounts) {
    let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
    let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
    if (mount.overlay) {
      let overlay = mount.overlay.map((r) => new Range(r.from + pos, r.to + pos));
      let changes = findCoverChanges(ranges, overlay, from, to);
      for (let i = 0, pos2 = from; ; i++) {
        let last = i == changes.length, end = last ? to : changes[i].from;
        if (end > pos2)
          result.push(new TreeFragment(pos2, end, mount.tree, -startPos, frag.from >= pos2, frag.to <= end));
        if (last)
          break;
        pos2 = changes[i].to;
      }
    } else {
      result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));
    }
  }
  return result;
}
const languageDataProp = /* @__PURE__ */ new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values2) => values2.concat(baseData) : void 0
  });
}
class Language {
  constructor(data2, parser2, topNode, extraExtensions = []) {
    this.data = data2;
    this.topNode = topNode;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", { get() {
        return syntaxTree(this);
      } });
    this.parser = parser2;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))
    ].concat(extraExtensions);
  }
  isActiveAt(state, pos, side = -1) {
    return languageDataFacetAt(state, pos, side) == this.data;
  }
  findRegions(state) {
    let lang2 = state.facet(language);
    if ((lang2 === null || lang2 === void 0 ? void 0 : lang2.data) == this.data)
      return [{ from: 0, to: state.doc.length }];
    if (!lang2 || !lang2.allowsNesting)
      return [];
    let result = [];
    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({ from, to: from + tree.length });
        return;
      }
      let mount = tree.prop(NodeProp.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay)
            for (let r of mount.overlay)
              result.push({ from: r.from + from, to: r.to + from });
          else
            result.push({ from, to: from + tree.length });
          return;
        } else if (mount.overlay) {
          let size = result.length;
          explore(mount.tree, mount.overlay[0].from + from);
          if (result.length > size)
            return;
        }
      }
      for (let i = 0; i < tree.children.length; i++) {
        let ch = tree.children[i];
        if (ch instanceof Tree)
          explore(ch, tree.positions[i] + from);
      }
    };
    explore(syntaxTree(state), 0);
    return result;
  }
  get allowsNesting() {
    return true;
  }
}
Language.setState = /* @__PURE__ */ StateEffect.define();
function languageDataFacetAt(state, pos, side) {
  let topLang = state.facet(language);
  if (!topLang)
    return null;
  let facet = topLang.data;
  if (topLang.allowsNesting) {
    for (let node = syntaxTree(state).topNode; node; node = node.enter(pos, side, true, false))
      facet = node.type.prop(languageDataProp) || facet;
  }
  return facet;
}
class LRLanguage extends Language {
  constructor(data2, parser2) {
    super(data2, parser2, parser2.topNode);
    this.parser = parser2;
  }
  static define(spec) {
    let data2 = defineLanguageFacet(spec.languageData);
    return new LRLanguage(data2, spec.parser.configure({
      props: [languageDataProp.add((type) => type.isTop ? data2 : void 0)]
    }));
  }
  configure(options) {
    return new LRLanguage(this.data, this.parser.configure(options));
  }
  get allowsNesting() {
    return this.parser.wrappers.length > 0;
  }
}
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
class DocInput {
  constructor(doc2, length = doc2.length) {
    this.doc = doc2;
    this.length = length;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc2.iter();
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from, to) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to >= this.cursorPos)
      return this.doc.sliceString(from, to);
    else
      return this.string.slice(from - stringStart, to - stringStart);
  }
}
let currentContext = null;
class ParseContext {
  constructor(parser2, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
    this.parser = parser2;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  work(time, upto) {
    if (upto != null && upto >= this.state.doc.length)
      upto = void 0;
    if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a;
      let endTime = Date.now() + time;
      if (!this.parse)
        this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
        this.parse.stopAt(upto);
      for (; ; ) {
        let done = this.parse.advance();
        if (done) {
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        }
        if (Date.now() > endTime)
          return false;
      }
    });
  }
  takeTree() {
    let pos, tree;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
        this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {
        }
      });
      this.treeLen = pos;
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f) {
    let prev = currentContext;
    currentContext = this;
    try {
      return f();
    } finally {
      currentContext = prev;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r; r = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r.from, r.to);
    return fragments;
  }
  changes(changes, newState) {
    let { fragments, tree, treeLen, viewport, skipped } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      treeLen = 0;
      viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
      if (this.skipped.length) {
        skipped = [];
        for (let r of this.skipped) {
          let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
          if (from < to)
            skipped.push({ from, to });
        }
      }
    }
    return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
  }
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
      return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from, to } = this.skipped[i];
      if (from < viewport.to && to > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to);
        this.skipped.splice(i--, 1);
      }
    }
    if (this.skipped.length >= startLen)
      return false;
    this.reset();
    return true;
  }
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  skipUntilInView(from, to) {
    this.skipped.push({ from, to });
  }
  static getSkippingParser(until) {
    return new class extends Parser {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from, to = ranges[ranges.length - 1].to;
        let parser2 = {
          parsedPos: from,
          advance() {
            let cx = currentContext;
            if (cx) {
              for (let r of ranges)
                cx.tempSkipped.push(r);
              if (until)
                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
            }
            this.parsedPos = to;
            return new Tree(NodeType.none, [], [], to - from);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
        return parser2;
      }
    }();
  }
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  static get() {
    return currentContext;
  }
}
function cutFragments(fragments, from, to) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
class LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr) {
    if (!tr.docChanged)
      return this;
    let newCx = this.context.changes(tr.changes, tr.state);
    let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto))
      newCx.takeTree();
    return new LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length);
    let parseState = new ParseContext(state.facet(language).parser, state, [], Tree.empty, 0, { from: 0, to: vpTo }, [], null);
    if (!parseState.work(20, vpTo))
      parseState.takeTree();
    return new LanguageState(parseState);
  }
}
Language.state = /* @__PURE__ */ StateField.define({
  create: LanguageState.init,
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(Language.setState))
        return e.value;
    if (tr.startState.facet(language) != tr.state.facet(language))
      return LanguageState.init(tr.state);
    return value.apply(tr);
  }
});
let requestIdle = (callback) => {
  let timeout = setTimeout(() => callback(), 500);
  return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
  requestIdle = (callback) => {
    let idle = -1, timeout = setTimeout(() => {
      idle = requestIdleCallback(callback, { timeout: 500 - 100 });
    }, 100);
    return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
  };
const parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
      this.scheduleWork();
    if (update.docChanged) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state } = this.view, field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
      this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now = Date.now();
    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(vpTo + 1e5))
      return;
    let time = Math.min(this.chunkBudget, 100, deadline ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
    let done = field.context.work(time, vpTo + (viewportFirst ? 0 : 1e5));
    this.chunkBudget -= Date.now() - now;
    if (done || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
    }
    if (this.chunkBudget > 0 && !(done && !viewportFirst))
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      this.workScheduled++;
      cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working)
      this.working();
  }
  isWorking() {
    return this.working || this.workScheduled > 0;
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
const language = /* @__PURE__ */ Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: [Language.state, parseWorker]
});
class LanguageSupport {
  constructor(language2, support = []) {
    this.language = language2;
    this.support = support;
    this.extension = [language2, support];
  }
}
class LanguageDescription {
  constructor(name2, alias, extensions2, filename, loadFunc, support = void 0) {
    this.name = name2;
    this.alias = alias;
    this.extensions = extensions2;
    this.filename = filename;
    this.loadFunc = loadFunc;
    this.support = support;
    this.loading = null;
  }
  load() {
    return this.loading || (this.loading = this.loadFunc().then((support) => this.support = support, (err) => {
      this.loading = null;
      throw err;
    }));
  }
  static of(spec) {
    let { load, support } = spec;
    if (!load) {
      if (!support)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      load = () => Promise.resolve(support);
    }
    return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s) => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);
  }
  static matchFilename(descs, filename) {
    for (let d of descs)
      if (d.filename && d.filename.test(filename))
        return d;
    let ext = /\.([^.]+)$/.exec(filename);
    if (ext) {
      for (let d of descs)
        if (d.extensions.indexOf(ext[1]) > -1)
          return d;
    }
    return null;
  }
  static matchLanguageName(descs, name2, fuzzy = true) {
    name2 = name2.toLowerCase();
    for (let d of descs)
      if (d.alias.some((a) => a == name2))
        return d;
    if (fuzzy)
      for (let d of descs)
        for (let a of d.alias) {
          let found = name2.indexOf(a);
          if (found > -1 && (a.length > 2 || !/\w/.test(name2[found - 1]) && !/\w/.test(name2[found + a.length])))
            return d;
        }
    return null;
  }
}
const indentService = /* @__PURE__ */ Facet.define();
const indentUnit = /* @__PURE__ */ Facet.define({
  combine: (values2) => {
    if (!values2.length)
      return "  ";
    if (!/^(?: +|\t+)$/.test(values2[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(values2[0]));
    return values2[0];
  }
});
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result = "", ts = state.tabSize;
  if (state.facet(indentUnit).charCodeAt(0) == 9)
    while (cols >= ts) {
      result += "	";
      cols -= ts;
    }
  for (let i = 0; i < cols; i++)
    result += " ";
  return result;
}
function getIndentation(context, pos) {
  if (context instanceof EditorState)
    context = new IndentContext(context);
  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos);
    if (result != null)
      return result;
  }
  let tree = syntaxTree(context.state);
  return tree ? syntaxIndentation(context, tree, pos) : null;
}
class IndentContext {
  constructor(state, options = {}) {
    this.state = state;
    this.options = options;
    this.unit = getIndentUnit(state);
  }
  lineAt(pos, bias = 1) {
    let line = this.state.doc.lineAt(pos);
    let { simulateBreak } = this.options;
    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
      if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
        return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
      else
        return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
    }
    return line;
  }
  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
      return "";
    let { text: text3, from } = this.lineAt(pos, bias);
    return text3.slice(pos - from, Math.min(text3.length, pos + 100 - from));
  }
  column(pos, bias = 1) {
    let { text: text3, from } = this.lineAt(pos, bias);
    let result = this.countColumn(text3, pos - from);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
    if (override > -1)
      result += override - this.countColumn(text3, text3.search(/\S|$/));
    return result;
  }
  countColumn(line, pos = line.length) {
    return countColumn(line, this.state.tabSize, pos);
  }
  lineIndent(pos, bias = 1) {
    let { text: text3, from } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;
    if (override) {
      let overriden = override(from);
      if (overriden > -1)
        return overriden;
    }
    return this.countColumn(text3, text3.search(/\S|$/));
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const indentNodeProp = /* @__PURE__ */ new NodeProp();
function syntaxIndentation(cx, ast2, pos) {
  return indentFrom(ast2.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy)
    return strategy;
  let first = tree.firstChild, close;
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
    return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
  }
  return tree.parent == null ? topIndent : null;
}
function indentFrom(node, pos, base2) {
  for (; node; node = node.parent) {
    let strategy = indentStrategy(node);
    if (strategy)
      return strategy(new TreeIndentContext(base2, pos, node));
  }
  return null;
}
function topIndent() {
  return 0;
}
class TreeIndentContext extends IndentContext {
  constructor(base2, pos, node) {
    super(base2.state, base2.options);
    this.base = base2;
    this.pos = pos;
    this.node = node;
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    let line = this.state.doc.lineAt(this.node.from);
    for (; ; ) {
      let atBreak = this.node.resolve(line.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from)
        atBreak = atBreak.parent;
      if (isParent(atBreak, this.node))
        break;
      line = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line.from);
  }
  continue() {
    let parent = this.node.parent;
    return parent ? indentFrom(parent, this.pos, this.base) : 0;
  }
}
function isParent(parent, of) {
  for (let cur2 = of; cur2; cur2 = cur2.parent)
    if (parent == cur2)
      return true;
  return false;
}
function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from), last = tree.lastChild;
  if (!openToken)
    return null;
  let sim2 = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd2 = sim2 == null || sim2 <= openLine.from ? openLine.to : Math.min(openLine.to, sim2);
  for (let pos = openToken.to; ; ) {
    let next = tree.childAfter(pos);
    if (!next || next == last)
      return null;
    if (!next.type.isSkipped)
      return next.from < lineEnd2 ? openToken : null;
    pos = next.to;
  }
}
function delimitedIndent({ closing: closing2, align = true, units = 1 }) {
  return (context) => delimitedStrategy(context, align, units, closing2);
}
function delimitedStrategy(context, align, units, closing2, closedAt) {
  let after = context.textAfter, space2 = after.match(/^\s*/)[0].length;
  let closed = closing2 && after.slice(space2, space2 + closing2.length) == closing2 || closedAt == context.pos + space2;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned)
    return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
const flatIndent = (context) => context.baseIndent;
function continuedIndent({ except, units = 1 } = {}) {
  return (context) => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}
const DontIndentBeyond = 200;
function indentOnInput() {
  return EditorState.transactionFilter.of((tr) => {
    if (!tr.docChanged || !tr.isUserEvent("input.type"))
      return tr;
    let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
    if (!rules.length)
      return tr;
    let doc2 = tr.newDoc, { head } = tr.newSelection.main, line = doc2.lineAt(head);
    if (head > line.from + DontIndentBeyond)
      return tr;
    let lineStart = doc2.sliceString(line.from, head);
    if (!rules.some((r) => r.test(lineStart)))
      return tr;
    let { state } = tr, last = -1, changes = [];
    for (let { head: head2 } of state.selection.ranges) {
      let line2 = state.doc.lineAt(head2);
      if (line2.from == last)
        continue;
      last = line2.from;
      let indent = getIndentation(state, line2.from);
      if (indent == null)
        continue;
      let cur2 = /^\s*/.exec(line2.text)[0];
      let norm = indentString(state, indent);
      if (cur2 != norm)
        changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
    }
    return changes.length ? [tr, { changes, sequential: true }] : tr;
  });
}
const foldService = /* @__PURE__ */ Facet.define();
const foldNodeProp = /* @__PURE__ */ new NodeProp();
function foldInside$1(node) {
  let first = node.firstChild, last = node.lastChild;
  return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
}
function syntaxFolding(state, start, end) {
  let tree = syntaxTree(state);
  if (tree.length == 0)
    return null;
  let inner = tree.resolveInner(end);
  let found = null;
  for (let cur2 = inner; cur2; cur2 = cur2.parent) {
    if (cur2.to <= end || cur2.from > end)
      continue;
    if (found && cur2.from < start)
      break;
    let prop2 = cur2.type.prop(foldNodeProp);
    if (prop2) {
      let value = prop2(cur2, state);
      if (value && value.from <= end && value.from >= start && value.to > end)
        found = value;
    }
  }
  return found;
}
function foldable(state, lineStart, lineEnd2) {
  for (let service of state.facet(foldService)) {
    let result = service(state, lineStart, lineEnd2);
    if (result)
      return result;
  }
  return syntaxFolding(state, lineStart, lineEnd2);
}
class GutterMarker extends RangeValue {
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  eq(other) {
    return false;
  }
  destroy(dom) {
  }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
const gutterLineClass = /* @__PURE__ */ Facet.define();
const defaults$1 = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => RangeSet.empty,
  lineMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};
const activeGutters = /* @__PURE__ */ Facet.define();
function gutter(config2) {
  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults$1), config2))];
}
const baseTheme$8 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-gutters": {
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#999",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  }
});
const unfixGutters = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.some((x) => x)
});
function gutters(config2) {
  let result = [
    gutterView,
    baseTheme$8
  ];
  if (config2 && config2.fixed === false)
    result.push(unfixGutters.of(true));
  return result;
}
const gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.prevViewport = view.viewport;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters";
    this.dom.setAttribute("aria-hidden", "true");
    this.dom.style.minHeight = this.view.contentHeight + "px";
    this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
    for (let gutter2 of this.gutters)
      this.dom.appendChild(gutter2.dom);
    this.fixed = !view.state.facet(unfixGutters);
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    this.syncGutters(false);
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
  }
  update(update) {
    if (this.updateGutters(update)) {
      let vpA = this.prevViewport, vpB = update.view.viewport;
      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
    }
    if (update.geometryChanged)
      this.dom.style.minHeight = this.view.contentHeight + "px";
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
    }
    this.prevViewport = update.view.viewport;
  }
  syncGutters(detach) {
    let after = this.dom.nextSibling;
    if (detach)
      this.dom.remove();
    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
    for (let line of this.view.viewportLineBlocks) {
      let text3;
      if (Array.isArray(line.type)) {
        for (let b of line.type)
          if (b.type == BlockType.Text) {
            text3 = b;
            break;
          }
      } else {
        text3 = line.type == BlockType.Text ? line : void 0;
      }
      if (!text3)
        continue;
      if (classSet.length)
        classSet = [];
      advanceCursor(lineClasses, classSet, line.from);
      for (let cx of contexts)
        cx.line(this.view, text3, classSet);
    }
    for (let cx of contexts)
      cx.finish();
    if (detach)
      this.view.scrollDOM.insertBefore(this.dom, after);
  }
  updateGutters(update) {
    let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
    if (prev == cur2) {
      for (let gutter2 of this.gutters)
        if (gutter2.update(update))
          change = true;
    } else {
      change = true;
      let gutters2 = [];
      for (let conf of cur2) {
        let known = prev.indexOf(conf);
        if (known < 0) {
          gutters2.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters2.push(this.gutters[known]);
        }
      }
      for (let g of this.gutters) {
        g.dom.remove();
        if (gutters2.indexOf(g) < 0)
          g.destroy();
      }
      for (let g of gutters2)
        this.dom.appendChild(g.dom);
      this.gutters = gutters2;
    }
    return change;
  }
  destroy() {
    for (let view of this.gutters)
      view.destroy();
    this.dom.remove();
  }
}, {
  provide: /* @__PURE__ */ PluginField.scrollMargins.from((value) => {
    if (value.gutters.length == 0 || !value.fixed)
      return null;
    return value.view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };
  })
});
function asArray(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor2, collect, pos) {
  while (cursor2.value && cursor2.from <= pos) {
    if (cursor2.from == pos)
      collect.push(cursor2.value);
    cursor2.next();
  }
}
class UpdateContext {
  constructor(gutter2, viewport, height) {
    this.gutter = gutter2;
    this.height = height;
    this.localMarkers = [];
    this.i = 0;
    this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
  }
  line(view, line, extraMarkers) {
    if (this.localMarkers.length)
      this.localMarkers = [];
    advanceCursor(this.cursor, this.localMarkers, line.from);
    let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine)
      localMarkers.unshift(forLine);
    let gutter2 = this.gutter;
    if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
      return;
    let above = line.top - this.height;
    if (this.i == gutter2.elements.length) {
      let newElt = new GutterElement(view, line.height, above, localMarkers);
      gutter2.elements.push(newElt);
      gutter2.dom.appendChild(newElt.dom);
    } else {
      gutter2.elements[this.i].update(view, line.height, above, localMarkers);
    }
    this.height = line.bottom;
    this.i++;
  }
  finish() {
    let gutter2 = this.gutter;
    while (gutter2.elements.length > this.i) {
      let last = gutter2.elements.pop();
      gutter2.dom.removeChild(last.dom);
      last.destroy();
    }
  }
}
class SingleGutterView {
  constructor(view, config2) {
    this.view = view;
    this.config = config2;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop2 in config2.domEventHandlers) {
      this.dom.addEventListener(prop2, (event) => {
        let line = view.lineBlockAtHeight(event.clientY - view.documentTop);
        if (config2.domEventHandlers[prop2](view, line, event))
          event.preventDefault();
      });
    }
    this.markers = asArray(config2.markers(view));
    if (config2.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray(this.config.markers(update.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0])
        this.spacer.update(update.view, 0, 0, [updated]);
    }
    let vp = update.view.viewport;
    return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
  }
  destroy() {
    for (let elt2 of this.elements)
      elt2.destroy();
  }
}
class GutterElement {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.markers = [];
    this.dom = document.createElement("div");
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height)
      this.dom.style.height = (this.height = height) + "px";
    if (this.above != above)
      this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (!sameMarkers(this.markers, markers))
      this.setMarkers(view, markers);
  }
  setMarkers(view, markers) {
    let cls = "cm-gutterElement", domPos = this.dom.firstChild;
    for (let iNew = 0, iOld = 0; ; ) {
      let skipTo = iOld, marker2 = iNew < markers.length ? markers[iNew++] : null, matched = false;
      if (marker2) {
        let c = marker2.elementClass;
        if (c)
          cls += " " + c;
        for (let i = iOld; i < this.markers.length; i++)
          if (this.markers[i].compare(marker2)) {
            skipTo = i;
            matched = true;
            break;
          }
      } else {
        skipTo = this.markers.length;
      }
      while (iOld < skipTo) {
        let next = this.markers[iOld++];
        if (next.toDOM) {
          next.destroy(domPos);
          let after = domPos.nextSibling;
          domPos.remove();
          domPos = after;
        }
      }
      if (!marker2)
        break;
      if (marker2.toDOM) {
        if (matched)
          domPos = domPos.nextSibling;
        else
          this.dom.insertBefore(marker2.toDOM(view), domPos);
      }
      if (matched)
        iOld++;
    }
    this.dom.className = cls;
    this.markers = markers;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function sameMarkers(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].compare(b[i]))
      return false;
  return true;
}
const lineNumberMarkers = /* @__PURE__ */ Facet.define();
const lineNumberConfig = /* @__PURE__ */ Facet.define({
  combine(values2) {
    return combineConfig(values2, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(a, b) {
        let result = Object.assign({}, a);
        for (let event in b) {
          let exists = result[event], add3 = b[event];
          result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add3(view, line, event2) : add3;
        }
        return result;
      }
    });
  }
});
class NumberMarker extends GutterMarker {
  constructor(number2) {
    super();
    this.number = number2;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function formatNumber(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
const lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line, others) {
    if (others.some((m) => m.toDOM))
      return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },
  lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update) {
    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max == spacer.number ? spacer : new NumberMarker(max);
  },
  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
function lineNumbers(config2 = {}) {
  return [
    lineNumberConfig.of(config2),
    gutters(),
    lineNumberGutter
  ];
}
function maxLineNumber(lines) {
  let last = 9;
  while (last < lines)
    last = last * 10 + 9;
  return last;
}
const activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }
}();
const activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
  let marks = [], last = -1;
  for (let range2 of state.selection.ranges)
    if (range2.empty) {
      let linePos = state.doc.lineAt(range2.head).from;
      if (linePos > last) {
        last = linePos;
        marks.push(activeLineGutterMarker.range(linePos));
      }
    }
  return RangeSet.of(marks);
});
function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}
function mapRange(range2, mapping) {
  let from = mapping.mapPos(range2.from, 1), to = mapping.mapPos(range2.to, -1);
  return from >= to ? void 0 : { from, to };
}
const foldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
const unfoldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
function selectedLines(view) {
  let lines = [];
  for (let { head } of view.state.selection.ranges) {
    if (lines.some((l) => l.from <= head && l.to >= head))
      continue;
    lines.push(view.lineBlockAt(head));
  }
  return lines;
}
const foldState = /* @__PURE__ */ StateField.define({
  create() {
    return Decoration.none;
  },
  update(folded, tr) {
    folded = folded.map(tr.changes);
    for (let e of tr.effects) {
      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))
        folded = folded.update({ add: [foldWidget.range(e.value.from, e.value.to)] });
      else if (e.is(unfoldEffect))
        folded = folded.update({
          filter: (from, to) => e.value.from != from || e.value.to != to,
          filterFrom: e.value.from,
          filterTo: e.value.to
        });
    }
    if (tr.selection) {
      let onSelection = false, { head } = tr.selection.main;
      folded.between(head, head, (a, b) => {
        if (a < head && b > head)
          onSelection = true;
      });
      if (onSelection)
        folded = folded.update({
          filterFrom: head,
          filterTo: head,
          filter: (a, b) => b <= head || a >= head
        });
    }
    return folded;
  },
  provide: (f) => EditorView.decorations.from(f)
});
function foldInside(state, from, to) {
  var _a;
  let found = null;
  (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from2, to2) => {
    if (!found || found.from > from2)
      found = { from: from2, to: to2 };
  });
  return found;
}
function foldExists(folded, from, to) {
  let found = false;
  folded.between(from, from, (a, b) => {
    if (a == from && b == to)
      found = true;
  });
  return found;
}
function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
const foldCode = (view) => {
  for (let line of selectedLines(view)) {
    let range2 = foldable(view.state, line.from, line.to);
    if (range2) {
      view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range2), announceFold(view, range2)]) });
      return true;
    }
  }
  return false;
};
const unfoldCode = (view) => {
  if (!view.state.field(foldState, false))
    return false;
  let effects = [];
  for (let line of selectedLines(view)) {
    let folded = foldInside(view.state, line.from, line.to);
    if (folded)
      effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
  }
  if (effects.length)
    view.dispatch({ effects });
  return effects.length > 0;
};
function announceFold(view, range2, fold = true) {
  let lineFrom = view.state.doc.lineAt(range2.from).number, lineTo = view.state.doc.lineAt(range2.to).number;
  return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
const foldAll = (view) => {
  let { state } = view, effects = [];
  for (let pos = 0; pos < state.doc.length; ) {
    let line = view.lineBlockAt(pos), range2 = foldable(state, line.from, line.to);
    if (range2)
      effects.push(foldEffect.of(range2));
    pos = (range2 ? view.lineBlockAt(range2.to) : line).to + 1;
  }
  if (effects.length)
    view.dispatch({ effects: maybeEnable(view.state, effects) });
  return !!effects.length;
};
const unfoldAll = (view) => {
  let field = view.state.field(foldState, false);
  if (!field || !field.size)
    return false;
  let effects = [];
  field.between(0, view.state.doc.length, (from, to) => {
    effects.push(unfoldEffect.of({ from, to }));
  });
  view.dispatch({ effects });
  return true;
};
const foldKeymap = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
  { key: "Ctrl-Alt-[", run: foldAll },
  { key: "Ctrl-Alt-]", run: unfoldAll }
];
const defaultConfig = {
  placeholderDOM: null,
  placeholderText: "\u2026"
};
const foldConfig = /* @__PURE__ */ Facet.define({
  combine(values2) {
    return combineConfig(values2, defaultConfig);
  }
});
function codeFolding(config2) {
  let result = [foldState, baseTheme$7];
  if (config2)
    result.push(foldConfig.of(config2));
  return result;
}
const foldWidget = /* @__PURE__ */ Decoration.replace({ widget: /* @__PURE__ */ new class extends WidgetType {
  toDOM(view) {
    let { state } = view, conf = state.facet(foldConfig);
    let onclick = (event) => {
      let line = view.lineBlockAt(view.posAtDOM(event.target));
      let folded = foldInside(view.state, line.from, line.to);
      if (folded)
        view.dispatch({ effects: unfoldEffect.of(folded) });
      event.preventDefault();
    };
    if (conf.placeholderDOM)
      return conf.placeholderDOM(view, onclick);
    let element = document.createElement("span");
    element.textContent = conf.placeholderText;
    element.setAttribute("aria-label", state.phrase("folded code"));
    element.title = state.phrase("unfold");
    element.className = "cm-foldPlaceholder";
    element.onclick = onclick;
    return element;
  }
}() });
const foldGutterDefaults = {
  openText: "\u2304",
  closedText: "\u203A",
  markerDOM: null,
  domEventHandlers: {}
};
class FoldMarker extends GutterMarker {
  constructor(config2, open) {
    super();
    this.config = config2;
    this.open = open;
  }
  eq(other) {
    return this.config == other.config && this.open == other.open;
  }
  toDOM(view) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let span2 = document.createElement("span");
    span2.textContent = this.open ? this.config.openText : this.config.closedText;
    span2.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
    return span2;
  }
}
function foldGutter(config2 = {}) {
  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config2);
  let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
  let markers = ViewPlugin.fromClass(class {
    constructor(view) {
      this.from = view.viewport.from;
      this.markers = this.buildMarkers(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false))
        this.markers = this.buildMarkers(update.view);
    }
    buildMarkers(view) {
      let builder = new RangeSetBuilder();
      for (let line of view.viewportLineBlocks) {
        let mark = foldInside(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
        if (mark)
          builder.add(line.from, line.from, mark);
      }
      return builder.finish();
    }
  });
  let { domEventHandlers: domEventHandlers2 } = fullConfig;
  return [
    markers,
    gutter({
      class: "cm-foldGutter",
      markers(view) {
        var _a;
        return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || RangeSet.empty;
      },
      initialSpacer() {
        return new FoldMarker(fullConfig, false);
      },
      domEventHandlers: Object.assign(Object.assign({}, domEventHandlers2), { click: (view, line, event) => {
        if (domEventHandlers2.click && domEventHandlers2.click(view, line, event))
          return true;
        let folded = foldInside(view.state, line.from, line.to);
        if (folded) {
          view.dispatch({ effects: unfoldEffect.of(folded) });
          return true;
        }
        let range2 = foldable(view.state, line.from, line.to);
        if (range2) {
          view.dispatch({ effects: foldEffect.of(range2) });
          return true;
        }
        return false;
      } })
    }),
    codeFolding()
  ];
}
const baseTheme$7 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
const baseTheme$6 = /* @__PURE__ */ EditorView.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
const DefaultScanDist = 1e4, DefaultBrackets = "()[]{}";
const bracketMatchingConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      afterCursor: true,
      brackets: DefaultBrackets,
      maxScanDistance: DefaultScanDist
    });
  }
});
const matchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-matchingBracket" }), nonmatchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-nonmatchingBracket" });
const bracketMatchingState = /* @__PURE__ */ StateField.define({
  create() {
    return Decoration.none;
  },
  update(deco, tr) {
    if (!tr.docChanged && !tr.selection)
      return deco;
    let decorations2 = [];
    let config2 = tr.state.facet(bracketMatchingConfig);
    for (let range2 of tr.state.selection.ranges) {
      if (!range2.empty)
        continue;
      let match2 = matchBrackets(tr.state, range2.head, -1, config2) || range2.head > 0 && matchBrackets(tr.state, range2.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range2.head, 1, config2) || range2.head < tr.state.doc.length && matchBrackets(tr.state, range2.head + 1, -1, config2));
      if (!match2)
        continue;
      let mark = match2.matched ? matchingMark : nonmatchingMark;
      decorations2.push(mark.range(match2.start.from, match2.start.to));
      if (match2.end)
        decorations2.push(mark.range(match2.end.from, match2.end.to));
    }
    return Decoration.set(decorations2, true);
  },
  provide: (f) => EditorView.decorations.from(f)
});
const bracketMatchingUnique = [
  bracketMatchingState,
  baseTheme$6
];
function bracketMatching(config2 = {}) {
  return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
}
function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp)
    return byProp;
  if (node.name.length == 1) {
    let index2 = brackets.indexOf(node.name);
    if (index2 > -1 && index2 % 2 == (dir < 0 ? 1 : 0))
      return [brackets[index2 + dir]];
  }
  return null;
}
function matchBrackets(state, pos, dir, config2 = {}) {
  let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
  let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
  for (let cur2 = node; cur2; cur2 = cur2.parent) {
    let matches = matchingNodes(cur2.type, dir, brackets);
    if (matches && cur2.from < cur2.to)
      return matchMarkedBrackets(state, pos, dir, cur2, matches, brackets);
  }
  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token2, matching, brackets) {
  let parent = token2.parent, firstToken = { from: token2.from, to: token2.to };
  let depth = 0, cursor2 = parent === null || parent === void 0 ? void 0 : parent.cursor;
  if (cursor2 && (dir < 0 ? cursor2.childBefore(token2.from) : cursor2.childAfter(token2.to)))
    do {
      if (dir < 0 ? cursor2.to <= token2.from : cursor2.from >= token2.to) {
        if (depth == 0 && matching.indexOf(cursor2.type.name) > -1 && cursor2.from < cursor2.to) {
          return { start: firstToken, end: { from: cursor2.from, to: cursor2.to }, matched: true };
        } else if (matchingNodes(cursor2.type, dir, brackets)) {
          depth++;
        } else if (matchingNodes(cursor2.type, -dir, brackets)) {
          depth--;
          if (depth == 0)
            return {
              start: firstToken,
              end: cursor2.from == cursor2.to ? void 0 : { from: cursor2.from, to: cursor2.to },
              matched: false
            };
        }
      }
    } while (dir < 0 ? cursor2.prevSibling() : cursor2.nextSibling());
  return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
    return null;
  let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text3 = iter.value;
    if (dir < 0)
      distance += text3.length;
    let basePos = pos + distance * dir;
    for (let pos2 = dir > 0 ? 0 : text3.length - 1, end = dir > 0 ? text3.length : -1; pos2 != end; pos2 += dir) {
      let found = brackets.indexOf(text3[pos2]);
      if (found < 0 || tree.resolve(basePos + pos2, 1).type != tokenType)
        continue;
      if (found % 2 == 0 == dir > 0) {
        depth++;
      } else if (depth == 1) {
        return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
      } else {
        depth--;
      }
    }
    if (dir > 0)
      distance += text3.length;
  }
  return iter.done ? { start: startToken, matched: false } : null;
}
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection2) {
  return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection2 = updateSel(state.selection, how);
  if (selection2.eq(state.selection))
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
function rangeEnd(range2, forward) {
  return EditorSelection.cursor(forward ? range2.to : range2.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range2) => range2.empty ? view.moveByChar(range2, forward) : rangeEnd(range2, forward));
}
const cursorCharLeft = (view) => cursorByChar(view, view.textDirection != Direction.LTR);
const cursorCharRight = (view) => cursorByChar(view, view.textDirection == Direction.LTR);
function cursorByGroup(view, forward) {
  return moveSel(view, (range2) => range2.empty ? view.moveByGroup(range2, forward) : rangeEnd(range2, forward));
}
const cursorGroupLeft = (view) => cursorByGroup(view, view.textDirection != Direction.LTR);
const cursorGroupRight = (view) => cursorByGroup(view, view.textDirection == Direction.LTR);
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp))
    return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at = start.head; ; ) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at = forward ? next.to : next.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match2, newPos;
  if (bracket2 && (match2 = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match2.matched)
    newPos = forward ? match2.end.to : match2.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
const cursorSyntaxLeft = (view) => moveSel(view, (range2) => moveBySyntax(view.state, range2, view.textDirection != Direction.LTR));
const cursorSyntaxRight = (view) => moveSel(view, (range2) => moveBySyntax(view.state, range2, view.textDirection == Direction.LTR));
function cursorByLine(view, forward) {
  return moveSel(view, (range2) => {
    if (!range2.empty)
      return rangeEnd(range2, forward);
    let moved = view.moveVertically(range2, forward);
    return moved.head != range2.head ? moved : view.moveToLineBoundary(range2, forward);
  });
}
const cursorLineUp = (view) => cursorByLine(view, false);
const cursorLineDown = (view) => cursorByLine(view, true);
function cursorByPage(view, forward) {
  let { state } = view, selection2 = updateSel(state.selection, (range2) => {
    return range2.empty ? view.moveVertically(range2, forward, view.dom.clientHeight) : rangeEnd(range2, forward);
  });
  if (selection2.eq(state.selection))
    return false;
  let startPos = view.coordsAtPos(state.selection.main.head);
  let scrollRect = view.scrollDOM.getBoundingClientRect();
  view.dispatch(setSel(state, selection2), {
    effects: startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom ? EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollRect.top }) : void 0
  });
  return true;
}
const cursorPageUp = (view) => cursorByPage(view, false);
const cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space2 = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space2 && start.head != line.from + space2)
      moved = EditorSelection.cursor(line.from + space2);
  }
  return moved;
}
const cursorLineBoundaryForward = (view) => moveSel(view, (range2) => moveByLineBoundary(view, range2, true));
const cursorLineBoundaryBackward = (view) => moveSel(view, (range2) => moveByLineBoundary(view, range2, false));
const cursorLineStart = (view) => moveSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).from, 1));
const cursorLineEnd = (view) => moveSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).to, -1));
function toMatchingBracket(state, dispatch, extend2) {
  let found = false, selection2 = updateSel(state.selection, (range2) => {
    let matching = matchBrackets(state, range2.head, -1) || matchBrackets(state, range2.head, 1) || range2.head > 0 && matchBrackets(state, range2.head - 1, 1) || range2.head < state.doc.length && matchBrackets(state, range2.head + 1, -1);
    if (!matching || !matching.end)
      return range2;
    found = true;
    let head = matching.start.from == range2.head ? matching.end.to : matching.end.from;
    return extend2 ? EditorSelection.range(range2.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
const cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
function extendSel(view, how) {
  let selection2 = updateSel(view.state.selection, (range2) => {
    let head = how(range2);
    return EditorSelection.range(range2.anchor, head.head, head.goalColumn);
  });
  if (selection2.eq(view.state.selection))
    return false;
  view.dispatch(setSel(view.state, selection2));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range2) => view.moveByChar(range2, forward));
}
const selectCharLeft = (view) => selectByChar(view, view.textDirection != Direction.LTR);
const selectCharRight = (view) => selectByChar(view, view.textDirection == Direction.LTR);
function selectByGroup(view, forward) {
  return extendSel(view, (range2) => view.moveByGroup(range2, forward));
}
const selectGroupLeft = (view) => selectByGroup(view, view.textDirection != Direction.LTR);
const selectGroupRight = (view) => selectByGroup(view, view.textDirection == Direction.LTR);
const selectSyntaxLeft = (view) => extendSel(view, (range2) => moveBySyntax(view.state, range2, view.textDirection != Direction.LTR));
const selectSyntaxRight = (view) => extendSel(view, (range2) => moveBySyntax(view.state, range2, view.textDirection == Direction.LTR));
function selectByLine(view, forward) {
  return extendSel(view, (range2) => view.moveVertically(range2, forward));
}
const selectLineUp = (view) => selectByLine(view, false);
const selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range2) => view.moveVertically(range2, forward, view.dom.clientHeight));
}
const selectPageUp = (view) => selectByPage(view, false);
const selectPageDown = (view) => selectByPage(view, true);
const selectLineBoundaryForward = (view) => extendSel(view, (range2) => moveByLineBoundary(view, range2, true));
const selectLineBoundaryBackward = (view) => extendSel(view, (range2) => moveByLineBoundary(view, range2, false));
const selectLineStart = (view) => extendSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).from));
const selectLineEnd = (view) => extendSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).to));
const cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
const cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
const selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
const selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
const selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
const selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
const selectParentSyntax = ({ state, dispatch }) => {
  let selection2 = updateSel(state.selection, (range2) => {
    var _a;
    let context = syntaxTree(state).resolveInner(range2.head, 1);
    while (!(context.from < range2.from && context.to >= range2.to || context.to > range2.to && context.from <= range2.from || !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))
      context = context.parent;
    return EditorSelection.range(context.to, context.from);
  });
  dispatch(setSel(state, selection2));
  return true;
};
const simplifySelection = ({ state, dispatch }) => {
  let cur2 = state.selection, selection2 = null;
  if (cur2.ranges.length > 1)
    selection2 = EditorSelection.create([cur2.main]);
  else if (!cur2.main.empty)
    selection2 = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
  if (!selection2)
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
function deleteBy({ state, dispatch }, by) {
  if (state.readOnly)
    return false;
  let event = "delete.selection";
  let changes = state.changeByRange((range2) => {
    let { from, to } = range2;
    if (from == to) {
      let towards = by(from);
      if (towards < from)
        event = "delete.backward";
      else if (towards > from)
        event = "delete.forward";
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    }
    return from == to ? { range: range2 } : { changes: { from, to }, range: EditorSelection.cursor(from) };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: event }));
  return true;
}
function skipAtomic(target2, pos, forward) {
  if (target2 instanceof EditorView)
    for (let ranges of target2.pluginField(PluginField.atomicRanges))
      ranges.between(pos, pos, (from, to) => {
        if (from < pos && to > pos)
          pos = forward ? to : from;
      });
  return pos;
}
const deleteByChar = (target2, forward) => deleteBy(target2, (pos) => {
  let { state } = target2, line = state.doc.lineAt(pos), before, targetPos;
  if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
  }
  return skipAtomic(target2, targetPos, forward);
});
const deleteCharBackward = (view) => deleteByChar(view, false);
const deleteCharForward = (view) => deleteByChar(view, true);
const deleteByGroup = (target2, forward) => deleteBy(target2, (start) => {
  let pos = start, { state } = target2, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == start && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
    let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar2);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar2 != " " || pos != start)
      cat = nextCat;
    pos = next;
  }
  return skipAtomic(target2, pos, forward);
});
const deleteGroupBackward = (target2) => deleteByGroup(target2, false);
const deleteGroupForward = (target2) => deleteByGroup(target2, true);
const deleteToLineEnd = (view) => deleteBy(view, (pos) => {
  let lineEnd2 = view.lineBlockAt(pos).to;
  return skipAtomic(view, pos < lineEnd2 ? lineEnd2 : Math.min(view.state.doc.length, pos + 1), true);
});
const deleteToLineStart = (view) => deleteBy(view, (pos) => {
  let lineStart = view.lineBlockAt(pos).from;
  return skipAtomic(view, pos > lineStart ? lineStart : Math.max(0, pos - 1), false);
});
const splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range2) => {
    return {
      changes: { from: range2.from, to: range2.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range2.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
const transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range2) => {
    if (!range2.empty || range2.from == 0 || range2.from == state.doc.length)
      return { range: range2 };
    let pos = range2.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
    return {
      changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range2 of state.selection.ranges) {
    let startLine = state.doc.lineAt(range2.from), endLine = state.doc.lineAt(range2.to);
    if (!range2.empty && range2.to == endLine.from)
      endLine = state.doc.lineAt(range2.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range2);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range2] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block3 of selectedLineBlocks(state)) {
    if (forward ? block3.to == state.doc.length : block3.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block3.to + 1 : block3.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block3.to, to: nextLine.to }, { from: block3.from, insert: nextLine.text + state.lineBreak });
      for (let r of block3.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block3.from }, { from: block3.to, insert: state.lineBreak + nextLine.text });
      for (let r of block3.ranges)
        ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
const moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block3 of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block3.from, insert: state.doc.slice(block3.from, block3.to) + state.lineBreak });
    else
      changes.push({ from: block3.to, insert: state.lineBreak + state.doc.slice(block3.from, block3.to) });
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
const copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
const deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
    if (from > 0)
      from--;
    else if (to < state.doc.length)
      to++;
    return { from, to };
  }));
  let selection2 = updateSel(state.selection, (range2) => view.moveVertically(range2, true)).map(changes);
  view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)
    return { from: before.to, to: after.from };
  return null;
}
const insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
const insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range2) => {
      let { from, to } = range2, line = state.doc.lineAt(from);
      let explode = !atEof && from == to && isBetweenBrackets(state, from);
      if (atEof)
        from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
      let indent = getIndentation(cx, from);
      if (indent == null)
        indent = /^\s*/.exec(state.doc.lineAt(from).text)[0].length;
      while (to < line.to && /\s/.test(line.text[to - line.from]))
        to++;
      if (explode)
        ({ from, to } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from;
      let insert2 = ["", indentString(state, indent)];
      if (explode)
        insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: { from, to, insert: Text.of(insert2) },
        range: EditorSelection.cursor(from + 1 + insert2[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange((range2) => {
    let changes = [];
    for (let pos = range2.from; pos <= range2.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range2.empty || range2.to > line.from)) {
        f(line, changes, range2);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range2.anchor, 1), changeSet.mapPos(range2.head, 1))
    };
  });
}
const indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start) => {
    let found = updated[start];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line, changes2, range2) => {
    let indent = getIndentation(context, line.from);
    if (indent == null)
      return;
    if (!/\S/.test(line.text))
      indent = 0;
    let cur2 = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent);
    if (cur2 != norm || range2.from < line.from + cur2.length) {
      updated[line.from] = indent;
      changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
const indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({ from: line.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
const indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space2 = /^\s*/.exec(line.text)[0];
    if (!space2)
      return;
    let col = countColumn(space2, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space2.length && keep < insert2.length && space2.charCodeAt(keep) == insert2.charCodeAt(keep))
      keep++;
    changes.push({ from: line.from + keep, to: line.from + space2.length, insert: insert2.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
const emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
const standardKeymap = /* @__PURE__ */ [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
  { key: "Delete", run: deleteCharForward },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
  { mac: "Mod-Backspace", run: deleteToLineStart },
  { mac: "Mod-Delete", run: deleteToLineEnd }
].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
const defaultKeymap = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket }
].concat(standardKeymap);
const indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };
const defaults = {
  brackets: ["(", "[", "{", "'", '"'],
  before: `)]}'":;>`
};
const closeBracketEffect = /* @__PURE__ */ StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
const skipBracketEffect = /* @__PURE__ */ StateEffect.define({
  map(value, mapping) {
    return mapping.mapPos(value);
  }
});
const closedBracket = /* @__PURE__ */ new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
const bracketState = /* @__PURE__ */ StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(value, tr) {
    if (tr.selection) {
      let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
      let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
      if (lineStart != tr.changes.mapPos(prevLineStart, -1))
        value = RangeSet.empty;
    }
    value = value.map(tr.changes);
    for (let effect of tr.effects) {
      if (effect.is(closeBracketEffect))
        value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
      else if (effect.is(skipBracketEffect))
        value = value.update({ filter: (from) => from != effect.value });
    }
    return value;
  }
});
function closeBrackets() {
  return [inputHandler, bracketState];
}
const definedClosing = "()[]{}<>";
function closing(ch) {
  for (let i = 0; i < definedClosing.length; i += 2)
    if (definedClosing.charCodeAt(i) == ch)
      return definedClosing.charAt(i + 1);
  return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults;
}
const android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
const inputHandler = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, insert2) => {
  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
    return false;
  let sel = view.state.selection.main;
  if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from != sel.from || to != sel.to)
    return false;
  let tr = insertBracket(view.state, insert2);
  if (!tr)
    return false;
  view.dispatch(tr);
  return true;
});
const deleteBracketPair = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults.brackets;
  let dont = null, changes = state.changeByRange((range2) => {
    if (range2.empty) {
      let before = prevChar(state.doc, range2.head);
      for (let token2 of tokens) {
        if (token2 == before && nextChar(state.doc, range2.head) == closing(codePointAt(token2, 0)))
          return {
            changes: { from: range2.head - token2.length, to: range2.head + token2.length },
            range: EditorSelection.cursor(range2.head - token2.length),
            userEvent: "delete.backward"
          };
      }
    }
    return { range: dont = range2 };
  });
  if (!dont)
    dispatch(state.update(changes, { scrollIntoView: true }));
  return !dont;
};
const closeBracketsKeymap = [
  { key: "Backspace", run: deleteBracketPair }
];
function insertBracket(state, bracket2) {
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults.brackets;
  for (let tok of tokens) {
    let closed = closing(codePointAt(tok, 0));
    if (bracket2 == tok)
      return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1) : handleOpen(state, tok, closed, conf.before || defaults.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
      return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from) => {
    if (from == pos)
      found = true;
  });
  return found;
}
function nextChar(doc2, pos) {
  let next = doc2.sliceString(pos, pos + 2);
  return next.slice(0, codePointSize(codePointAt(next, 0)));
}
function prevChar(doc2, pos) {
  let prev = doc2.sliceString(pos - 2, pos);
  return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range2) => {
    if (!range2.empty)
      return {
        changes: [{ insert: open, from: range2.from }, { insert: close, from: range2.to }],
        effects: closeBracketEffect.of(range2.to + open.length),
        range: EditorSelection.range(range2.anchor + open.length, range2.head + open.length)
      };
    let next = nextChar(state.doc, range2.head);
    if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
      return {
        changes: { insert: open + close, from: range2.head },
        effects: closeBracketEffect.of(range2.head + open.length),
        range: EditorSelection.cursor(range2.head + open.length)
      };
    return { range: dont = range2 };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state, _open, close) {
  let dont = null, moved = state.selection.ranges.map((range2) => {
    if (range2.empty && nextChar(state.doc, range2.head) == close)
      return EditorSelection.cursor(range2.head + close.length);
    return dont = range2;
  });
  return dont ? null : state.update({
    selection: EditorSelection.create(moved, state.selection.mainIndex),
    scrollIntoView: true,
    effects: state.selection.ranges.map(({ from }) => skipBracketEffect.of(from))
  });
}
function handleSame(state, token2, allowTriple) {
  let dont = null, changes = state.changeByRange((range2) => {
    if (!range2.empty)
      return {
        changes: [{ insert: token2, from: range2.from }, { insert: token2, from: range2.to }],
        effects: closeBracketEffect.of(range2.to + token2.length),
        range: EditorSelection.range(range2.anchor + token2.length, range2.head + token2.length)
      };
    let pos = range2.head, next = nextChar(state.doc, pos);
    if (next == token2) {
      if (nodeStart$1(state, pos)) {
        return {
          changes: { insert: token2 + token2, from: pos },
          effects: closeBracketEffect.of(pos + token2.length),
          range: EditorSelection.cursor(pos + token2.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token2.length * 3) == token2 + token2 + token2;
        return {
          range: EditorSelection.cursor(pos + token2.length * (isTriple ? 3 : 1)),
          effects: skipBracketEffect.of(pos)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token2.length, pos) == token2 + token2 && nodeStart$1(state, pos - 2 * token2.length)) {
      return {
        changes: { insert: token2 + token2 + token2 + token2, from: pos },
        effects: closeBracketEffect.of(pos + token2.length),
        range: EditorSelection.cursor(pos + token2.length)
      };
    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
      let prev = state.sliceDoc(pos - 1, pos);
      if (prev != token2 && state.charCategorizer(pos)(prev) != CharCategory.Word && !probablyInString(state, pos, token2))
        return {
          changes: { insert: token2 + token2, from: pos },
          effects: closeBracketEffect.of(pos + token2.length),
          range: EditorSelection.cursor(pos + token2.length)
        };
    }
    return { range: dont = range2 };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart$1(state, pos) {
  let tree = syntaxTree(state).resolveInner(pos + 1);
  return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken) {
  let node = syntaxTree(state).resolveInner(pos, -1);
  for (let i = 0; i < 5; i++) {
    if (state.sliceDoc(node.from, node.from + quoteToken.length) == quoteToken)
      return true;
    let parent = node.to == pos && node.parent;
    if (!parent)
      break;
    node = parent;
  }
  return false;
}
const ios = typeof navigator != "undefined" && !/* @__PURE__ */ /Edge\/(\d+)/.exec(navigator.userAgent) && /* @__PURE__ */ /Apple Computer/.test(navigator.vendor) && (/* @__PURE__ */ /Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
const Outside = "-10000px";
class TooltipViewManager {
  constructor(view, facet, createTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter((t2) => t2);
    this.tooltipViews = this.tooltips.map(createTooltipView);
  }
  update(update) {
    let input = update.state.facet(this.facet);
    let tooltips = input.filter((x) => x);
    if (input === this.input) {
      for (let t2 of this.tooltipViews)
        if (t2.update)
          t2.update(update);
      return false;
    }
    let tooltipViews = [];
    for (let i = 0; i < tooltips.length; i++) {
      let tip = tooltips[i], known = -1;
      if (!tip)
        continue;
      for (let i2 = 0; i2 < this.tooltips.length; i2++) {
        let other = this.tooltips[i2];
        if (other && other.create == tip.create)
          known = i2;
      }
      if (known < 0) {
        tooltipViews[i] = this.createTooltipView(tip);
      } else {
        let tooltipView = tooltipViews[i] = this.tooltipViews[known];
        if (tooltipView.update)
          tooltipView.update(update);
      }
    }
    for (let t2 of this.tooltipViews)
      if (tooltipViews.indexOf(t2) < 0)
        t2.dom.remove();
    this.input = input;
    this.tooltips = tooltips;
    this.tooltipViews = tooltipViews;
    return true;
  }
}
function windowSpace() {
  return { top: 0, left: 0, bottom: innerHeight, right: innerWidth };
}
const tooltipConfig = /* @__PURE__ */ Facet.define({
  combine: (values2) => {
    var _a, _b, _c;
    return {
      position: ios ? "absolute" : ((_a = values2.find((conf) => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || "fixed",
      parent: ((_b = values2.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
      tooltipSpace: ((_c = values2.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
    };
  }
});
const tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    var _a;
    this.view = view;
    this.inView = true;
    this.lastTransaction = 0;
    this.measureTimeout = -1;
    let config2 = view.state.facet(tooltipConfig);
    this.position = config2.position;
    this.parent = config2.parent;
    this.classes = view.themeClasses;
    this.createContainer();
    this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
    this.manager = new TooltipViewManager(view, showTooltip, (t2) => this.createTooltip(t2));
    this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
      if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
        this.measureSoon();
    }, { threshold: [1] }) : null;
    this.observeIntersection();
    (_a = view.dom.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
    this.maybeMeasure();
  }
  createContainer() {
    if (this.parent) {
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.className = this.view.themeClasses;
      this.parent.appendChild(this.container);
    } else {
      this.container = this.view.dom;
    }
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let tooltip of this.manager.tooltipViews)
        this.intersectionObserver.observe(tooltip.dom);
    }
  }
  measureSoon() {
    if (this.measureTimeout < 0)
      this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1;
        this.maybeMeasure();
      }, 50);
  }
  update(update) {
    if (update.transactions.length)
      this.lastTransaction = Date.now();
    let updated = this.manager.update(update);
    if (updated)
      this.observeIntersection();
    let shouldMeasure = updated || update.geometryChanged;
    let newConfig = update.state.facet(tooltipConfig);
    if (newConfig.position != this.position) {
      this.position = newConfig.position;
      for (let t2 of this.manager.tooltipViews)
        t2.dom.style.position = this.position;
      shouldMeasure = true;
    }
    if (newConfig.parent != this.parent) {
      if (this.parent)
        this.container.remove();
      this.parent = newConfig.parent;
      this.createContainer();
      for (let t2 of this.manager.tooltipViews)
        this.container.appendChild(t2.dom);
      shouldMeasure = true;
    } else if (this.parent && this.view.themeClasses != this.classes) {
      this.classes = this.container.className = this.view.themeClasses;
    }
    if (shouldMeasure)
      this.maybeMeasure();
  }
  createTooltip(tooltip) {
    let tooltipView = tooltip.create(this.view);
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let arrow = document.createElement("div");
      arrow.className = "cm-tooltip-arrow";
      tooltipView.dom.appendChild(arrow);
    }
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    this.container.appendChild(tooltipView.dom);
    if (tooltipView.mount)
      tooltipView.mount(this.view);
    return tooltipView;
  }
  destroy() {
    var _a, _b;
    (_a = this.view.dom.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.removeEventListener("resize", this.measureSoon);
    for (let { dom } of this.manager.tooltipViews)
      dom.remove();
    (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let editor = this.view.dom.getBoundingClientRect();
    return {
      editor,
      parent: this.parent ? this.container.getBoundingClientRect() : editor,
      pos: this.manager.tooltips.map((t2) => this.view.coordsAtPos(t2.pos)),
      size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)
    };
  }
  writeMeasure(measured) {
    let { editor, space: space2 } = measured;
    let others = [];
    for (let i = 0; i < this.manager.tooltips.length; i++) {
      let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
      let pos = measured.pos[i], size = measured.size[i];
      if (!pos || pos.bottom <= Math.max(editor.top, space2.top) || pos.top >= Math.min(editor.bottom, space2.bottom) || pos.right < Math.max(editor.left, space2.left) - 0.1 || pos.left > Math.min(editor.right, space2.right) + 0.1) {
        dom.style.top = Outside;
        continue;
      }
      let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
      let arrowHeight = arrow ? 7 : 0;
      let width = size.right - size.left, height = size.bottom - size.top;
      let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
      let left = size.width > space2.right - space2.left ? ltr ? space2.left : space2.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space2.right - width) : Math.max(space2.left, pos.left - width + (arrow ? 14 : 0) - offset.x);
      let above = !!tooltip.above;
      if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space2.top : pos.bottom + (size.bottom - size.top) + offset.y > space2.bottom) && above == space2.bottom - pos.bottom > pos.top - space2.top)
        above = !above;
      let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
      let right = left + width;
      if (tView.overlap !== true) {
        for (let r of others)
          if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2)
            top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
      }
      if (this.position == "absolute") {
        dom.style.top = top2 - measured.parent.top + "px";
        dom.style.left = left - measured.parent.left + "px";
      } else {
        dom.style.top = top2 + "px";
        dom.style.left = left + "px";
      }
      if (arrow)
        arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7)}px`;
      if (tView.overlap !== true)
        others.push({ left, top: top2, right, bottom: top2 + height });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned)
        tView.positioned();
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView)
        this.view.requestMeasure(this.measureReq);
      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView)
          for (let tv of this.manager.tooltipViews)
            tv.dom.style.top = Outside;
      }
    }
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
const baseTheme$5 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 100
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
const noOffset = { x: 0, y: 0 };
const showTooltip = /* @__PURE__ */ Facet.define({
  enables: [tooltipPlugin, baseTheme$5]
});
const showHoverTooltip = /* @__PURE__ */ Facet.define();
class HoverTooltipHost {
  constructor(view) {
    this.view = view;
    this.mounted = false;
    this.dom = document.createElement("div");
    this.dom.classList.add("cm-tooltip-hover");
    this.manager = new TooltipViewManager(view, showHoverTooltip, (t2) => this.createHostedView(t2));
  }
  static create(view) {
    return new HoverTooltipHost(view);
  }
  createHostedView(tooltip) {
    let hostedView = tooltip.create(this.view);
    hostedView.dom.classList.add("cm-tooltip-section");
    this.dom.appendChild(hostedView.dom);
    if (this.mounted && hostedView.mount)
      hostedView.mount(this.view);
    return hostedView;
  }
  mount(view) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.mount)
        hostedView.mount(view);
    }
    this.mounted = true;
  }
  positioned() {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.positioned)
        hostedView.positioned();
    }
  }
  update(update) {
    this.manager.update(update);
  }
}
const showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state) => {
  let tooltips = state.facet(showHoverTooltip).filter((t2) => t2);
  if (tooltips.length === 0)
    return null;
  return {
    pos: Math.min(...tooltips.map((t2) => t2.pos)),
    end: Math.max(...tooltips.filter((t2) => t2.end != null).map((t2) => t2.end)),
    create: HoverTooltipHost.create,
    above: tooltips[0].above,
    arrow: tooltips.some((t2) => t2.arrow)
  };
});
class HoverPlugin {
  constructor(view, source, field, setHover, hoverTime) {
    this.view = view;
    this.source = source;
    this.field = field;
    this.setHover = setHover;
    this.hoverTime = hoverTime;
    this.hoverTimeout = -1;
    this.restartTimeout = -1;
    this.pending = null;
    this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
    this.checkHover = this.checkHover.bind(this);
    view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
    view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    if (this.pending) {
      this.pending = null;
      clearTimeout(this.restartTimeout);
      this.restartTimeout = setTimeout(() => this.startHover(), 20);
    }
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    this.hoverTimeout = -1;
    if (this.active)
      return;
    let hovered = Date.now() - this.lastMove.time;
    if (hovered < this.hoverTime)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
    else
      this.startHover();
  }
  startHover() {
    var _a;
    clearTimeout(this.restartTimeout);
    let { lastMove } = this;
    let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
    if (pos == null)
      return;
    let posCoords = this.view.coordsAtPos(pos);
    if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth)
      return;
    let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
    let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
    let open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);
    if ((_a = open) === null || _a === void 0 ? void 0 : _a.then) {
      let pending = this.pending = { pos };
      open.then((result) => {
        if (this.pending == pending) {
          this.pending = null;
          if (result)
            this.view.dispatch({ effects: this.setHover.of(result) });
        }
      }, (e) => logException(this.view.state, e, "hover tooltip"));
    } else if (open) {
      this.view.dispatch({ effects: this.setHover.of(open) });
    }
  }
  mousemove(event) {
    var _a;
    this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
    if (this.hoverTimeout < 0)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
    let tooltip = this.active;
    if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
      let { pos } = tooltip || this.pending, end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;
      if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6)) {
        this.view.dispatch({ effects: this.setHover.of(null) });
        this.pending = null;
      }
    }
  }
  mouseleave() {
    clearTimeout(this.hoverTimeout);
    this.hoverTimeout = -1;
    if (this.active)
      this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout);
    this.view.dom.removeEventListener("mouseleave", this.mouseleave);
    this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
function isInTooltip(elt2) {
  for (let cur2 = elt2; cur2; cur2 = cur2.parentNode)
    if (cur2.nodeType == 1 && cur2.classList.contains("cm-tooltip"))
      return true;
  return false;
}
function isOverRange(view, from, to, x, y, margin) {
  let range2 = document.createRange();
  let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
  range2.setEnd(toDOM.node, toDOM.offset);
  range2.setStart(fromDOM.node, fromDOM.offset);
  let rects = range2.getClientRects();
  range2.detach();
  for (let i = 0; i < rects.length; i++) {
    let rect2 = rects[i];
    let dist = Math.max(rect2.top - y, y - rect2.bottom, rect2.left - x, x - rect2.right);
    if (dist <= margin)
      return true;
  }
  return false;
}
function hoverTooltip(source, options = {}) {
  let setHover = StateEffect.define();
  let hoverState = StateField.define({
    create() {
      return null;
    },
    update(value, tr) {
      if (value && (options.hideOnChange && (tr.docChanged || tr.selection)))
        return null;
      for (let effect of tr.effects) {
        if (effect.is(setHover))
          return effect.value;
        if (effect.is(closeHoverTooltipEffect))
          return null;
      }
      if (value && tr.docChanged) {
        let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
        if (newPos == null)
          return null;
        let copy2 = Object.assign(/* @__PURE__ */ Object.create(null), value);
        copy2.pos = newPos;
        if (value.end != null)
          copy2.end = tr.changes.mapPos(value.end);
        return copy2;
      }
      return value;
    },
    provide: (f) => showHoverTooltip.from(f)
  });
  let hoverTime = options.hoverTime || 600;
  return [
    hoverState,
    ViewPlugin.define((view) => new HoverPlugin(view, source, hoverState, setHover, hoverTime)),
    showHoverTooltipHost
  ];
}
function getTooltip(view, tooltip) {
  let plugin = view.plugin(tooltipPlugin);
  if (!plugin)
    return null;
  let found = plugin.manager.tooltips.indexOf(tooltip);
  return found < 0 ? null : plugin.manager.tooltipViews[found];
}
const closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
class CompletionContext {
  constructor(state, pos, explicit) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    this.abortListeners = [];
  }
  tokenBefore(types2) {
    let token2 = syntaxTree(this.state).resolveInner(this.pos, -1);
    while (token2 && types2.indexOf(token2.name) < 0)
      token2 = token2.parent;
    return token2 ? {
      from: token2.from,
      to: this.pos,
      text: this.state.sliceDoc(token2.from, this.pos),
      type: token2.type
    } : null;
  }
  matchBefore(expr) {
    let line = this.state.doc.lineAt(this.pos);
    let start = Math.max(line.from, this.pos - 250);
    let str = line.text.slice(start - line.from, this.pos - line.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
  }
  get aborted() {
    return this.abortListeners == null;
  }
  addEventListener(type, listener) {
    if (type == "abort" && this.abortListeners)
      this.abortListeners.push(listener);
  }
}
function toSet(chars) {
  let flat2 = Object.keys(chars).join("");
  let words = /\w/.test(flat2);
  if (words)
    flat2 = flat2.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat2.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
  let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options) {
    first[label[0]] = true;
    for (let i = 1; i < label.length; i++)
      rest[label[i]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list3) {
  let options = list3.map((o) => typeof o == "string" ? { label: o } : o);
  let [span2, match2] = options.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
  return (context) => {
    let token2 = context.matchBefore(match2);
    return token2 || context.explicit ? { from: token2 ? token2.from : context.pos, options, span: span2 } : null;
  };
}
function ifNotIn(nodes, source) {
  return (context) => {
    for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent)
      if (nodes.indexOf(pos.name) > -1)
        return null;
    return source(context);
  };
}
class Option {
  constructor(completion, source, match2) {
    this.completion = completion;
    this.source = source;
    this.match = match2;
  }
}
function cur(state) {
  return state.selection.main.head;
}
function ensureAnchor(expr, start) {
  var _a;
  let { source } = expr;
  let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? "i" : "");
}
const pickedCompletion = /* @__PURE__ */ Annotation.define();
function applyCompletion(view, option) {
  let apply = option.completion.apply || option.completion.label;
  let result = option.source;
  if (typeof apply == "string") {
    view.dispatch({
      changes: { from: result.from, to: result.to, insert: apply },
      selection: { anchor: result.from + apply.length },
      userEvent: "input.complete",
      annotations: pickedCompletion.of(option.completion)
    });
  } else {
    apply(view, option.completion, result.from, result.to);
  }
}
const SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
class FuzzyMatcher {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    for (let p = 0; p < pattern.length; ) {
      let char = codePointAt(pattern, p), size = codePointSize(char);
      this.chars.push(char);
      let part2 = pattern.slice(p, p + size), upper = part2.toUpperCase();
      this.folded.push(codePointAt(upper == part2 ? part2.toLowerCase() : upper, 0));
      p += size;
    }
    this.astral = pattern.length != this.chars.length;
  }
  match(word) {
    if (this.pattern.length == 0)
      return [0];
    if (word.length < this.pattern.length)
      return null;
    let { chars, folded, any, precise, byWord } = this;
    if (chars.length == 1) {
      let first = codePointAt(word, 0);
      return first == chars[0] ? [0, 0, codePointSize(first)] : first == folded[0] ? [-200, 0, codePointSize(first)] : null;
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0)
      return [0, 0, this.pattern.length];
    let len = chars.length, anyTo = 0;
    if (direct < 0) {
      for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {
        let next = codePointAt(word, i);
        if (next == chars[anyTo] || next == folded[anyTo])
          any[anyTo++] = i;
        i += codePointSize(next);
      }
      if (anyTo < len)
        return null;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word), wordAdjacent = true;
    for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {
      let next = codePointAt(word, i);
      if (direct < 0) {
        if (preciseTo < len && next == chars[preciseTo])
          precise[preciseTo++] = i;
        if (adjacentTo < len) {
          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
            if (adjacentTo == 0)
              adjacentStart = i;
            adjacentEnd = i + 1;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
      if (!i || type == 1 && hasLower || prevType == 0 && type != 0) {
        if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
          byWord[byWordTo++] = i;
        else if (byWord.length)
          wordAdjacent = false;
      }
      prevType = type;
      i += codePointSize(next);
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0)
      return [-200 - word.length, 0, adjacentEnd];
    if (direct > -1)
      return [-700 - word.length, direct, direct + this.pattern.length];
    if (adjacentTo == len)
      return [-200 + -700 - word.length, adjacentStart, adjacentEnd];
    if (byWordTo == len)
      return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
    return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
  }
  result(score2, positions, word) {
    let result = [score2 - word.length], i = 1;
    for (let pos of positions) {
      let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
      if (i > 1 && result[i - 1] == pos)
        result[i - 1] = to;
      else {
        result[i++] = pos;
        result[i++] = to;
      }
    }
    return result;
  }
}
const completionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      activateOnTyping: true,
      override: null,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: []
    }, {
      defaultKeymap: (a, b) => a && b,
      icons: (a, b) => a && b,
      optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
      addToOptions: (a, b) => a.concat(b)
    });
  }
});
function joinClass(a, b) {
  return a ? b ? a + " " + b : a : b;
}
function optionContent(config2) {
  let content2 = config2.addToOptions.slice();
  if (config2.icons)
    content2.push({
      render(completion) {
        let icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type)
          icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
  content2.push({
    render(completion, _s, match2) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let { label } = completion, off = 0;
      for (let j = 1; j < match2.length; ) {
        let from = match2[j++], to = match2[j++];
        if (from > off)
          labelElt.appendChild(document.createTextNode(label.slice(off, from)));
        let span2 = labelElt.appendChild(document.createElement("span"));
        span2.appendChild(document.createTextNode(label.slice(from, to)));
        span2.className = "cm-completionMatchedText";
        off = to;
      }
      if (off < label.length)
        labelElt.appendChild(document.createTextNode(label.slice(off)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail)
        return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content2.sort((a, b) => a.position - b.position).map((a) => a.render);
}
function createInfoDialog(option, view) {
  let dom = document.createElement("div");
  dom.className = "cm-tooltip cm-completionInfo";
  let { info } = option.completion;
  if (typeof info == "string") {
    dom.textContent = info;
  } else {
    let content2 = info(option.completion);
    if (content2.then)
      content2.then((node) => dom.appendChild(node), (e) => logException(view.state, e, "completion info"));
    else
      dom.appendChild(content2);
  }
  return dom;
}
function rangeAroundSelected(total, selected, max) {
  if (total <= max)
    return { from: 0, to: total };
  if (selected <= total >> 1) {
    let off2 = Math.floor(selected / max);
    return { from: off2 * max, to: (off2 + 1) * max };
  }
  let off = Math.floor((total - selected) / max);
  return { from: total - (off + 1) * max, to: total - off * max };
}
class CompletionTooltip {
  constructor(view, stateField) {
    this.view = view;
    this.stateField = stateField;
    this.info = null;
    this.placeInfo = {
      read: () => this.measureInfo(),
      write: (pos) => this.positionInfo(pos),
      key: this
    };
    let cState = view.state.field(stateField);
    let { options, selected } = cState.open;
    let config2 = view.state.facet(completionConfig);
    this.optionContent = optionContent(config2);
    this.optionClass = config2.optionClass;
    this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.dom.addEventListener("mousedown", (e) => {
      for (let dom = e.target, match2; dom && dom != this.dom; dom = dom.parentNode) {
        if (dom.nodeName == "LI" && (match2 = /-(\d+)$/.exec(dom.id)) && +match2[1] < options.length) {
          applyCompletion(view, options[+match2[1]]);
          e.preventDefault();
          return;
        }
      }
    });
    this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info)
        this.view.requestMeasure(this.placeInfo);
    });
  }
  mount() {
    this.updateSel();
  }
  update(update) {
    if (update.state.field(this.stateField) != update.startState.field(this.stateField))
      this.updateSel();
  }
  positioned() {
    if (this.info)
      this.view.requestMeasure(this.placeInfo);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.list.remove();
      this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info)
          this.view.requestMeasure(this.placeInfo);
      });
    }
    if (this.updateSelectedOption(open.selected)) {
      if (this.info) {
        this.info.remove();
        this.info = null;
      }
      let option = open.options[open.selected];
      if (option.completion.info) {
        this.info = this.dom.appendChild(createInfoDialog(option, this.view));
        this.view.requestMeasure(this.placeInfo);
      }
    }
  }
  updateSelectedOption(selected) {
    let set2 = null;
    for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
      if (i == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set2 = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected"))
          opt.removeAttribute("aria-selected");
      }
    }
    if (set2)
      scrollIntoView(this.list, set2);
    return set2;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel || !this.info)
      return null;
    let listRect = this.dom.getBoundingClientRect();
    let infoRect = this.info.getBoundingClientRect();
    let selRect = sel.getBoundingClientRect();
    if (selRect.top > Math.min(innerHeight, listRect.bottom) - 10 || selRect.bottom < Math.max(0, listRect.top) + 10)
      return null;
    let top2 = Math.max(0, Math.min(selRect.top, innerHeight - infoRect.height)) - listRect.top;
    let left = this.view.textDirection == Direction.RTL;
    let spaceLeft = listRect.left, spaceRight = innerWidth - listRect.right;
    if (left && spaceLeft < Math.min(infoRect.width, spaceRight))
      left = false;
    else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft))
      left = true;
    return { top: top2, left };
  }
  positionInfo(pos) {
    if (this.info) {
      this.info.style.top = (pos ? pos.top : -1e6) + "px";
      if (pos) {
        this.info.classList.toggle("cm-completionInfo-left", pos.left);
        this.info.classList.toggle("cm-completionInfo-right", !pos.left);
      }
    }
  }
  createListBox(options, id2, range2) {
    const ul = document.createElement("ul");
    ul.id = id2;
    ul.setAttribute("role", "listbox");
    for (let i = range2.from; i < range2.to; i++) {
      let { completion, match: match2 } = options[i];
      const li = ul.appendChild(document.createElement("li"));
      li.id = id2 + "-" + i;
      li.setAttribute("role", "option");
      let cls = this.optionClass(completion);
      if (cls)
        li.className = cls;
      for (let source of this.optionContent) {
        let node = source(completion, this.view.state, match2);
        if (node)
          li.appendChild(node);
      }
    }
    if (range2.from)
      ul.classList.add("cm-completionListIncompleteTop");
    if (range2.to < options.length)
      ul.classList.add("cm-completionListIncompleteBottom");
    return ul;
  }
}
function completionTooltip(stateField) {
  return (view) => new CompletionTooltip(view, stateField);
}
function scrollIntoView(container, element) {
  let parent = container.getBoundingClientRect();
  let self2 = element.getBoundingClientRect();
  if (self2.top < parent.top)
    container.scrollTop -= parent.top - self2.top;
  else if (self2.bottom > parent.bottom)
    container.scrollTop += self2.bottom - parent.bottom;
}
const MaxOptions = 300;
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state) {
  let options = [], i = 0;
  for (let a of active)
    if (a.hasResult()) {
      if (a.result.filter === false) {
        for (let option of a.result.options)
          options.push(new Option(option, a, [1e9 - i++]));
      } else {
        let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)), match2;
        for (let option of a.result.options)
          if (match2 = matcher.match(option.label)) {
            if (option.boost != null)
              match2[0] += option.boost;
            options.push(new Option(option, a, match2));
          }
      }
    }
  options.sort(cmpOption);
  let result = [], prev = null;
  for (let opt of options.sort(cmpOption)) {
    if (result.length == MaxOptions)
      break;
    if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != opt.completion.type || prev.apply != opt.completion.apply)
      result.push(opt);
    else if (score(opt.completion) > score(prev))
      result[result.length - 1] = opt;
    prev = opt.completion;
  }
  return result;
}
class CompletionDialog {
  constructor(options, attrs, tooltip, timestamp, selected) {
    this.options = options;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
  }
  setSelected(selected, id2) {
    return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected);
  }
  static build(active, state, id2, prev, conf) {
    let options = sortOptions(active, state);
    if (!options.length)
      return null;
    let selected = 0;
    if (prev && prev.selected) {
      let selectedValue = prev.options[prev.selected].completion;
      for (let i = 0; i < options.length && !selected; i++) {
        if (options[i].completion == selectedValue)
          selected = i;
      }
    }
    return new CompletionDialog(options, makeAttrs(id2, selected), {
      pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
      create: completionTooltip(completionState),
      above: conf.aboveCursor
    }, prev ? prev.timestamp : Date.now(), selected);
  }
  map(changes) {
    return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected);
  }
}
class CompletionState {
  constructor(active, id2, open) {
    this.active = active;
    this.id = id2;
    this.open = open;
  }
  static start() {
    return new CompletionState(none$1, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr) {
    let { state } = tr, conf = state.facet(completionConfig);
    let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active = sources.map((source) => {
      let value = this.active.find((s) => s.source == source) || new ActiveSource(source, this.active.some((a) => a.state != 0) ? 1 : 0);
      return value.update(tr, conf);
    });
    if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
      active = this.active;
    let open = tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open, conf) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;
    if (!open && active.every((a) => a.state != 1) && active.some((a) => a.hasResult()))
      active = active.map((a) => a.hasResult() ? new ActiveSource(a.source, 0) : a);
    for (let effect of tr.effects)
      if (effect.is(setSelectedEffect))
        open = open && open.setSelected(effect.value, this.id);
    return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : baseAttrs;
  }
}
function sameResults(a, b) {
  if (a == b)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a.length && !a[iA].hasResult)
      iA++;
    while (iB < b.length && !b[iB].hasResult)
      iB++;
    let endA = iA == a.length, endB = iB == b.length;
    if (endA || endB)
      return endA == endB;
    if (a[iA++].result != b[iB++].result)
      return false;
  }
}
const baseAttrs = {
  "aria-autocomplete": "list",
  "aria-expanded": "false"
};
function makeAttrs(id2, selected) {
  return {
    "aria-autocomplete": "list",
    "aria-expanded": "true",
    "aria-activedescendant": id2 + "-" + selected,
    "aria-controls": id2
  };
}
const none$1 = [];
function cmpOption(a, b) {
  let dScore = b.match[0] - a.match[0];
  if (dScore)
    return dScore;
  return a.completion.label.localeCompare(b.completion.label);
}
function getUserEvent(tr) {
  return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
}
class ActiveSource {
  constructor(source, state, explicitPos = -1) {
    this.source = source;
    this.state = state;
    this.explicitPos = explicitPos;
  }
  hasResult() {
    return false;
  }
  update(tr, conf) {
    let event = getUserEvent(tr), value = this;
    if (event)
      value = value.handleUserEvent(tr, event, conf);
    else if (tr.docChanged)
      value = value.handleChange(tr);
    else if (tr.selection && value.state != 0)
      value = new ActiveSource(value.source, 0);
    for (let effect of tr.effects) {
      if (effect.is(startCompletionEffect))
        value = new ActiveSource(value.source, 1, effect.value ? cur(tr.state) : -1);
      else if (effect.is(closeCompletionEffect))
        value = new ActiveSource(value.source, 0);
      else if (effect.is(setActiveEffect)) {
        for (let active of effect.value)
          if (active.source == value.source)
            value = active;
      }
    }
    return value;
  }
  handleUserEvent(tr, type, conf) {
    return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1);
  }
  handleChange(tr) {
    return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
  }
  map(changes) {
    return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
  }
}
class ActiveResult extends ActiveSource {
  constructor(source, explicitPos, result, from, to, span2) {
    super(source, 2, explicitPos);
    this.result = result;
    this.from = from;
    this.to = to;
    this.span = span2;
  }
  hasResult() {
    return true;
  }
  handleUserEvent(tr, type, conf) {
    let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
    let pos = cur(tr.state);
    if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == "delete" && cur(tr.startState) == this.from)
      return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1 : 0);
    let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos);
    if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to))))
      return new ActiveResult(this.source, explicitPos, this.result, from, to, this.span);
    return new ActiveSource(this.source, 1, explicitPos);
  }
  handleChange(tr) {
    return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
  }
  map(mapping) {
    return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);
  }
}
const startCompletionEffect = /* @__PURE__ */ StateEffect.define();
const closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
const setActiveEffect = /* @__PURE__ */ StateEffect.define({
  map(sources, mapping) {
    return sources.map((s) => s.map(mapping));
  }
});
const setSelectedEffect = /* @__PURE__ */ StateEffect.define();
const completionState = /* @__PURE__ */ StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr) {
    return value.update(tr);
  },
  provide: (f) => [
    showTooltip.from(f, (val) => val.tooltip),
    EditorView.contentAttributes.from(f, (state) => state.attrs)
  ]
});
const CompletionInteractMargin = 75;
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)
      return false;
    let step = 1, tooltip;
    if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
      step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
    let selected = cState.open.selected + step * (forward ? 1 : -1), { length } = cState.open.options;
    if (selected < 0)
      selected = by == "page" ? 0 : length - 1;
    else if (selected >= length)
      selected = by == "page" ? length - 1 : 0;
    view.dispatch({ effects: setSelectedEffect.of(selected) });
    return true;
  };
}
const acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (view.state.readOnly || !cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)
    return false;
  applyCompletion(view, cState.open.options[cState.open.selected]);
  return true;
};
const startCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState)
    return false;
  view.dispatch({ effects: startCompletionEffect.of(true) });
  return true;
};
const closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some((a) => a.state != 0))
    return false;
  view.dispatch({ effects: closeCompletionEffect.of(null) });
  return true;
};
class RunningQuery {
  constructor(active, context) {
    this.active = active;
    this.context = context;
    this.time = Date.now();
    this.updates = [];
    this.done = void 0;
  }
}
const DebounceTime = 50, MaxUpdateCount = 50, MinAbortTime = 1e3;
const completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.debounceUpdate = -1;
    this.running = [];
    this.debounceAccept = -1;
    this.composing = 0;
    for (let active of view.state.field(completionState).active)
      if (active.state == 1)
        this.startQuery(active);
  }
  update(update) {
    let cState = update.state.field(completionState);
    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
      return;
    let doesReset = update.transactions.some((tr) => {
      return (tr.selection || tr.docChanged) && !getUserEvent(tr);
    });
    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && query.time - Date.now() > MinAbortTime) {
        for (let handler of query.context.abortListeners) {
          try {
            handler();
          } catch (e) {
            logException(this.view.state, e);
          }
        }
        query.context.abortListeners = null;
        this.running.splice(i--, 1);
      } else {
        query.updates.push(...update.transactions);
      }
    }
    if (this.debounceUpdate > -1)
      clearTimeout(this.debounceUpdate);
    this.debounceUpdate = cState.active.some((a) => a.state == 1 && !this.running.some((q) => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
    if (this.composing != 0)
      for (let tr of update.transactions) {
        if (getUserEvent(tr) == "input")
          this.composing = 2;
        else if (this.composing == 2 && tr.selection)
          this.composing = 3;
      }
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state } = this.view, cState = state.field(completionState);
    for (let active of cState.active) {
      if (active.state == 1 && !this.running.some((r) => r.active.source == active.source))
        this.startQuery(active);
    }
  }
  startQuery(active) {
    let { state } = this.view, pos = cur(state);
    let context = new CompletionContext(state, pos, active.explicitPos == pos);
    let pending = new RunningQuery(active, context);
    this.running.push(pending);
    Promise.resolve(active.source(context)).then((result) => {
      if (!pending.context.aborted) {
        pending.done = result || null;
        this.scheduleAccept();
      }
    }, (err) => {
      this.view.dispatch({ effects: closeCompletionEffect.of(null) });
      logException(this.view.state, err);
    });
  }
  scheduleAccept() {
    if (this.running.every((q) => q.done !== void 0))
      this.accept();
    else if (this.debounceAccept < 0)
      this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
  }
  accept() {
    var _a;
    if (this.debounceAccept > -1)
      clearTimeout(this.debounceAccept);
    this.debounceAccept = -1;
    let updated = [];
    let conf = this.view.state.facet(completionConfig);
    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (query.done === void 0)
        continue;
      this.running.splice(i--, 1);
      if (query.done) {
        let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state), query.done.span && query.done.filter !== false ? ensureAnchor(query.done.span, true) : null);
        for (let tr of query.updates)
          active = active.update(tr, conf);
        if (active.hasResult()) {
          updated.push(active);
          continue;
        }
      }
      let current = this.view.state.field(completionState).active.find((a) => a.source == query.active.source);
      if (current && current.state == 1) {
        if (query.done == null) {
          let active = new ActiveSource(query.active.source, 0);
          for (let tr of query.updates)
            active = active.update(tr, conf);
          if (active.state != 1)
            updated.push(active);
        } else {
          this.startQuery(current);
        }
      }
    }
    if (updated.length)
      this.view.dispatch({ effects: setActiveEffect.of(updated) });
  }
}, {
  eventHandlers: {
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      if (this.composing == 3) {
        setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
      }
      this.composing = 0;
    }
  }
});
const baseTheme$4 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer",
        padding: "1px 3px",
        lineHeight: 1.2
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"\xB7\xB7\xB7"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "300px"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'\u0192'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'\u25CB'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'\u25CC'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'\u{1D465}'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'\u{1D436}'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'\u{1D461}'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'\u222A'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'\u25A1'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'\u{1F511}\uFE0E'" }
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'\u25A2'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class FieldPos {
  constructor(field, line, from, to) {
    this.field = field;
    this.line = line;
    this.from = from;
    this.to = to;
  }
}
class FieldRange {
  constructor(field, from, to) {
    this.field = field;
    this.from = from;
    this.to = to;
  }
  map(changes) {
    let from = changes.mapPos(this.from, -1, MapMode.TrackDel);
    let to = changes.mapPos(this.to, 1, MapMode.TrackDel);
    return from == null || to == null ? null : new FieldRange(this.field, from, to);
  }
}
class Snippet {
  constructor(lines, fieldPositions) {
    this.lines = lines;
    this.fieldPositions = fieldPositions;
  }
  instantiate(state, pos) {
    let text3 = [], lineStart = [pos];
    let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
    for (let line of this.lines) {
      if (text3.length) {
        let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
        for (let i = 0; i < tabs; i++)
          indent += state.facet(indentUnit);
        lineStart.push(pos + indent.length - tabs);
        line = indent + line.slice(tabs);
      }
      text3.push(line);
      pos += line.length + 1;
    }
    let ranges = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
    return { text: text3, ranges };
  }
  static parse(template2) {
    let fields = [];
    let lines = [], positions = [], m;
    for (let line of template2.split(/\r\n?|\n/)) {
      while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line)) {
        let seq = m[1] ? +m[1] : null, name2 = m[2] || m[3] || "", found = -1;
        for (let i = 0; i < fields.length; i++) {
          if (seq != null ? fields[i].seq == seq : name2 ? fields[i].name == name2 : false)
            found = i;
        }
        if (found < 0) {
          let i = 0;
          while (i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))
            i++;
          fields.splice(i, 0, { seq, name: name2 });
          found = i;
          for (let pos of positions)
            if (pos.field >= found)
              pos.field++;
        }
        positions.push(new FieldPos(found, lines.length, m.index, m.index + name2.length));
        line = line.slice(0, m.index) + name2 + line.slice(m.index + m[0].length);
      }
      lines.push(line);
    }
    return new Snippet(lines, positions);
  }
}
let fieldMarker = /* @__PURE__ */ Decoration.widget({ widget: /* @__PURE__ */ new class extends WidgetType {
  toDOM() {
    let span2 = document.createElement("span");
    span2.className = "cm-snippetFieldPosition";
    return span2;
  }
  ignoreEvent() {
    return false;
  }
}() });
let fieldRange = /* @__PURE__ */ Decoration.mark({ class: "cm-snippetField" });
class ActiveSnippet {
  constructor(ranges, active) {
    this.ranges = ranges;
    this.active = active;
    this.deco = Decoration.set(ranges.map((r) => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
  }
  map(changes) {
    let ranges = [];
    for (let r of this.ranges) {
      let mapped = r.map(changes);
      if (!mapped)
        return null;
      ranges.push(mapped);
    }
    return new ActiveSnippet(ranges, this.active);
  }
  selectionInsideField(sel) {
    return sel.ranges.every((range2) => this.ranges.some((r) => r.field == this.active && r.from <= range2.from && r.to >= range2.to));
  }
}
const setActive = /* @__PURE__ */ StateEffect.define({
  map(value, changes) {
    return value && value.map(changes);
  }
});
const moveToField = /* @__PURE__ */ StateEffect.define();
const snippetState = /* @__PURE__ */ StateField.define({
  create() {
    return null;
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setActive))
        return effect.value;
      if (effect.is(moveToField) && value)
        return new ActiveSnippet(value.ranges, effect.value);
    }
    if (value && tr.docChanged)
      value = value.map(tr.changes);
    if (value && tr.selection && !value.selectionInsideField(tr.selection))
      value = null;
    return value;
  },
  provide: (f) => EditorView.decorations.from(f, (val) => val ? val.deco : Decoration.none)
});
function fieldSelection(ranges, field) {
  return EditorSelection.create(ranges.filter((r) => r.field == field).map((r) => EditorSelection.range(r.from, r.to)));
}
function snippet(template2) {
  let snippet2 = Snippet.parse(template2);
  return (editor, _completion, from, to) => {
    let { text: text3, ranges } = snippet2.instantiate(editor.state, from);
    let spec = { changes: { from, to, insert: Text.of(text3) } };
    if (ranges.length)
      spec.selection = fieldSelection(ranges, 0);
    if (ranges.length > 1) {
      let active = new ActiveSnippet(ranges, 0);
      let effects = spec.effects = [setActive.of(active)];
      if (editor.state.field(snippetState, false) === void 0)
        effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme$4]));
    }
    editor.dispatch(editor.state.update(spec));
  };
}
function moveField(dir) {
  return ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active || dir < 0 && active.active == 0)
      return false;
    let next = active.active + dir, last = dir > 0 && !active.ranges.some((r) => r.field == next + dir);
    dispatch(state.update({
      selection: fieldSelection(active.ranges, next),
      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))
    }));
    return true;
  };
}
const clearSnippet = ({ state, dispatch }) => {
  let active = state.field(snippetState, false);
  if (!active)
    return false;
  dispatch(state.update({ effects: setActive.of(null) }));
  return true;
};
const nextSnippetField = /* @__PURE__ */ moveField(1);
const prevSnippetField = /* @__PURE__ */ moveField(-1);
const defaultSnippetKeymap = [
  { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
  { key: "Escape", run: clearSnippet }
];
const snippetKeymap = /* @__PURE__ */ Facet.define({
  combine(maps) {
    return maps.length ? maps[0] : defaultSnippetKeymap;
  }
});
const addSnippetKeymap = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
function snippetCompletion(template2, completion) {
  return Object.assign(Object.assign({}, completion), { apply: snippet(template2) });
}
const snippetPointerHandler = /* @__PURE__ */ EditorView.domEventHandlers({
  mousedown(event, view) {
    let active = view.state.field(snippetState, false), pos;
    if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
      return false;
    let match2 = active.ranges.find((r) => r.from <= pos && r.to >= pos);
    if (!match2 || match2.field == active.active)
      return false;
    view.dispatch({
      selection: fieldSelection(active.ranges, match2.field),
      effects: setActive.of(active.ranges.some((r) => r.field > match2.field) ? new ActiveSnippet(active.ranges, match2.field) : null)
    });
    return true;
  }
});
function autocompletion(config2 = {}) {
  return [
    completionState,
    completionConfig.of(config2),
    completionPlugin,
    completionKeymapExt,
    baseTheme$4
  ];
}
const completionKeymap = [
  { key: "Ctrl-Space", run: startCompletion },
  { key: "Escape", run: closeCompletion },
  { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
  { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
  { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
  { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
  { key: "Enter", run: acceptCompletion }
];
const completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
const panelConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let topContainer, bottomContainer;
    for (let c of configs) {
      topContainer = topContainer || c.topContainer;
      bottomContainer = bottomContainer || c.bottomContainer;
    }
    return { topContainer, bottomContainer };
  }
});
function getPanel(view, panel) {
  let plugin = view.plugin(panelPlugin);
  let index2 = plugin ? plugin.specs.indexOf(panel) : -1;
  return index2 > -1 ? plugin.panels[index2] : null;
}
const panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter((s) => s);
    this.panels = this.specs.map((spec) => spec(view));
    let conf = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf.topContainer);
    this.bottom = new PanelGroup(view, false, conf.bottomContainer);
    this.top.sync(this.panels.filter((p) => p.top));
    this.bottom.sync(this.panels.filter((p) => !p.top));
    for (let p of this.panels) {
      p.dom.classList.add("cm-panel");
      if (p.mount)
        p.mount();
    }
  }
  update(update) {
    let conf = update.state.facet(panelConfig);
    if (this.top.container != conf.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update.view, true, conf.topContainer);
    }
    if (this.bottom.container != conf.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
    }
    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update.state.facet(showPanel);
    if (input != this.input) {
      let specs = input.filter((x) => x);
      let panels = [], top2 = [], bottom2 = [], mount = [];
      for (let spec of specs) {
        let known = this.specs.indexOf(spec), panel;
        if (known < 0) {
          panel = spec(update.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update)
            panel.update(update);
        }
        panels.push(panel);
        (panel.top ? top2 : bottom2).push(panel);
      }
      this.specs = specs;
      this.panels = panels;
      this.top.sync(top2);
      this.bottom.sync(bottom2);
      for (let p of mount) {
        p.dom.classList.add("cm-panel");
        if (p.mount)
          p.mount();
      }
    } else {
      for (let p of this.panels)
        if (p.update)
          p.update(update);
    }
  }
  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }
}, {
  provide: /* @__PURE__ */ PluginField.scrollMargins.from((value) => ({ top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() }))
});
class PanelGroup {
  constructor(view, top2, container) {
    this.view = view;
    this.top = top2;
    this.container = container;
    this.dom = void 0;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }
  sync(panels) {
    for (let p of this.panels)
      if (p.destroy && panels.indexOf(p) < 0)
        p.destroy();
    this.panels = panels;
    this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = void 0;
      }
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent = this.container || this.view.dom;
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
    }
    let curDOM = this.dom.firstChild;
    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom)
          curDOM = rm(curDOM);
        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }
    while (curDOM)
      curDOM = rm(curDOM);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses)
      return;
    for (let cls of this.classes.split(" "))
      if (cls)
        this.container.classList.remove(cls);
    for (let cls of (this.classes = this.view.themeClasses).split(" "))
      if (cls)
        this.container.classList.add(cls);
  }
}
function rm(node) {
  let next = node.nextSibling;
  node.remove();
  return next;
}
const baseTheme$3 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  }
});
const showPanel = /* @__PURE__ */ Facet.define({
  enables: [panelPlugin, baseTheme$3]
});
function crelt() {
  var elt2 = arguments[0];
  if (typeof elt2 == "string")
    elt2 = document.createElement(elt2);
  var i = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name2 in next)
      if (Object.prototype.hasOwnProperty.call(next, name2)) {
        var value = next[name2];
        if (typeof value == "string")
          elt2.setAttribute(name2, value);
        else if (value != null)
          elt2[name2] = value;
      }
    i++;
  }
  for (; i < arguments.length; i++)
    add2(elt2, arguments[i]);
  return elt2;
}
function add2(elt2, child) {
  if (typeof child == "string") {
    elt2.appendChild(document.createTextNode(child));
  } else if (child == null)
    ;
  else if (child.nodeType != null) {
    elt2.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++)
      add2(elt2, child[i]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}
const basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
class SearchCursor {
  constructor(text3, query, from = 0, to = text3.length, normalize4) {
    this.value = { from: 0, to: 0 };
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text3.iterRange(from, to);
    this.bufferStart = from;
    this.normalize = normalize4 ? (x) => normalize4(basicNormalize(x)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done)
        return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt(this.buffer, this.bufferPos);
  }
  next() {
    while (this.matches.length)
      this.matches.pop();
    return this.nextOverlapping();
  }
  nextOverlapping() {
    for (; ; ) {
      let next = this.peek();
      if (next < 0) {
        this.done = true;
        return this;
      }
      let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize(next);
      let norm = this.normalize(str);
      for (let i = 0, pos = start; ; i++) {
        let code2 = norm.charCodeAt(i);
        let match2 = this.match(code2, pos);
        if (match2) {
          this.value = match2;
          return this;
        }
        if (i == norm.length - 1)
          break;
        if (pos == start && i < str.length && str.charCodeAt(i) == code2)
          pos++;
      }
    }
  }
  match(code2, pos) {
    let match2 = null;
    for (let i = 0; i < this.matches.length; i += 2) {
      let index2 = this.matches[i], keep = false;
      if (this.query.charCodeAt(index2) == code2) {
        if (index2 == this.query.length - 1) {
          match2 = { from: this.matches[i + 1], to: pos + 1 };
        } else {
          this.matches[i]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i, 2);
        i -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code2) {
      if (this.query.length == 1)
        match2 = { from: pos, to: pos + 1 };
      else
        this.matches.push(1, pos);
    }
    return match2;
  }
}
if (typeof Symbol != "undefined")
  SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
const empty = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
class RegExpCursor {
  constructor(text3, query, options, from = 0, to = text3.length) {
    this.to = to;
    this.curLine = "";
    this.done = false;
    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text3, query, options, from, to);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.iter = text3.iter();
    let startLine = text3.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = from;
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to)
      this.curLine = "";
    else
      this.getLine(0);
  }
  next() {
    for (let off = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off;
      let match2 = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match2) {
        let from = this.curLineStart + match2.index, to = from + match2[0].length;
        this.matchPos = to + (from == to ? 1 : 0);
        if (from == this.curLine.length)
          this.nextLine();
        if (from < to || from > this.value.to) {
          this.value = { from, to, match: match2 };
          return this;
        }
        off = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
}
const flattened = /* @__PURE__ */ new WeakMap();
class FlattenedDoc {
  constructor(from, text3) {
    this.from = from;
    this.text = text3;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc2, from, to) {
    let cached = flattened.get(doc2);
    if (!cached || cached.from >= to || cached.to <= from) {
      let flat2 = new FlattenedDoc(from, doc2.sliceString(from, to));
      flattened.set(doc2, flat2);
      return flat2;
    }
    if (cached.from == from && cached.to == to)
      return cached;
    let { text: text3, from: cachedFrom } = cached;
    if (cachedFrom > from) {
      text3 = doc2.sliceString(from, cachedFrom) + text3;
      cachedFrom = from;
    }
    if (cached.to < to)
      text3 += doc2.sliceString(cached.to, to);
    flattened.set(doc2, new FlattenedDoc(cachedFrom, text3));
    return new FlattenedDoc(from, text3.slice(from - cachedFrom, to - cachedFrom));
  }
}
class MultilineRegExpCursor {
  constructor(text3, query, options, from, to) {
    this.text = text3;
    this.to = to;
    this.done = false;
    this.value = empty;
    this.matchPos = from;
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.flat = FlattenedDoc.get(text3, from, this.chunkEnd(from + 5e3));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off = this.re.lastIndex = this.matchPos - this.flat.from;
      let match2 = this.re.exec(this.flat.text);
      if (match2 && !match2[0] && match2.index == off) {
        this.re.lastIndex = off + 1;
        match2 = this.re.exec(this.flat.text);
      }
      if (match2 && this.flat.to < this.to && match2.index + match2[0].length > this.flat.text.length - 10)
        match2 = null;
      if (match2) {
        let from = this.flat.from + match2.index, to = from + match2[0].length;
        this.value = { from, to, match: match2 };
        this.matchPos = to + (from == to ? 1 : 0);
        return this;
      } else {
        if (this.flat.to == this.to) {
          this.done = true;
          return this;
        }
        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  }
}
if (typeof Symbol != "undefined") {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a) {
    return false;
  }
}
function createLineDialog(view) {
  let input = crelt("input", { class: "cm-textfield", name: "line" });
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({ effects: dialogEffect.of(false) });
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
  function go() {
    let match2 = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match2)
      return;
    let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl, percent2] = match2;
    let col = cl ? +cl.slice(1) : 0;
    let line = ln ? +ln : startLine.number;
    if (ln && percent2) {
      let pc = line / 100;
      if (sign)
        pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line = Math.round(state.doc.lines * pc);
    } else if (ln && sign) {
      line = line * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
    view.dispatch({
      effects: dialogEffect.of(false),
      selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
      scrollIntoView: true
    });
    view.focus();
  }
  return { dom, pos: -10 };
}
const dialogEffect = /* @__PURE__ */ StateEffect.define();
const dialogField = /* @__PURE__ */ StateField.define({
  create() {
    return true;
  },
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(dialogEffect))
        value = e.value;
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
});
const gotoLine = (view) => {
  let panel = getPanel(view, createLineDialog);
  if (!panel) {
    let effects = [dialogEffect.of(true)];
    if (view.state.field(dialogField, false) == null)
      effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));
    view.dispatch({ effects });
    panel = getPanel(view, createLineDialog);
  }
  if (panel)
    panel.dom.querySelector("input").focus();
  return true;
};
const baseTheme$1 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
});
const defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100
};
const highlightConfig = /* @__PURE__ */ Facet.define({
  combine(options) {
    return combineConfig(options, defaultHighlightOptions, {
      highlightWordAroundCursor: (a, b) => a || b,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function highlightSelectionMatches(options) {
  let ext = [defaultTheme, matchHighlighter];
  if (options)
    ext.push(highlightConfig.of(options));
  return ext;
}
const matchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch" });
const mainMatchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
const matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let { state } = view, sel = state.selection;
    if (sel.ranges.length > 1)
      return Decoration.none;
    let range2 = sel.main, query, check2 = null;
    if (range2.empty) {
      if (!conf.highlightWordAroundCursor)
        return Decoration.none;
      let word = state.wordAt(range2.head);
      if (!word)
        return Decoration.none;
      check2 = state.charCategorizer(range2.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range2.to - range2.from;
      if (len < conf.minSelectionLength || len > 200)
        return Decoration.none;
      query = state.sliceDoc(range2.from, range2.to).trim();
      if (!query)
        return Decoration.none;
    }
    let deco = [];
    for (let part2 of view.visibleRanges) {
      let cursor2 = new SearchCursor(state.doc, query, part2.from, part2.to);
      while (!cursor2.next().done) {
        let { from, to } = cursor2.value;
        if (!check2 || (from == 0 || check2(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check2(state.sliceDoc(to, to + 1)) != CharCategory.Word)) {
          if (check2 && from <= range2.from && to >= range2.to)
            deco.push(mainMatchDeco.range(from, to));
          else if (from >= range2.to || to <= range2.from)
            deco.push(matchDeco.range(from, to));
          if (deco.length > conf.maxMatches)
            return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
const defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
const selectWord = ({ state, dispatch }) => {
  let { selection: selection2 } = state;
  let newSel = EditorSelection.create(selection2.ranges.map((range2) => state.wordAt(range2.head) || EditorSelection.cursor(range2.head)), selection2.mainIndex);
  if (newSel.eq(selection2))
    return false;
  dispatch(state.update({ selection: newSel }));
  return true;
};
function findNextOccurrence(state, query) {
  let { main, ranges } = state.selection;
  let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
  for (let cycled = false, cursor2 = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
    cursor2.next();
    if (cursor2.done) {
      if (cycled)
        return null;
      cursor2 = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some((r) => r.from == cursor2.value.from))
        continue;
      if (fullWord) {
        let word2 = state.wordAt(cursor2.value.from);
        if (!word2 || word2.from != cursor2.value.from || word2.to != cursor2.value.to)
          continue;
      }
      return cursor2.value;
    }
  }
}
const selectNextOccurrence = ({ state, dispatch }) => {
  let { ranges } = state.selection;
  if (ranges.some((sel) => sel.from === sel.to))
    return selectWord({ state, dispatch });
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some((r) => state.sliceDoc(r.from, r.to) != searchedText))
    return false;
  let range2 = findNextOccurrence(state, searchedText);
  if (!range2)
    return false;
  dispatch(state.update({
    selection: state.selection.addRange(EditorSelection.range(range2.from, range2.to), false),
    effects: EditorView.scrollIntoView(range2.to)
  }));
  return true;
};
const searchConfigFacet = /* @__PURE__ */ Facet.define({
  combine(configs) {
    var _a;
    return {
      top: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.top, void 0) || false,
      caseSensitive: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.caseSensitive || conf.matchCase, void 0) || false,
      createPanel: ((_a = configs.find((c) => c.createPanel)) === null || _a === void 0 ? void 0 : _a.createPanel) || ((view) => new SearchPanel(view))
    };
  }
});
class SearchQuery {
  constructor(config2) {
    this.search = config2.search;
    this.caseSensitive = !!config2.caseSensitive;
    this.regexp = !!config2.regexp;
    this.replace = config2.replace || "";
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
  }
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp;
  }
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
}
class QueryType {
  constructor(spec) {
    this.spec = spec;
  }
}
class StringQuery extends QueryType {
  constructor(spec) {
    super(spec);
    this.unquoted = spec.search.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  cursor(doc2, from = 0, to = doc2.length) {
    return new SearchCursor(doc2, this.unquoted, from, to, this.spec.caseSensitive ? void 0 : (x) => x.toLowerCase());
  }
  nextMatch(doc2, curFrom, curTo) {
    let cursor2 = this.cursor(doc2, curTo).nextOverlapping();
    if (cursor2.done)
      cursor2 = this.cursor(doc2, 0, curFrom).nextOverlapping();
    return cursor2.done ? null : cursor2.value;
  }
  prevMatchInRange(doc2, from, to) {
    for (let pos = to; ; ) {
      let start = Math.max(from, pos - 1e4 - this.unquoted.length);
      let cursor2 = this.cursor(doc2, start, pos), range2 = null;
      while (!cursor2.nextOverlapping().done)
        range2 = cursor2.value;
      if (range2)
        return range2;
      if (start == from)
        return null;
      pos -= 1e4;
    }
  }
  prevMatch(doc2, curFrom, curTo) {
    return this.prevMatchInRange(doc2, 0, curFrom) || this.prevMatchInRange(doc2, curTo, doc2.length);
  }
  getReplacement(_result) {
    return this.spec.replace;
  }
  matchAll(doc2, limit) {
    let cursor2 = this.cursor(doc2), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(doc2, from, to, add3) {
    let cursor2 = this.cursor(doc2, Math.max(0, from - this.unquoted.length), Math.min(to + this.unquoted.length, doc2.length));
    while (!cursor2.next().done)
      add3(cursor2.value.from, cursor2.value.to);
  }
}
class RegExpQuery extends QueryType {
  cursor(doc2, from = 0, to = doc2.length) {
    return new RegExpCursor(doc2, this.spec.search, this.spec.caseSensitive ? void 0 : { ignoreCase: true }, from, to);
  }
  nextMatch(doc2, curFrom, curTo) {
    let cursor2 = this.cursor(doc2, curTo).next();
    if (cursor2.done)
      cursor2 = this.cursor(doc2, 0, curFrom).next();
    return cursor2.done ? null : cursor2.value;
  }
  prevMatchInRange(doc2, from, to) {
    for (let size = 1; ; size++) {
      let start = Math.max(from, to - size * 1e4);
      let cursor2 = this.cursor(doc2, start, to), range2 = null;
      while (!cursor2.next().done)
        range2 = cursor2.value;
      if (range2 && (start == from || range2.from > start + 10))
        return range2;
      if (start == from)
        return null;
    }
  }
  prevMatch(doc2, curFrom, curTo) {
    return this.prevMatchInRange(doc2, 0, curFrom) || this.prevMatchInRange(doc2, curTo, doc2.length);
  }
  getReplacement(result) {
    return this.spec.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$" : i == "&" ? result.match[0] : i != "0" && +i < result.match.length ? result.match[i] : m);
  }
  matchAll(doc2, limit) {
    let cursor2 = this.cursor(doc2), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(doc2, from, to, add3) {
    let cursor2 = this.cursor(doc2, Math.max(0, from - 250), Math.min(to + 250, doc2.length));
    while (!cursor2.next().done)
      add3(cursor2.value.from, cursor2.value.to);
  }
}
const setSearchQuery = /* @__PURE__ */ StateEffect.define();
const togglePanel$1 = /* @__PURE__ */ StateEffect.define();
const searchState = /* @__PURE__ */ StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null);
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setSearchQuery))
        value = new SearchState(effect.value.create(), value.panel);
      else if (effect.is(togglePanel$1))
        value = new SearchState(value.query, effect.value ? createSearchPanel : null);
    }
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val.panel)
});
class SearchState {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
}
const matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" }), selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
const searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet)
      this.decorations = this.highlight(state);
  }
  highlight({ query, panel }) {
    if (!panel || !query.spec.valid)
      return Decoration.none;
    let { view } = this;
    let builder = new RangeSetBuilder();
    for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
      let { from, to } = ranges[i];
      while (i < l - 1 && to > ranges[i + 1].from - 2 * 250)
        to = ranges[++i].to;
      query.highlight(view.state.doc, from, to, (from2, to2) => {
        let selected = view.state.selection.ranges.some((r) => r.from == from2 && r.to == to2);
        builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});
function searchCommand(f) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
  };
}
const findNext = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { from, to } = view.state.selection.main;
  let next = query.nextMatch(view.state.doc, from, to);
  if (!next || next.from == from && next.to == to)
    return false;
  view.dispatch({
    selection: { anchor: next.from, head: next.to },
    scrollIntoView: true,
    effects: announceMatch(view, next),
    userEvent: "select.search"
  });
  return true;
});
const findPrevious = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { state } = view, { from, to } = state.selection.main;
  let range2 = query.prevMatch(state.doc, from, to);
  if (!range2)
    return false;
  view.dispatch({
    selection: { anchor: range2.from, head: range2.to },
    scrollIntoView: true,
    effects: announceMatch(view, range2),
    userEvent: "select.search"
  });
  return true;
});
const selectMatches = /* @__PURE__ */ searchCommand((view, { query }) => {
  let ranges = query.matchAll(view.state.doc, 1e3);
  if (!ranges || !ranges.length)
    return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
    userEvent: "select.search.matches"
  });
  return true;
});
const selectSelectionMatches = ({ state, dispatch }) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty)
    return false;
  let { from, to } = sel.main;
  let ranges = [], main = 0;
  for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur2.next().done; ) {
    if (ranges.length > 1e3)
      return false;
    if (cur2.value.from == from)
      main = ranges.length;
    ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
  }
  dispatch(state.update({
    selection: EditorSelection.create(ranges, main),
    userEvent: "select.search.matches"
  }));
  return true;
};
const replaceNext = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { state } = view, { from, to } = state.selection.main;
  if (state.readOnly)
    return false;
  let next = query.nextMatch(state.doc, from, from);
  if (!next)
    return false;
  let changes = [], selection2, replacement;
  if (next.from == from && next.to == to) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({ from: next.from, to: next.to, insert: replacement });
    next = query.nextMatch(state.doc, next.from, next.to);
  }
  if (next) {
    let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
    selection2 = { anchor: next.from - off, head: next.to - off };
  }
  view.dispatch({
    changes,
    selection: selection2,
    scrollIntoView: !!selection2,
    effects: next ? announceMatch(view, next) : void 0,
    userEvent: "input.replace"
  });
  return true;
});
const replaceAll = /* @__PURE__ */ searchCommand((view, { query }) => {
  if (view.state.readOnly)
    return false;
  let changes = query.matchAll(view.state.doc, 1e9).map((match2) => {
    let { from, to } = match2;
    return { from, to, insert: query.getReplacement(match2) };
  });
  if (!changes.length)
    return false;
  view.dispatch({
    changes,
    userEvent: "input.replace.all"
  });
  return true;
});
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  let caseSensitive = (_a = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _a !== void 0 ? _a : state.facet(searchConfigFacet).caseSensitive;
  return fallback && !selText ? fallback : new SearchQuery({ search: selText.replace(/\n/g, "\\n"), caseSensitive });
}
const openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let panel = getPanel(view, createSearchPanel);
    if (!panel)
      return false;
    let searchInput = panel.dom.querySelector("[name=search]");
    if (searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec);
      if (query.valid)
        view.dispatch({ effects: setSearchQuery.of(query) });
      searchInput.focus();
      searchInput.select();
    }
  } else {
    view.dispatch({ effects: [
      togglePanel$1.of(true),
      state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
    ] });
  }
  return true;
};
const closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel)
    return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement))
    view.focus();
  view.dispatch({ effects: togglePanel$1.of(false) });
  return true;
};
const searchKeymap = [
  { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
  { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: selectSelectionMatches },
  { key: "Alt-g", run: gotoLine },
  { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
];
class SearchPanel {
  constructor(view) {
    this.view = view;
    let query = this.query = view.state.field(searchState).query.spec;
    this.commit = this.commit.bind(this);
    this.searchField = crelt("input", {
      value: query.search,
      placeholder: phrase(view, "Find"),
      "aria-label": phrase(view, "Find"),
      class: "cm-textfield",
      name: "search",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.replaceField = crelt("input", {
      value: query.replace,
      placeholder: phrase(view, "Replace"),
      "aria-label": phrase(view, "Replace"),
      class: "cm-textfield",
      name: "replace",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.caseField = crelt("input", {
      type: "checkbox",
      name: "case",
      checked: query.caseSensitive,
      onchange: this.commit
    });
    this.reField = crelt("input", {
      type: "checkbox",
      name: "re",
      checked: query.regexp,
      onchange: this.commit
    });
    function button(name2, onclick, content2) {
      return crelt("button", { class: "cm-button", name: name2, onclick, type: "button" }, content2);
    }
    this.dom = crelt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
      this.searchField,
      button("next", () => findNext(view), [phrase(view, "next")]),
      button("prev", () => findPrevious(view), [phrase(view, "previous")]),
      button("select", () => selectMatches(view), [phrase(view, "all")]),
      crelt("label", null, [this.caseField, phrase(view, "match case")]),
      crelt("label", null, [this.reField, phrase(view, "regexp")]),
      ...view.state.readOnly ? [] : [
        crelt("br"),
        this.replaceField,
        button("replace", () => replaceNext(view), [phrase(view, "replace")]),
        button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")]),
        crelt("button", {
          name: "close",
          onclick: () => closeSearchPanel(view),
          "aria-label": phrase(view, "close"),
          type: "button"
        }, ["\xD7"])
      ]
    ]);
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      replace: this.replaceField.value
    });
    if (!query.eq(this.query)) {
      this.query = query;
      this.view.dispatch({ effects: setSearchQuery.of(query) });
    }
  }
  keydown(e) {
    if (runScopeHandlers(this.view, e, "search-panel")) {
      e.preventDefault();
    } else if (e.keyCode == 13 && e.target == this.searchField) {
      e.preventDefault();
      (e.shiftKey ? findPrevious : findNext)(this.view);
    } else if (e.keyCode == 13 && e.target == this.replaceField) {
      e.preventDefault();
      replaceNext(this.view);
    }
  }
  update(update) {
    for (let tr of update.transactions)
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
          this.setQuery(effect.value);
      }
  }
  setQuery(query) {
    this.query = query;
    this.searchField.value = query.search;
    this.replaceField.value = query.replace;
    this.caseField.checked = query.caseSensitive;
    this.reField.checked = query.regexp;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
}
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
const AnnounceMargin = 30;
const Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to }) {
  let lineStart = view.state.doc.lineAt(from).from, lineEnd2 = view.state.doc.lineAt(to).to;
  let start = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd2, to + AnnounceMargin);
  let text3 = view.state.sliceDoc(start, end);
  if (start != lineStart) {
    for (let i = 0; i < AnnounceMargin; i++)
      if (!Break.test(text3[i + 1]) && Break.test(text3[i])) {
        text3 = text3.slice(i);
        break;
      }
  }
  if (end != lineEnd2) {
    for (let i = text3.length - 1; i > text3.length - AnnounceMargin; i--)
      if (!Break.test(text3[i - 1]) && Break.test(text3[i])) {
        text3 = text3.slice(0, i);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text3} ${view.state.phrase("on line")} ${view.state.doc.lineAt(from).number}`);
}
const baseTheme$2 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
const searchExtensions = [
  searchState,
  /* @__PURE__ */ Prec.lowest(searchHighlighter),
  baseTheme$2
];
const toggleComment = (target2) => {
  let config2 = getConfig(target2.state);
  return config2.line ? toggleLineComment(target2) : config2.block ? toggleBlockCommentByLine(target2) : false;
};
function command(f, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr = f(option, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
const toggleLineComment = /* @__PURE__ */ command(changeLineComment, 0);
const toggleBlockComment = /* @__PURE__ */ command(changeBlockComment, 0);
const toggleBlockCommentByLine = /* @__PURE__ */ command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
const commentKeymap = [
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment }
];
function getConfig(state, pos = state.selection.main.head) {
  let data2 = state.languageDataAt("commentTokens", pos);
  return data2.length ? data2[0] : {};
}
const SearchMargin = 50;
function findBlockComment(state, { open, close }, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r.from);
    let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last].to > fromLine.from)
      ranges[last].to = toLine.to;
    else
      ranges.push({ from: fromLine.from, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r) => getConfig(state, r.from).block);
  if (!tokens.every((c) => c))
    return null;
  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
  if (option != 2 && !comments.every((c) => c)) {
    return { changes: state.changes(ranges.map((range2, i) => {
      if (comments[i])
        return [];
      return [{ from: range2.from, insert: tokens[i].open + " " }, { from: range2.to, insert: " " + tokens[i].close }];
    })) };
  } else if (option != 1 && comments.some((c) => c)) {
    let changes = [];
    for (let i = 0, comment2; i < comments.length; i++)
      if (comment2 = comments[i]) {
        let token2 = tokens[i], { open, close } = comment2;
        changes.push({ from: open.pos - token2.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token2.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from, to } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    for (let pos = from; pos <= to; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let token2 = getConfig(state, pos).line;
        if (!token2)
          continue;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty2 = indent == line.length;
        let comment2 = line.text.slice(indent, indent + token2.length) == token2 ? indent : -1;
        if (indent < line.text.length && indent < minIndent)
          minIndent = indent;
        lines.push({ line, comment: comment2, token: token2, indent, empty: empty2, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i = startI; i < lines.length; i++)
        if (lines[i].indent < lines[i].line.text.length)
          lines[i].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];
    for (let { line, token: token2, indent, empty: empty2, single } of lines)
      if (single || !empty2)
        changes.push({ from: line.from + indent, insert: token2 + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
    let changes = [];
    for (let { line, comment: comment2, token: token2 } of lines)
      if (comment2 >= 0) {
        let from = line.from + comment2, to = from + token2.length;
        if (line.text[to - line.from] == " ")
          to++;
        changes.push({ from, to });
      }
    return { changes };
  }
  return null;
}
class SelectedDiagnostic {
  constructor(from, to, diagnostic) {
    this.from = from;
    this.to = to;
    this.diagnostic = diagnostic;
  }
}
class LintState {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }
  static init(diagnostics, panel, state) {
    let ranges = Decoration.set(diagnostics.map((d) => {
      return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? Decoration.widget({
        widget: new DiagnosticWidget(d),
        diagnostic: d
      }).range(d.from) : Decoration.mark({
        attributes: { class: "cm-lintRange cm-lintRange-" + d.severity },
        diagnostic: d
      }).range(d.from, d.to);
    }), true);
    return new LintState(ranges, panel, findDiagnostic(ranges));
  }
}
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from, to, { spec }) => {
    if (diagnostic && spec.diagnostic != diagnostic)
      return;
    found = new SelectedDiagnostic(from, to, spec.diagnostic);
    return false;
  });
  return found;
}
function maybeEnableLint(state, effects) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of([
    lintState,
    EditorView.decorations.compute([lintState], (state2) => {
      let { selected, panel } = state2.field(lintState);
      return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
        activeMark.range(selected.from, selected.to)
      ]);
    }),
    hoverTooltip(lintTooltip),
    baseTheme
  ]));
}
const setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
const togglePanel = /* @__PURE__ */ StateEffect.define();
const movePanelSelection = /* @__PURE__ */ StateEffect.define();
const lintState = /* @__PURE__ */ StateField.define({
  create() {
    return new LintState(Decoration.none, null, null);
  },
  update(value, tr) {
    if (tr.docChanged) {
      let mapped = value.diagnostics.map(tr.changes), selected = null;
      if (value.selected) {
        let selPos = tr.changes.mapPos(value.selected.from, 1);
        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }
      value = new LintState(mapped, value.panel, selected);
    }
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        value = LintState.init(effect.value, value.panel, tr.state);
      } else if (effect.is(togglePanel)) {
        value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
      } else if (effect.is(movePanelSelection)) {
        value = new LintState(value.diagnostics, value.panel, effect.value);
      }
    }
    return value;
  },
  provide: (f) => [
    showPanel.from(f, (val) => val.panel),
    EditorView.decorations.from(f, (s) => s.diagnostics)
  ]
});
const activeMark = /* @__PURE__ */ Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
  let { diagnostics } = view.state.field(lintState);
  let found = [], stackStart = 2e8, stackEnd = 0;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
    if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
      found.push(spec.diagnostic);
      stackStart = Math.min(from, stackStart);
      stackEnd = Math.max(to, stackEnd);
    }
  });
  if (!found.length)
    return null;
  return {
    pos: stackStart,
    end: stackEnd,
    above: view.state.doc.lineAt(stackStart).to < stackEnd,
    create() {
      return { dom: diagnosticsTooltip(view, found) };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d) => renderDiagnostic(view, d, false)));
}
const openLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel.of(true)]) });
  let panel = getPanel(view, LintPanel.open);
  if (panel)
    panel.dom.querySelector(".cm-panel-lint ul").focus();
  return true;
};
const closeLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    return false;
  view.dispatch({ effects: togglePanel.of(false) });
  return true;
};
const nextDiagnostic = (view) => {
  let field = view.state.field(lintState, false);
  if (!field)
    return false;
  let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
  if (!next.value) {
    next = field.diagnostics.iter(0);
    if (!next.value || next.from == sel.from && next.to == sel.to)
      return false;
  }
  view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
  return true;
};
const lintKeymap = [
  { key: "Mod-Shift-m", run: openLintPanel },
  { key: "F8", run: nextDiagnostic }
];
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions:
      for (let { name: name2 } of actions) {
        for (let i = 0; i < name2.length; i++) {
          let ch = name2[i];
          if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
            assigned.push(ch);
            continue actions;
          }
        }
        assigned.push("");
      }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a;
  let keys = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {
    let click = (e) => {
      e.preventDefault();
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found)
        action.apply(view, found.from, found.to);
    };
    let { name: name2 } = action, keyIndex = keys[i] ? name2.indexOf(keys[i]) : -1;
    let nameElt = keyIndex < 0 ? name2 : [
      name2.slice(0, keyIndex),
      crelt("u", name2.slice(keyIndex, keyIndex + 1)),
      name2.slice(keyIndex + 1)
    ];
    return crelt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys[i]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
class DiagnosticWidget extends WidgetType {
  constructor(diagnostic) {
    super();
    this.diagnostic = diagnostic;
  }
  eq(other) {
    return other.diagnostic == this.diagnostic;
  }
  toDOM() {
    return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class PanelItem {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }
}
class LintPanel {
  constructor(view) {
    this.view = view;
    this.items = [];
    let onkeydown = (event) => {
      if (event.keyCode == 27) {
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event.keyCode == 38 || event.keyCode == 33) {
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event.keyCode == 40 || event.keyCode == 34) {
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event.keyCode == 36) {
        this.moveSelection(0);
      } else if (event.keyCode == 35) {
        this.moveSelection(this.items.length - 1);
      } else if (event.keyCode == 13) {
        this.view.focus();
      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
        for (let i = 0; i < keys.length; i++)
          if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
            if (found)
              diagnostic.actions[i].apply(view, found.from, found.to);
          }
      } else {
        return;
      }
      event.preventDefault();
    };
    let onclick = (event) => {
      for (let i = 0; i < this.items.length; i++) {
        if (this.items[i].dom.contains(event.target))
          this.moveSelection(i);
      }
    };
    this.list = crelt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, "\xD7"));
    this.update();
  }
  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected)
      return -1;
    for (let i = 0; i < this.items.length; i++)
      if (this.items[i].diagnostic == selected.diagnostic)
        return i;
    return -1;
  }
  update() {
    let { diagnostics, selected } = this.view.state.field(lintState);
    let i = 0, needsSync = false, newSelectedItem = null;
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
      let found = -1, item;
      for (let j = i; j < this.items.length; j++)
        if (this.items[j].diagnostic == spec.diagnostic) {
          found = j;
          break;
        }
      if (found < 0) {
        item = new PanelItem(this.view, spec.diagnostic);
        this.items.splice(i, 0, item);
        needsSync = true;
      } else {
        item = this.items[found];
        if (found > i) {
          this.items.splice(i, found - i);
          needsSync = true;
        }
      }
      if (selected && item.diagnostic == selected.diagnostic) {
        if (!item.dom.hasAttribute("aria-selected")) {
          item.dom.setAttribute("aria-selected", "true");
          newSelectedItem = item;
        }
      } else if (item.dom.hasAttribute("aria-selected")) {
        item.dom.removeAttribute("aria-selected");
      }
      i++;
    });
    while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }
    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }
    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
        write: ({ sel, panel }) => {
          if (sel.top < panel.top)
            this.list.scrollTop -= panel.top - sel.top;
          else if (sel.bottom > panel.bottom)
            this.list.scrollTop += sel.bottom - panel.bottom;
        }
      });
    } else if (this.selectedIndex < 0) {
      this.list.removeAttribute("aria-activedescendant");
    }
    if (needsSync)
      this.sync();
  }
  sync() {
    let domPos = this.list.firstChild;
    function rm2() {
      let prev = domPos;
      domPos = prev.nextSibling;
      prev.remove();
    }
    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom)
          rm2();
        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }
    while (domPos)
      rm2();
  }
  moveSelection(selectedIndex) {
    if (this.selectedIndex < 0)
      return;
    let field = this.view.state.field(lintState);
    let selection2 = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection2)
      return;
    this.view.dispatch({
      selection: { anchor: selection2.from, head: selection2.to },
      scrollIntoView: true,
      effects: movePanelSelection.of(selection2)
    });
  }
  static open(view) {
    return new LintPanel(view);
  }
}
function svg(content2, attrs = `viewBox="0 0 40 40"`) {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
}
function underline(color) {
  return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
const baseTheme = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ underline("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ underline("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ underline("#999") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
var standalone = { exports: {} };
(function(module, exports) {
  !function(e, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    var e = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : {};
    function t2(e2) {
      return e2 && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
    }
    var n = { version: "2.5.1" }, r = {}, o = {};
    !function(e2) {
      function t3() {
      }
      function n2(e3, t4, n3, r3, o2) {
        for (var i2 = 0, u2 = t4.length, s2 = 0, a2 = 0; i2 < u2; i2++) {
          var c2 = t4[i2];
          if (c2.removed) {
            if (c2.value = e3.join(r3.slice(a2, a2 + c2.count)), a2 += c2.count, i2 && t4[i2 - 1].added) {
              var l2 = t4[i2 - 1];
              t4[i2 - 1] = t4[i2], t4[i2] = l2;
            }
          } else {
            if (!c2.added && o2) {
              var p2 = n3.slice(s2, s2 + c2.count);
              p2 = p2.map(function(e4, t5) {
                var n4 = r3[a2 + t5];
                return n4.length > e4.length ? n4 : e4;
              }), c2.value = e3.join(p2);
            } else
              c2.value = e3.join(n3.slice(s2, s2 + c2.count));
            s2 += c2.count, c2.added || (a2 += c2.count);
          }
        }
        var f2 = t4[u2 - 1];
        return u2 > 1 && typeof f2.value == "string" && (f2.added || f2.removed) && e3.equals("", f2.value) && (t4[u2 - 2].value += f2.value, t4.pop()), t4;
      }
      function r2(e3) {
        return { newPos: e3.newPos, components: e3.components.slice(0) };
      }
      Object.defineProperty(e2, "__esModule", { value: true }), e2.default = t3, t3.prototype = { diff: function(e3, t4) {
        var o2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i2 = o2.callback;
        typeof o2 == "function" && (i2 = o2, o2 = {}), this.options = o2;
        var u2 = this;
        function s2(e4) {
          return i2 ? (setTimeout(function() {
            i2(void 0, e4);
          }, 0), true) : e4;
        }
        e3 = this.castInput(e3), t4 = this.castInput(t4), e3 = this.removeEmpty(this.tokenize(e3));
        var a2 = (t4 = this.removeEmpty(this.tokenize(t4))).length, c2 = e3.length, l2 = 1, p2 = a2 + c2, f2 = [{ newPos: -1, components: [] }], d2 = this.extractCommon(f2[0], t4, e3, 0);
        if (f2[0].newPos + 1 >= a2 && d2 + 1 >= c2)
          return s2([{ value: this.join(t4), count: t4.length }]);
        function h2() {
          for (var o3 = -1 * l2; o3 <= l2; o3 += 2) {
            var i3 = void 0, p3 = f2[o3 - 1], d3 = f2[o3 + 1], h3 = (d3 ? d3.newPos : 0) - o3;
            p3 && (f2[o3 - 1] = void 0);
            var g3 = p3 && p3.newPos + 1 < a2, m2 = d3 && 0 <= h3 && h3 < c2;
            if (g3 || m2) {
              if (!g3 || m2 && p3.newPos < d3.newPos ? (i3 = r2(d3), u2.pushComponent(i3.components, void 0, true)) : ((i3 = p3).newPos++, u2.pushComponent(i3.components, true, void 0)), h3 = u2.extractCommon(i3, t4, e3, o3), i3.newPos + 1 >= a2 && h3 + 1 >= c2)
                return s2(n2(u2, i3.components, t4, e3, u2.useLongestToken));
              f2[o3] = i3;
            } else
              f2[o3] = void 0;
          }
          l2++;
        }
        if (i2)
          !function e4() {
            setTimeout(function() {
              if (l2 > p2)
                return i2();
              h2() || e4();
            }, 0);
          }();
        else
          for (; l2 <= p2; ) {
            var g2 = h2();
            if (g2)
              return g2;
          }
      }, pushComponent: function(e3, t4, n3) {
        var r3 = e3[e3.length - 1];
        r3 && r3.added === t4 && r3.removed === n3 ? e3[e3.length - 1] = { count: r3.count + 1, added: t4, removed: n3 } : e3.push({ count: 1, added: t4, removed: n3 });
      }, extractCommon: function(e3, t4, n3, r3) {
        for (var o2 = t4.length, i2 = n3.length, u2 = e3.newPos, s2 = u2 - r3, a2 = 0; u2 + 1 < o2 && s2 + 1 < i2 && this.equals(t4[u2 + 1], n3[s2 + 1]); )
          u2++, s2++, a2++;
        return a2 && e3.components.push({ count: a2 }), e3.newPos = u2, s2;
      }, equals: function(e3, t4) {
        return this.options.comparator ? this.options.comparator(e3, t4) : e3 === t4 || this.options.ignoreCase && e3.toLowerCase() === t4.toLowerCase();
      }, removeEmpty: function(e3) {
        for (var t4 = [], n3 = 0; n3 < e3.length; n3++)
          e3[n3] && t4.push(e3[n3]);
        return t4;
      }, castInput: function(e3) {
        return e3;
      }, tokenize: function(e3) {
        return e3.split("");
      }, join: function(e3) {
        return e3.join("");
      } };
    }(o);
    var i, u = {};
    Object.defineProperty(u, "__esModule", { value: true }), u.diffChars = function(e2, t3, n2) {
      return s.diff(e2, t3, n2);
    }, u.characterDiff = void 0;
    var s = new ((i = o) && i.__esModule ? i : { default: i }).default();
    u.characterDiff = s;
    var a = {}, c = {};
    Object.defineProperty(c, "__esModule", { value: true }), c.generateOptions = function(e2, t3) {
      if (typeof e2 == "function")
        t3.callback = e2;
      else if (e2)
        for (var n2 in e2)
          e2.hasOwnProperty(n2) && (t3[n2] = e2[n2]);
      return t3;
    }, Object.defineProperty(a, "__esModule", { value: true }), a.diffWords = function(e2, t3, n2) {
      return n2 = (0, p.generateOptions)(n2, { ignoreWhitespace: true }), h.diff(e2, t3, n2);
    }, a.diffWordsWithSpace = function(e2, t3, n2) {
      return h.diff(e2, t3, n2);
    }, a.wordDiff = void 0;
    var l = function(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }(o), p = c;
    var f = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, d = /\S/, h = new l.default();
    a.wordDiff = h, h.equals = function(e2, t3) {
      return this.options.ignoreCase && (e2 = e2.toLowerCase(), t3 = t3.toLowerCase()), e2 === t3 || this.options.ignoreWhitespace && !d.test(e2) && !d.test(t3);
    }, h.tokenize = function(e2) {
      for (var t3 = e2.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n2 = 0; n2 < t3.length - 1; n2++)
        !t3[n2 + 1] && t3[n2 + 2] && f.test(t3[n2]) && f.test(t3[n2 + 2]) && (t3[n2] += t3[n2 + 2], t3.splice(n2 + 1, 2), n2--);
      return t3;
    };
    var g = {};
    Object.defineProperty(g, "__esModule", { value: true }), g.diffLines = function(e2, t3, n2) {
      return D.diff(e2, t3, n2);
    }, g.diffTrimmedLines = function(e2, t3, n2) {
      var r2 = (0, y.generateOptions)(n2, { ignoreWhitespace: true });
      return D.diff(e2, t3, r2);
    }, g.lineDiff = void 0;
    var m = function(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }(o), y = c;
    var D = new m.default();
    g.lineDiff = D, D.tokenize = function(e2) {
      var t3 = [], n2 = e2.split(/(\n|\r\n)/);
      n2[n2.length - 1] || n2.pop();
      for (var r2 = 0; r2 < n2.length; r2++) {
        var o2 = n2[r2];
        r2 % 2 && !this.options.newlineIsToken ? t3[t3.length - 1] += o2 : (this.options.ignoreWhitespace && (o2 = o2.trim()), t3.push(o2));
      }
      return t3;
    };
    var E = {};
    Object.defineProperty(E, "__esModule", { value: true }), E.diffSentences = function(e2, t3, n2) {
      return b.diff(e2, t3, n2);
    }, E.sentenceDiff = void 0;
    var C2 = function(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }(o);
    var b = new C2.default();
    E.sentenceDiff = b, b.tokenize = function(e2) {
      return e2.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    var v = {};
    Object.defineProperty(v, "__esModule", { value: true }), v.diffCss = function(e2, t3, n2) {
      return F.diff(e2, t3, n2);
    }, v.cssDiff = void 0;
    var A = function(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }(o);
    var F = new A.default();
    v.cssDiff = F, F.tokenize = function(e2) {
      return e2.split(/([{}:;,]|\s+)/);
    };
    var x = function(e2) {
      return e2 && e2.Math == Math && e2;
    }, S2 = x(typeof globalThis == "object" && globalThis) || x(typeof window == "object" && window) || x(typeof self == "object" && self) || x(typeof e == "object" && e) || function() {
      return this;
    }() || Function("return this")(), w = {}, T = function(e2) {
      try {
        return !!e2();
      } catch (e3) {
        return true;
      }
    }, B = !T(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] != 7;
    }), N = Function.prototype.call, k = N.bind ? N.bind(N) : function() {
      return N.apply(N, arguments);
    }, P = {}, O = {}.propertyIsEnumerable, I = Object.getOwnPropertyDescriptor, L = I && !O.call({ 1: 2 }, 1);
    P.f = L ? function(e2) {
      var t3 = I(this, e2);
      return !!t3 && t3.enumerable;
    } : O;
    var j, _, M = function(e2, t3) {
      return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t3 };
    }, R = Function.prototype, V = R.bind, $ = R.call, W = V && V.bind($), q = V ? function(e2) {
      return e2 && W($, e2);
    } : function(e2) {
      return e2 && function() {
        return $.apply(e2, arguments);
      };
    }, U = q, z = U({}.toString), G = U("".slice), H = function(e2) {
      return G(z(e2), 8, -1);
    }, J = q, X = T, Y = H, K = S2.Object, Q = J("".split), Z = X(function() {
      return !K("z").propertyIsEnumerable(0);
    }) ? function(e2) {
      return Y(e2) == "String" ? Q(e2, "") : K(e2);
    } : K, ee2 = S2.TypeError, te = function(e2) {
      if (e2 == null)
        throw ee2("Can't call method on " + e2);
      return e2;
    }, ne2 = Z, re2 = te, oe = function(e2) {
      return ne2(re2(e2));
    }, ie2 = function(e2) {
      return typeof e2 == "function";
    }, ue = ie2, se = function(e2) {
      return typeof e2 == "object" ? e2 !== null : ue(e2);
    }, ae = S2, ce = ie2, le2 = function(e2) {
      return ce(e2) ? e2 : void 0;
    }, pe = function(e2, t3) {
      return arguments.length < 2 ? le2(ae[e2]) : ae[e2] && ae[e2][t3];
    }, fe = q({}.isPrototypeOf), de = pe("navigator", "userAgent") || "", he = S2, ge2 = de, me = he.process, ye = he.Deno, De = me && me.versions || ye && ye.version, Ee = De && De.v8;
    Ee && (_ = (j = Ee.split("."))[0] > 0 && j[0] < 4 ? 1 : +(j[0] + j[1])), !_ && ge2 && (!(j = ge2.match(/Edge\/(\d+)/)) || j[1] >= 74) && (j = ge2.match(/Chrome\/(\d+)/)) && (_ = +j[1]);
    var Ce = _, be = Ce, ve = T, Ae = !!Object.getOwnPropertySymbols && !ve(function() {
      var e2 = Symbol();
      return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && be && be < 41;
    }), Fe = Ae && !Symbol.sham && typeof Symbol.iterator == "symbol", xe = pe, Se = ie2, we = fe, Te = Fe, Be = S2.Object, Ne = Te ? function(e2) {
      return typeof e2 == "symbol";
    } : function(e2) {
      var t3 = xe("Symbol");
      return Se(t3) && we(t3.prototype, Be(e2));
    }, ke = S2.String, Pe = function(e2) {
      try {
        return ke(e2);
      } catch (e3) {
        return "Object";
      }
    }, Oe = ie2, Ie = Pe, Le = S2.TypeError, je = function(e2) {
      if (Oe(e2))
        return e2;
      throw Le(Ie(e2) + " is not a function");
    }, _e = je, Me = function(e2, t3) {
      var n2 = e2[t3];
      return n2 == null ? void 0 : _e(n2);
    }, Re2 = k, Ve = ie2, $e = se, We = S2.TypeError, qe = { exports: {} }, Ue = S2, ze = Object.defineProperty, Ge = function(e2, t3) {
      try {
        ze(Ue, e2, { value: t3, configurable: true, writable: true });
      } catch (n2) {
        Ue[e2] = t3;
      }
      return t3;
    }, He = Ge, Je = "__core-js_shared__", Xe = S2[Je] || He(Je, {}), Ye = Xe;
    (qe.exports = function(e2, t3) {
      return Ye[e2] || (Ye[e2] = t3 !== void 0 ? t3 : {});
    })("versions", []).push({ version: "3.19.1", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
    var Ke = te, Qe = S2.Object, Ze = function(e2) {
      return Qe(Ke(e2));
    }, et = Ze, tt = q({}.hasOwnProperty), nt = Object.hasOwn || function(e2, t3) {
      return tt(et(e2), t3);
    }, rt = q, ot = 0, it2 = Math.random(), ut = rt(1 .toString), st = function(e2) {
      return "Symbol(" + (e2 === void 0 ? "" : e2) + ")_" + ut(++ot + it2, 36);
    }, at = S2, ct = qe.exports, lt2 = nt, pt = st, ft = Ae, dt = Fe, ht = ct("wks"), gt2 = at.Symbol, mt = gt2 && gt2.for, yt = dt ? gt2 : gt2 && gt2.withoutSetter || pt, Dt = function(e2) {
      if (!lt2(ht, e2) || !ft && typeof ht[e2] != "string") {
        var t3 = "Symbol." + e2;
        ft && lt2(gt2, e2) ? ht[e2] = gt2[e2] : ht[e2] = dt && mt ? mt(t3) : yt(t3);
      }
      return ht[e2];
    }, Et = k, Ct = se, bt = Ne, vt = Me, At = function(e2, t3) {
      var n2, r2;
      if (t3 === "string" && Ve(n2 = e2.toString) && !$e(r2 = Re2(n2, e2)))
        return r2;
      if (Ve(n2 = e2.valueOf) && !$e(r2 = Re2(n2, e2)))
        return r2;
      if (t3 !== "string" && Ve(n2 = e2.toString) && !$e(r2 = Re2(n2, e2)))
        return r2;
      throw We("Can't convert object to primitive value");
    }, Ft = Dt, xt = S2.TypeError, St = Ft("toPrimitive"), wt = function(e2, t3) {
      if (!Ct(e2) || bt(e2))
        return e2;
      var n2, r2 = vt(e2, St);
      if (r2) {
        if (t3 === void 0 && (t3 = "default"), n2 = Et(r2, e2, t3), !Ct(n2) || bt(n2))
          return n2;
        throw xt("Can't convert object to primitive value");
      }
      return t3 === void 0 && (t3 = "number"), At(e2, t3);
    }, Tt = Ne, Bt = function(e2) {
      var t3 = wt(e2, "string");
      return Tt(t3) ? t3 : t3 + "";
    }, Nt = se, kt = S2.document, Pt = Nt(kt) && Nt(kt.createElement), Ot = function(e2) {
      return Pt ? kt.createElement(e2) : {};
    }, It = Ot, Lt2 = !B && !T(function() {
      return Object.defineProperty(It("div"), "a", { get: function() {
        return 7;
      } }).a != 7;
    }), jt = B, _t = k, Mt = P, Rt = M, Vt = oe, $t = Bt, Wt = nt, qt = Lt2, Ut = Object.getOwnPropertyDescriptor;
    w.f = jt ? Ut : function(e2, t3) {
      if (e2 = Vt(e2), t3 = $t(t3), qt)
        try {
          return Ut(e2, t3);
        } catch (e3) {
        }
      if (Wt(e2, t3))
        return Rt(!_t(Mt.f, e2, t3), e2[t3]);
    };
    var zt = {}, Gt2 = S2, Ht = se, Jt = Gt2.String, Xt = Gt2.TypeError, Yt = function(e2) {
      if (Ht(e2))
        return e2;
      throw Xt(Jt(e2) + " is not an object");
    }, Kt = B, Qt = Lt2, Zt = Yt, en = Bt, tn = S2.TypeError, nn = Object.defineProperty;
    zt.f = Kt ? nn : function(e2, t3, n2) {
      if (Zt(e2), t3 = en(t3), Zt(n2), Qt)
        try {
          return nn(e2, t3, n2);
        } catch (e3) {
        }
      if ("get" in n2 || "set" in n2)
        throw tn("Accessors not supported");
      return "value" in n2 && (e2[t3] = n2.value), e2;
    };
    var rn = zt, on = M, un = B ? function(e2, t3, n2) {
      return rn.f(e2, t3, on(1, n2));
    } : function(e2, t3, n2) {
      return e2[t3] = n2, e2;
    }, sn = { exports: {} }, an = ie2, cn = Xe, ln = q(Function.toString);
    an(cn.inspectSource) || (cn.inspectSource = function(e2) {
      return ln(e2);
    });
    var pn, fn, dn, hn = cn.inspectSource, gn = ie2, mn = hn, yn = S2.WeakMap, Dn = gn(yn) && /native code/.test(mn(yn)), En = qe.exports, Cn = st, bn = En("keys"), vn = function(e2) {
      return bn[e2] || (bn[e2] = Cn(e2));
    }, An = {}, Fn = Dn, xn = S2, Sn = q, wn = se, Tn = un, Bn = nt, Nn = Xe, kn = vn, Pn = An, On = "Object already initialized", In = xn.TypeError, Ln = xn.WeakMap;
    if (Fn || Nn.state) {
      var jn = Nn.state || (Nn.state = new Ln()), _n = Sn(jn.get), Mn = Sn(jn.has), Rn = Sn(jn.set);
      pn = function(e2, t3) {
        if (Mn(jn, e2))
          throw new In(On);
        return t3.facade = e2, Rn(jn, e2, t3), t3;
      }, fn = function(e2) {
        return _n(jn, e2) || {};
      }, dn = function(e2) {
        return Mn(jn, e2);
      };
    } else {
      var Vn = kn("state");
      Pn[Vn] = true, pn = function(e2, t3) {
        if (Bn(e2, Vn))
          throw new In(On);
        return t3.facade = e2, Tn(e2, Vn, t3), t3;
      }, fn = function(e2) {
        return Bn(e2, Vn) ? e2[Vn] : {};
      }, dn = function(e2) {
        return Bn(e2, Vn);
      };
    }
    var $n = { set: pn, get: fn, has: dn, enforce: function(e2) {
      return dn(e2) ? fn(e2) : pn(e2, {});
    }, getterFor: function(e2) {
      return function(t3) {
        var n2;
        if (!wn(t3) || (n2 = fn(t3)).type !== e2)
          throw In("Incompatible receiver, " + e2 + " required");
        return n2;
      };
    } }, Wn = B, qn = nt, Un = Function.prototype, zn = Wn && Object.getOwnPropertyDescriptor, Gn = qn(Un, "name"), Hn = Gn && function() {
    }.name === "something", Jn = Gn && (!Wn || Wn && zn(Un, "name").configurable), Xn = S2, Yn = ie2, Kn = nt, Qn = un, Zn = Ge, er = hn, tr = { EXISTS: Gn, PROPER: Hn, CONFIGURABLE: Jn }.CONFIGURABLE, nr = $n.get, rr = $n.enforce, or2 = String(String).split("String");
    (sn.exports = function(e2, t3, n2, r2) {
      var o2, i2 = !!r2 && !!r2.unsafe, u2 = !!r2 && !!r2.enumerable, s2 = !!r2 && !!r2.noTargetGet, a2 = r2 && r2.name !== void 0 ? r2.name : t3;
      Yn(n2) && (String(a2).slice(0, 7) === "Symbol(" && (a2 = "[" + String(a2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Kn(n2, "name") || tr && n2.name !== a2) && Qn(n2, "name", a2), (o2 = rr(n2)).source || (o2.source = or2.join(typeof a2 == "string" ? a2 : ""))), e2 !== Xn ? (i2 ? !s2 && e2[t3] && (u2 = true) : delete e2[t3], u2 ? e2[t3] = n2 : Qn(e2, t3, n2)) : u2 ? e2[t3] = n2 : Zn(t3, n2);
    })(Function.prototype, "toString", function() {
      return Yn(this) && nr(this).source || er(this);
    });
    var ir = {}, ur = Math.ceil, sr = Math.floor, ar = function(e2) {
      var t3 = +e2;
      return t3 != t3 || t3 === 0 ? 0 : (t3 > 0 ? sr : ur)(t3);
    }, cr = ar, lr = Math.max, pr2 = Math.min, fr = ar, dr = Math.min, hr3 = function(e2) {
      return e2 > 0 ? dr(fr(e2), 9007199254740991) : 0;
    }, gr = function(e2) {
      return hr3(e2.length);
    }, mr = oe, yr = function(e2, t3) {
      var n2 = cr(e2);
      return n2 < 0 ? lr(n2 + t3, 0) : pr2(n2, t3);
    }, Dr = gr, Er = function(e2) {
      return function(t3, n2, r2) {
        var o2, i2 = mr(t3), u2 = Dr(i2), s2 = yr(r2, u2);
        if (e2 && n2 != n2) {
          for (; u2 > s2; )
            if ((o2 = i2[s2++]) != o2)
              return true;
        } else
          for (; u2 > s2; s2++)
            if ((e2 || s2 in i2) && i2[s2] === n2)
              return e2 || s2 || 0;
        return !e2 && -1;
      };
    }, Cr = { includes: Er(true), indexOf: Er(false) }, br = nt, vr = oe, Ar = Cr.indexOf, Fr = An, xr = q([].push), Sr = function(e2, t3) {
      var n2, r2 = vr(e2), o2 = 0, i2 = [];
      for (n2 in r2)
        !br(Fr, n2) && br(r2, n2) && xr(i2, n2);
      for (; t3.length > o2; )
        br(r2, n2 = t3[o2++]) && (~Ar(i2, n2) || xr(i2, n2));
      return i2;
    }, wr2 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Tr = Sr, Br = wr2.concat("length", "prototype");
    ir.f = Object.getOwnPropertyNames || function(e2) {
      return Tr(e2, Br);
    };
    var Nr = {};
    Nr.f = Object.getOwnPropertySymbols;
    var kr = pe, Pr2 = ir, Or2 = Nr, Ir = Yt, Lr = q([].concat), jr = kr("Reflect", "ownKeys") || function(e2) {
      var t3 = Pr2.f(Ir(e2)), n2 = Or2.f;
      return n2 ? Lr(t3, n2(e2)) : t3;
    }, _r = nt, Mr = jr, Rr = w, Vr = zt, $r = T, Wr = ie2, qr = /#|\.prototype\./, Ur = function(e2, t3) {
      var n2 = Gr[zr(e2)];
      return n2 == Jr || n2 != Hr && (Wr(t3) ? $r(t3) : !!t3);
    }, zr = Ur.normalize = function(e2) {
      return String(e2).replace(qr, ".").toLowerCase();
    }, Gr = Ur.data = {}, Hr = Ur.NATIVE = "N", Jr = Ur.POLYFILL = "P", Xr = Ur, Yr = S2, Kr = w.f, Qr = un, Zr = sn.exports, eo = Ge, to = function(e2, t3) {
      for (var n2 = Mr(t3), r2 = Vr.f, o2 = Rr.f, i2 = 0; i2 < n2.length; i2++) {
        var u2 = n2[i2];
        _r(e2, u2) || r2(e2, u2, o2(t3, u2));
      }
    }, no = Xr, ro = function(e2, t3) {
      var n2, r2, o2, i2, u2, s2 = e2.target, a2 = e2.global, c2 = e2.stat;
      if (n2 = a2 ? Yr : c2 ? Yr[s2] || eo(s2, {}) : (Yr[s2] || {}).prototype)
        for (r2 in t3) {
          if (i2 = t3[r2], o2 = e2.noTargetGet ? (u2 = Kr(n2, r2)) && u2.value : n2[r2], !no(a2 ? r2 : s2 + (c2 ? "." : "#") + r2, e2.forced) && o2 !== void 0) {
            if (typeof i2 == typeof o2)
              continue;
            to(i2, o2);
          }
          (e2.sham || o2 && o2.sham) && Qr(i2, "sham", true), Zr(n2, r2, i2, e2);
        }
    }, oo = {};
    oo[Dt("toStringTag")] = "z";
    var io = S2, uo = String(oo) === "[object z]", so = ie2, ao = H, co = Dt("toStringTag"), lo = io.Object, po = ao(function() {
      return arguments;
    }()) == "Arguments", fo = uo ? ao : function(e2) {
      var t3, n2, r2;
      return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (n2 = function(e3, t4) {
        try {
          return e3[t4];
        } catch (e4) {
        }
      }(t3 = lo(e2), co)) == "string" ? n2 : po ? ao(t3) : (r2 = ao(t3)) == "Object" && so(t3.callee) ? "Arguments" : r2;
    }, ho = fo, go = S2.String, mo = q([].slice), yo = Math.floor, Do = function(e2, t3) {
      var n2 = e2.length, r2 = yo(n2 / 2);
      return n2 < 8 ? Eo(e2, t3) : Co(e2, Do(mo(e2, 0, r2), t3), Do(mo(e2, r2), t3), t3);
    }, Eo = function(e2, t3) {
      for (var n2, r2, o2 = e2.length, i2 = 1; i2 < o2; ) {
        for (r2 = i2, n2 = e2[i2]; r2 && t3(e2[r2 - 1], n2) > 0; )
          e2[r2] = e2[--r2];
        r2 !== i2++ && (e2[r2] = n2);
      }
      return e2;
    }, Co = function(e2, t3, n2, r2) {
      for (var o2 = t3.length, i2 = n2.length, u2 = 0, s2 = 0; u2 < o2 || s2 < i2; )
        e2[u2 + s2] = u2 < o2 && s2 < i2 ? r2(t3[u2], n2[s2]) <= 0 ? t3[u2++] : n2[s2++] : u2 < o2 ? t3[u2++] : n2[s2++];
      return e2;
    }, bo = Do, vo = T, Ao = de.match(/firefox\/(\d+)/i), Fo = !!Ao && +Ao[1], xo = /MSIE|Trident/.test(de), So = de.match(/AppleWebKit\/(\d+)\./), wo = !!So && +So[1], To = ro, Bo = q, No = je, ko = Ze, Po = gr, Oo = function(e2) {
      if (ho(e2) === "Symbol")
        throw TypeError("Cannot convert a Symbol value to a string");
      return go(e2);
    }, Io = T, Lo = bo, jo = function(e2, t3) {
      var n2 = [][e2];
      return !!n2 && vo(function() {
        n2.call(null, t3 || function() {
          throw 1;
        }, 1);
      });
    }, _o = Fo, Mo = xo, Ro = Ce, Vo = wo, $o = [], Wo = Bo($o.sort), qo = Bo($o.push), Uo = Io(function() {
      $o.sort(void 0);
    }), zo = Io(function() {
      $o.sort(null);
    }), Go = jo("sort"), Ho = !Io(function() {
      if (Ro)
        return Ro < 70;
      if (!(_o && _o > 3)) {
        if (Mo)
          return true;
        if (Vo)
          return Vo < 603;
        var e2, t3, n2, r2, o2 = "";
        for (e2 = 65; e2 < 76; e2++) {
          switch (t3 = String.fromCharCode(e2), e2) {
            case 66:
            case 69:
            case 70:
            case 72:
              n2 = 3;
              break;
            case 68:
            case 71:
              n2 = 4;
              break;
            default:
              n2 = 2;
          }
          for (r2 = 0; r2 < 47; r2++)
            $o.push({ k: t3 + r2, v: n2 });
        }
        for ($o.sort(function(e3, t4) {
          return t4.v - e3.v;
        }), r2 = 0; r2 < $o.length; r2++)
          t3 = $o[r2].k.charAt(0), o2.charAt(o2.length - 1) !== t3 && (o2 += t3);
        return o2 !== "DGBEFHACIJK";
      }
    });
    To({ target: "Array", proto: true, forced: Uo || !zo || !Go || !Ho }, { sort: function(e2) {
      e2 !== void 0 && No(e2);
      var t3 = ko(this);
      if (Ho)
        return e2 === void 0 ? Wo(t3) : Wo(t3, e2);
      var n2, r2, o2 = [], i2 = Po(t3);
      for (r2 = 0; r2 < i2; r2++)
        r2 in t3 && qo(o2, t3[r2]);
      for (Lo(o2, function(e3) {
        return function(t4, n3) {
          return n3 === void 0 ? -1 : t4 === void 0 ? 1 : e3 !== void 0 ? +e3(t4, n3) || 0 : Oo(t4) > Oo(n3) ? 1 : -1;
        };
      }(e2)), n2 = o2.length, r2 = 0; r2 < n2; )
        t3[r2] = o2[r2++];
      for (; r2 < i2; )
        delete t3[r2++];
      return t3;
    } });
    var Jo = {};
    Object.defineProperty(Jo, "__esModule", { value: true }), Jo.diffJson = function(e2, t3, n2) {
      return Zo.diff(e2, t3, n2);
    }, Jo.canonicalize = ei, Jo.jsonDiff = void 0;
    var Xo = function(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }(o), Yo = g;
    function Ko(e2) {
      return Ko = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e3) {
        return typeof e3;
      } : function(e3) {
        return e3 && typeof Symbol == "function" && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
      }, Ko(e2);
    }
    var Qo = Object.prototype.toString, Zo = new Xo.default();
    function ei(e2, t3, n2, r2, o2) {
      var i2, u2;
      for (t3 = t3 || [], n2 = n2 || [], r2 && (e2 = r2(o2, e2)), i2 = 0; i2 < t3.length; i2 += 1)
        if (t3[i2] === e2)
          return n2[i2];
      if (Qo.call(e2) === "[object Array]") {
        for (t3.push(e2), u2 = new Array(e2.length), n2.push(u2), i2 = 0; i2 < e2.length; i2 += 1)
          u2[i2] = ei(e2[i2], t3, n2, r2, o2);
        return t3.pop(), n2.pop(), u2;
      }
      if (e2 && e2.toJSON && (e2 = e2.toJSON()), Ko(e2) === "object" && e2 !== null) {
        t3.push(e2), u2 = {}, n2.push(u2);
        var s2, a2 = [];
        for (s2 in e2)
          e2.hasOwnProperty(s2) && a2.push(s2);
        for (a2.sort(), i2 = 0; i2 < a2.length; i2 += 1)
          u2[s2 = a2[i2]] = ei(e2[s2], t3, n2, r2, s2);
        t3.pop(), n2.pop();
      } else
        u2 = e2;
      return u2;
    }
    Jo.jsonDiff = Zo, Zo.useLongestToken = true, Zo.tokenize = Yo.lineDiff.tokenize, Zo.castInput = function(e2) {
      var t3 = this.options, n2 = t3.undefinedReplacement, r2 = t3.stringifyReplacer, o2 = r2 === void 0 ? function(e3, t4) {
        return t4 === void 0 ? n2 : t4;
      } : r2;
      return typeof e2 == "string" ? e2 : JSON.stringify(ei(e2, null, null, o2), o2, "  ");
    }, Zo.equals = function(e2, t3) {
      return Xo.default.prototype.equals.call(Zo, e2.replace(/,([\r\n])/g, "$1"), t3.replace(/,([\r\n])/g, "$1"));
    };
    var ti = {};
    Object.defineProperty(ti, "__esModule", { value: true }), ti.diffArrays = function(e2, t3, n2) {
      return ri.diff(e2, t3, n2);
    }, ti.arrayDiff = void 0;
    var ni2 = function(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }(o);
    var ri = new ni2.default();
    ti.arrayDiff = ri, ri.tokenize = function(e2) {
      return e2.slice();
    }, ri.join = ri.removeEmpty = function(e2) {
      return e2;
    };
    var oi = {}, ii2 = {};
    Object.defineProperty(ii2, "__esModule", { value: true }), ii2.parsePatch = function(e2) {
      var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n2 = e2.split(/\r\n|[\n\v\f\r\x85]/), r2 = e2.match(/\r\n|[\n\v\f\r\x85]/g) || [], o2 = [], i2 = 0;
      function u2() {
        var e3 = {};
        for (o2.push(e3); i2 < n2.length; ) {
          var r3 = n2[i2];
          if (/^(\-\-\-|\+\+\+|@@)\s/.test(r3))
            break;
          var u3 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r3);
          u3 && (e3.index = u3[1]), i2++;
        }
        for (s2(e3), s2(e3), e3.hunks = []; i2 < n2.length; ) {
          var c2 = n2[i2];
          if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(c2))
            break;
          if (/^@@/.test(c2))
            e3.hunks.push(a2());
          else {
            if (c2 && t3.strict)
              throw new Error("Unknown line " + (i2 + 1) + " " + JSON.stringify(c2));
            i2++;
          }
        }
      }
      function s2(e3) {
        var t4 = /^(---|\+\+\+)\s+(.*)$/.exec(n2[i2]);
        if (t4) {
          var r3 = t4[1] === "---" ? "old" : "new", o3 = t4[2].split("	", 2), u3 = o3[0].replace(/\\\\/g, "\\");
          /^".*"$/.test(u3) && (u3 = u3.substr(1, u3.length - 2)), e3[r3 + "FileName"] = u3, e3[r3 + "Header"] = (o3[1] || "").trim(), i2++;
        }
      }
      function a2() {
        var e3 = i2, o3 = n2[i2++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), u3 = { oldStart: +o3[1], oldLines: o3[2] === void 0 ? 1 : +o3[2], newStart: +o3[3], newLines: o3[4] === void 0 ? 1 : +o3[4], lines: [], linedelimiters: [] };
        u3.oldLines === 0 && (u3.oldStart += 1), u3.newLines === 0 && (u3.newStart += 1);
        for (var s3 = 0, a3 = 0; i2 < n2.length && !(n2[i2].indexOf("--- ") === 0 && i2 + 2 < n2.length && n2[i2 + 1].indexOf("+++ ") === 0 && n2[i2 + 2].indexOf("@@") === 0); i2++) {
          var c2 = n2[i2].length == 0 && i2 != n2.length - 1 ? " " : n2[i2][0];
          if (c2 !== "+" && c2 !== "-" && c2 !== " " && c2 !== "\\")
            break;
          u3.lines.push(n2[i2]), u3.linedelimiters.push(r2[i2] || "\n"), c2 === "+" ? s3++ : c2 === "-" ? a3++ : c2 === " " && (s3++, a3++);
        }
        if (s3 || u3.newLines !== 1 || (u3.newLines = 0), a3 || u3.oldLines !== 1 || (u3.oldLines = 0), t3.strict) {
          if (s3 !== u3.newLines)
            throw new Error("Added line count did not match for hunk at line " + (e3 + 1));
          if (a3 !== u3.oldLines)
            throw new Error("Removed line count did not match for hunk at line " + (e3 + 1));
        }
        return u3;
      }
      for (; i2 < n2.length; )
        u2();
      return o2;
    };
    var ui = {};
    !function(e2) {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.default = function(e3, t3, n2) {
        var r2 = true, o2 = false, i2 = false, u2 = 1;
        return function s2() {
          if (r2 && !i2) {
            if (o2 ? u2++ : r2 = false, e3 + u2 <= n2)
              return u2;
            i2 = true;
          }
          if (!o2)
            return i2 || (r2 = true), t3 <= e3 - u2 ? -u2++ : (o2 = true, s2());
        };
      };
    }(ui), Object.defineProperty(oi, "__esModule", { value: true }), oi.applyPatch = ci, oi.applyPatches = function(e2, t3) {
      typeof e2 == "string" && (e2 = (0, si.parsePatch)(e2));
      var n2 = 0;
      !function r2() {
        var o2 = e2[n2++];
        if (!o2)
          return t3.complete();
        t3.loadFile(o2, function(e3, n3) {
          if (e3)
            return t3.complete(e3);
          var i2 = ci(n3, o2, t3);
          t3.patched(o2, i2, function(e4) {
            if (e4)
              return t3.complete(e4);
            r2();
          });
        });
      }();
    };
    var si = ii2, ai = function(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }(ui);
    function ci(e2, t3) {
      var n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (typeof t3 == "string" && (t3 = (0, si.parsePatch)(t3)), Array.isArray(t3)) {
        if (t3.length > 1)
          throw new Error("applyPatch only works with a single input.");
        t3 = t3[0];
      }
      var r2, o2, i2 = e2.split(/\r\n|[\n\v\f\r\x85]/), u2 = e2.match(/\r\n|[\n\v\f\r\x85]/g) || [], s2 = t3.hunks, a2 = n2.compareLine || function(e3, t4, n3, r3) {
        return t4 === r3;
      }, c2 = 0, l2 = n2.fuzzFactor || 0, p2 = 0, f2 = 0;
      function d2(e3, t4) {
        for (var n3 = 0; n3 < e3.lines.length; n3++) {
          var r3 = e3.lines[n3], o3 = r3.length > 0 ? r3[0] : " ", u3 = r3.length > 0 ? r3.substr(1) : r3;
          if (o3 === " " || o3 === "-") {
            if (!a2(t4 + 1, i2[t4], o3, u3) && ++c2 > l2)
              return false;
            t4++;
          }
        }
        return true;
      }
      for (var h2 = 0; h2 < s2.length; h2++) {
        for (var g2 = s2[h2], m2 = i2.length - g2.oldLines, y2 = 0, D2 = f2 + g2.oldStart - 1, E2 = (0, ai.default)(D2, p2, m2); y2 !== void 0; y2 = E2())
          if (d2(g2, D2 + y2)) {
            g2.offset = f2 += y2;
            break;
          }
        if (y2 === void 0)
          return false;
        p2 = g2.offset + g2.oldStart + g2.oldLines;
      }
      for (var C3 = 0, b2 = 0; b2 < s2.length; b2++) {
        var v2 = s2[b2], A2 = v2.oldStart + v2.offset + C3 - 1;
        C3 += v2.newLines - v2.oldLines;
        for (var F2 = 0; F2 < v2.lines.length; F2++) {
          var x2 = v2.lines[F2], S3 = x2.length > 0 ? x2[0] : " ", w2 = x2.length > 0 ? x2.substr(1) : x2, T2 = v2.linedelimiters[F2];
          if (S3 === " ")
            A2++;
          else if (S3 === "-")
            i2.splice(A2, 1), u2.splice(A2, 1);
          else if (S3 === "+")
            i2.splice(A2, 0, w2), u2.splice(A2, 0, T2), A2++;
          else if (S3 === "\\") {
            var B2 = v2.lines[F2 - 1] ? v2.lines[F2 - 1][0] : null;
            B2 === "+" ? r2 = true : B2 === "-" && (o2 = true);
          }
        }
      }
      if (r2)
        for (; !i2[i2.length - 1]; )
          i2.pop(), u2.pop();
      else
        o2 && (i2.push(""), u2.push("\n"));
      for (var N2 = 0; N2 < i2.length - 1; N2++)
        i2[N2] = i2[N2] + u2[N2];
      return i2.join("");
    }
    var li = {}, pi2 = {};
    Object.defineProperty(pi2, "__esModule", { value: true }), pi2.structuredPatch = gi, pi2.formatPatch = mi, pi2.createTwoFilesPatch = yi, pi2.createPatch = function(e2, t3, n2, r2, o2, i2) {
      return yi(e2, e2, t3, n2, r2, o2, i2);
    };
    var fi = g;
    function di(e2) {
      return function(e3) {
        if (Array.isArray(e3))
          return hi(e3);
      }(e2) || function(e3) {
        if (typeof Symbol != "undefined" && Symbol.iterator in Object(e3))
          return Array.from(e3);
      }(e2) || function(e3, t3) {
        if (!e3)
          return;
        if (typeof e3 == "string")
          return hi(e3, t3);
        var n2 = Object.prototype.toString.call(e3).slice(8, -1);
        n2 === "Object" && e3.constructor && (n2 = e3.constructor.name);
        if (n2 === "Map" || n2 === "Set")
          return Array.from(e3);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return hi(e3, t3);
      }(e2) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function hi(e2, t3) {
      (t3 == null || t3 > e2.length) && (t3 = e2.length);
      for (var n2 = 0, r2 = new Array(t3); n2 < t3; n2++)
        r2[n2] = e2[n2];
      return r2;
    }
    function gi(e2, t3, n2, r2, o2, i2, u2) {
      u2 || (u2 = {}), u2.context === void 0 && (u2.context = 4);
      var s2 = (0, fi.diffLines)(n2, r2, u2);
      function a2(e3) {
        return e3.map(function(e4) {
          return " " + e4;
        });
      }
      s2.push({ value: "", lines: [] });
      for (var c2 = [], l2 = 0, p2 = 0, f2 = [], d2 = 1, h2 = 1, g2 = function(e3) {
        var t4 = s2[e3], o3 = t4.lines || t4.value.replace(/\n$/, "").split("\n");
        if (t4.lines = o3, t4.added || t4.removed) {
          var i3;
          if (!l2) {
            var g3 = s2[e3 - 1];
            l2 = d2, p2 = h2, g3 && (f2 = u2.context > 0 ? a2(g3.lines.slice(-u2.context)) : [], l2 -= f2.length, p2 -= f2.length);
          }
          (i3 = f2).push.apply(i3, di(o3.map(function(e4) {
            return (t4.added ? "+" : "-") + e4;
          }))), t4.added ? h2 += o3.length : d2 += o3.length;
        } else {
          if (l2)
            if (o3.length <= 2 * u2.context && e3 < s2.length - 2) {
              var m3;
              (m3 = f2).push.apply(m3, di(a2(o3)));
            } else {
              var y2, D2 = Math.min(o3.length, u2.context);
              (y2 = f2).push.apply(y2, di(a2(o3.slice(0, D2))));
              var E2 = { oldStart: l2, oldLines: d2 - l2 + D2, newStart: p2, newLines: h2 - p2 + D2, lines: f2 };
              if (e3 >= s2.length - 2 && o3.length <= u2.context) {
                var C3 = /\n$/.test(n2), b2 = /\n$/.test(r2), v2 = o3.length == 0 && f2.length > E2.oldLines;
                !C3 && v2 && n2.length > 0 && f2.splice(E2.oldLines, 0, "\\ No newline at end of file"), (C3 || v2) && b2 || f2.push("\\ No newline at end of file");
              }
              c2.push(E2), l2 = 0, p2 = 0, f2 = [];
            }
          d2 += o3.length, h2 += o3.length;
        }
      }, m2 = 0; m2 < s2.length; m2++)
        g2(m2);
      return { oldFileName: e2, newFileName: t3, oldHeader: o2, newHeader: i2, hunks: c2 };
    }
    function mi(e2) {
      var t3 = [];
      e2.oldFileName == e2.newFileName && t3.push("Index: " + e2.oldFileName), t3.push("==================================================================="), t3.push("--- " + e2.oldFileName + (e2.oldHeader === void 0 ? "" : "	" + e2.oldHeader)), t3.push("+++ " + e2.newFileName + (e2.newHeader === void 0 ? "" : "	" + e2.newHeader));
      for (var n2 = 0; n2 < e2.hunks.length; n2++) {
        var r2 = e2.hunks[n2];
        r2.oldLines === 0 && (r2.oldStart -= 1), r2.newLines === 0 && (r2.newStart -= 1), t3.push("@@ -" + r2.oldStart + "," + r2.oldLines + " +" + r2.newStart + "," + r2.newLines + " @@"), t3.push.apply(t3, r2.lines);
      }
      return t3.join("\n") + "\n";
    }
    function yi(e2, t3, n2, r2, o2, i2, u2) {
      return mi(gi(e2, t3, n2, r2, o2, i2, u2));
    }
    var Di = {};
    function Ei(e2, t3) {
      if (t3.length > e2.length)
        return false;
      for (var n2 = 0; n2 < t3.length; n2++)
        if (t3[n2] !== e2[n2])
          return false;
      return true;
    }
    Object.defineProperty(Di, "__esModule", { value: true }), Di.arrayEqual = function(e2, t3) {
      if (e2.length !== t3.length)
        return false;
      return Ei(e2, t3);
    }, Di.arrayStartsWith = Ei, Object.defineProperty(li, "__esModule", { value: true }), li.calcLineCount = xi2, li.merge = function(e2, t3, n2) {
      e2 = Si(e2, n2), t3 = Si(t3, n2);
      var r2 = {};
      (e2.index || t3.index) && (r2.index = e2.index || t3.index);
      (e2.newFileName || t3.newFileName) && (wi(e2) ? wi(t3) ? (r2.oldFileName = Ti(r2, e2.oldFileName, t3.oldFileName), r2.newFileName = Ti(r2, e2.newFileName, t3.newFileName), r2.oldHeader = Ti(r2, e2.oldHeader, t3.oldHeader), r2.newHeader = Ti(r2, e2.newHeader, t3.newHeader)) : (r2.oldFileName = e2.oldFileName, r2.newFileName = e2.newFileName, r2.oldHeader = e2.oldHeader, r2.newHeader = e2.newHeader) : (r2.oldFileName = t3.oldFileName || e2.oldFileName, r2.newFileName = t3.newFileName || e2.newFileName, r2.oldHeader = t3.oldHeader || e2.oldHeader, r2.newHeader = t3.newHeader || e2.newHeader));
      r2.hunks = [];
      var o2 = 0, i2 = 0, u2 = 0, s2 = 0;
      for (; o2 < e2.hunks.length || i2 < t3.hunks.length; ) {
        var a2 = e2.hunks[o2] || { oldStart: 1 / 0 }, c2 = t3.hunks[i2] || { oldStart: 1 / 0 };
        if (Bi(a2, c2))
          r2.hunks.push(Ni(a2, u2)), o2++, s2 += a2.newLines - a2.oldLines;
        else if (Bi(c2, a2))
          r2.hunks.push(Ni(c2, s2)), i2++, u2 += c2.newLines - c2.oldLines;
        else {
          var l2 = { oldStart: Math.min(a2.oldStart, c2.oldStart), oldLines: 0, newStart: Math.min(a2.newStart + u2, c2.oldStart + s2), newLines: 0, lines: [] };
          ki(l2, a2.oldStart, a2.lines, c2.oldStart, c2.lines), i2++, o2++, r2.hunks.push(l2);
        }
      }
      return r2;
    };
    var Ci = pi2, bi = ii2, vi = Di;
    function Ai(e2) {
      return function(e3) {
        if (Array.isArray(e3))
          return Fi(e3);
      }(e2) || function(e3) {
        if (typeof Symbol != "undefined" && Symbol.iterator in Object(e3))
          return Array.from(e3);
      }(e2) || function(e3, t3) {
        if (!e3)
          return;
        if (typeof e3 == "string")
          return Fi(e3, t3);
        var n2 = Object.prototype.toString.call(e3).slice(8, -1);
        n2 === "Object" && e3.constructor && (n2 = e3.constructor.name);
        if (n2 === "Map" || n2 === "Set")
          return Array.from(e3);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return Fi(e3, t3);
      }(e2) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function Fi(e2, t3) {
      (t3 == null || t3 > e2.length) && (t3 = e2.length);
      for (var n2 = 0, r2 = new Array(t3); n2 < t3; n2++)
        r2[n2] = e2[n2];
      return r2;
    }
    function xi2(e2) {
      var t3 = Vi(e2.lines), n2 = t3.oldLines, r2 = t3.newLines;
      n2 !== void 0 ? e2.oldLines = n2 : delete e2.oldLines, r2 !== void 0 ? e2.newLines = r2 : delete e2.newLines;
    }
    function Si(e2, t3) {
      if (typeof e2 == "string") {
        if (/^@@/m.test(e2) || /^Index:/m.test(e2))
          return (0, bi.parsePatch)(e2)[0];
        if (!t3)
          throw new Error("Must provide a base reference or pass in a patch");
        return (0, Ci.structuredPatch)(void 0, void 0, t3, e2);
      }
      return e2;
    }
    function wi(e2) {
      return e2.newFileName && e2.newFileName !== e2.oldFileName;
    }
    function Ti(e2, t3, n2) {
      return t3 === n2 ? t3 : (e2.conflict = true, { mine: t3, theirs: n2 });
    }
    function Bi(e2, t3) {
      return e2.oldStart < t3.oldStart && e2.oldStart + e2.oldLines < t3.oldStart;
    }
    function Ni(e2, t3) {
      return { oldStart: e2.oldStart, oldLines: e2.oldLines, newStart: e2.newStart + t3, newLines: e2.newLines, lines: e2.lines };
    }
    function ki(e2, t3, n2, r2, o2) {
      var i2 = { offset: t3, lines: n2, index: 0 }, u2 = { offset: r2, lines: o2, index: 0 };
      for (Li(e2, i2, u2), Li(e2, u2, i2); i2.index < i2.lines.length && u2.index < u2.lines.length; ) {
        var s2 = i2.lines[i2.index], a2 = u2.lines[u2.index];
        if (s2[0] !== "-" && s2[0] !== "+" || a2[0] !== "-" && a2[0] !== "+")
          if (s2[0] === "+" && a2[0] === " ") {
            var c2;
            (c2 = e2.lines).push.apply(c2, Ai(_i(i2)));
          } else if (a2[0] === "+" && s2[0] === " ") {
            var l2;
            (l2 = e2.lines).push.apply(l2, Ai(_i(u2)));
          } else
            s2[0] === "-" && a2[0] === " " ? Oi(e2, i2, u2) : a2[0] === "-" && s2[0] === " " ? Oi(e2, u2, i2, true) : s2 === a2 ? (e2.lines.push(s2), i2.index++, u2.index++) : Ii(e2, _i(i2), _i(u2));
        else
          Pi2(e2, i2, u2);
      }
      ji(e2, i2), ji(e2, u2), xi2(e2);
    }
    function Pi2(e2, t3, n2) {
      var r2 = _i(t3), o2 = _i(n2);
      if (Mi(r2) && Mi(o2)) {
        var i2, u2;
        if ((0, vi.arrayStartsWith)(r2, o2) && Ri(n2, r2, r2.length - o2.length))
          return void (i2 = e2.lines).push.apply(i2, Ai(r2));
        if ((0, vi.arrayStartsWith)(o2, r2) && Ri(t3, o2, o2.length - r2.length))
          return void (u2 = e2.lines).push.apply(u2, Ai(o2));
      } else if ((0, vi.arrayEqual)(r2, o2)) {
        var s2;
        return void (s2 = e2.lines).push.apply(s2, Ai(r2));
      }
      Ii(e2, r2, o2);
    }
    function Oi(e2, t3, n2, r2) {
      var o2, i2 = _i(t3), u2 = function(e3, t4) {
        var n3 = [], r3 = [], o3 = 0, i3 = false, u3 = false;
        for (; o3 < t4.length && e3.index < e3.lines.length; ) {
          var s2 = e3.lines[e3.index], a2 = t4[o3];
          if (a2[0] === "+")
            break;
          if (i3 = i3 || s2[0] !== " ", r3.push(a2), o3++, s2[0] === "+")
            for (u3 = true; s2[0] === "+"; )
              n3.push(s2), s2 = e3.lines[++e3.index];
          a2.substr(1) === s2.substr(1) ? (n3.push(s2), e3.index++) : u3 = true;
        }
        (t4[o3] || "")[0] === "+" && i3 && (u3 = true);
        if (u3)
          return n3;
        for (; o3 < t4.length; )
          r3.push(t4[o3++]);
        return { merged: r3, changes: n3 };
      }(n2, i2);
      u2.merged ? (o2 = e2.lines).push.apply(o2, Ai(u2.merged)) : Ii(e2, r2 ? u2 : i2, r2 ? i2 : u2);
    }
    function Ii(e2, t3, n2) {
      e2.conflict = true, e2.lines.push({ conflict: true, mine: t3, theirs: n2 });
    }
    function Li(e2, t3, n2) {
      for (; t3.offset < n2.offset && t3.index < t3.lines.length; ) {
        var r2 = t3.lines[t3.index++];
        e2.lines.push(r2), t3.offset++;
      }
    }
    function ji(e2, t3) {
      for (; t3.index < t3.lines.length; ) {
        var n2 = t3.lines[t3.index++];
        e2.lines.push(n2);
      }
    }
    function _i(e2) {
      for (var t3 = [], n2 = e2.lines[e2.index][0]; e2.index < e2.lines.length; ) {
        var r2 = e2.lines[e2.index];
        if (n2 === "-" && r2[0] === "+" && (n2 = "+"), n2 !== r2[0])
          break;
        t3.push(r2), e2.index++;
      }
      return t3;
    }
    function Mi(e2) {
      return e2.reduce(function(e3, t3) {
        return e3 && t3[0] === "-";
      }, true);
    }
    function Ri(e2, t3, n2) {
      for (var r2 = 0; r2 < n2; r2++) {
        var o2 = t3[t3.length - n2 + r2].substr(1);
        if (e2.lines[e2.index + r2] !== " " + o2)
          return false;
      }
      return e2.index += n2, true;
    }
    function Vi(e2) {
      var t3 = 0, n2 = 0;
      return e2.forEach(function(e3) {
        if (typeof e3 != "string") {
          var r2 = Vi(e3.mine), o2 = Vi(e3.theirs);
          t3 !== void 0 && (r2.oldLines === o2.oldLines ? t3 += r2.oldLines : t3 = void 0), n2 !== void 0 && (r2.newLines === o2.newLines ? n2 += r2.newLines : n2 = void 0);
        } else
          n2 === void 0 || e3[0] !== "+" && e3[0] !== " " || n2++, t3 === void 0 || e3[0] !== "-" && e3[0] !== " " || t3++;
      }), { oldLines: t3, newLines: n2 };
    }
    var $i = {};
    Object.defineProperty($i, "__esModule", { value: true }), $i.convertChangesToDMP = function(e2) {
      for (var t3, n2, r2 = [], o2 = 0; o2 < e2.length; o2++)
        t3 = e2[o2], n2 = t3.added ? 1 : t3.removed ? -1 : 0, r2.push([n2, t3.value]);
      return r2;
    };
    var Wi = {};
    function qi(e2) {
      var t3 = e2;
      return t3 = (t3 = (t3 = (t3 = t3.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;");
    }
    function Ui(e2) {
      return { type: "concat", parts: e2 };
    }
    function zi(e2) {
      return { type: "indent", contents: e2 };
    }
    function Gi(e2, t3) {
      return { type: "align", contents: t3, n: e2 };
    }
    function Hi(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return { type: "group", id: t3.id, contents: e2, break: Boolean(t3.shouldBreak), expandedStates: t3.expandedStates };
    }
    Object.defineProperty(Wi, "__esModule", { value: true }), Wi.convertChangesToXML = function(e2) {
      for (var t3 = [], n2 = 0; n2 < e2.length; n2++) {
        var r2 = e2[n2];
        r2.added ? t3.push("<ins>") : r2.removed && t3.push("<del>"), t3.push(qi(r2.value)), r2.added ? t3.push("</ins>") : r2.removed && t3.push("</del>");
      }
      return t3.join("");
    }, function(e2) {
      Object.defineProperty(e2, "__esModule", { value: true }), Object.defineProperty(e2, "Diff", { enumerable: true, get: function() {
        return t3.default;
      } }), Object.defineProperty(e2, "diffChars", { enumerable: true, get: function() {
        return n2.diffChars;
      } }), Object.defineProperty(e2, "diffWords", { enumerable: true, get: function() {
        return r2.diffWords;
      } }), Object.defineProperty(e2, "diffWordsWithSpace", { enumerable: true, get: function() {
        return r2.diffWordsWithSpace;
      } }), Object.defineProperty(e2, "diffLines", { enumerable: true, get: function() {
        return i2.diffLines;
      } }), Object.defineProperty(e2, "diffTrimmedLines", { enumerable: true, get: function() {
        return i2.diffTrimmedLines;
      } }), Object.defineProperty(e2, "diffSentences", { enumerable: true, get: function() {
        return s2.diffSentences;
      } }), Object.defineProperty(e2, "diffCss", { enumerable: true, get: function() {
        return c2.diffCss;
      } }), Object.defineProperty(e2, "diffJson", { enumerable: true, get: function() {
        return l2.diffJson;
      } }), Object.defineProperty(e2, "canonicalize", { enumerable: true, get: function() {
        return l2.canonicalize;
      } }), Object.defineProperty(e2, "diffArrays", { enumerable: true, get: function() {
        return p2.diffArrays;
      } }), Object.defineProperty(e2, "applyPatch", { enumerable: true, get: function() {
        return f2.applyPatch;
      } }), Object.defineProperty(e2, "applyPatches", { enumerable: true, get: function() {
        return f2.applyPatches;
      } }), Object.defineProperty(e2, "parsePatch", { enumerable: true, get: function() {
        return d2.parsePatch;
      } }), Object.defineProperty(e2, "merge", { enumerable: true, get: function() {
        return h2.merge;
      } }), Object.defineProperty(e2, "structuredPatch", { enumerable: true, get: function() {
        return m2.structuredPatch;
      } }), Object.defineProperty(e2, "createTwoFilesPatch", { enumerable: true, get: function() {
        return m2.createTwoFilesPatch;
      } }), Object.defineProperty(e2, "createPatch", { enumerable: true, get: function() {
        return m2.createPatch;
      } }), Object.defineProperty(e2, "convertChangesToDMP", { enumerable: true, get: function() {
        return y2.convertChangesToDMP;
      } }), Object.defineProperty(e2, "convertChangesToXML", { enumerable: true, get: function() {
        return D2.convertChangesToXML;
      } });
      var t3 = function(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }(o), n2 = u, r2 = a, i2 = g, s2 = E, c2 = v, l2 = Jo, p2 = ti, f2 = oi, d2 = ii2, h2 = li, m2 = pi2, y2 = $i, D2 = Wi;
    }(r);
    const Ji = { type: "break-parent" }, Xi2 = { type: "line", hard: true }, Yi = { type: "line", hard: true, literal: true }, Ki = Ui([Xi2, Ji]), Qi = Ui([Yi, Ji]);
    var Zi = { concat: Ui, join: function(e2, t3) {
      const n2 = [];
      for (let r2 = 0; r2 < t3.length; r2++)
        r2 !== 0 && n2.push(e2), n2.push(t3[r2]);
      return Ui(n2);
    }, line: { type: "line" }, softline: { type: "line", soft: true }, hardline: Ki, literalline: Qi, group: Hi, conditionalGroup: function(e2, t3) {
      return Hi(e2[0], Object.assign(Object.assign({}, t3), {}, { expandedStates: e2 }));
    }, fill: function(e2) {
      return { type: "fill", parts: e2 };
    }, lineSuffix: function(e2) {
      return { type: "line-suffix", contents: e2 };
    }, lineSuffixBoundary: { type: "line-suffix-boundary" }, cursor: { type: "cursor", placeholder: Symbol("cursor") }, breakParent: Ji, ifBreak: function(e2, t3) {
      let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return { type: "if-break", breakContents: e2, flatContents: t3, groupId: n2.groupId };
    }, trim: { type: "trim" }, indent: zi, indentIfBreak: function(e2, t3) {
      return { type: "indent-if-break", contents: e2, groupId: t3.groupId, negate: t3.negate };
    }, align: Gi, addAlignmentToDoc: function(e2, t3, n2) {
      let r2 = e2;
      if (t3 > 0) {
        for (let e3 = 0; e3 < Math.floor(t3 / n2); ++e3)
          r2 = zi(r2);
        r2 = Gi(t3 % n2, r2), r2 = Gi(Number.NEGATIVE_INFINITY, r2);
      }
      return r2;
    }, markAsRoot: function(e2) {
      return Gi({ type: "root" }, e2);
    }, dedentToRoot: function(e2) {
      return Gi(Number.NEGATIVE_INFINITY, e2);
    }, dedent: function(e2) {
      return Gi(-1, e2);
    }, hardlineWithoutBreakParent: Xi2, literallineWithoutBreakParent: Yi, label: function(e2, t3) {
      return { type: "label", label: e2, contents: t3 };
    } }, eu = { exports: {} };
    const tu = function() {
      let { onlyFirst: e2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const t3 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(t3, e2 ? void 0 : "g");
    };
    var nu2 = { exports: {} };
    const ru = (e2) => !Number.isNaN(e2) && (e2 >= 4352 && (e2 <= 4447 || e2 === 9001 || e2 === 9002 || 11904 <= e2 && e2 <= 12871 && e2 !== 12351 || 12880 <= e2 && e2 <= 19903 || 19968 <= e2 && e2 <= 42182 || 43360 <= e2 && e2 <= 43388 || 44032 <= e2 && e2 <= 55203 || 63744 <= e2 && e2 <= 64255 || 65040 <= e2 && e2 <= 65049 || 65072 <= e2 && e2 <= 65131 || 65281 <= e2 && e2 <= 65376 || 65504 <= e2 && e2 <= 65510 || 110592 <= e2 && e2 <= 110593 || 127488 <= e2 && e2 <= 127569 || 131072 <= e2 && e2 <= 262141));
    nu2.exports = ru, nu2.exports.default = ru;
    const ou = (e2) => typeof e2 == "string" ? e2.replace(tu(), "") : e2, iu = nu2.exports, uu = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    }, su = (e2) => {
      if (typeof e2 != "string" || e2.length === 0)
        return 0;
      if ((e2 = ou(e2)).length === 0)
        return 0;
      e2 = e2.replace(uu(), "  ");
      let t3 = 0;
      for (let n2 = 0; n2 < e2.length; n2++) {
        const r2 = e2.codePointAt(n2);
        r2 <= 31 || r2 >= 127 && r2 <= 159 || (r2 >= 768 && r2 <= 879 || (r2 > 65535 && n2++, t3 += iu(r2) ? 2 : 1));
      }
      return t3;
    };
    eu.exports = su, eu.exports.default = su;
    var au = (e2) => e2[e2.length - 1];
    function cu(e2, t3) {
      if (e2 == null)
        return {};
      var n2, r2, o2 = function(e3, t4) {
        if (e3 == null)
          return {};
        var n3, r3, o3 = {}, i3 = Object.keys(e3);
        for (r3 = 0; r3 < i3.length; r3++)
          n3 = i3[r3], t4.indexOf(n3) >= 0 || (o3[n3] = e3[n3]);
        return o3;
      }(e2, t3);
      if (Object.getOwnPropertySymbols) {
        var i2 = Object.getOwnPropertySymbols(e2);
        for (r2 = 0; r2 < i2.length; r2++)
          n2 = i2[r2], t3.indexOf(n2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, n2) && (o2[n2] = e2[n2]);
      }
      return o2;
    }
    function lu(e2, t3) {
      return t3 || (t3 = e2.slice(0)), Object.freeze(Object.defineProperties(e2, { raw: { value: Object.freeze(t3) } }));
    }
    var pu = H, fu = Array.isArray || function(e2) {
      return pu(e2) == "Array";
    }, du = je, hu = q(q.bind), gu = function(e2, t3) {
      return du(e2), t3 === void 0 ? e2 : hu ? hu(e2, t3) : function() {
        return e2.apply(t3, arguments);
      };
    }, mu2 = fu, yu = gr, Du = gu, Eu = S2.TypeError, Cu = function(e2, t3, n2, r2, o2, i2, u2, s2) {
      for (var a2, c2, l2 = o2, p2 = 0, f2 = !!u2 && Du(u2, s2); p2 < r2; ) {
        if (p2 in n2) {
          if (a2 = f2 ? f2(n2[p2], p2, t3) : n2[p2], i2 > 0 && mu2(a2))
            c2 = yu(a2), l2 = Cu(e2, t3, a2, c2, l2, i2 - 1) - 1;
          else {
            if (l2 >= 9007199254740991)
              throw Eu("Exceed the acceptable array length");
            e2[l2] = a2;
          }
          l2++;
        }
        p2++;
      }
      return l2;
    }, bu = Cu, vu = q, Au = T, Fu = ie2, xu = fo, Su = hn, wu = function() {
    }, Tu = [], Bu = pe("Reflect", "construct"), Nu2 = /^\s*(?:class|function)\b/, ku = vu(Nu2.exec), Pu = !Nu2.exec(wu), Ou = function(e2) {
      if (!Fu(e2))
        return false;
      try {
        return Bu(wu, Tu, e2), true;
      } catch (e3) {
        return false;
      }
    }, Iu = !Bu || Au(function() {
      var e2;
      return Ou(Ou.call) || !Ou(Object) || !Ou(function() {
        e2 = true;
      }) || e2;
    }) ? function(e2) {
      if (!Fu(e2))
        return false;
      switch (xu(e2)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      return Pu || !!ku(Nu2, Su(e2));
    } : Ou, Lu = S2, ju = fu, _u = Iu, Mu2 = se, Ru = Dt("species"), Vu = Lu.Array, $u = function(e2) {
      var t3;
      return ju(e2) && (t3 = e2.constructor, (_u(t3) && (t3 === Vu || ju(t3.prototype)) || Mu2(t3) && (t3 = t3[Ru]) === null) && (t3 = void 0)), t3 === void 0 ? Vu : t3;
    }, Wu = function(e2, t3) {
      return new ($u(e2))(t3 === 0 ? 0 : t3);
    }, qu = bu, Uu = je, zu = Ze, Gu = gr, Hu = Wu;
    ro({ target: "Array", proto: true }, { flatMap: function(e2) {
      var t3, n2 = zu(this), r2 = Gu(n2);
      return Uu(e2), (t3 = Hu(n2, 0)).length = qu(t3, n2, n2, r2, 0, 1, e2, arguments.length > 1 ? arguments[1] : void 0), t3;
    } });
    var Ju = {}, Xu = Ju, Yu = Dt("iterator"), Ku = Array.prototype, Qu = fo, Zu = Me, es = Ju, ts = Dt("iterator"), ns = function(e2) {
      if (e2 != null)
        return Zu(e2, ts) || Zu(e2, "@@iterator") || es[Qu(e2)];
    }, rs = k, os = je, is = Yt, us = Pe, ss = ns, as = S2.TypeError, cs = k, ls = Yt, ps = Me, fs = gu, ds = k, hs = Yt, gs = Pe, ms = function(e2) {
      return e2 !== void 0 && (Xu.Array === e2 || Ku[Yu] === e2);
    }, ys = gr, Ds = fe, Es = function(e2, t3) {
      var n2 = arguments.length < 2 ? ss(e2) : t3;
      if (os(n2))
        return is(rs(n2, e2));
      throw as(us(e2) + " is not iterable");
    }, Cs = ns, bs = function(e2, t3, n2) {
      var r2, o2;
      ls(e2);
      try {
        if (!(r2 = ps(e2, "return"))) {
          if (t3 === "throw")
            throw n2;
          return n2;
        }
        r2 = cs(r2, e2);
      } catch (e3) {
        o2 = true, r2 = e3;
      }
      if (t3 === "throw")
        throw n2;
      if (o2)
        throw r2;
      return ls(r2), n2;
    }, vs = S2.TypeError, As = function(e2, t3) {
      this.stopped = e2, this.result = t3;
    }, Fs = As.prototype, xs = Bt, Ss = zt, ws = M, Ts = function(e2, t3, n2) {
      var r2, o2, i2, u2, s2, a2, c2, l2 = n2 && n2.that, p2 = !(!n2 || !n2.AS_ENTRIES), f2 = !(!n2 || !n2.IS_ITERATOR), d2 = !(!n2 || !n2.INTERRUPTED), h2 = fs(t3, l2), g2 = function(e3) {
        return r2 && bs(r2, "normal", e3), new As(true, e3);
      }, m2 = function(e3) {
        return p2 ? (hs(e3), d2 ? h2(e3[0], e3[1], g2) : h2(e3[0], e3[1])) : d2 ? h2(e3, g2) : h2(e3);
      };
      if (f2)
        r2 = e2;
      else {
        if (!(o2 = Cs(e2)))
          throw vs(gs(e2) + " is not iterable");
        if (ms(o2)) {
          for (i2 = 0, u2 = ys(e2); u2 > i2; i2++)
            if ((s2 = m2(e2[i2])) && Ds(Fs, s2))
              return s2;
          return new As(false);
        }
        r2 = Es(e2, o2);
      }
      for (a2 = r2.next; !(c2 = ds(a2, r2)).done; ) {
        try {
          s2 = m2(c2.value);
        } catch (e3) {
          bs(r2, "throw", e3);
        }
        if (typeof s2 == "object" && s2 && Ds(Fs, s2))
          return s2;
      }
      return new As(false);
    }, Bs = function(e2, t3, n2) {
      var r2 = xs(t3);
      r2 in e2 ? Ss.f(e2, r2, ws(0, n2)) : e2[r2] = n2;
    };
    ro({ target: "Object", stat: true }, { fromEntries: function(e2) {
      var t3 = {};
      return Ts(e2, function(e3, n2) {
        Bs(t3, e3, n2);
      }, { AS_ENTRIES: true }), t3;
    } });
    var Ns = Ns !== void 0 ? Ns : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
    function ks() {
      throw new Error("setTimeout has not been defined");
    }
    function Ps() {
      throw new Error("clearTimeout has not been defined");
    }
    var Os = ks, Is = Ps;
    function Ls(e2) {
      if (Os === setTimeout)
        return setTimeout(e2, 0);
      if ((Os === ks || !Os) && setTimeout)
        return Os = setTimeout, setTimeout(e2, 0);
      try {
        return Os(e2, 0);
      } catch (t3) {
        try {
          return Os.call(null, e2, 0);
        } catch (t4) {
          return Os.call(this, e2, 0);
        }
      }
    }
    typeof Ns.setTimeout == "function" && (Os = setTimeout), typeof Ns.clearTimeout == "function" && (Is = clearTimeout);
    var js, _s = [], Ms = false, Rs = -1;
    function Vs() {
      Ms && js && (Ms = false, js.length ? _s = js.concat(_s) : Rs = -1, _s.length && $s());
    }
    function $s() {
      if (!Ms) {
        var e2 = Ls(Vs);
        Ms = true;
        for (var t3 = _s.length; t3; ) {
          for (js = _s, _s = []; ++Rs < t3; )
            js && js[Rs].run();
          Rs = -1, t3 = _s.length;
        }
        js = null, Ms = false, function(e3) {
          if (Is === clearTimeout)
            return clearTimeout(e3);
          if ((Is === Ps || !Is) && clearTimeout)
            return Is = clearTimeout, clearTimeout(e3);
          try {
            Is(e3);
          } catch (t4) {
            try {
              return Is.call(null, e3);
            } catch (t5) {
              return Is.call(this, e3);
            }
          }
        }(e2);
      }
    }
    function Ws(e2, t3) {
      this.fun = e2, this.array = t3;
    }
    Ws.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    function qs() {
    }
    var Us = qs, zs = qs, Gs = qs, Hs = qs, Js = qs, Xs = qs, Ys = qs;
    var Ks = Ns.performance || {}, Qs = Ks.now || Ks.mozNow || Ks.msNow || Ks.oNow || Ks.webkitNow || function() {
      return new Date().getTime();
    };
    var Zs = new Date();
    var ea = { nextTick: function(e2) {
      var t3 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n2 = 1; n2 < arguments.length; n2++)
          t3[n2 - 1] = arguments[n2];
      _s.push(new Ws(e2, t3)), _s.length !== 1 || Ms || Ls($s);
    }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: Us, addListener: zs, once: Gs, off: Hs, removeListener: Js, removeAllListeners: Xs, emit: Ys, binding: function(e2) {
      throw new Error("process.binding is not supported");
    }, cwd: function() {
      return "/";
    }, chdir: function(e2) {
      throw new Error("process.chdir is not supported");
    }, umask: function() {
      return 0;
    }, hrtime: function(e2) {
      var t3 = 1e-3 * Qs.call(Ks), n2 = Math.floor(t3), r2 = Math.floor(t3 % 1 * 1e9);
      return e2 && (n2 -= e2[0], (r2 -= e2[1]) < 0 && (n2--, r2 += 1e9)), [n2, r2];
    }, platform: "browser", release: {}, config: {}, uptime: function() {
      return (new Date() - Zs) / 1e3;
    } }, ta = ea;
    const na = typeof ta == "object" && ta.env && ta.env.NODE_DEBUG && /\bsemver\b/i.test(ta.env.NODE_DEBUG) ? function() {
      for (var e2 = arguments.length, t3 = new Array(e2), n2 = 0; n2 < e2; n2++)
        t3[n2] = arguments[n2];
      return console.error("SEMVER", ...t3);
    } : () => {
    };
    var ra = na;
    var oa = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 }, ia = { exports: {} };
    !function(e2, t3) {
      const { MAX_SAFE_COMPONENT_LENGTH: n2 } = oa, r2 = ra, o2 = (t3 = e2.exports = {}).re = [], i2 = t3.src = [], u2 = t3.t = {};
      let s2 = 0;
      const a2 = (e3, t4, n3) => {
        const a3 = s2++;
        r2(a3, t4), u2[e3] = a3, i2[a3] = t4, o2[a3] = new RegExp(t4, n3 ? "g" : void 0);
      };
      a2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a2("MAINVERSION", "(".concat(i2[u2.NUMERICIDENTIFIER], ")\\.") + "(".concat(i2[u2.NUMERICIDENTIFIER], ")\\.") + "(".concat(i2[u2.NUMERICIDENTIFIER], ")")), a2("MAINVERSIONLOOSE", "(".concat(i2[u2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i2[u2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i2[u2.NUMERICIDENTIFIERLOOSE], ")")), a2("PRERELEASEIDENTIFIER", "(?:".concat(i2[u2.NUMERICIDENTIFIER], "|").concat(i2[u2.NONNUMERICIDENTIFIER], ")")), a2("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(i2[u2.NUMERICIDENTIFIERLOOSE], "|").concat(i2[u2.NONNUMERICIDENTIFIER], ")")), a2("PRERELEASE", "(?:-(".concat(i2[u2.PRERELEASEIDENTIFIER], "(?:\\.").concat(i2[u2.PRERELEASEIDENTIFIER], ")*))")), a2("PRERELEASELOOSE", "(?:-?(".concat(i2[u2.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(i2[u2.PRERELEASEIDENTIFIERLOOSE], ")*))")), a2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a2("BUILD", "(?:\\+(".concat(i2[u2.BUILDIDENTIFIER], "(?:\\.").concat(i2[u2.BUILDIDENTIFIER], ")*))")), a2("FULLPLAIN", "v?".concat(i2[u2.MAINVERSION]).concat(i2[u2.PRERELEASE], "?").concat(i2[u2.BUILD], "?")), a2("FULL", "^".concat(i2[u2.FULLPLAIN], "$")), a2("LOOSEPLAIN", "[v=\\s]*".concat(i2[u2.MAINVERSIONLOOSE]).concat(i2[u2.PRERELEASELOOSE], "?").concat(i2[u2.BUILD], "?")), a2("LOOSE", "^".concat(i2[u2.LOOSEPLAIN], "$")), a2("GTLT", "((?:<|>)?=?)"), a2("XRANGEIDENTIFIERLOOSE", "".concat(i2[u2.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), a2("XRANGEIDENTIFIER", "".concat(i2[u2.NUMERICIDENTIFIER], "|x|X|\\*")), a2("XRANGEPLAIN", "[v=\\s]*(".concat(i2[u2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i2[u2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i2[u2.XRANGEIDENTIFIER], ")") + "(?:".concat(i2[u2.PRERELEASE], ")?").concat(i2[u2.BUILD], "?") + ")?)?"), a2("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(i2[u2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i2[u2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i2[u2.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(i2[u2.PRERELEASELOOSE], ")?").concat(i2[u2.BUILD], "?") + ")?)?"), a2("XRANGE", "^".concat(i2[u2.GTLT], "\\s*").concat(i2[u2.XRANGEPLAIN], "$")), a2("XRANGELOOSE", "^".concat(i2[u2.GTLT], "\\s*").concat(i2[u2.XRANGEPLAINLOOSE], "$")), a2("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(n2, "})") + "(?:\\.(\\d{1,".concat(n2, "}))?") + "(?:\\.(\\d{1,".concat(n2, "}))?") + "(?:$|[^\\d])"), a2("COERCERTL", i2[u2.COERCE], true), a2("LONETILDE", "(?:~>?)"), a2("TILDETRIM", "(\\s*)".concat(i2[u2.LONETILDE], "\\s+"), true), t3.tildeTrimReplace = "$1~", a2("TILDE", "^".concat(i2[u2.LONETILDE]).concat(i2[u2.XRANGEPLAIN], "$")), a2("TILDELOOSE", "^".concat(i2[u2.LONETILDE]).concat(i2[u2.XRANGEPLAINLOOSE], "$")), a2("LONECARET", "(?:\\^)"), a2("CARETTRIM", "(\\s*)".concat(i2[u2.LONECARET], "\\s+"), true), t3.caretTrimReplace = "$1^", a2("CARET", "^".concat(i2[u2.LONECARET]).concat(i2[u2.XRANGEPLAIN], "$")), a2("CARETLOOSE", "^".concat(i2[u2.LONECARET]).concat(i2[u2.XRANGEPLAINLOOSE], "$")), a2("COMPARATORLOOSE", "^".concat(i2[u2.GTLT], "\\s*(").concat(i2[u2.LOOSEPLAIN], ")$|^$")), a2("COMPARATOR", "^".concat(i2[u2.GTLT], "\\s*(").concat(i2[u2.FULLPLAIN], ")$|^$")), a2("COMPARATORTRIM", "(\\s*)".concat(i2[u2.GTLT], "\\s*(").concat(i2[u2.LOOSEPLAIN], "|").concat(i2[u2.XRANGEPLAIN], ")"), true), t3.comparatorTrimReplace = "$1$2$3", a2("HYPHENRANGE", "^\\s*(".concat(i2[u2.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(i2[u2.XRANGEPLAIN], ")") + "\\s*$"), a2("HYPHENRANGELOOSE", "^\\s*(".concat(i2[u2.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(i2[u2.XRANGEPLAINLOOSE], ")") + "\\s*$"), a2("STAR", "(<|>)?=?\\s*\\*"), a2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
    }(ia, ia.exports);
    const ua = ["includePrerelease", "loose", "rtl"];
    var sa = (e2) => e2 ? typeof e2 != "object" ? { loose: true } : ua.filter((t3) => e2[t3]).reduce((e3, t3) => (e3[t3] = true, e3), {}) : {};
    const aa = /^[0-9]+$/, ca = (e2, t3) => {
      const n2 = aa.test(e2), r2 = aa.test(t3);
      return n2 && r2 && (e2 = +e2, t3 = +t3), e2 === t3 ? 0 : n2 && !r2 ? -1 : r2 && !n2 ? 1 : e2 < t3 ? -1 : 1;
    };
    var la = { compareIdentifiers: ca, rcompareIdentifiers: (e2, t3) => ca(t3, e2) };
    const pa = ra, { MAX_LENGTH: fa, MAX_SAFE_INTEGER: da } = oa, { re: ha, t: ga } = ia.exports, ma = sa, { compareIdentifiers: ya } = la;
    class Da {
      constructor(e2, t3) {
        if (t3 = ma(t3), e2 instanceof Da) {
          if (e2.loose === !!t3.loose && e2.includePrerelease === !!t3.includePrerelease)
            return e2;
          e2 = e2.version;
        } else if (typeof e2 != "string")
          throw new TypeError("Invalid Version: ".concat(e2));
        if (e2.length > fa)
          throw new TypeError("version is longer than ".concat(fa, " characters"));
        pa("SemVer", e2, t3), this.options = t3, this.loose = !!t3.loose, this.includePrerelease = !!t3.includePrerelease;
        const n2 = e2.trim().match(t3.loose ? ha[ga.LOOSE] : ha[ga.FULL]);
        if (!n2)
          throw new TypeError("Invalid Version: ".concat(e2));
        if (this.raw = e2, this.major = +n2[1], this.minor = +n2[2], this.patch = +n2[3], this.major > da || this.major < 0)
          throw new TypeError("Invalid major version");
        if (this.minor > da || this.minor < 0)
          throw new TypeError("Invalid minor version");
        if (this.patch > da || this.patch < 0)
          throw new TypeError("Invalid patch version");
        n2[4] ? this.prerelease = n2[4].split(".").map((e3) => {
          if (/^[0-9]+$/.test(e3)) {
            const t4 = +e3;
            if (t4 >= 0 && t4 < da)
              return t4;
          }
          return e3;
        }) : this.prerelease = [], this.build = n2[5] ? n2[5].split(".") : [], this.format();
      }
      format() {
        return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
      }
      toString() {
        return this.version;
      }
      compare(e2) {
        if (pa("SemVer.compare", this.version, this.options, e2), !(e2 instanceof Da)) {
          if (typeof e2 == "string" && e2 === this.version)
            return 0;
          e2 = new Da(e2, this.options);
        }
        return e2.version === this.version ? 0 : this.compareMain(e2) || this.comparePre(e2);
      }
      compareMain(e2) {
        return e2 instanceof Da || (e2 = new Da(e2, this.options)), ya(this.major, e2.major) || ya(this.minor, e2.minor) || ya(this.patch, e2.patch);
      }
      comparePre(e2) {
        if (e2 instanceof Da || (e2 = new Da(e2, this.options)), this.prerelease.length && !e2.prerelease.length)
          return -1;
        if (!this.prerelease.length && e2.prerelease.length)
          return 1;
        if (!this.prerelease.length && !e2.prerelease.length)
          return 0;
        let t3 = 0;
        do {
          const n2 = this.prerelease[t3], r2 = e2.prerelease[t3];
          if (pa("prerelease compare", t3, n2, r2), n2 === void 0 && r2 === void 0)
            return 0;
          if (r2 === void 0)
            return 1;
          if (n2 === void 0)
            return -1;
          if (n2 !== r2)
            return ya(n2, r2);
        } while (++t3);
      }
      compareBuild(e2) {
        e2 instanceof Da || (e2 = new Da(e2, this.options));
        let t3 = 0;
        do {
          const n2 = this.build[t3], r2 = e2.build[t3];
          if (pa("prerelease compare", t3, n2, r2), n2 === void 0 && r2 === void 0)
            return 0;
          if (r2 === void 0)
            return 1;
          if (n2 === void 0)
            return -1;
          if (n2 !== r2)
            return ya(n2, r2);
        } while (++t3);
      }
      inc(e2, t3) {
        switch (e2) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t3);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t3);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", t3), this.inc("pre", t3);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", t3), this.inc("pre", t3);
            break;
          case "major":
            this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++, this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0)
              this.prerelease = [0];
            else {
              let e3 = this.prerelease.length;
              for (; --e3 >= 0; )
                typeof this.prerelease[e3] == "number" && (this.prerelease[e3]++, e3 = -2);
              e3 === -1 && this.prerelease.push(0);
            }
            t3 && (this.prerelease[0] === t3 ? isNaN(this.prerelease[1]) && (this.prerelease = [t3, 0]) : this.prerelease = [t3, 0]);
            break;
          default:
            throw new Error("invalid increment argument: ".concat(e2));
        }
        return this.format(), this.raw = this.version, this;
      }
    }
    const Ea = Da;
    var Ca = (e2, t3, n2) => new Ea(e2, n2).compare(new Ea(t3, n2));
    const ba = Ca;
    var va = (e2, t3, n2) => ba(e2, t3, n2) < 0;
    const Aa = Ca;
    var Fa, xa, Sa, wa, Ta, Ba, Na = (e2, t3, n2) => Aa(e2, t3, n2) >= 0, ka = { exports: {} };
    !function(e2, t3) {
      function n2() {
        for (var e3 = [], t4 = 0; t4 < arguments.length; t4++)
          e3[t4] = arguments[t4];
      }
      function r2() {
        return typeof WeakMap != "undefined" ? /* @__PURE__ */ new WeakMap() : { add: n2, delete: n2, get: n2, set: n2, has: function(e3) {
          return false;
        } };
      }
      Object.defineProperty(t3, "__esModule", { value: true }), t3.outdent = void 0;
      var o2 = Object.prototype.hasOwnProperty, i2 = function(e3, t4) {
        return o2.call(e3, t4);
      };
      function u2(e3, t4) {
        for (var n3 in t4)
          i2(t4, n3) && (e3[n3] = t4[n3]);
        return e3;
      }
      var s2 = /^[ \t]*(?:\r\n|\r|\n)/, a2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
      function f2(e3, t4, n3) {
        var r3 = 0, o3 = e3[0].match(l2);
        o3 && (r3 = o3[1].length);
        var i3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
        t4 && (e3 = e3.slice(1));
        var u3 = n3.newline, c3 = n3.trimLeadingNewline, p3 = n3.trimTrailingNewline, f3 = typeof u3 == "string", d3 = e3.length;
        return e3.map(function(e4, t5) {
          return e4 = e4.replace(i3, "$1"), t5 === 0 && c3 && (e4 = e4.replace(s2, "")), t5 === d3 - 1 && p3 && (e4 = e4.replace(a2, "")), f3 && (e4 = e4.replace(/\r\n|\n|\r/g, function(e5) {
            return u3;
          })), e4;
        });
      }
      function d2(e3, t4) {
        for (var n3 = "", r3 = 0, o3 = e3.length; r3 < o3; r3++)
          n3 += e3[r3], r3 < o3 - 1 && (n3 += t4[r3]);
        return n3;
      }
      function h2(e3) {
        return i2(e3, "raw") && i2(e3, "length");
      }
      var g2 = function e3(t4) {
        var n3 = r2(), o3 = r2(), i3 = u2(function r3(i4) {
          for (var s3 = [], a3 = 1; a3 < arguments.length; a3++)
            s3[a3 - 1] = arguments[a3];
          if (h2(i4)) {
            var l3 = i4, m2 = (s3[0] === r3 || s3[0] === g2) && p2.test(l3[0]) && c2.test(l3[1]), y2 = m2 ? o3 : n3, D2 = y2.get(l3);
            if (D2 || (D2 = f2(l3, m2, t4), y2.set(l3, D2)), s3.length === 0)
              return D2[0];
            var E2 = d2(D2, m2 ? s3.slice(1) : s3);
            return E2;
          }
          return e3(u2(u2({}, t4), i4 || {}));
        }, { string: function(e4) {
          return f2([e4], false, t4)[0];
        } });
        return i3;
      }({ trimLeadingNewline: true, trimTrailingNewline: true });
      t3.outdent = g2, t3.default = g2;
      try {
        e2.exports = g2, Object.defineProperty(g2, "__esModule", { value: true }), g2.default = g2, g2.outdent = g2;
      } catch (e3) {
      }
    }(ka, ka.exports);
    const { outdent: Pa } = ka.exports, Oa = "Config", Ia = "Editor", La = "Other", ja = "Global", _a = "Special", Ma = { cursorOffset: { since: "1.4.0", category: _a, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: Pa(Fa || (Fa = lu(["\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "]))), cliCategory: Ia }, endOfLine: { since: "1.15.0", category: ja, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: Pa(xa || (xa = lu(["\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "]))) }] }, filepath: { since: "1.4.0", category: _a, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: La, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: _a, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: La }, parser: { since: "0.0.10", category: ja, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: ja, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: Oa }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: ja, description: Pa(Sa || (Sa = lu(["\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "]))), exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin-search-dir", cliCategory: Oa }, printWidth: { since: "0.0.0", category: ja, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: _a, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Pa(wa || (wa = lu(["\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))), cliCategory: Ia }, rangeStart: { since: "1.4.0", category: _a, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Pa(Ta || (Ta = lu(["\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))), cliCategory: Ia }, requirePragma: { since: "1.7.0", category: _a, type: "boolean", default: false, description: Pa(Ba || (Ba = lu(["\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "]))), cliCategory: La }, tabWidth: { type: "int", category: ja, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: ja, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: ja, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
    const Ra = ["cliName", "cliCategory", "cliDescription"], Va = { compare: Ca, lt: va, gte: Na }, $a = (e2, t3) => Object.entries(e2).map((e3) => {
      let [n2, r2] = e3;
      return Object.assign({ [t3]: n2 }, r2);
    }), Wa = n.version, qa = { CATEGORY_CONFIG: Oa, CATEGORY_EDITOR: Ia, CATEGORY_FORMAT: "Format", CATEGORY_OTHER: La, CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: ja, CATEGORY_SPECIAL: _a, options: Ma }.options;
    function Ua(e2, t3, n2) {
      const r2 = new Set(e2.choices.map((e3) => e3.value));
      for (const o2 of t3)
        if (o2.parsers) {
          for (const t4 of o2.parsers)
            if (!r2.has(t4)) {
              r2.add(t4);
              const i2 = n2.find((e3) => e3.parsers && e3.parsers[t4]);
              let u2 = o2.name;
              i2 && i2.name && (u2 += " (plugin: ".concat(i2.name, ")")), e2.choices.push({ value: t4, description: u2 });
            }
        }
    }
    var za = { getSupportInfo: function() {
      let { plugins: e2 = [], showUnreleased: t3 = false, showDeprecated: n2 = false, showInternal: r2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const o2 = Wa.split("-", 1)[0], i2 = e2.flatMap((e3) => e3.languages || []).filter(s2), u2 = $a(Object.assign({}, ...e2.map((e3) => {
        let { options: t4 } = e3;
        return t4;
      }), qa), "name").filter((e3) => s2(e3) && a2(e3)).sort((e3, t4) => e3.name === t4.name ? 0 : e3.name < t4.name ? -1 : 1).map(c2).map((t4) => {
        t4 = Object.assign({}, t4), Array.isArray(t4.default) && (t4.default = t4.default.length === 1 ? t4.default[0].value : t4.default.filter(s2).sort((e3, t5) => Va.compare(t5.since, e3.since))[0].value), Array.isArray(t4.choices) && (t4.choices = t4.choices.filter((e3) => s2(e3) && a2(e3)), t4.name === "parser" && Ua(t4, i2, e2));
        const n3 = Object.fromEntries(e2.filter((e3) => e3.defaultOptions && e3.defaultOptions[t4.name] !== void 0).map((e3) => [e3.name, e3.defaultOptions[t4.name]]));
        return Object.assign(Object.assign({}, t4), {}, { pluginDefaults: n3 });
      });
      return { languages: i2, options: u2 };
      function s2(e3) {
        return t3 || !("since" in e3) || e3.since && Va.gte(o2, e3.since);
      }
      function a2(e3) {
        return n2 || !("deprecated" in e3) || e3.deprecated && Va.lt(o2, e3.deprecated);
      }
      function c2(e3) {
        if (r2)
          return e3;
        return cu(e3, Ra);
      }
    } };
    const Ga = eu.exports, Ha = (e2) => {
      if (typeof e2 != "string")
        throw new TypeError("Expected a string");
      return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }, Ja = au, { getSupportInfo: Xa } = za, Ya = /[^\x20-\x7F]/;
    function Ka(e2) {
      return (t3, n2, r2) => {
        const o2 = r2 && r2.backwards;
        if (n2 === false)
          return false;
        const { length: i2 } = t3;
        let u2 = n2;
        for (; u2 >= 0 && u2 < i2; ) {
          const n3 = t3.charAt(u2);
          if (e2 instanceof RegExp) {
            if (!e2.test(n3))
              return u2;
          } else if (!e2.includes(n3))
            return u2;
          o2 ? u2-- : u2++;
        }
        return (u2 === -1 || u2 === i2) && u2;
      };
    }
    const Qa = Ka(/\s/), Za = Ka(" 	"), ec = Ka(",; 	"), tc = Ka(/[^\n\r]/);
    function nc(e2, t3) {
      if (t3 === false)
        return false;
      if (e2.charAt(t3) === "/" && e2.charAt(t3 + 1) === "*") {
        for (let n2 = t3 + 2; n2 < e2.length; ++n2)
          if (e2.charAt(n2) === "*" && e2.charAt(n2 + 1) === "/")
            return n2 + 2;
      }
      return t3;
    }
    function rc(e2, t3) {
      return t3 !== false && (e2.charAt(t3) === "/" && e2.charAt(t3 + 1) === "/" ? tc(e2, t3) : t3);
    }
    function oc(e2, t3, n2) {
      const r2 = n2 && n2.backwards;
      if (t3 === false)
        return false;
      const o2 = e2.charAt(t3);
      if (r2) {
        if (e2.charAt(t3 - 1) === "\r" && o2 === "\n")
          return t3 - 2;
        if (o2 === "\n" || o2 === "\r" || o2 === "\u2028" || o2 === "\u2029")
          return t3 - 1;
      } else {
        if (o2 === "\r" && e2.charAt(t3 + 1) === "\n")
          return t3 + 2;
        if (o2 === "\n" || o2 === "\r" || o2 === "\u2028" || o2 === "\u2029")
          return t3 + 1;
      }
      return t3;
    }
    function ic2(e2, t3) {
      let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const r2 = Za(e2, n2.backwards ? t3 - 1 : t3, n2), o2 = oc(e2, r2, n2);
      return r2 !== o2;
    }
    function uc(e2, t3) {
      let n2 = null, r2 = t3;
      for (; r2 !== n2; )
        n2 = r2, r2 = ec(e2, r2), r2 = nc(e2, r2), r2 = Za(e2, r2);
      return r2 = rc(e2, r2), r2 = oc(e2, r2), r2 !== false && ic2(e2, r2);
    }
    function sc2(e2, t3) {
      let n2 = null, r2 = t3;
      for (; r2 !== n2; )
        n2 = r2, r2 = Za(e2, r2), r2 = nc(e2, r2), r2 = rc(e2, r2), r2 = oc(e2, r2);
      return r2;
    }
    function ac2(e2, t3, n2) {
      return sc2(e2, n2(t3));
    }
    function cc(e2, t3) {
      let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r2 = 0;
      for (let o2 = n2; o2 < e2.length; ++o2)
        e2[o2] === "	" ? r2 = r2 + t3 - r2 % t3 : r2++;
      return r2;
    }
    function lc(e2, t3) {
      const n2 = { quote: '"', regex: /"/g, escaped: "&quot;" }, r2 = { quote: "'", regex: /'/g, escaped: "&apos;" }, o2 = t3 === "'" ? r2 : n2, i2 = o2 === r2 ? n2 : r2;
      let u2 = o2;
      if (e2.includes(o2.quote) || e2.includes(i2.quote)) {
        u2 = (e2.match(o2.regex) || []).length > (e2.match(i2.regex) || []).length ? i2 : o2;
      }
      return u2;
    }
    function pc(e2, t3, n2) {
      const r2 = t3 === '"' ? "'" : '"', o2 = e2.replace(/\\(.)|(["'])/gs, (e3, o3, i2) => o3 === r2 ? o3 : i2 === t3 ? "\\" + i2 : i2 || (n2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o3) ? o3 : "\\" + o3));
      return t3 + o2 + t3;
    }
    function fc(e2, t3) {
      (e2.comments || (e2.comments = [])).push(t3), t3.printed = false, t3.nodeDescription = function(e3) {
        const t4 = e3.type || e3.kind || "(unknown type)";
        let n2 = String(e3.name || e3.id && (typeof e3.id == "object" ? e3.id.name : e3.id) || e3.key && (typeof e3.key == "object" ? e3.key.name : e3.key) || e3.value && (typeof e3.value == "object" ? "" : String(e3.value)) || e3.operator || "");
        n2.length > 20 && (n2 = n2.slice(0, 19) + "\u2026");
        return t4 + (n2 ? " " + n2 : "");
      }(e2);
    }
    var dc = { inferParserByLanguage: function(e2, t3) {
      const { languages: n2 } = Xa({ plugins: t3.plugins }), r2 = n2.find((t4) => {
        let { name: n3 } = t4;
        return n3.toLowerCase() === e2;
      }) || n2.find((t4) => {
        let { aliases: n3 } = t4;
        return Array.isArray(n3) && n3.includes(e2);
      }) || n2.find((t4) => {
        let { extensions: n3 } = t4;
        return Array.isArray(n3) && n3.includes(".".concat(e2));
      });
      return r2 && r2.parsers[0];
    }, getStringWidth: function(e2) {
      return e2 ? Ya.test(e2) ? Ga(e2) : e2.length : 0;
    }, getMaxContinuousCount: function(e2, t3) {
      const n2 = e2.match(new RegExp("(".concat(Ha(t3), ")+"), "g"));
      return n2 === null ? 0 : n2.reduce((e3, n3) => Math.max(e3, n3.length / t3.length), 0);
    }, getMinNotPresentContinuousCount: function(e2, t3) {
      const n2 = e2.match(new RegExp("(".concat(Ha(t3), ")+"), "g"));
      if (n2 === null)
        return 0;
      const r2 = /* @__PURE__ */ new Map();
      let o2 = 0;
      for (const e3 of n2) {
        const n3 = e3.length / t3.length;
        r2.set(n3, true), n3 > o2 && (o2 = n3);
      }
      for (let e3 = 1; e3 < o2; e3++)
        if (!r2.get(e3))
          return e3;
      return o2 + 1;
    }, getPenultimate: (e2) => e2[e2.length - 2], getLast: Ja, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: sc2, getNextNonSpaceNonCommentCharacterIndex: ac2, getNextNonSpaceNonCommentCharacter: function(e2, t3, n2) {
      return e2.charAt(ac2(e2, t3, n2));
    }, skip: Ka, skipWhitespace: Qa, skipSpaces: Za, skipToLineEnd: ec, skipEverythingButNewLine: tc, skipInlineComment: nc, skipTrailingComment: rc, skipNewline: oc, isNextLineEmptyAfterIndex: uc, isNextLineEmpty: function(e2, t3, n2) {
      return uc(e2, n2(t3));
    }, isPreviousLineEmpty: function(e2, t3, n2) {
      let r2 = n2(t3) - 1;
      return r2 = Za(e2, r2, { backwards: true }), r2 = oc(e2, r2, { backwards: true }), r2 = Za(e2, r2, { backwards: true }), r2 !== oc(e2, r2, { backwards: true });
    }, hasNewline: ic2, hasNewlineInRange: function(e2, t3, n2) {
      for (let r2 = t3; r2 < n2; ++r2)
        if (e2.charAt(r2) === "\n")
          return true;
      return false;
    }, hasSpaces: function(e2, t3) {
      let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const r2 = Za(e2, n2.backwards ? t3 - 1 : t3, n2);
      return r2 !== t3;
    }, getAlignmentSize: cc, getIndentSize: function(e2, t3) {
      const n2 = e2.lastIndexOf("\n");
      return n2 === -1 ? 0 : cc(e2.slice(n2 + 1).match(/^[\t ]*/)[0], t3);
    }, getPreferredQuote: lc, printString: function(e2, t3) {
      const n2 = e2.slice(1, -1);
      return pc(n2, t3.parser === "json" || t3.parser === "json5" && t3.quoteProps === "preserve" && !t3.singleQuote ? '"' : t3.__isInHtmlAttribute ? "'" : lc(n2, t3.singleQuote ? "'" : '"').quote, !(t3.parser === "css" || t3.parser === "less" || t3.parser === "scss" || t3.__embeddedInHtml));
    }, printNumber: function(e2) {
      return e2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
    }, makeString: pc, addLeadingComment: function(e2, t3) {
      t3.leading = true, t3.trailing = false, fc(e2, t3);
    }, addDanglingComment: function(e2, t3, n2) {
      t3.leading = false, t3.trailing = false, n2 && (t3.marker = n2), fc(e2, t3);
    }, addTrailingComment: function(e2, t3) {
      t3.leading = false, t3.trailing = true, fc(e2, t3);
    }, isFrontMatterNode: function(e2) {
      return e2 && e2.type === "front-matter";
    }, getShebang: function(e2) {
      if (!e2.startsWith("#!"))
        return "";
      const t3 = e2.indexOf("\n");
      return t3 === -1 ? e2 : e2.slice(0, t3);
    }, isNonEmptyArray: function(e2) {
      return Array.isArray(e2) && e2.length > 0;
    }, createGroupIdMapper: function(e2) {
      const t3 = /* @__PURE__ */ new WeakMap();
      return function(n2) {
        return t3.has(n2) || t3.set(n2, Symbol(e2)), t3.get(n2);
      };
    } };
    var hc = { guessEndOfLine: function(e2) {
      const t3 = e2.indexOf("\r");
      return t3 >= 0 ? e2.charAt(t3 + 1) === "\n" ? "crlf" : "cr" : "lf";
    }, convertEndOfLineToChars: function(e2) {
      switch (e2) {
        case "cr":
          return "\r";
        case "crlf":
          return "\r\n";
        default:
          return "\n";
      }
    }, countEndOfLineChars: function(e2, t3) {
      let n2;
      if (t3 === "\n")
        n2 = /\n/g;
      else if (t3 === "\r")
        n2 = /\r/g;
      else {
        if (t3 !== "\r\n")
          throw new Error('Unexpected "eol" '.concat(JSON.stringify(t3), "."));
        n2 = /\r\n/g;
      }
      const r2 = e2.match(n2);
      return r2 ? r2.length : 0;
    }, normalizeEndOfLine: function(e2) {
      return e2.replace(/\r\n?/g, "\n");
    } };
    const gc = au, { literalline: mc, join: yc } = Zi, Dc = (e2) => Array.isArray(e2) || e2 && e2.type === "concat", Ec = (e2) => {
      if (Array.isArray(e2))
        return e2;
      if (e2.type !== "concat" && e2.type !== "fill")
        throw new Error("Expect doc type to be `concat` or `fill`.");
      return e2.parts;
    }, Cc = {};
    function bc(e2, t3, n2, r2) {
      const o2 = [e2];
      for (; o2.length > 0; ) {
        const e3 = o2.pop();
        if (e3 !== Cc) {
          if (n2 && o2.push(e3, Cc), !t3 || t3(e3) !== false)
            if (Dc(e3) || e3.type === "fill") {
              const t4 = Ec(e3);
              for (let e4 = t4.length - 1; e4 >= 0; --e4)
                o2.push(t4[e4]);
            } else if (e3.type === "if-break")
              e3.flatContents && o2.push(e3.flatContents), e3.breakContents && o2.push(e3.breakContents);
            else if (e3.type === "group" && e3.expandedStates)
              if (r2)
                for (let t4 = e3.expandedStates.length - 1; t4 >= 0; --t4)
                  o2.push(e3.expandedStates[t4]);
              else
                o2.push(e3.contents);
            else
              e3.contents && o2.push(e3.contents);
        } else
          n2(o2.pop());
      }
    }
    function vc(e2, t3) {
      const n2 = /* @__PURE__ */ new Map();
      return r2(e2);
      function r2(e3) {
        if (n2.has(e3))
          return n2.get(e3);
        const o2 = function(e4) {
          if (Array.isArray(e4))
            return t3(e4.map(r2));
          if (e4.type === "concat" || e4.type === "fill") {
            const n3 = e4.parts.map(r2);
            return t3(Object.assign(Object.assign({}, e4), {}, { parts: n3 }));
          }
          if (e4.type === "if-break") {
            const n3 = e4.breakContents && r2(e4.breakContents), o3 = e4.flatContents && r2(e4.flatContents);
            return t3(Object.assign(Object.assign({}, e4), {}, { breakContents: n3, flatContents: o3 }));
          }
          if (e4.type === "group" && e4.expandedStates) {
            const n3 = e4.expandedStates.map(r2), o3 = n3[0];
            return t3(Object.assign(Object.assign({}, e4), {}, { contents: o3, expandedStates: n3 }));
          }
          if (e4.contents) {
            const n3 = r2(e4.contents);
            return t3(Object.assign(Object.assign({}, e4), {}, { contents: n3 }));
          }
          return t3(e4);
        }(e3);
        return n2.set(e3, o2), o2;
      }
    }
    function Ac(e2, t3, n2) {
      let r2 = n2, o2 = false;
      return bc(e2, function(e3) {
        const n3 = t3(e3);
        if (n3 !== void 0 && (o2 = true, r2 = n3), o2)
          return false;
      }), r2;
    }
    function Fc(e2) {
      return !(e2.type !== "group" || !e2.break) || (!(e2.type !== "line" || !e2.hard) || (e2.type === "break-parent" || void 0));
    }
    function xc(e2) {
      if (e2.length > 0) {
        const t3 = gc(e2);
        t3.expandedStates || t3.break || (t3.break = "propagated");
      }
      return null;
    }
    function Sc2(e2) {
      return e2.type !== "line" || e2.hard ? e2.type === "if-break" ? e2.flatContents || "" : e2 : e2.soft ? "" : " ";
    }
    const wc = (e2, t3) => e2 && e2.type === "line" && e2.hard && t3 && t3.type === "break-parent";
    function Tc(e2) {
      if (!e2)
        return e2;
      if (Dc(e2) || e2.type === "fill") {
        const t3 = Ec(e2);
        for (; t3.length > 1 && wc(...t3.slice(-2)); )
          t3.length -= 2;
        if (t3.length > 0) {
          const e3 = Tc(gc(t3));
          t3[t3.length - 1] = e3;
        }
        return Array.isArray(e2) ? t3 : Object.assign(Object.assign({}, e2), {}, { parts: t3 });
      }
      switch (e2.type) {
        case "align":
        case "indent":
        case "indent-if-break":
        case "group":
        case "line-suffix":
        case "label": {
          const t3 = Tc(e2.contents);
          return Object.assign(Object.assign({}, e2), {}, { contents: t3 });
        }
        case "if-break": {
          const t3 = Tc(e2.breakContents), n2 = Tc(e2.flatContents);
          return Object.assign(Object.assign({}, e2), {}, { breakContents: t3, flatContents: n2 });
        }
      }
      return e2;
    }
    function Bc(e2) {
      return vc(e2, (e3) => function(e4) {
        switch (e4.type) {
          case "fill":
            if (e4.parts.every((e5) => e5 === ""))
              return "";
            break;
          case "group":
            if (!(e4.contents || e4.id || e4.break || e4.expandedStates))
              return "";
            if (e4.contents.type === "group" && e4.contents.id === e4.id && e4.contents.break === e4.break && e4.contents.expandedStates === e4.expandedStates)
              return e4.contents;
            break;
          case "align":
          case "indent":
          case "indent-if-break":
          case "line-suffix":
            if (!e4.contents)
              return "";
            break;
          case "if-break":
            if (!e4.flatContents && !e4.breakContents)
              return "";
        }
        if (!Dc(e4))
          return e4;
        const t3 = [];
        for (const n2 of Ec(e4)) {
          if (!n2)
            continue;
          const [e5, ...r2] = Dc(n2) ? Ec(n2) : [n2];
          typeof e5 == "string" && typeof gc(t3) == "string" ? t3[t3.length - 1] += e5 : t3.push(e5), t3.push(...r2);
        }
        return t3.length === 0 ? "" : t3.length === 1 ? t3[0] : Array.isArray(e4) ? t3 : Object.assign(Object.assign({}, e4), {}, { parts: t3 });
      }(e3));
    }
    function Nc(e2) {
      const t3 = [], n2 = e2.filter(Boolean);
      for (; n2.length > 0; ) {
        const e3 = n2.shift();
        e3 && (Dc(e3) ? n2.unshift(...Ec(e3)) : t3.length > 0 && typeof gc(t3) == "string" && typeof e3 == "string" ? t3[t3.length - 1] += e3 : t3.push(e3));
      }
      return t3;
    }
    function kc(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : mc;
      return yc(t3, e2.split("\n")).parts;
    }
    function Pc(e2) {
      if (e2.type === "line")
        return true;
    }
    var Oc = { isConcat: Dc, getDocParts: Ec, willBreak: function(e2) {
      return Ac(e2, Fc, false);
    }, traverseDoc: bc, findInDoc: Ac, mapDoc: vc, propagateBreaks: function(e2) {
      const t3 = /* @__PURE__ */ new Set(), n2 = [];
      bc(e2, function(e3) {
        if (e3.type === "break-parent" && xc(n2), e3.type === "group") {
          if (n2.push(e3), t3.has(e3))
            return false;
          t3.add(e3);
        }
      }, function(e3) {
        if (e3.type === "group") {
          n2.pop().break && xc(n2);
        }
      }, true);
    }, removeLines: function(e2) {
      return vc(e2, Sc2);
    }, stripTrailingHardline: function(e2) {
      return Tc(Bc(e2));
    }, normalizeParts: Nc, normalizeDoc: function(e2) {
      return vc(e2, (e3) => Array.isArray(e3) ? Nc(e3) : e3.parts ? Object.assign(Object.assign({}, e3), {}, { parts: Nc(e3.parts) }) : e3);
    }, cleanDoc: Bc, replaceTextEndOfLine: kc, replaceEndOfLine: function(e2) {
      return vc(e2, (e3) => typeof e3 == "string" && e3.includes("\n") ? kc(e3) : e3);
    }, canBreak: function(e2) {
      return Ac(e2, Pc, false);
    } };
    const { getStringWidth: Ic, getLast: Lc } = dc, { convertEndOfLineToChars: jc } = hc, { fill: _c, cursor: Mc, indent: Rc } = Zi, { isConcat: Vc, getDocParts: $c } = Oc;
    let Wc;
    function qc(e2, t3) {
      return zc(e2, { type: "indent" }, t3);
    }
    function Uc(e2, t3, n2) {
      if (t3 === Number.NEGATIVE_INFINITY)
        return e2.root || { value: "", length: 0, queue: [] };
      if (t3 < 0)
        return zc(e2, { type: "dedent" }, n2);
      if (!t3)
        return e2;
      if (t3.type === "root")
        return Object.assign(Object.assign({}, e2), {}, { root: e2 });
      return zc(e2, { type: typeof t3 == "string" ? "stringAlign" : "numberAlign", n: t3 }, n2);
    }
    function zc(e2, t3, n2) {
      const r2 = t3.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t3];
      let o2 = "", i2 = 0, u2 = 0, s2 = 0;
      for (const e3 of r2)
        switch (e3.type) {
          case "indent":
            l2(), n2.useTabs ? a2(1) : c2(n2.tabWidth);
            break;
          case "stringAlign":
            l2(), o2 += e3.n, i2 += e3.n.length;
            break;
          case "numberAlign":
            u2 += 1, s2 += e3.n;
            break;
          default:
            throw new Error("Unexpected type '".concat(e3.type, "'"));
        }
      return p2(), Object.assign(Object.assign({}, e2), {}, { value: o2, length: i2, queue: r2 });
      function a2(e3) {
        o2 += "	".repeat(e3), i2 += n2.tabWidth * e3;
      }
      function c2(e3) {
        o2 += " ".repeat(e3), i2 += e3;
      }
      function l2() {
        n2.useTabs ? function() {
          u2 > 0 && a2(u2);
          f2();
        }() : p2();
      }
      function p2() {
        s2 > 0 && c2(s2), f2();
      }
      function f2() {
        u2 = 0, s2 = 0;
      }
    }
    function Gc(e2) {
      if (e2.length === 0)
        return 0;
      let t3 = 0;
      for (; e2.length > 0 && typeof Lc(e2) == "string" && /^[\t ]*$/.test(Lc(e2)); )
        t3 += e2.pop().length;
      if (e2.length > 0 && typeof Lc(e2) == "string") {
        const n2 = Lc(e2).replace(/[\t ]*$/, "");
        t3 += Lc(e2).length - n2.length, e2[e2.length - 1] = n2;
      }
      return t3;
    }
    function Hc(e2, t3, n2, r2, o2, i2) {
      let u2 = t3.length;
      const s2 = [e2], a2 = [];
      for (; n2 >= 0; ) {
        if (s2.length === 0) {
          if (u2 === 0)
            return true;
          s2.push(t3[u2 - 1]), u2--;
          continue;
        }
        const [e3, c2, l2] = s2.pop();
        if (typeof l2 == "string")
          a2.push(l2), n2 -= Ic(l2);
        else if (Vc(l2)) {
          const t4 = $c(l2);
          for (let n3 = t4.length - 1; n3 >= 0; n3--)
            s2.push([e3, c2, t4[n3]]);
        } else
          switch (l2.type) {
            case "indent":
              s2.push([qc(e3, r2), c2, l2.contents]);
              break;
            case "align":
              s2.push([Uc(e3, l2.n, r2), c2, l2.contents]);
              break;
            case "trim":
              n2 += Gc(a2);
              break;
            case "group": {
              if (i2 && l2.break)
                return false;
              const t4 = l2.break ? 1 : c2;
              s2.push([e3, t4, l2.expandedStates && t4 === 1 ? Lc(l2.expandedStates) : l2.contents]), l2.id && (Wc[l2.id] = t4);
              break;
            }
            case "fill":
              for (let t4 = l2.parts.length - 1; t4 >= 0; t4--)
                s2.push([e3, c2, l2.parts[t4]]);
              break;
            case "if-break":
            case "indent-if-break": {
              const t4 = l2.groupId ? Wc[l2.groupId] : c2;
              if (t4 === 1) {
                const t5 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Rc(l2.contents);
                t5 && s2.push([e3, c2, t5]);
              }
              if (t4 === 2) {
                const t5 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Rc(l2.contents) : l2.contents;
                t5 && s2.push([e3, c2, t5]);
              }
              break;
            }
            case "line":
              switch (c2) {
                case 2:
                  if (!l2.hard) {
                    l2.soft || (a2.push(" "), n2 -= 1);
                    break;
                  }
                  return true;
                case 1:
                  return true;
              }
              break;
            case "line-suffix":
              o2 = true;
              break;
            case "line-suffix-boundary":
              if (o2)
                return false;
              break;
            case "label":
              s2.push([e3, c2, l2.contents]);
          }
      }
      return false;
    }
    var Jc = { printDocToString: function(e2, t3) {
      Wc = {};
      const n2 = t3.printWidth, r2 = jc(t3.endOfLine);
      let o2 = 0;
      const i2 = [[{ value: "", length: 0, queue: [] }, 1, e2]], u2 = [];
      let s2 = false, a2 = [];
      for (; i2.length > 0; ) {
        const [e3, c3, l2] = i2.pop();
        if (typeof l2 == "string") {
          const e4 = r2 !== "\n" ? l2.replace(/\n/g, r2) : l2;
          u2.push(e4), o2 += Ic(e4);
        } else if (Vc(l2)) {
          const t4 = $c(l2);
          for (let n3 = t4.length - 1; n3 >= 0; n3--)
            i2.push([e3, c3, t4[n3]]);
        } else
          switch (l2.type) {
            case "cursor":
              u2.push(Mc.placeholder);
              break;
            case "indent":
              i2.push([qc(e3, t3), c3, l2.contents]);
              break;
            case "align":
              i2.push([Uc(e3, l2.n, t3), c3, l2.contents]);
              break;
            case "trim":
              o2 -= Gc(u2);
              break;
            case "group":
              switch (c3) {
                case 2:
                  if (!s2) {
                    i2.push([e3, l2.break ? 1 : 2, l2.contents]);
                    break;
                  }
                case 1: {
                  s2 = false;
                  const r3 = [e3, 2, l2.contents], u3 = n2 - o2, c4 = a2.length > 0;
                  if (!l2.break && Hc(r3, i2, u3, t3, c4))
                    i2.push(r3);
                  else if (l2.expandedStates) {
                    const n3 = Lc(l2.expandedStates);
                    if (l2.break) {
                      i2.push([e3, 1, n3]);
                      break;
                    }
                    for (let r4 = 1; r4 < l2.expandedStates.length + 1; r4++) {
                      if (r4 >= l2.expandedStates.length) {
                        i2.push([e3, 1, n3]);
                        break;
                      }
                      {
                        const n4 = [e3, 2, l2.expandedStates[r4]];
                        if (Hc(n4, i2, u3, t3, c4)) {
                          i2.push(n4);
                          break;
                        }
                      }
                    }
                  } else
                    i2.push([e3, 1, l2.contents]);
                  break;
                }
              }
              l2.id && (Wc[l2.id] = Lc(i2)[1]);
              break;
            case "fill": {
              const r3 = n2 - o2, { parts: u3 } = l2;
              if (u3.length === 0)
                break;
              const [s3, p2] = u3, f2 = [e3, 2, s3], d2 = [e3, 1, s3], h2 = Hc(f2, [], r3, t3, a2.length > 0, true);
              if (u3.length === 1) {
                h2 ? i2.push(f2) : i2.push(d2);
                break;
              }
              const g2 = [e3, 2, p2], m2 = [e3, 1, p2];
              if (u3.length === 2) {
                h2 ? i2.push(g2, f2) : i2.push(m2, d2);
                break;
              }
              u3.splice(0, 2);
              const y2 = [e3, c3, _c(u3)];
              Hc([e3, 2, [s3, p2, u3[0]]], [], r3, t3, a2.length > 0, true) ? i2.push(y2, g2, f2) : h2 ? i2.push(y2, m2, f2) : i2.push(y2, m2, d2);
              break;
            }
            case "if-break":
            case "indent-if-break": {
              const t4 = l2.groupId ? Wc[l2.groupId] : c3;
              if (t4 === 1) {
                const t5 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Rc(l2.contents);
                t5 && i2.push([e3, c3, t5]);
              }
              if (t4 === 2) {
                const t5 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Rc(l2.contents) : l2.contents;
                t5 && i2.push([e3, c3, t5]);
              }
              break;
            }
            case "line-suffix":
              a2.push([e3, c3, l2.contents]);
              break;
            case "line-suffix-boundary":
              a2.length > 0 && i2.push([e3, c3, { type: "line", hard: true }]);
              break;
            case "line":
              switch (c3) {
                case 2:
                  if (!l2.hard) {
                    l2.soft || (u2.push(" "), o2 += 1);
                    break;
                  }
                  s2 = true;
                case 1:
                  if (a2.length > 0) {
                    i2.push([e3, c3, l2], ...a2.reverse()), a2 = [];
                    break;
                  }
                  l2.literal ? e3.root ? (u2.push(r2, e3.root.value), o2 = e3.root.length) : (u2.push(r2), o2 = 0) : (o2 -= Gc(u2), u2.push(r2 + e3.value), o2 = e3.length);
              }
              break;
            case "label":
              i2.push([e3, c3, l2.contents]);
          }
        i2.length === 0 && a2.length > 0 && (i2.push(...a2.reverse()), a2 = []);
      }
      const c2 = u2.indexOf(Mc.placeholder);
      if (c2 !== -1) {
        const e3 = u2.indexOf(Mc.placeholder, c2 + 1), t4 = u2.slice(0, c2).join(""), n3 = u2.slice(c2 + 1, e3).join("");
        return { formatted: t4 + n3 + u2.slice(e3 + 1).join(""), cursorNodeStart: t4.length, cursorNodeText: n3 };
      }
      return { formatted: u2.join("") };
    } };
    const { isConcat: Xc, getDocParts: Yc } = Oc;
    function Kc(e2) {
      if (!e2)
        return "";
      if (Xc(e2)) {
        const t3 = [];
        for (const n2 of Yc(e2))
          if (Xc(n2))
            t3.push(...Kc(n2).parts);
          else {
            const e3 = Kc(n2);
            e3 !== "" && t3.push(e3);
          }
        return { type: "concat", parts: t3 };
      }
      return e2.type === "if-break" ? Object.assign(Object.assign({}, e2), {}, { breakContents: Kc(e2.breakContents), flatContents: Kc(e2.flatContents) }) : e2.type === "group" ? Object.assign(Object.assign({}, e2), {}, { contents: Kc(e2.contents), expandedStates: e2.expandedStates && e2.expandedStates.map(Kc) }) : e2.type === "fill" ? { type: "fill", parts: e2.parts.map(Kc) } : e2.contents ? Object.assign(Object.assign({}, e2), {}, { contents: Kc(e2.contents) }) : e2;
    }
    var Qc = { printDocToDebug: function(e2) {
      const t3 = /* @__PURE__ */ Object.create(null), n2 = /* @__PURE__ */ new Set();
      return function e3(t4, n3, o2) {
        if (typeof t4 == "string")
          return JSON.stringify(t4);
        if (Xc(t4)) {
          const n4 = Yc(t4).map(e3).filter(Boolean);
          return n4.length === 1 ? n4[0] : "[".concat(n4.join(", "), "]");
        }
        if (t4.type === "line") {
          const e4 = Array.isArray(o2) && o2[n3 + 1] && o2[n3 + 1].type === "break-parent";
          return t4.literal ? e4 ? "literalline" : "literallineWithoutBreakParent" : t4.hard ? e4 ? "hardline" : "hardlineWithoutBreakParent" : t4.soft ? "softline" : "line";
        }
        if (t4.type === "break-parent") {
          return Array.isArray(o2) && o2[n3 - 1] && o2[n3 - 1].type === "line" && o2[n3 - 1].hard ? void 0 : "breakParent";
        }
        if (t4.type === "trim")
          return "trim";
        if (t4.type === "indent")
          return "indent(" + e3(t4.contents) + ")";
        if (t4.type === "align")
          return t4.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e3(t4.contents) + ")" : t4.n < 0 ? "dedent(" + e3(t4.contents) + ")" : t4.n.type === "root" ? "markAsRoot(" + e3(t4.contents) + ")" : "align(" + JSON.stringify(t4.n) + ", " + e3(t4.contents) + ")";
        if (t4.type === "if-break")
          return "ifBreak(" + e3(t4.breakContents) + (t4.flatContents ? ", " + e3(t4.flatContents) : "") + (t4.groupId ? (t4.flatContents ? "" : ', ""') + ", { groupId: ".concat(r2(t4.groupId), " }") : "") + ")";
        if (t4.type === "indent-if-break") {
          const n4 = [];
          t4.negate && n4.push("negate: true"), t4.groupId && n4.push("groupId: ".concat(r2(t4.groupId)));
          const o3 = n4.length > 0 ? ", { ".concat(n4.join(", "), " }") : "";
          return "indentIfBreak(".concat(e3(t4.contents)).concat(o3, ")");
        }
        if (t4.type === "group") {
          const n4 = [];
          t4.break && t4.break !== "propagated" && n4.push("shouldBreak: true"), t4.id && n4.push("id: ".concat(r2(t4.id)));
          const o3 = n4.length > 0 ? ", { ".concat(n4.join(", "), " }") : "";
          return t4.expandedStates ? "conditionalGroup([".concat(t4.expandedStates.map((t5) => e3(t5)).join(","), "]").concat(o3, ")") : "group(".concat(e3(t4.contents)).concat(o3, ")");
        }
        if (t4.type === "fill")
          return "fill([".concat(t4.parts.map((t5) => e3(t5)).join(", "), "])");
        if (t4.type === "line-suffix")
          return "lineSuffix(" + e3(t4.contents) + ")";
        if (t4.type === "line-suffix-boundary")
          return "lineSuffixBoundary";
        if (t4.type === "label")
          return "label(".concat(JSON.stringify(t4.label), ", ").concat(e3(t4.contents), ")");
        throw new Error("Unknown doc type " + t4.type);
      }(Kc(e2));
      function r2(e3) {
        if (typeof e3 != "symbol")
          return JSON.stringify(String(e3));
        if (e3 in t3)
          return t3[e3];
        const r3 = String(e3).slice(7, -1) || "symbol";
        for (let o2 = 0; ; o2++) {
          const i2 = r3 + (o2 > 0 ? " #".concat(o2) : "");
          if (!n2.has(i2))
            return n2.add(i2), t3[e3] = "Symbol.for(".concat(JSON.stringify(i2), ")");
        }
      }
    } }, Zc = { builders: Zi, printer: Jc, utils: Oc, debug: Qc }, el2 = t2(Object.freeze({ __proto__: null, default: {} }));
    function tl(e2, t3) {
      for (var n2 = 0, r2 = e2.length - 1; r2 >= 0; r2--) {
        var o2 = e2[r2];
        o2 === "." ? e2.splice(r2, 1) : o2 === ".." ? (e2.splice(r2, 1), n2++) : n2 && (e2.splice(r2, 1), n2--);
      }
      if (t3)
        for (; n2--; n2)
          e2.unshift("..");
      return e2;
    }
    var nl = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, rl = function(e2) {
      return nl.exec(e2).slice(1);
    };
    function ol() {
      for (var e2 = "", t3 = false, n2 = arguments.length - 1; n2 >= -1 && !t3; n2--) {
        var r2 = n2 >= 0 ? arguments[n2] : "/";
        if (typeof r2 != "string")
          throw new TypeError("Arguments to path.resolve must be strings");
        r2 && (e2 = r2 + "/" + e2, t3 = r2.charAt(0) === "/");
      }
      return e2 = tl(dl(e2.split("/"), function(e3) {
        return !!e3;
      }), !t3).join("/"), (t3 ? "/" : "") + e2 || ".";
    }
    function il(e2) {
      var t3 = ul(e2), n2 = hl(e2, -1) === "/";
      return e2 = tl(dl(e2.split("/"), function(e3) {
        return !!e3;
      }), !t3).join("/"), e2 || t3 || (e2 = "."), e2 && n2 && (e2 += "/"), (t3 ? "/" : "") + e2;
    }
    function ul(e2) {
      return e2.charAt(0) === "/";
    }
    function sl() {
      var e2 = Array.prototype.slice.call(arguments, 0);
      return il(dl(e2, function(e3, t3) {
        if (typeof e3 != "string")
          throw new TypeError("Arguments to path.join must be strings");
        return e3;
      }).join("/"));
    }
    function al(e2, t3) {
      function n2(e3) {
        for (var t4 = 0; t4 < e3.length && e3[t4] === ""; t4++)
          ;
        for (var n3 = e3.length - 1; n3 >= 0 && e3[n3] === ""; n3--)
          ;
        return t4 > n3 ? [] : e3.slice(t4, n3 - t4 + 1);
      }
      e2 = ol(e2).substr(1), t3 = ol(t3).substr(1);
      for (var r2 = n2(e2.split("/")), o2 = n2(t3.split("/")), i2 = Math.min(r2.length, o2.length), u2 = i2, s2 = 0; s2 < i2; s2++)
        if (r2[s2] !== o2[s2]) {
          u2 = s2;
          break;
        }
      var a2 = [];
      for (s2 = u2; s2 < r2.length; s2++)
        a2.push("..");
      return (a2 = a2.concat(o2.slice(u2))).join("/");
    }
    function cl(e2) {
      var t3 = rl(e2), n2 = t3[0], r2 = t3[1];
      return n2 || r2 ? (r2 && (r2 = r2.substr(0, r2.length - 1)), n2 + r2) : ".";
    }
    function ll2(e2, t3) {
      var n2 = rl(e2)[2];
      return t3 && n2.substr(-1 * t3.length) === t3 && (n2 = n2.substr(0, n2.length - t3.length)), n2;
    }
    function pl(e2) {
      return rl(e2)[3];
    }
    var fl = { extname: pl, basename: ll2, dirname: cl, sep: "/", delimiter: ":", relative: al, join: sl, isAbsolute: ul, normalize: il, resolve: ol };
    function dl(e2, t3) {
      if (e2.filter)
        return e2.filter(t3);
      for (var n2 = [], r2 = 0; r2 < e2.length; r2++)
        t3(e2[r2], r2, e2) && n2.push(e2[r2]);
      return n2;
    }
    var hl = "ab".substr(-1) === "b" ? function(e2, t3, n2) {
      return e2.substr(t3, n2);
    } : function(e2, t3, n2) {
      return t3 < 0 && (t3 = e2.length + t3), e2.substr(t3, n2);
    }, gl2 = t2(Object.freeze({ __proto__: null, resolve: ol, normalize: il, isAbsolute: ul, join: sl, relative: al, sep: "/", delimiter: ":", dirname: cl, basename: ll2, extname: pl, default: fl })), ml = [], yl = [], Dl = typeof Uint8Array != "undefined" ? Uint8Array : Array, El = false;
    function Cl() {
      El = true;
      for (var e2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t3 = 0, n2 = e2.length; t3 < n2; ++t3)
        ml[t3] = e2[t3], yl[e2.charCodeAt(t3)] = t3;
      yl["-".charCodeAt(0)] = 62, yl["_".charCodeAt(0)] = 63;
    }
    function bl(e2, t3, n2) {
      for (var r2, o2, i2 = [], u2 = t3; u2 < n2; u2 += 3)
        r2 = (e2[u2] << 16) + (e2[u2 + 1] << 8) + e2[u2 + 2], i2.push(ml[(o2 = r2) >> 18 & 63] + ml[o2 >> 12 & 63] + ml[o2 >> 6 & 63] + ml[63 & o2]);
      return i2.join("");
    }
    function vl(e2) {
      var t3;
      El || Cl();
      for (var n2 = e2.length, r2 = n2 % 3, o2 = "", i2 = [], u2 = 16383, s2 = 0, a2 = n2 - r2; s2 < a2; s2 += u2)
        i2.push(bl(e2, s2, s2 + u2 > a2 ? a2 : s2 + u2));
      return r2 === 1 ? (t3 = e2[n2 - 1], o2 += ml[t3 >> 2], o2 += ml[t3 << 4 & 63], o2 += "==") : r2 === 2 && (t3 = (e2[n2 - 2] << 8) + e2[n2 - 1], o2 += ml[t3 >> 10], o2 += ml[t3 >> 4 & 63], o2 += ml[t3 << 2 & 63], o2 += "="), i2.push(o2), i2.join("");
    }
    function Al(e2, t3, n2, r2, o2) {
      var i2, u2, s2 = 8 * o2 - r2 - 1, a2 = (1 << s2) - 1, c2 = a2 >> 1, l2 = -7, p2 = n2 ? o2 - 1 : 0, f2 = n2 ? -1 : 1, d2 = e2[t3 + p2];
      for (p2 += f2, i2 = d2 & (1 << -l2) - 1, d2 >>= -l2, l2 += s2; l2 > 0; i2 = 256 * i2 + e2[t3 + p2], p2 += f2, l2 -= 8)
        ;
      for (u2 = i2 & (1 << -l2) - 1, i2 >>= -l2, l2 += r2; l2 > 0; u2 = 256 * u2 + e2[t3 + p2], p2 += f2, l2 -= 8)
        ;
      if (i2 === 0)
        i2 = 1 - c2;
      else {
        if (i2 === a2)
          return u2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
        u2 += Math.pow(2, r2), i2 -= c2;
      }
      return (d2 ? -1 : 1) * u2 * Math.pow(2, i2 - r2);
    }
    function Fl(e2, t3, n2, r2, o2, i2) {
      var u2, s2, a2, c2 = 8 * i2 - o2 - 1, l2 = (1 << c2) - 1, p2 = l2 >> 1, f2 = o2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = r2 ? 0 : i2 - 1, h2 = r2 ? 1 : -1, g2 = t3 < 0 || t3 === 0 && 1 / t3 < 0 ? 1 : 0;
      for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (s2 = isNaN(t3) ? 1 : 0, u2 = l2) : (u2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (a2 = Math.pow(2, -u2)) < 1 && (u2--, a2 *= 2), (t3 += u2 + p2 >= 1 ? f2 / a2 : f2 * Math.pow(2, 1 - p2)) * a2 >= 2 && (u2++, a2 /= 2), u2 + p2 >= l2 ? (s2 = 0, u2 = l2) : u2 + p2 >= 1 ? (s2 = (t3 * a2 - 1) * Math.pow(2, o2), u2 += p2) : (s2 = t3 * Math.pow(2, p2 - 1) * Math.pow(2, o2), u2 = 0)); o2 >= 8; e2[n2 + d2] = 255 & s2, d2 += h2, s2 /= 256, o2 -= 8)
        ;
      for (u2 = u2 << o2 | s2, c2 += o2; c2 > 0; e2[n2 + d2] = 255 & u2, d2 += h2, u2 /= 256, c2 -= 8)
        ;
      e2[n2 + d2 - h2] |= 128 * g2;
    }
    var xl = {}.toString, Sl = Array.isArray || function(e2) {
      return xl.call(e2) == "[object Array]";
    };
    function wl() {
      return Bl.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    }
    function Tl(e2, t3) {
      if (wl() < t3)
        throw new RangeError("Invalid typed array length");
      return Bl.TYPED_ARRAY_SUPPORT ? (e2 = new Uint8Array(t3)).__proto__ = Bl.prototype : (e2 === null && (e2 = new Bl(t3)), e2.length = t3), e2;
    }
    function Bl(e2, t3, n2) {
      if (!(Bl.TYPED_ARRAY_SUPPORT || this instanceof Bl))
        return new Bl(e2, t3, n2);
      if (typeof e2 == "number") {
        if (typeof t3 == "string")
          throw new Error("If encoding is specified then the first argument must be a string");
        return Pl(this, e2);
      }
      return Nl(this, e2, t3, n2);
    }
    function Nl(e2, t3, n2, r2) {
      if (typeof t3 == "number")
        throw new TypeError('"value" argument must not be a number');
      return typeof ArrayBuffer != "undefined" && t3 instanceof ArrayBuffer ? function(e3, t4, n3, r3) {
        if (t4.byteLength, n3 < 0 || t4.byteLength < n3)
          throw new RangeError("'offset' is out of bounds");
        if (t4.byteLength < n3 + (r3 || 0))
          throw new RangeError("'length' is out of bounds");
        t4 = n3 === void 0 && r3 === void 0 ? new Uint8Array(t4) : r3 === void 0 ? new Uint8Array(t4, n3) : new Uint8Array(t4, n3, r3);
        Bl.TYPED_ARRAY_SUPPORT ? (e3 = t4).__proto__ = Bl.prototype : e3 = Ol(e3, t4);
        return e3;
      }(e2, t3, n2, r2) : typeof t3 == "string" ? function(e3, t4, n3) {
        typeof n3 == "string" && n3 !== "" || (n3 = "utf8");
        if (!Bl.isEncoding(n3))
          throw new TypeError('"encoding" must be a valid string encoding');
        var r3 = 0 | jl(t4, n3), o2 = (e3 = Tl(e3, r3)).write(t4, n3);
        o2 !== r3 && (e3 = e3.slice(0, o2));
        return e3;
      }(e2, t3, n2) : function(e3, t4) {
        if (Ll2(t4)) {
          var n3 = 0 | Il(t4.length);
          return (e3 = Tl(e3, n3)).length === 0 || t4.copy(e3, 0, 0, n3), e3;
        }
        if (t4) {
          if (typeof ArrayBuffer != "undefined" && t4.buffer instanceof ArrayBuffer || "length" in t4)
            return typeof t4.length != "number" || (r3 = t4.length) != r3 ? Tl(e3, 0) : Ol(e3, t4);
          if (t4.type === "Buffer" && Sl(t4.data))
            return Ol(e3, t4.data);
        }
        var r3;
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }(e2, t3);
    }
    function kl(e2) {
      if (typeof e2 != "number")
        throw new TypeError('"size" argument must be a number');
      if (e2 < 0)
        throw new RangeError('"size" argument must not be negative');
    }
    function Pl(e2, t3) {
      if (kl(t3), e2 = Tl(e2, t3 < 0 ? 0 : 0 | Il(t3)), !Bl.TYPED_ARRAY_SUPPORT)
        for (var n2 = 0; n2 < t3; ++n2)
          e2[n2] = 0;
      return e2;
    }
    function Ol(e2, t3) {
      var n2 = t3.length < 0 ? 0 : 0 | Il(t3.length);
      e2 = Tl(e2, n2);
      for (var r2 = 0; r2 < n2; r2 += 1)
        e2[r2] = 255 & t3[r2];
      return e2;
    }
    function Il(e2) {
      if (e2 >= wl())
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + wl().toString(16) + " bytes");
      return 0 | e2;
    }
    function Ll2(e2) {
      return !(e2 == null || !e2._isBuffer);
    }
    function jl(e2, t3) {
      if (Ll2(e2))
        return e2.length;
      if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e2) || e2 instanceof ArrayBuffer))
        return e2.byteLength;
      typeof e2 != "string" && (e2 = "" + e2);
      var n2 = e2.length;
      if (n2 === 0)
        return 0;
      for (var r2 = false; ; )
        switch (t3) {
          case "ascii":
          case "latin1":
          case "binary":
            return n2;
          case "utf8":
          case "utf-8":
          case void 0:
            return cp(e2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * n2;
          case "hex":
            return n2 >>> 1;
          case "base64":
            return lp(e2).length;
          default:
            if (r2)
              return cp(e2).length;
            t3 = ("" + t3).toLowerCase(), r2 = true;
        }
    }
    function _l(e2, t3, n2) {
      var r2 = false;
      if ((t3 === void 0 || t3 < 0) && (t3 = 0), t3 > this.length)
        return "";
      if ((n2 === void 0 || n2 > this.length) && (n2 = this.length), n2 <= 0)
        return "";
      if ((n2 >>>= 0) <= (t3 >>>= 0))
        return "";
      for (e2 || (e2 = "utf8"); ; )
        switch (e2) {
          case "hex":
            return Ql(this, t3, n2);
          case "utf8":
          case "utf-8":
            return Jl(this, t3, n2);
          case "ascii":
            return Yl(this, t3, n2);
          case "latin1":
          case "binary":
            return Kl(this, t3, n2);
          case "base64":
            return Hl(this, t3, n2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Zl(this, t3, n2);
          default:
            if (r2)
              throw new TypeError("Unknown encoding: " + e2);
            e2 = (e2 + "").toLowerCase(), r2 = true;
        }
    }
    function Ml(e2, t3, n2) {
      var r2 = e2[t3];
      e2[t3] = e2[n2], e2[n2] = r2;
    }
    function Rl(e2, t3, n2, r2, o2) {
      if (e2.length === 0)
        return -1;
      if (typeof n2 == "string" ? (r2 = n2, n2 = 0) : n2 > 2147483647 ? n2 = 2147483647 : n2 < -2147483648 && (n2 = -2147483648), n2 = +n2, isNaN(n2) && (n2 = o2 ? 0 : e2.length - 1), n2 < 0 && (n2 = e2.length + n2), n2 >= e2.length) {
        if (o2)
          return -1;
        n2 = e2.length - 1;
      } else if (n2 < 0) {
        if (!o2)
          return -1;
        n2 = 0;
      }
      if (typeof t3 == "string" && (t3 = Bl.from(t3, r2)), Ll2(t3))
        return t3.length === 0 ? -1 : Vl(e2, t3, n2, r2, o2);
      if (typeof t3 == "number")
        return t3 &= 255, Bl.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? o2 ? Uint8Array.prototype.indexOf.call(e2, t3, n2) : Uint8Array.prototype.lastIndexOf.call(e2, t3, n2) : Vl(e2, [t3], n2, r2, o2);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Vl(e2, t3, n2, r2, o2) {
      var i2, u2 = 1, s2 = e2.length, a2 = t3.length;
      if (r2 !== void 0 && ((r2 = String(r2).toLowerCase()) === "ucs2" || r2 === "ucs-2" || r2 === "utf16le" || r2 === "utf-16le")) {
        if (e2.length < 2 || t3.length < 2)
          return -1;
        u2 = 2, s2 /= 2, a2 /= 2, n2 /= 2;
      }
      function c2(e3, t4) {
        return u2 === 1 ? e3[t4] : e3.readUInt16BE(t4 * u2);
      }
      if (o2) {
        var l2 = -1;
        for (i2 = n2; i2 < s2; i2++)
          if (c2(e2, i2) === c2(t3, l2 === -1 ? 0 : i2 - l2)) {
            if (l2 === -1 && (l2 = i2), i2 - l2 + 1 === a2)
              return l2 * u2;
          } else
            l2 !== -1 && (i2 -= i2 - l2), l2 = -1;
      } else
        for (n2 + a2 > s2 && (n2 = s2 - a2), i2 = n2; i2 >= 0; i2--) {
          for (var p2 = true, f2 = 0; f2 < a2; f2++)
            if (c2(e2, i2 + f2) !== c2(t3, f2)) {
              p2 = false;
              break;
            }
          if (p2)
            return i2;
        }
      return -1;
    }
    function $l(e2, t3, n2, r2) {
      n2 = Number(n2) || 0;
      var o2 = e2.length - n2;
      r2 ? (r2 = Number(r2)) > o2 && (r2 = o2) : r2 = o2;
      var i2 = t3.length;
      if (i2 % 2 != 0)
        throw new TypeError("Invalid hex string");
      r2 > i2 / 2 && (r2 = i2 / 2);
      for (var u2 = 0; u2 < r2; ++u2) {
        var s2 = parseInt(t3.substr(2 * u2, 2), 16);
        if (isNaN(s2))
          return u2;
        e2[n2 + u2] = s2;
      }
      return u2;
    }
    function Wl(e2, t3, n2, r2) {
      return pp(cp(t3, e2.length - n2), e2, n2, r2);
    }
    function ql(e2, t3, n2, r2) {
      return pp(function(e3) {
        for (var t4 = [], n3 = 0; n3 < e3.length; ++n3)
          t4.push(255 & e3.charCodeAt(n3));
        return t4;
      }(t3), e2, n2, r2);
    }
    function Ul(e2, t3, n2, r2) {
      return ql(e2, t3, n2, r2);
    }
    function zl(e2, t3, n2, r2) {
      return pp(lp(t3), e2, n2, r2);
    }
    function Gl(e2, t3, n2, r2) {
      return pp(function(e3, t4) {
        for (var n3, r3, o2, i2 = [], u2 = 0; u2 < e3.length && !((t4 -= 2) < 0); ++u2)
          r3 = (n3 = e3.charCodeAt(u2)) >> 8, o2 = n3 % 256, i2.push(o2), i2.push(r3);
        return i2;
      }(t3, e2.length - n2), e2, n2, r2);
    }
    function Hl(e2, t3, n2) {
      return t3 === 0 && n2 === e2.length ? vl(e2) : vl(e2.slice(t3, n2));
    }
    function Jl(e2, t3, n2) {
      n2 = Math.min(e2.length, n2);
      for (var r2 = [], o2 = t3; o2 < n2; ) {
        var i2, u2, s2, a2, c2 = e2[o2], l2 = null, p2 = c2 > 239 ? 4 : c2 > 223 ? 3 : c2 > 191 ? 2 : 1;
        if (o2 + p2 <= n2)
          switch (p2) {
            case 1:
              c2 < 128 && (l2 = c2);
              break;
            case 2:
              (192 & (i2 = e2[o2 + 1])) == 128 && (a2 = (31 & c2) << 6 | 63 & i2) > 127 && (l2 = a2);
              break;
            case 3:
              i2 = e2[o2 + 1], u2 = e2[o2 + 2], (192 & i2) == 128 && (192 & u2) == 128 && (a2 = (15 & c2) << 12 | (63 & i2) << 6 | 63 & u2) > 2047 && (a2 < 55296 || a2 > 57343) && (l2 = a2);
              break;
            case 4:
              i2 = e2[o2 + 1], u2 = e2[o2 + 2], s2 = e2[o2 + 3], (192 & i2) == 128 && (192 & u2) == 128 && (192 & s2) == 128 && (a2 = (15 & c2) << 18 | (63 & i2) << 12 | (63 & u2) << 6 | 63 & s2) > 65535 && a2 < 1114112 && (l2 = a2);
          }
        l2 === null ? (l2 = 65533, p2 = 1) : l2 > 65535 && (l2 -= 65536, r2.push(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), r2.push(l2), o2 += p2;
      }
      return function(e3) {
        var t4 = e3.length;
        if (t4 <= Xl)
          return String.fromCharCode.apply(String, e3);
        var n3 = "", r3 = 0;
        for (; r3 < t4; )
          n3 += String.fromCharCode.apply(String, e3.slice(r3, r3 += Xl));
        return n3;
      }(r2);
    }
    Bl.TYPED_ARRAY_SUPPORT = Ns.TYPED_ARRAY_SUPPORT === void 0 || Ns.TYPED_ARRAY_SUPPORT, Bl.poolSize = 8192, Bl._augment = function(e2) {
      return e2.__proto__ = Bl.prototype, e2;
    }, Bl.from = function(e2, t3, n2) {
      return Nl(null, e2, t3, n2);
    }, Bl.TYPED_ARRAY_SUPPORT && (Bl.prototype.__proto__ = Uint8Array.prototype, Bl.__proto__ = Uint8Array), Bl.alloc = function(e2, t3, n2) {
      return function(e3, t4, n3, r2) {
        return kl(t4), t4 <= 0 ? Tl(e3, t4) : n3 !== void 0 ? typeof r2 == "string" ? Tl(e3, t4).fill(n3, r2) : Tl(e3, t4).fill(n3) : Tl(e3, t4);
      }(null, e2, t3, n2);
    }, Bl.allocUnsafe = function(e2) {
      return Pl(null, e2);
    }, Bl.allocUnsafeSlow = function(e2) {
      return Pl(null, e2);
    }, Bl.isBuffer = fp, Bl.compare = function(e2, t3) {
      if (!Ll2(e2) || !Ll2(t3))
        throw new TypeError("Arguments must be Buffers");
      if (e2 === t3)
        return 0;
      for (var n2 = e2.length, r2 = t3.length, o2 = 0, i2 = Math.min(n2, r2); o2 < i2; ++o2)
        if (e2[o2] !== t3[o2]) {
          n2 = e2[o2], r2 = t3[o2];
          break;
        }
      return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
    }, Bl.isEncoding = function(e2) {
      switch (String(e2).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, Bl.concat = function(e2, t3) {
      if (!Sl(e2))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (e2.length === 0)
        return Bl.alloc(0);
      var n2;
      if (t3 === void 0)
        for (t3 = 0, n2 = 0; n2 < e2.length; ++n2)
          t3 += e2[n2].length;
      var r2 = Bl.allocUnsafe(t3), o2 = 0;
      for (n2 = 0; n2 < e2.length; ++n2) {
        var i2 = e2[n2];
        if (!Ll2(i2))
          throw new TypeError('"list" argument must be an Array of Buffers');
        i2.copy(r2, o2), o2 += i2.length;
      }
      return r2;
    }, Bl.byteLength = jl, Bl.prototype._isBuffer = true, Bl.prototype.swap16 = function() {
      var e2 = this.length;
      if (e2 % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var t3 = 0; t3 < e2; t3 += 2)
        Ml(this, t3, t3 + 1);
      return this;
    }, Bl.prototype.swap32 = function() {
      var e2 = this.length;
      if (e2 % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var t3 = 0; t3 < e2; t3 += 4)
        Ml(this, t3, t3 + 3), Ml(this, t3 + 1, t3 + 2);
      return this;
    }, Bl.prototype.swap64 = function() {
      var e2 = this.length;
      if (e2 % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var t3 = 0; t3 < e2; t3 += 8)
        Ml(this, t3, t3 + 7), Ml(this, t3 + 1, t3 + 6), Ml(this, t3 + 2, t3 + 5), Ml(this, t3 + 3, t3 + 4);
      return this;
    }, Bl.prototype.toString = function() {
      var e2 = 0 | this.length;
      return e2 === 0 ? "" : arguments.length === 0 ? Jl(this, 0, e2) : _l.apply(this, arguments);
    }, Bl.prototype.equals = function(e2) {
      if (!Ll2(e2))
        throw new TypeError("Argument must be a Buffer");
      return this === e2 || Bl.compare(this, e2) === 0;
    }, Bl.prototype.inspect = function() {
      var e2 = "";
      return this.length > 0 && (e2 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e2 += " ... ")), "<Buffer " + e2 + ">";
    }, Bl.prototype.compare = function(e2, t3, n2, r2, o2) {
      if (!Ll2(e2))
        throw new TypeError("Argument must be a Buffer");
      if (t3 === void 0 && (t3 = 0), n2 === void 0 && (n2 = e2 ? e2.length : 0), r2 === void 0 && (r2 = 0), o2 === void 0 && (o2 = this.length), t3 < 0 || n2 > e2.length || r2 < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (r2 >= o2 && t3 >= n2)
        return 0;
      if (r2 >= o2)
        return -1;
      if (t3 >= n2)
        return 1;
      if (this === e2)
        return 0;
      for (var i2 = (o2 >>>= 0) - (r2 >>>= 0), u2 = (n2 >>>= 0) - (t3 >>>= 0), s2 = Math.min(i2, u2), a2 = this.slice(r2, o2), c2 = e2.slice(t3, n2), l2 = 0; l2 < s2; ++l2)
        if (a2[l2] !== c2[l2]) {
          i2 = a2[l2], u2 = c2[l2];
          break;
        }
      return i2 < u2 ? -1 : u2 < i2 ? 1 : 0;
    }, Bl.prototype.includes = function(e2, t3, n2) {
      return this.indexOf(e2, t3, n2) !== -1;
    }, Bl.prototype.indexOf = function(e2, t3, n2) {
      return Rl(this, e2, t3, n2, true);
    }, Bl.prototype.lastIndexOf = function(e2, t3, n2) {
      return Rl(this, e2, t3, n2, false);
    }, Bl.prototype.write = function(e2, t3, n2, r2) {
      if (t3 === void 0)
        r2 = "utf8", n2 = this.length, t3 = 0;
      else if (n2 === void 0 && typeof t3 == "string")
        r2 = t3, n2 = this.length, t3 = 0;
      else {
        if (!isFinite(t3))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        t3 |= 0, isFinite(n2) ? (n2 |= 0, r2 === void 0 && (r2 = "utf8")) : (r2 = n2, n2 = void 0);
      }
      var o2 = this.length - t3;
      if ((n2 === void 0 || n2 > o2) && (n2 = o2), e2.length > 0 && (n2 < 0 || t3 < 0) || t3 > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      r2 || (r2 = "utf8");
      for (var i2 = false; ; )
        switch (r2) {
          case "hex":
            return $l(this, e2, t3, n2);
          case "utf8":
          case "utf-8":
            return Wl(this, e2, t3, n2);
          case "ascii":
            return ql(this, e2, t3, n2);
          case "latin1":
          case "binary":
            return Ul(this, e2, t3, n2);
          case "base64":
            return zl(this, e2, t3, n2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Gl(this, e2, t3, n2);
          default:
            if (i2)
              throw new TypeError("Unknown encoding: " + r2);
            r2 = ("" + r2).toLowerCase(), i2 = true;
        }
    }, Bl.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    var Xl = 4096;
    function Yl(e2, t3, n2) {
      var r2 = "";
      n2 = Math.min(e2.length, n2);
      for (var o2 = t3; o2 < n2; ++o2)
        r2 += String.fromCharCode(127 & e2[o2]);
      return r2;
    }
    function Kl(e2, t3, n2) {
      var r2 = "";
      n2 = Math.min(e2.length, n2);
      for (var o2 = t3; o2 < n2; ++o2)
        r2 += String.fromCharCode(e2[o2]);
      return r2;
    }
    function Ql(e2, t3, n2) {
      var r2 = e2.length;
      (!t3 || t3 < 0) && (t3 = 0), (!n2 || n2 < 0 || n2 > r2) && (n2 = r2);
      for (var o2 = "", i2 = t3; i2 < n2; ++i2)
        o2 += ap2(e2[i2]);
      return o2;
    }
    function Zl(e2, t3, n2) {
      for (var r2 = e2.slice(t3, n2), o2 = "", i2 = 0; i2 < r2.length; i2 += 2)
        o2 += String.fromCharCode(r2[i2] + 256 * r2[i2 + 1]);
      return o2;
    }
    function ep(e2, t3, n2) {
      if (e2 % 1 != 0 || e2 < 0)
        throw new RangeError("offset is not uint");
      if (e2 + t3 > n2)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function tp(e2, t3, n2, r2, o2, i2) {
      if (!Ll2(e2))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t3 > o2 || t3 < i2)
        throw new RangeError('"value" argument is out of bounds');
      if (n2 + r2 > e2.length)
        throw new RangeError("Index out of range");
    }
    function np(e2, t3, n2, r2) {
      t3 < 0 && (t3 = 65535 + t3 + 1);
      for (var o2 = 0, i2 = Math.min(e2.length - n2, 2); o2 < i2; ++o2)
        e2[n2 + o2] = (t3 & 255 << 8 * (r2 ? o2 : 1 - o2)) >>> 8 * (r2 ? o2 : 1 - o2);
    }
    function rp(e2, t3, n2, r2) {
      t3 < 0 && (t3 = 4294967295 + t3 + 1);
      for (var o2 = 0, i2 = Math.min(e2.length - n2, 4); o2 < i2; ++o2)
        e2[n2 + o2] = t3 >>> 8 * (r2 ? o2 : 3 - o2) & 255;
    }
    function op(e2, t3, n2, r2, o2, i2) {
      if (n2 + r2 > e2.length)
        throw new RangeError("Index out of range");
      if (n2 < 0)
        throw new RangeError("Index out of range");
    }
    function ip(e2, t3, n2, r2, o2) {
      return o2 || op(e2, 0, n2, 4), Fl(e2, t3, n2, r2, 23, 4), n2 + 4;
    }
    function up(e2, t3, n2, r2, o2) {
      return o2 || op(e2, 0, n2, 8), Fl(e2, t3, n2, r2, 52, 8), n2 + 8;
    }
    Bl.prototype.slice = function(e2, t3) {
      var n2, r2 = this.length;
      if ((e2 = ~~e2) < 0 ? (e2 += r2) < 0 && (e2 = 0) : e2 > r2 && (e2 = r2), (t3 = t3 === void 0 ? r2 : ~~t3) < 0 ? (t3 += r2) < 0 && (t3 = 0) : t3 > r2 && (t3 = r2), t3 < e2 && (t3 = e2), Bl.TYPED_ARRAY_SUPPORT)
        (n2 = this.subarray(e2, t3)).__proto__ = Bl.prototype;
      else {
        var o2 = t3 - e2;
        n2 = new Bl(o2, void 0);
        for (var i2 = 0; i2 < o2; ++i2)
          n2[i2] = this[i2 + e2];
      }
      return n2;
    }, Bl.prototype.readUIntLE = function(e2, t3, n2) {
      e2 |= 0, t3 |= 0, n2 || ep(e2, t3, this.length);
      for (var r2 = this[e2], o2 = 1, i2 = 0; ++i2 < t3 && (o2 *= 256); )
        r2 += this[e2 + i2] * o2;
      return r2;
    }, Bl.prototype.readUIntBE = function(e2, t3, n2) {
      e2 |= 0, t3 |= 0, n2 || ep(e2, t3, this.length);
      for (var r2 = this[e2 + --t3], o2 = 1; t3 > 0 && (o2 *= 256); )
        r2 += this[e2 + --t3] * o2;
      return r2;
    }, Bl.prototype.readUInt8 = function(e2, t3) {
      return t3 || ep(e2, 1, this.length), this[e2];
    }, Bl.prototype.readUInt16LE = function(e2, t3) {
      return t3 || ep(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
    }, Bl.prototype.readUInt16BE = function(e2, t3) {
      return t3 || ep(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
    }, Bl.prototype.readUInt32LE = function(e2, t3) {
      return t3 || ep(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
    }, Bl.prototype.readUInt32BE = function(e2, t3) {
      return t3 || ep(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
    }, Bl.prototype.readIntLE = function(e2, t3, n2) {
      e2 |= 0, t3 |= 0, n2 || ep(e2, t3, this.length);
      for (var r2 = this[e2], o2 = 1, i2 = 0; ++i2 < t3 && (o2 *= 256); )
        r2 += this[e2 + i2] * o2;
      return r2 >= (o2 *= 128) && (r2 -= Math.pow(2, 8 * t3)), r2;
    }, Bl.prototype.readIntBE = function(e2, t3, n2) {
      e2 |= 0, t3 |= 0, n2 || ep(e2, t3, this.length);
      for (var r2 = t3, o2 = 1, i2 = this[e2 + --r2]; r2 > 0 && (o2 *= 256); )
        i2 += this[e2 + --r2] * o2;
      return i2 >= (o2 *= 128) && (i2 -= Math.pow(2, 8 * t3)), i2;
    }, Bl.prototype.readInt8 = function(e2, t3) {
      return t3 || ep(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
    }, Bl.prototype.readInt16LE = function(e2, t3) {
      t3 || ep(e2, 2, this.length);
      var n2 = this[e2] | this[e2 + 1] << 8;
      return 32768 & n2 ? 4294901760 | n2 : n2;
    }, Bl.prototype.readInt16BE = function(e2, t3) {
      t3 || ep(e2, 2, this.length);
      var n2 = this[e2 + 1] | this[e2] << 8;
      return 32768 & n2 ? 4294901760 | n2 : n2;
    }, Bl.prototype.readInt32LE = function(e2, t3) {
      return t3 || ep(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
    }, Bl.prototype.readInt32BE = function(e2, t3) {
      return t3 || ep(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
    }, Bl.prototype.readFloatLE = function(e2, t3) {
      return t3 || ep(e2, 4, this.length), Al(this, e2, true, 23, 4);
    }, Bl.prototype.readFloatBE = function(e2, t3) {
      return t3 || ep(e2, 4, this.length), Al(this, e2, false, 23, 4);
    }, Bl.prototype.readDoubleLE = function(e2, t3) {
      return t3 || ep(e2, 8, this.length), Al(this, e2, true, 52, 8);
    }, Bl.prototype.readDoubleBE = function(e2, t3) {
      return t3 || ep(e2, 8, this.length), Al(this, e2, false, 52, 8);
    }, Bl.prototype.writeUIntLE = function(e2, t3, n2, r2) {
      (e2 = +e2, t3 |= 0, n2 |= 0, r2) || tp(this, e2, t3, n2, Math.pow(2, 8 * n2) - 1, 0);
      var o2 = 1, i2 = 0;
      for (this[t3] = 255 & e2; ++i2 < n2 && (o2 *= 256); )
        this[t3 + i2] = e2 / o2 & 255;
      return t3 + n2;
    }, Bl.prototype.writeUIntBE = function(e2, t3, n2, r2) {
      (e2 = +e2, t3 |= 0, n2 |= 0, r2) || tp(this, e2, t3, n2, Math.pow(2, 8 * n2) - 1, 0);
      var o2 = n2 - 1, i2 = 1;
      for (this[t3 + o2] = 255 & e2; --o2 >= 0 && (i2 *= 256); )
        this[t3 + o2] = e2 / i2 & 255;
      return t3 + n2;
    }, Bl.prototype.writeUInt8 = function(e2, t3, n2) {
      return e2 = +e2, t3 |= 0, n2 || tp(this, e2, t3, 1, 255, 0), Bl.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), this[t3] = 255 & e2, t3 + 1;
    }, Bl.prototype.writeUInt16LE = function(e2, t3, n2) {
      return e2 = +e2, t3 |= 0, n2 || tp(this, e2, t3, 2, 65535, 0), Bl.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e2, this[t3 + 1] = e2 >>> 8) : np(this, e2, t3, true), t3 + 2;
    }, Bl.prototype.writeUInt16BE = function(e2, t3, n2) {
      return e2 = +e2, t3 |= 0, n2 || tp(this, e2, t3, 2, 65535, 0), Bl.TYPED_ARRAY_SUPPORT ? (this[t3] = e2 >>> 8, this[t3 + 1] = 255 & e2) : np(this, e2, t3, false), t3 + 2;
    }, Bl.prototype.writeUInt32LE = function(e2, t3, n2) {
      return e2 = +e2, t3 |= 0, n2 || tp(this, e2, t3, 4, 4294967295, 0), Bl.TYPED_ARRAY_SUPPORT ? (this[t3 + 3] = e2 >>> 24, this[t3 + 2] = e2 >>> 16, this[t3 + 1] = e2 >>> 8, this[t3] = 255 & e2) : rp(this, e2, t3, true), t3 + 4;
    }, Bl.prototype.writeUInt32BE = function(e2, t3, n2) {
      return e2 = +e2, t3 |= 0, n2 || tp(this, e2, t3, 4, 4294967295, 0), Bl.TYPED_ARRAY_SUPPORT ? (this[t3] = e2 >>> 24, this[t3 + 1] = e2 >>> 16, this[t3 + 2] = e2 >>> 8, this[t3 + 3] = 255 & e2) : rp(this, e2, t3, false), t3 + 4;
    }, Bl.prototype.writeIntLE = function(e2, t3, n2, r2) {
      if (e2 = +e2, t3 |= 0, !r2) {
        var o2 = Math.pow(2, 8 * n2 - 1);
        tp(this, e2, t3, n2, o2 - 1, -o2);
      }
      var i2 = 0, u2 = 1, s2 = 0;
      for (this[t3] = 255 & e2; ++i2 < n2 && (u2 *= 256); )
        e2 < 0 && s2 === 0 && this[t3 + i2 - 1] !== 0 && (s2 = 1), this[t3 + i2] = (e2 / u2 >> 0) - s2 & 255;
      return t3 + n2;
    }, Bl.prototype.writeIntBE = function(e2, t3, n2, r2) {
      if (e2 = +e2, t3 |= 0, !r2) {
        var o2 = Math.pow(2, 8 * n2 - 1);
        tp(this, e2, t3, n2, o2 - 1, -o2);
      }
      var i2 = n2 - 1, u2 = 1, s2 = 0;
      for (this[t3 + i2] = 255 & e2; --i2 >= 0 && (u2 *= 256); )
        e2 < 0 && s2 === 0 && this[t3 + i2 + 1] !== 0 && (s2 = 1), this[t3 + i2] = (e2 / u2 >> 0) - s2 & 255;
      return t3 + n2;
    }, Bl.prototype.writeInt8 = function(e2, t3, n2) {
      return e2 = +e2, t3 |= 0, n2 || tp(this, e2, t3, 1, 127, -128), Bl.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), e2 < 0 && (e2 = 255 + e2 + 1), this[t3] = 255 & e2, t3 + 1;
    }, Bl.prototype.writeInt16LE = function(e2, t3, n2) {
      return e2 = +e2, t3 |= 0, n2 || tp(this, e2, t3, 2, 32767, -32768), Bl.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e2, this[t3 + 1] = e2 >>> 8) : np(this, e2, t3, true), t3 + 2;
    }, Bl.prototype.writeInt16BE = function(e2, t3, n2) {
      return e2 = +e2, t3 |= 0, n2 || tp(this, e2, t3, 2, 32767, -32768), Bl.TYPED_ARRAY_SUPPORT ? (this[t3] = e2 >>> 8, this[t3 + 1] = 255 & e2) : np(this, e2, t3, false), t3 + 2;
    }, Bl.prototype.writeInt32LE = function(e2, t3, n2) {
      return e2 = +e2, t3 |= 0, n2 || tp(this, e2, t3, 4, 2147483647, -2147483648), Bl.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e2, this[t3 + 1] = e2 >>> 8, this[t3 + 2] = e2 >>> 16, this[t3 + 3] = e2 >>> 24) : rp(this, e2, t3, true), t3 + 4;
    }, Bl.prototype.writeInt32BE = function(e2, t3, n2) {
      return e2 = +e2, t3 |= 0, n2 || tp(this, e2, t3, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), Bl.TYPED_ARRAY_SUPPORT ? (this[t3] = e2 >>> 24, this[t3 + 1] = e2 >>> 16, this[t3 + 2] = e2 >>> 8, this[t3 + 3] = 255 & e2) : rp(this, e2, t3, false), t3 + 4;
    }, Bl.prototype.writeFloatLE = function(e2, t3, n2) {
      return ip(this, e2, t3, true, n2);
    }, Bl.prototype.writeFloatBE = function(e2, t3, n2) {
      return ip(this, e2, t3, false, n2);
    }, Bl.prototype.writeDoubleLE = function(e2, t3, n2) {
      return up(this, e2, t3, true, n2);
    }, Bl.prototype.writeDoubleBE = function(e2, t3, n2) {
      return up(this, e2, t3, false, n2);
    }, Bl.prototype.copy = function(e2, t3, n2, r2) {
      if (n2 || (n2 = 0), r2 || r2 === 0 || (r2 = this.length), t3 >= e2.length && (t3 = e2.length), t3 || (t3 = 0), r2 > 0 && r2 < n2 && (r2 = n2), r2 === n2)
        return 0;
      if (e2.length === 0 || this.length === 0)
        return 0;
      if (t3 < 0)
        throw new RangeError("targetStart out of bounds");
      if (n2 < 0 || n2 >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (r2 < 0)
        throw new RangeError("sourceEnd out of bounds");
      r2 > this.length && (r2 = this.length), e2.length - t3 < r2 - n2 && (r2 = e2.length - t3 + n2);
      var o2, i2 = r2 - n2;
      if (this === e2 && n2 < t3 && t3 < r2)
        for (o2 = i2 - 1; o2 >= 0; --o2)
          e2[o2 + t3] = this[o2 + n2];
      else if (i2 < 1e3 || !Bl.TYPED_ARRAY_SUPPORT)
        for (o2 = 0; o2 < i2; ++o2)
          e2[o2 + t3] = this[o2 + n2];
      else
        Uint8Array.prototype.set.call(e2, this.subarray(n2, n2 + i2), t3);
      return i2;
    }, Bl.prototype.fill = function(e2, t3, n2, r2) {
      if (typeof e2 == "string") {
        if (typeof t3 == "string" ? (r2 = t3, t3 = 0, n2 = this.length) : typeof n2 == "string" && (r2 = n2, n2 = this.length), e2.length === 1) {
          var o2 = e2.charCodeAt(0);
          o2 < 256 && (e2 = o2);
        }
        if (r2 !== void 0 && typeof r2 != "string")
          throw new TypeError("encoding must be a string");
        if (typeof r2 == "string" && !Bl.isEncoding(r2))
          throw new TypeError("Unknown encoding: " + r2);
      } else
        typeof e2 == "number" && (e2 &= 255);
      if (t3 < 0 || this.length < t3 || this.length < n2)
        throw new RangeError("Out of range index");
      if (n2 <= t3)
        return this;
      var i2;
      if (t3 >>>= 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, e2 || (e2 = 0), typeof e2 == "number")
        for (i2 = t3; i2 < n2; ++i2)
          this[i2] = e2;
      else {
        var u2 = Ll2(e2) ? e2 : cp(new Bl(e2, r2).toString()), s2 = u2.length;
        for (i2 = 0; i2 < n2 - t3; ++i2)
          this[i2 + t3] = u2[i2 % s2];
      }
      return this;
    };
    var sp = /[^+\/0-9A-Za-z-_]/g;
    function ap2(e2) {
      return e2 < 16 ? "0" + e2.toString(16) : e2.toString(16);
    }
    function cp(e2, t3) {
      var n2;
      t3 = t3 || 1 / 0;
      for (var r2 = e2.length, o2 = null, i2 = [], u2 = 0; u2 < r2; ++u2) {
        if ((n2 = e2.charCodeAt(u2)) > 55295 && n2 < 57344) {
          if (!o2) {
            if (n2 > 56319) {
              (t3 -= 3) > -1 && i2.push(239, 191, 189);
              continue;
            }
            if (u2 + 1 === r2) {
              (t3 -= 3) > -1 && i2.push(239, 191, 189);
              continue;
            }
            o2 = n2;
            continue;
          }
          if (n2 < 56320) {
            (t3 -= 3) > -1 && i2.push(239, 191, 189), o2 = n2;
            continue;
          }
          n2 = 65536 + (o2 - 55296 << 10 | n2 - 56320);
        } else
          o2 && (t3 -= 3) > -1 && i2.push(239, 191, 189);
        if (o2 = null, n2 < 128) {
          if ((t3 -= 1) < 0)
            break;
          i2.push(n2);
        } else if (n2 < 2048) {
          if ((t3 -= 2) < 0)
            break;
          i2.push(n2 >> 6 | 192, 63 & n2 | 128);
        } else if (n2 < 65536) {
          if ((t3 -= 3) < 0)
            break;
          i2.push(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128);
        } else {
          if (!(n2 < 1114112))
            throw new Error("Invalid code point");
          if ((t3 -= 4) < 0)
            break;
          i2.push(n2 >> 18 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128);
        }
      }
      return i2;
    }
    function lp(e2) {
      return function(e3) {
        var t3, n2, r2, o2, i2, u2;
        El || Cl();
        var s2 = e3.length;
        if (s2 % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        i2 = e3[s2 - 2] === "=" ? 2 : e3[s2 - 1] === "=" ? 1 : 0, u2 = new Dl(3 * s2 / 4 - i2), r2 = i2 > 0 ? s2 - 4 : s2;
        var a2 = 0;
        for (t3 = 0, n2 = 0; t3 < r2; t3 += 4, n2 += 3)
          o2 = yl[e3.charCodeAt(t3)] << 18 | yl[e3.charCodeAt(t3 + 1)] << 12 | yl[e3.charCodeAt(t3 + 2)] << 6 | yl[e3.charCodeAt(t3 + 3)], u2[a2++] = o2 >> 16 & 255, u2[a2++] = o2 >> 8 & 255, u2[a2++] = 255 & o2;
        return i2 === 2 ? (o2 = yl[e3.charCodeAt(t3)] << 2 | yl[e3.charCodeAt(t3 + 1)] >> 4, u2[a2++] = 255 & o2) : i2 === 1 && (o2 = yl[e3.charCodeAt(t3)] << 10 | yl[e3.charCodeAt(t3 + 1)] << 4 | yl[e3.charCodeAt(t3 + 2)] >> 2, u2[a2++] = o2 >> 8 & 255, u2[a2++] = 255 & o2), u2;
      }(function(e3) {
        if ((e3 = function(e4) {
          return e4.trim ? e4.trim() : e4.replace(/^\s+|\s+$/g, "");
        }(e3).replace(sp, "")).length < 2)
          return "";
        for (; e3.length % 4 != 0; )
          e3 += "=";
        return e3;
      }(e2));
    }
    function pp(e2, t3, n2, r2) {
      for (var o2 = 0; o2 < r2 && !(o2 + n2 >= t3.length || o2 >= e2.length); ++o2)
        t3[o2 + n2] = e2[o2];
      return o2;
    }
    function fp(e2) {
      return e2 != null && (!!e2._isBuffer || dp(e2) || function(e3) {
        return typeof e3.readFloatLE == "function" && typeof e3.slice == "function" && dp(e3.slice(0, 0));
      }(e2));
    }
    function dp(e2) {
      return !!e2.constructor && typeof e2.constructor.isBuffer == "function" && e2.constructor.isBuffer(e2);
    }
    const hp = el2;
    var gp = class {
      constructor(e2, t3) {
        (t3 = t3 || {}).readChunk || (t3.readChunk = 1024), t3.newLineCharacter ? t3.newLineCharacter = t3.newLineCharacter.charCodeAt(0) : t3.newLineCharacter = 10, this.fd = typeof e2 == "number" ? e2 : hp.openSync(e2, "r"), this.options = t3, this.newLineCharacter = t3.newLineCharacter, this.reset();
      }
      _searchInBuffer(e2, t3) {
        let n2 = -1;
        for (let r2 = 0; r2 <= e2.length; r2++) {
          if (e2[r2] === t3) {
            n2 = r2;
            break;
          }
        }
        return n2;
      }
      reset() {
        this.eofReached = false, this.linesCache = [], this.fdPosition = 0;
      }
      close() {
        hp.closeSync(this.fd), this.fd = null;
      }
      _extractLines(e2) {
        let t3;
        const n2 = [];
        let r2 = 0, o2 = 0;
        for (; ; ) {
          let i3 = e2[r2++];
          if (i3 === this.newLineCharacter)
            t3 = e2.slice(o2, r2), n2.push(t3), o2 = r2;
          else if (i3 === void 0)
            break;
        }
        let i2 = e2.slice(o2, r2);
        return i2.length && n2.push(i2), n2;
      }
      _readChunk(e2) {
        let t3, n2 = 0;
        const r2 = [];
        do {
          const e3 = new Bl(this.options.readChunk);
          t3 = hp.readSync(this.fd, e3, 0, this.options.readChunk, this.fdPosition), n2 += t3, this.fdPosition = this.fdPosition + t3, r2.push(e3);
        } while (t3 && this._searchInBuffer(r2[r2.length - 1], this.options.newLineCharacter) === -1);
        let o2 = Bl.concat(r2);
        return t3 < this.options.readChunk && (this.eofReached = true, o2 = o2.slice(0, n2)), n2 && (this.linesCache = this._extractLines(o2), e2 && (this.linesCache[0] = Bl.concat([e2, this.linesCache[0]]))), n2;
      }
      next() {
        if (!this.fd)
          return false;
        let e2, t3 = false;
        if (this.eofReached && this.linesCache.length === 0)
          return t3;
        if (this.linesCache.length || (e2 = this._readChunk()), this.linesCache.length) {
          t3 = this.linesCache.shift();
          t3[t3.length - 1] !== this.newLineCharacter && (e2 = this._readChunk(t3), e2 && (t3 = this.linesCache.shift()));
        }
        return this.eofReached && this.linesCache.length === 0 && this.close(), t3 && t3[t3.length - 1] === this.newLineCharacter && (t3 = t3.slice(0, t3.length - 1)), t3;
      }
    };
    class mp2 extends Error {
    }
    class yp extends Error {
    }
    class Dp extends Error {
    }
    class Ep extends Error {
    }
    var Cp = { ConfigError: mp2, DebugError: yp, UndefinedParserError: Dp, ArgExpansionBailout: Ep }, bp = {}, vp = function(e2, t3) {
      return vp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t4) {
        e3.__proto__ = t4;
      } || function(e3, t4) {
        for (var n2 in t4)
          t4.hasOwnProperty(n2) && (e3[n2] = t4[n2]);
      }, vp(e2, t3);
    };
    var Ap = function() {
      return Ap = Object.assign || function(e2) {
        for (var t3, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
          for (var o2 in t3 = arguments[n2])
            Object.prototype.hasOwnProperty.call(t3, o2) && (e2[o2] = t3[o2]);
        return e2;
      }, Ap.apply(this, arguments);
    };
    function Fp(e2) {
      var t3 = typeof Symbol == "function" && Symbol.iterator, n2 = t3 && e2[t3], r2 = 0;
      if (n2)
        return n2.call(e2);
      if (e2 && typeof e2.length == "number")
        return { next: function() {
          return e2 && r2 >= e2.length && (e2 = void 0), { value: e2 && e2[r2++], done: !e2 };
        } };
      throw new TypeError(t3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function xp(e2, t3) {
      var n2 = typeof Symbol == "function" && e2[Symbol.iterator];
      if (!n2)
        return e2;
      var r2, o2, i2 = n2.call(e2), u2 = [];
      try {
        for (; (t3 === void 0 || t3-- > 0) && !(r2 = i2.next()).done; )
          u2.push(r2.value);
      } catch (e3) {
        o2 = { error: e3 };
      } finally {
        try {
          r2 && !r2.done && (n2 = i2.return) && n2.call(i2);
        } finally {
          if (o2)
            throw o2.error;
        }
      }
      return u2;
    }
    function Sp(e2) {
      return this instanceof Sp ? (this.v = e2, this) : new Sp(e2);
    }
    var wp2 = Object.freeze({ __proto__: null, __extends: function(e2, t3) {
      function n2() {
        this.constructor = e2;
      }
      vp(e2, t3), e2.prototype = t3 === null ? Object.create(t3) : (n2.prototype = t3.prototype, new n2());
    }, get __assign() {
      return Ap;
    }, __rest: function(e2, t3) {
      var n2 = {};
      for (var r2 in e2)
        Object.prototype.hasOwnProperty.call(e2, r2) && t3.indexOf(r2) < 0 && (n2[r2] = e2[r2]);
      if (e2 != null && typeof Object.getOwnPropertySymbols == "function") {
        var o2 = 0;
        for (r2 = Object.getOwnPropertySymbols(e2); o2 < r2.length; o2++)
          t3.indexOf(r2[o2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, r2[o2]) && (n2[r2[o2]] = e2[r2[o2]]);
      }
      return n2;
    }, __decorate: function(e2, t3, n2, r2) {
      var o2, i2 = arguments.length, u2 = i2 < 3 ? t3 : r2 === null ? r2 = Object.getOwnPropertyDescriptor(t3, n2) : r2;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        u2 = Reflect.decorate(e2, t3, n2, r2);
      else
        for (var s2 = e2.length - 1; s2 >= 0; s2--)
          (o2 = e2[s2]) && (u2 = (i2 < 3 ? o2(u2) : i2 > 3 ? o2(t3, n2, u2) : o2(t3, n2)) || u2);
      return i2 > 3 && u2 && Object.defineProperty(t3, n2, u2), u2;
    }, __param: function(e2, t3) {
      return function(n2, r2) {
        t3(n2, r2, e2);
      };
    }, __metadata: function(e2, t3) {
      if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(e2, t3);
    }, __awaiter: function(e2, t3, n2, r2) {
      return new (n2 || (n2 = Promise))(function(o2, i2) {
        function u2(e3) {
          try {
            a2(r2.next(e3));
          } catch (e4) {
            i2(e4);
          }
        }
        function s2(e3) {
          try {
            a2(r2.throw(e3));
          } catch (e4) {
            i2(e4);
          }
        }
        function a2(e3) {
          var t4;
          e3.done ? o2(e3.value) : (t4 = e3.value, t4 instanceof n2 ? t4 : new n2(function(e4) {
            e4(t4);
          })).then(u2, s2);
        }
        a2((r2 = r2.apply(e2, t3 || [])).next());
      });
    }, __generator: function(e2, t3) {
      var n2, r2, o2, i2, u2 = { label: 0, sent: function() {
        if (1 & o2[0])
          throw o2[1];
        return o2[1];
      }, trys: [], ops: [] };
      return i2 = { next: s2(0), throw: s2(1), return: s2(2) }, typeof Symbol == "function" && (i2[Symbol.iterator] = function() {
        return this;
      }), i2;
      function s2(i3) {
        return function(s3) {
          return function(i4) {
            if (n2)
              throw new TypeError("Generator is already executing.");
            for (; u2; )
              try {
                if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done)
                  return o2;
                switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
                  case 0:
                  case 1:
                    o2 = i4;
                    break;
                  case 4:
                    return u2.label++, { value: i4[1], done: false };
                  case 5:
                    u2.label++, r2 = i4[1], i4 = [0];
                    continue;
                  case 7:
                    i4 = u2.ops.pop(), u2.trys.pop();
                    continue;
                  default:
                    if (!(o2 = u2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || i4[0] !== 6 && i4[0] !== 2)) {
                      u2 = 0;
                      continue;
                    }
                    if (i4[0] === 3 && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                      u2.label = i4[1];
                      break;
                    }
                    if (i4[0] === 6 && u2.label < o2[1]) {
                      u2.label = o2[1], o2 = i4;
                      break;
                    }
                    if (o2 && u2.label < o2[2]) {
                      u2.label = o2[2], u2.ops.push(i4);
                      break;
                    }
                    o2[2] && u2.ops.pop(), u2.trys.pop();
                    continue;
                }
                i4 = t3.call(e2, u2);
              } catch (e3) {
                i4 = [6, e3], r2 = 0;
              } finally {
                n2 = o2 = 0;
              }
            if (5 & i4[0])
              throw i4[1];
            return { value: i4[0] ? i4[1] : void 0, done: true };
          }([i3, s3]);
        };
      }
    }, __createBinding: function(e2, t3, n2, r2) {
      r2 === void 0 && (r2 = n2), e2[r2] = t3[n2];
    }, __exportStar: function(e2, t3) {
      for (var n2 in e2)
        n2 === "default" || t3.hasOwnProperty(n2) || (t3[n2] = e2[n2]);
    }, __values: Fp, __read: xp, __spread: function() {
      for (var e2 = [], t3 = 0; t3 < arguments.length; t3++)
        e2 = e2.concat(xp(arguments[t3]));
      return e2;
    }, __spreadArrays: function() {
      for (var e2 = 0, t3 = 0, n2 = arguments.length; t3 < n2; t3++)
        e2 += arguments[t3].length;
      var r2 = Array(e2), o2 = 0;
      for (t3 = 0; t3 < n2; t3++)
        for (var i2 = arguments[t3], u2 = 0, s2 = i2.length; u2 < s2; u2++, o2++)
          r2[o2] = i2[u2];
      return r2;
    }, __await: Sp, __asyncGenerator: function(e2, t3, n2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var r2, o2 = n2.apply(e2, t3 || []), i2 = [];
      return r2 = {}, u2("next"), u2("throw"), u2("return"), r2[Symbol.asyncIterator] = function() {
        return this;
      }, r2;
      function u2(e3) {
        o2[e3] && (r2[e3] = function(t4) {
          return new Promise(function(n3, r3) {
            i2.push([e3, t4, n3, r3]) > 1 || s2(e3, t4);
          });
        });
      }
      function s2(e3, t4) {
        try {
          (n3 = o2[e3](t4)).value instanceof Sp ? Promise.resolve(n3.value.v).then(a2, c2) : l2(i2[0][2], n3);
        } catch (e4) {
          l2(i2[0][3], e4);
        }
        var n3;
      }
      function a2(e3) {
        s2("next", e3);
      }
      function c2(e3) {
        s2("throw", e3);
      }
      function l2(e3, t4) {
        e3(t4), i2.shift(), i2.length && s2(i2[0][0], i2[0][1]);
      }
    }, __asyncDelegator: function(e2) {
      var t3, n2;
      return t3 = {}, r2("next"), r2("throw", function(e3) {
        throw e3;
      }), r2("return"), t3[Symbol.iterator] = function() {
        return this;
      }, t3;
      function r2(r3, o2) {
        t3[r3] = e2[r3] ? function(t4) {
          return (n2 = !n2) ? { value: Sp(e2[r3](t4)), done: r3 === "return" } : o2 ? o2(t4) : t4;
        } : o2;
      }
    }, __asyncValues: function(e2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var t3, n2 = e2[Symbol.asyncIterator];
      return n2 ? n2.call(e2) : (e2 = Fp(e2), t3 = {}, r2("next"), r2("throw"), r2("return"), t3[Symbol.asyncIterator] = function() {
        return this;
      }, t3);
      function r2(n3) {
        t3[n3] = e2[n3] && function(t4) {
          return new Promise(function(r3, o2) {
            (function(e3, t5, n4, r4) {
              Promise.resolve(r4).then(function(t6) {
                e3({ value: t6, done: n4 });
              }, t5);
            })(r3, o2, (t4 = e2[n3](t4)).done, t4.value);
          });
        };
      }
    }, __makeTemplateObject: function(e2, t3) {
      return Object.defineProperty ? Object.defineProperty(e2, "raw", { value: t3 }) : e2.raw = t3, e2;
    }, __importStar: function(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var t3 = {};
      if (e2 != null)
        for (var n2 in e2)
          Object.hasOwnProperty.call(e2, n2) && (t3[n2] = e2[n2]);
      return t3.default = e2, t3;
    }, __importDefault: function(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }, __classPrivateFieldGet: function(e2, t3) {
      if (!t3.has(e2))
        throw new TypeError("attempted to get private field on non-instance");
      return t3.get(e2);
    }, __classPrivateFieldSet: function(e2, t3, n2) {
      if (!t3.has(e2))
        throw new TypeError("attempted to set private field on non-instance");
      return t3.set(e2, n2), n2;
    } }), Tp = {}, Bp = {};
    !function(e2) {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.apiDescriptor = { key: (e3) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e3) ? e3 : JSON.stringify(e3), value(t3) {
        if (t3 === null || typeof t3 != "object")
          return JSON.stringify(t3);
        if (Array.isArray(t3))
          return "[".concat(t3.map((t4) => e2.apiDescriptor.value(t4)).join(", "), "]");
        const n2 = Object.keys(t3);
        return n2.length === 0 ? "{}" : "{ ".concat(n2.map((n3) => "".concat(e2.apiDescriptor.key(n3), ": ").concat(e2.apiDescriptor.value(t3[n3]))).join(", "), " }");
      }, pair: (t3) => {
        let { key: n2, value: r2 } = t3;
        return e2.apiDescriptor.value({ [n2]: r2 });
      } };
    }(Bp), function(e2) {
      Object.defineProperty(e2, "__esModule", { value: true });
      wp2.__exportStar(Bp, e2);
    }(Tp);
    var Np = {}, kp = {}, Pp = {}, Op = { exports: {} }, Ip = /[|\\{}()[\]^$+*?.]/g, Lp = function(e2) {
      if (typeof e2 != "string")
        throw new TypeError("Expected a string");
      return e2.replace(Ip, "\\$&");
    }, jp = { exports: {} }, _p = { exports: {} }, Mp = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Rp = {};
    for (var Vp in Mp)
      Mp.hasOwnProperty(Vp) && (Rp[Mp[Vp]] = Vp);
    var $p = _p.exports = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
    for (var Wp in $p)
      if ($p.hasOwnProperty(Wp)) {
        if (!("channels" in $p[Wp]))
          throw new Error("missing channels property: " + Wp);
        if (!("labels" in $p[Wp]))
          throw new Error("missing channel labels property: " + Wp);
        if ($p[Wp].labels.length !== $p[Wp].channels)
          throw new Error("channel and label counts mismatch: " + Wp);
        var qp = $p[Wp].channels, Up = $p[Wp].labels;
        delete $p[Wp].channels, delete $p[Wp].labels, Object.defineProperty($p[Wp], "channels", { value: qp }), Object.defineProperty($p[Wp], "labels", { value: Up });
      }
    $p.rgb.hsl = function(e2) {
      var t3, n2, r2 = e2[0] / 255, o2 = e2[1] / 255, i2 = e2[2] / 255, u2 = Math.min(r2, o2, i2), s2 = Math.max(r2, o2, i2), a2 = s2 - u2;
      return s2 === u2 ? t3 = 0 : r2 === s2 ? t3 = (o2 - i2) / a2 : o2 === s2 ? t3 = 2 + (i2 - r2) / a2 : i2 === s2 && (t3 = 4 + (r2 - o2) / a2), (t3 = Math.min(60 * t3, 360)) < 0 && (t3 += 360), n2 = (u2 + s2) / 2, [t3, 100 * (s2 === u2 ? 0 : n2 <= 0.5 ? a2 / (s2 + u2) : a2 / (2 - s2 - u2)), 100 * n2];
    }, $p.rgb.hsv = function(e2) {
      var t3, n2, r2, o2, i2, u2 = e2[0] / 255, s2 = e2[1] / 255, a2 = e2[2] / 255, c2 = Math.max(u2, s2, a2), l2 = c2 - Math.min(u2, s2, a2), p2 = function(e3) {
        return (c2 - e3) / 6 / l2 + 0.5;
      };
      return l2 === 0 ? o2 = i2 = 0 : (i2 = l2 / c2, t3 = p2(u2), n2 = p2(s2), r2 = p2(a2), u2 === c2 ? o2 = r2 - n2 : s2 === c2 ? o2 = 1 / 3 + t3 - r2 : a2 === c2 && (o2 = 2 / 3 + n2 - t3), o2 < 0 ? o2 += 1 : o2 > 1 && (o2 -= 1)), [360 * o2, 100 * i2, 100 * c2];
    }, $p.rgb.hwb = function(e2) {
      var t3 = e2[0], n2 = e2[1], r2 = e2[2];
      return [$p.rgb.hsl(e2)[0], 100 * (1 / 255 * Math.min(t3, Math.min(n2, r2))), 100 * (r2 = 1 - 1 / 255 * Math.max(t3, Math.max(n2, r2)))];
    }, $p.rgb.cmyk = function(e2) {
      var t3, n2 = e2[0] / 255, r2 = e2[1] / 255, o2 = e2[2] / 255;
      return [100 * ((1 - n2 - (t3 = Math.min(1 - n2, 1 - r2, 1 - o2))) / (1 - t3) || 0), 100 * ((1 - r2 - t3) / (1 - t3) || 0), 100 * ((1 - o2 - t3) / (1 - t3) || 0), 100 * t3];
    }, $p.rgb.keyword = function(e2) {
      var t3 = Rp[e2];
      if (t3)
        return t3;
      var n2, r2, o2, i2 = 1 / 0;
      for (var u2 in Mp)
        if (Mp.hasOwnProperty(u2)) {
          var s2 = Mp[u2], a2 = (r2 = e2, o2 = s2, Math.pow(r2[0] - o2[0], 2) + Math.pow(r2[1] - o2[1], 2) + Math.pow(r2[2] - o2[2], 2));
          a2 < i2 && (i2 = a2, n2 = u2);
        }
      return n2;
    }, $p.keyword.rgb = function(e2) {
      return Mp[e2];
    }, $p.rgb.xyz = function(e2) {
      var t3 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255;
      return [100 * (0.4124 * (t3 = t3 > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92) + 0.3576 * (n2 = n2 > 0.04045 ? Math.pow((n2 + 0.055) / 1.055, 2.4) : n2 / 12.92) + 0.1805 * (r2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92)), 100 * (0.2126 * t3 + 0.7152 * n2 + 0.0722 * r2), 100 * (0.0193 * t3 + 0.1192 * n2 + 0.9505 * r2)];
    }, $p.rgb.lab = function(e2) {
      var t3 = $p.rgb.xyz(e2), n2 = t3[0], r2 = t3[1], o2 = t3[2];
      return r2 /= 100, o2 /= 108.883, n2 = (n2 /= 95.047) > 8856e-6 ? Math.pow(n2, 1 / 3) : 7.787 * n2 + 16 / 116, [116 * (r2 = r2 > 8856e-6 ? Math.pow(r2, 1 / 3) : 7.787 * r2 + 16 / 116) - 16, 500 * (n2 - r2), 200 * (r2 - (o2 = o2 > 8856e-6 ? Math.pow(o2, 1 / 3) : 7.787 * o2 + 16 / 116))];
    }, $p.hsl.rgb = function(e2) {
      var t3, n2, r2, o2, i2, u2 = e2[0] / 360, s2 = e2[1] / 100, a2 = e2[2] / 100;
      if (s2 === 0)
        return [i2 = 255 * a2, i2, i2];
      t3 = 2 * a2 - (n2 = a2 < 0.5 ? a2 * (1 + s2) : a2 + s2 - a2 * s2), o2 = [0, 0, 0];
      for (var c2 = 0; c2 < 3; c2++)
        (r2 = u2 + 1 / 3 * -(c2 - 1)) < 0 && r2++, r2 > 1 && r2--, i2 = 6 * r2 < 1 ? t3 + 6 * (n2 - t3) * r2 : 2 * r2 < 1 ? n2 : 3 * r2 < 2 ? t3 + (n2 - t3) * (2 / 3 - r2) * 6 : t3, o2[c2] = 255 * i2;
      return o2;
    }, $p.hsl.hsv = function(e2) {
      var t3 = e2[0], n2 = e2[1] / 100, r2 = e2[2] / 100, o2 = n2, i2 = Math.max(r2, 0.01);
      return n2 *= (r2 *= 2) <= 1 ? r2 : 2 - r2, o2 *= i2 <= 1 ? i2 : 2 - i2, [t3, 100 * (r2 === 0 ? 2 * o2 / (i2 + o2) : 2 * n2 / (r2 + n2)), 100 * ((r2 + n2) / 2)];
    }, $p.hsv.rgb = function(e2) {
      var t3 = e2[0] / 60, n2 = e2[1] / 100, r2 = e2[2] / 100, o2 = Math.floor(t3) % 6, i2 = t3 - Math.floor(t3), u2 = 255 * r2 * (1 - n2), s2 = 255 * r2 * (1 - n2 * i2), a2 = 255 * r2 * (1 - n2 * (1 - i2));
      switch (r2 *= 255, o2) {
        case 0:
          return [r2, a2, u2];
        case 1:
          return [s2, r2, u2];
        case 2:
          return [u2, r2, a2];
        case 3:
          return [u2, s2, r2];
        case 4:
          return [a2, u2, r2];
        case 5:
          return [r2, u2, s2];
      }
    }, $p.hsv.hsl = function(e2) {
      var t3, n2, r2, o2 = e2[0], i2 = e2[1] / 100, u2 = e2[2] / 100, s2 = Math.max(u2, 0.01);
      return r2 = (2 - i2) * u2, n2 = i2 * s2, [o2, 100 * (n2 = (n2 /= (t3 = (2 - i2) * s2) <= 1 ? t3 : 2 - t3) || 0), 100 * (r2 /= 2)];
    }, $p.hwb.rgb = function(e2) {
      var t3, n2, r2, o2, i2, u2, s2, a2 = e2[0] / 360, c2 = e2[1] / 100, l2 = e2[2] / 100, p2 = c2 + l2;
      switch (p2 > 1 && (c2 /= p2, l2 /= p2), r2 = 6 * a2 - (t3 = Math.floor(6 * a2)), (1 & t3) != 0 && (r2 = 1 - r2), o2 = c2 + r2 * ((n2 = 1 - l2) - c2), t3) {
        default:
        case 6:
        case 0:
          i2 = n2, u2 = o2, s2 = c2;
          break;
        case 1:
          i2 = o2, u2 = n2, s2 = c2;
          break;
        case 2:
          i2 = c2, u2 = n2, s2 = o2;
          break;
        case 3:
          i2 = c2, u2 = o2, s2 = n2;
          break;
        case 4:
          i2 = o2, u2 = c2, s2 = n2;
          break;
        case 5:
          i2 = n2, u2 = c2, s2 = o2;
      }
      return [255 * i2, 255 * u2, 255 * s2];
    }, $p.cmyk.rgb = function(e2) {
      var t3 = e2[0] / 100, n2 = e2[1] / 100, r2 = e2[2] / 100, o2 = e2[3] / 100;
      return [255 * (1 - Math.min(1, t3 * (1 - o2) + o2)), 255 * (1 - Math.min(1, n2 * (1 - o2) + o2)), 255 * (1 - Math.min(1, r2 * (1 - o2) + o2))];
    }, $p.xyz.rgb = function(e2) {
      var t3, n2, r2, o2 = e2[0] / 100, i2 = e2[1] / 100, u2 = e2[2] / 100;
      return n2 = -0.9689 * o2 + 1.8758 * i2 + 0.0415 * u2, r2 = 0.0557 * o2 + -0.204 * i2 + 1.057 * u2, t3 = (t3 = 3.2406 * o2 + -1.5372 * i2 + -0.4986 * u2) > 31308e-7 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3, n2 = n2 > 31308e-7 ? 1.055 * Math.pow(n2, 1 / 2.4) - 0.055 : 12.92 * n2, r2 = r2 > 31308e-7 ? 1.055 * Math.pow(r2, 1 / 2.4) - 0.055 : 12.92 * r2, [255 * (t3 = Math.min(Math.max(0, t3), 1)), 255 * (n2 = Math.min(Math.max(0, n2), 1)), 255 * (r2 = Math.min(Math.max(0, r2), 1))];
    }, $p.xyz.lab = function(e2) {
      var t3 = e2[0], n2 = e2[1], r2 = e2[2];
      return n2 /= 100, r2 /= 108.883, t3 = (t3 /= 95.047) > 8856e-6 ? Math.pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116, [116 * (n2 = n2 > 8856e-6 ? Math.pow(n2, 1 / 3) : 7.787 * n2 + 16 / 116) - 16, 500 * (t3 - n2), 200 * (n2 - (r2 = r2 > 8856e-6 ? Math.pow(r2, 1 / 3) : 7.787 * r2 + 16 / 116))];
    }, $p.lab.xyz = function(e2) {
      var t3, n2, r2, o2 = e2[0];
      t3 = e2[1] / 500 + (n2 = (o2 + 16) / 116), r2 = n2 - e2[2] / 200;
      var i2 = Math.pow(n2, 3), u2 = Math.pow(t3, 3), s2 = Math.pow(r2, 3);
      return n2 = i2 > 8856e-6 ? i2 : (n2 - 16 / 116) / 7.787, t3 = u2 > 8856e-6 ? u2 : (t3 - 16 / 116) / 7.787, r2 = s2 > 8856e-6 ? s2 : (r2 - 16 / 116) / 7.787, [t3 *= 95.047, n2 *= 100, r2 *= 108.883];
    }, $p.lab.lch = function(e2) {
      var t3, n2 = e2[0], r2 = e2[1], o2 = e2[2];
      return (t3 = 360 * Math.atan2(o2, r2) / 2 / Math.PI) < 0 && (t3 += 360), [n2, Math.sqrt(r2 * r2 + o2 * o2), t3];
    }, $p.lch.lab = function(e2) {
      var t3, n2 = e2[0], r2 = e2[1];
      return t3 = e2[2] / 360 * 2 * Math.PI, [n2, r2 * Math.cos(t3), r2 * Math.sin(t3)];
    }, $p.rgb.ansi16 = function(e2) {
      var t3 = e2[0], n2 = e2[1], r2 = e2[2], o2 = 1 in arguments ? arguments[1] : $p.rgb.hsv(e2)[2];
      if ((o2 = Math.round(o2 / 50)) === 0)
        return 30;
      var i2 = 30 + (Math.round(r2 / 255) << 2 | Math.round(n2 / 255) << 1 | Math.round(t3 / 255));
      return o2 === 2 && (i2 += 60), i2;
    }, $p.hsv.ansi16 = function(e2) {
      return $p.rgb.ansi16($p.hsv.rgb(e2), e2[2]);
    }, $p.rgb.ansi256 = function(e2) {
      var t3 = e2[0], n2 = e2[1], r2 = e2[2];
      return t3 === n2 && n2 === r2 ? t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n2 / 255 * 5) + Math.round(r2 / 255 * 5);
    }, $p.ansi16.rgb = function(e2) {
      var t3 = e2 % 10;
      if (t3 === 0 || t3 === 7)
        return e2 > 50 && (t3 += 3.5), [t3 = t3 / 10.5 * 255, t3, t3];
      var n2 = 0.5 * (1 + ~~(e2 > 50));
      return [(1 & t3) * n2 * 255, (t3 >> 1 & 1) * n2 * 255, (t3 >> 2 & 1) * n2 * 255];
    }, $p.ansi256.rgb = function(e2) {
      if (e2 >= 232) {
        var t3 = 10 * (e2 - 232) + 8;
        return [t3, t3, t3];
      }
      var n2;
      return e2 -= 16, [Math.floor(e2 / 36) / 5 * 255, Math.floor((n2 = e2 % 36) / 6) / 5 * 255, n2 % 6 / 5 * 255];
    }, $p.rgb.hex = function(e2) {
      var t3 = (((255 & Math.round(e2[0])) << 16) + ((255 & Math.round(e2[1])) << 8) + (255 & Math.round(e2[2]))).toString(16).toUpperCase();
      return "000000".substring(t3.length) + t3;
    }, $p.hex.rgb = function(e2) {
      var t3 = e2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!t3)
        return [0, 0, 0];
      var n2 = t3[0];
      t3[0].length === 3 && (n2 = n2.split("").map(function(e3) {
        return e3 + e3;
      }).join(""));
      var r2 = parseInt(n2, 16);
      return [r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2];
    }, $p.rgb.hcg = function(e2) {
      var t3, n2 = e2[0] / 255, r2 = e2[1] / 255, o2 = e2[2] / 255, i2 = Math.max(Math.max(n2, r2), o2), u2 = Math.min(Math.min(n2, r2), o2), s2 = i2 - u2;
      return t3 = s2 <= 0 ? 0 : i2 === n2 ? (r2 - o2) / s2 % 6 : i2 === r2 ? 2 + (o2 - n2) / s2 : 4 + (n2 - r2) / s2 + 4, t3 /= 6, [360 * (t3 %= 1), 100 * s2, 100 * (s2 < 1 ? u2 / (1 - s2) : 0)];
    }, $p.hsl.hcg = function(e2) {
      var t3 = e2[1] / 100, n2 = e2[2] / 100, r2 = 1, o2 = 0;
      return (r2 = n2 < 0.5 ? 2 * t3 * n2 : 2 * t3 * (1 - n2)) < 1 && (o2 = (n2 - 0.5 * r2) / (1 - r2)), [e2[0], 100 * r2, 100 * o2];
    }, $p.hsv.hcg = function(e2) {
      var t3 = e2[1] / 100, n2 = e2[2] / 100, r2 = t3 * n2, o2 = 0;
      return r2 < 1 && (o2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * o2];
    }, $p.hcg.rgb = function(e2) {
      var t3 = e2[0] / 360, n2 = e2[1] / 100, r2 = e2[2] / 100;
      if (n2 === 0)
        return [255 * r2, 255 * r2, 255 * r2];
      var o2, i2 = [0, 0, 0], u2 = t3 % 1 * 6, s2 = u2 % 1, a2 = 1 - s2;
      switch (Math.floor(u2)) {
        case 0:
          i2[0] = 1, i2[1] = s2, i2[2] = 0;
          break;
        case 1:
          i2[0] = a2, i2[1] = 1, i2[2] = 0;
          break;
        case 2:
          i2[0] = 0, i2[1] = 1, i2[2] = s2;
          break;
        case 3:
          i2[0] = 0, i2[1] = a2, i2[2] = 1;
          break;
        case 4:
          i2[0] = s2, i2[1] = 0, i2[2] = 1;
          break;
        default:
          i2[0] = 1, i2[1] = 0, i2[2] = a2;
      }
      return o2 = (1 - n2) * r2, [255 * (n2 * i2[0] + o2), 255 * (n2 * i2[1] + o2), 255 * (n2 * i2[2] + o2)];
    }, $p.hcg.hsv = function(e2) {
      var t3 = e2[1] / 100, n2 = t3 + e2[2] / 100 * (1 - t3), r2 = 0;
      return n2 > 0 && (r2 = t3 / n2), [e2[0], 100 * r2, 100 * n2];
    }, $p.hcg.hsl = function(e2) {
      var t3 = e2[1] / 100, n2 = e2[2] / 100 * (1 - t3) + 0.5 * t3, r2 = 0;
      return n2 > 0 && n2 < 0.5 ? r2 = t3 / (2 * n2) : n2 >= 0.5 && n2 < 1 && (r2 = t3 / (2 * (1 - n2))), [e2[0], 100 * r2, 100 * n2];
    }, $p.hcg.hwb = function(e2) {
      var t3 = e2[1] / 100, n2 = t3 + e2[2] / 100 * (1 - t3);
      return [e2[0], 100 * (n2 - t3), 100 * (1 - n2)];
    }, $p.hwb.hcg = function(e2) {
      var t3 = e2[1] / 100, n2 = 1 - e2[2] / 100, r2 = n2 - t3, o2 = 0;
      return r2 < 1 && (o2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * o2];
    }, $p.apple.rgb = function(e2) {
      return [e2[0] / 65535 * 255, e2[1] / 65535 * 255, e2[2] / 65535 * 255];
    }, $p.rgb.apple = function(e2) {
      return [e2[0] / 255 * 65535, e2[1] / 255 * 65535, e2[2] / 255 * 65535];
    }, $p.gray.rgb = function(e2) {
      return [e2[0] / 100 * 255, e2[0] / 100 * 255, e2[0] / 100 * 255];
    }, $p.gray.hsl = $p.gray.hsv = function(e2) {
      return [0, 0, e2[0]];
    }, $p.gray.hwb = function(e2) {
      return [0, 100, e2[0]];
    }, $p.gray.cmyk = function(e2) {
      return [0, 0, 0, e2[0]];
    }, $p.gray.lab = function(e2) {
      return [e2[0], 0, 0];
    }, $p.gray.hex = function(e2) {
      var t3 = 255 & Math.round(e2[0] / 100 * 255), n2 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
      return "000000".substring(n2.length) + n2;
    }, $p.rgb.gray = function(e2) {
      return [(e2[0] + e2[1] + e2[2]) / 3 / 255 * 100];
    };
    var zp = _p.exports;
    function Gp(e2) {
      var t3 = function() {
        for (var e3 = {}, t4 = Object.keys(zp), n3 = t4.length, r3 = 0; r3 < n3; r3++)
          e3[t4[r3]] = { distance: -1, parent: null };
        return e3;
      }(), n2 = [e2];
      for (t3[e2].distance = 0; n2.length; )
        for (var r2 = n2.pop(), o2 = Object.keys(zp[r2]), i2 = o2.length, u2 = 0; u2 < i2; u2++) {
          var s2 = o2[u2], a2 = t3[s2];
          a2.distance === -1 && (a2.distance = t3[r2].distance + 1, a2.parent = r2, n2.unshift(s2));
        }
      return t3;
    }
    function Hp(e2, t3) {
      return function(n2) {
        return t3(e2(n2));
      };
    }
    function Jp(e2, t3) {
      for (var n2 = [t3[e2].parent, e2], r2 = zp[t3[e2].parent][e2], o2 = t3[e2].parent; t3[o2].parent; )
        n2.unshift(t3[o2].parent), r2 = Hp(zp[t3[o2].parent][o2], r2), o2 = t3[o2].parent;
      return r2.conversion = n2, r2;
    }
    var Xp = _p.exports, Yp = function(e2) {
      for (var t3 = Gp(e2), n2 = {}, r2 = Object.keys(t3), o2 = r2.length, i2 = 0; i2 < o2; i2++) {
        var u2 = r2[i2];
        t3[u2].parent !== null && (n2[u2] = Jp(u2, t3));
      }
      return n2;
    }, Kp = {};
    Object.keys(Xp).forEach(function(e2) {
      Kp[e2] = {}, Object.defineProperty(Kp[e2], "channels", { value: Xp[e2].channels }), Object.defineProperty(Kp[e2], "labels", { value: Xp[e2].labels });
      var t3 = Yp(e2);
      Object.keys(t3).forEach(function(n2) {
        var r2 = t3[n2];
        Kp[e2][n2] = function(e3) {
          var t4 = function(t5) {
            if (t5 == null)
              return t5;
            arguments.length > 1 && (t5 = Array.prototype.slice.call(arguments));
            var n3 = e3(t5);
            if (typeof n3 == "object")
              for (var r3 = n3.length, o2 = 0; o2 < r3; o2++)
                n3[o2] = Math.round(n3[o2]);
            return n3;
          };
          return "conversion" in e3 && (t4.conversion = e3.conversion), t4;
        }(r2), Kp[e2][n2].raw = function(e3) {
          var t4 = function(t5) {
            return t5 == null ? t5 : (arguments.length > 1 && (t5 = Array.prototype.slice.call(arguments)), e3(t5));
          };
          return "conversion" in e3 && (t4.conversion = e3.conversion), t4;
        }(r2);
      });
    });
    var Qp, Zp = Kp;
    function ef() {
      if (Qp === void 0) {
        var e2 = new ArrayBuffer(2), t3 = new Uint8Array(e2), n2 = new Uint16Array(e2);
        if (t3[0] = 1, t3[1] = 2, n2[0] === 258)
          Qp = "BE";
        else {
          if (n2[0] !== 513)
            throw new Error("unable to figure out endianess");
          Qp = "LE";
        }
      }
      return Qp;
    }
    function tf() {
      return Ns.location !== void 0 ? Ns.location.hostname : "";
    }
    function nf() {
      return [];
    }
    function rf() {
      return 0;
    }
    function of() {
      return Number.MAX_VALUE;
    }
    function uf() {
      return Number.MAX_VALUE;
    }
    function sf() {
      return [];
    }
    function af2() {
      return "Browser";
    }
    function cf() {
      return Ns.navigator !== void 0 ? Ns.navigator.appVersion : "";
    }
    function lf() {
    }
    function pf() {
    }
    function ff() {
      return "javascript";
    }
    function df() {
      return "browser";
    }
    function hf() {
      return "/tmp";
    }
    !function(e2) {
      const t3 = Zp, n2 = (e3, n3) => function() {
        const r3 = e3.apply(t3, arguments);
        return "\x1B[".concat(r3 + n3, "m");
      }, r2 = (e3, n3) => function() {
        const r3 = e3.apply(t3, arguments);
        return "\x1B[".concat(38 + n3, ";5;").concat(r3, "m");
      }, o2 = (e3, n3) => function() {
        const r3 = e3.apply(t3, arguments);
        return "\x1B[".concat(38 + n3, ";2;").concat(r3[0], ";").concat(r3[1], ";").concat(r3[2], "m");
      };
      Object.defineProperty(e2, "exports", { enumerable: true, get: function() {
        const e3 = /* @__PURE__ */ new Map(), i2 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
        i2.color.grey = i2.color.gray;
        for (const t4 of Object.keys(i2)) {
          const n3 = i2[t4];
          for (const t5 of Object.keys(n3)) {
            const r3 = n3[t5];
            i2[t5] = { open: "\x1B[".concat(r3[0], "m"), close: "\x1B[".concat(r3[1], "m") }, n3[t5] = i2[t5], e3.set(r3[0], r3[1]);
          }
          Object.defineProperty(i2, t4, { value: n3, enumerable: false }), Object.defineProperty(i2, "codes", { value: e3, enumerable: false });
        }
        const u2 = (e4) => e4, s2 = (e4, t4, n3) => [e4, t4, n3];
        i2.color.close = "\x1B[39m", i2.bgColor.close = "\x1B[49m", i2.color.ansi = { ansi: n2(u2, 0) }, i2.color.ansi256 = { ansi256: r2(u2, 0) }, i2.color.ansi16m = { rgb: o2(s2, 0) }, i2.bgColor.ansi = { ansi: n2(u2, 10) }, i2.bgColor.ansi256 = { ansi256: r2(u2, 10) }, i2.bgColor.ansi16m = { rgb: o2(s2, 10) };
        for (let e4 of Object.keys(t3)) {
          if (typeof t3[e4] != "object")
            continue;
          const u3 = t3[e4];
          e4 === "ansi16" && (e4 = "ansi"), "ansi16" in u3 && (i2.color.ansi[e4] = n2(u3.ansi16, 0), i2.bgColor.ansi[e4] = n2(u3.ansi16, 10)), "ansi256" in u3 && (i2.color.ansi256[e4] = r2(u3.ansi256, 0), i2.bgColor.ansi256[e4] = r2(u3.ansi256, 10)), "rgb" in u3 && (i2.color.ansi16m[e4] = o2(u3.rgb, 0), i2.bgColor.ansi16m[e4] = o2(u3.rgb, 10));
        }
        return i2;
      } });
    }(jp);
    var gf = hf, mf = { EOL: "\n", arch: ff, platform: df, tmpdir: gf, tmpDir: hf, networkInterfaces: lf, getNetworkInterfaces: pf, release: cf, type: af2, cpus: sf, totalmem: uf, freemem: of, uptime: rf, loadavg: nf, hostname: tf, endianness: ef }, yf = t2(Object.freeze({ __proto__: null, endianness: ef, hostname: tf, loadavg: nf, uptime: rf, freemem: of, totalmem: uf, cpus: sf, type: af2, release: cf, networkInterfaces: lf, getNetworkInterfaces: pf, arch: ff, platform: df, tmpDir: hf, tmpdir: gf, EOL: "\n", default: mf }));
    const Ef = (e2, t3) => {
      t3 = t3 || ta.argv;
      const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t3.indexOf(n2 + e2), o2 = t3.indexOf("--");
      return r2 !== -1 && (o2 === -1 || r2 < o2);
    }, Cf = ta.env;
    let bf;
    function vf(e2) {
      const t3 = function(e3) {
        if (bf === false)
          return 0;
        if (Ef("color=16m") || Ef("color=full") || Ef("color=truecolor"))
          return 3;
        if (Ef("color=256"))
          return 2;
        if (e3 && !e3.isTTY && bf !== true)
          return 0;
        const t4 = bf ? 1 : 0;
        if ("CI" in Cf)
          return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e4) => e4 in Cf) || Cf.CI_NAME === "codeship" ? 1 : t4;
        if ("TEAMCITY_VERSION" in Cf)
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Cf.TEAMCITY_VERSION) ? 1 : 0;
        if (Cf.COLORTERM === "truecolor")
          return 3;
        if ("TERM_PROGRAM" in Cf) {
          const e4 = parseInt((Cf.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (Cf.TERM_PROGRAM) {
            case "iTerm.app":
              return e4 >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(Cf.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Cf.TERM) || "COLORTERM" in Cf ? 1 : (Cf.TERM, t4);
      }(e2);
      return function(e3) {
        return e3 !== 0 && { level: e3, hasBasic: true, has256: e3 >= 2, has16m: e3 >= 3 };
      }(t3);
    }
    Ef("no-color") || Ef("no-colors") || Ef("color=false") ? bf = false : (Ef("color") || Ef("colors") || Ef("color=true") || Ef("color=always")) && (bf = true), "FORCE_COLOR" in Cf && (bf = Cf.FORCE_COLOR.length === 0 || parseInt(Cf.FORCE_COLOR, 10) !== 0);
    var Af = { supportsColor: vf, stdout: vf(ta.stdout), stderr: vf(ta.stderr) };
    const Ff = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, xf = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Sf = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, wf = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Tf = /* @__PURE__ */ new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", "\x1B"], ["a", "\x07"]]);
    function Bf(e2) {
      return e2[0] === "u" && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : Tf.get(e2) || e2;
    }
    function Nf(e2, t3) {
      const n2 = [], r2 = t3.trim().split(/\s*,\s*/g);
      let o2;
      for (const t4 of r2)
        if (isNaN(t4)) {
          if (!(o2 = t4.match(Sf)))
            throw new Error("Invalid Chalk template style argument: ".concat(t4, " (in style '").concat(e2, "')"));
          n2.push(o2[2].replace(wf, (e3, t5, n3) => t5 ? Bf(t5) : n3));
        } else
          n2.push(Number(t4));
      return n2;
    }
    function kf(e2) {
      xf.lastIndex = 0;
      const t3 = [];
      let n2;
      for (; (n2 = xf.exec(e2)) !== null; ) {
        const e3 = n2[1];
        if (n2[2]) {
          const r2 = Nf(e3, n2[2]);
          t3.push([e3].concat(r2));
        } else
          t3.push([e3]);
      }
      return t3;
    }
    function Pf(e2, t3) {
      const n2 = {};
      for (const e3 of t3)
        for (const t4 of e3.styles)
          n2[t4[0]] = e3.inverse ? null : t4.slice(1);
      let r2 = e2;
      for (const e3 of Object.keys(n2))
        if (Array.isArray(n2[e3])) {
          if (!(e3 in r2))
            throw new Error("Unknown Chalk style: ".concat(e3));
          r2 = n2[e3].length > 0 ? r2[e3].apply(r2, n2[e3]) : r2[e3];
        }
      return r2;
    }
    var Of = (e2, t3) => {
      const n2 = [], r2 = [];
      let o2 = [];
      if (t3.replace(Ff, (t4, i2, u2, s2, a2, c2) => {
        if (i2)
          o2.push(Bf(i2));
        else if (s2) {
          const t5 = o2.join("");
          o2 = [], r2.push(n2.length === 0 ? t5 : Pf(e2, n2)(t5)), n2.push({ inverse: u2, styles: kf(s2) });
        } else if (a2) {
          if (n2.length === 0)
            throw new Error("Found extraneous } in Chalk template literal");
          r2.push(Pf(e2, n2)(o2.join(""))), o2 = [], n2.pop();
        } else
          o2.push(c2);
      }), r2.push(o2.join("")), n2.length > 0) {
        const e3 = "Chalk template literal is missing ".concat(n2.length, " closing bracket").concat(n2.length === 1 ? "" : "s", " (`}`)");
        throw new Error(e3);
      }
      return r2.join("");
    };
    !function(e2) {
      const t3 = Lp, n2 = jp.exports, r2 = Af.stdout, o2 = Of, u2 = ["ansi", "ansi", "ansi256", "ansi16m"], s2 = /* @__PURE__ */ new Set(["gray"]), a2 = /* @__PURE__ */ Object.create(null);
      function c2(e3, t4) {
        t4 = t4 || {};
        const n3 = r2 ? r2.level : 0;
        e3.level = t4.level === void 0 ? n3 : t4.level, e3.enabled = "enabled" in t4 ? t4.enabled : e3.level > 0;
      }
      function l2(e3) {
        if (!this || !(this instanceof l2) || this.template) {
          const t4 = {};
          return c2(t4, e3), t4.template = function() {
            const e4 = [].slice.call(arguments);
            return h2.apply(null, [t4.template].concat(e4));
          }, Object.setPrototypeOf(t4, l2.prototype), Object.setPrototypeOf(t4.template, t4), t4.template.constructor = l2, t4.template;
        }
        c2(this, e3);
      }
      for (const e3 of Object.keys(n2))
        n2[e3].closeRe = new RegExp(t3(n2[e3].close), "g"), a2[e3] = { get() {
          const t4 = n2[e3];
          return f2.call(this, this._styles ? this._styles.concat(t4) : [t4], this._empty, e3);
        } };
      a2.visible = { get() {
        return f2.call(this, this._styles || [], true, "visible");
      } }, n2.color.closeRe = new RegExp(t3(n2.color.close), "g");
      for (const e3 of Object.keys(n2.color.ansi))
        s2.has(e3) || (a2[e3] = { get() {
          const t4 = this.level;
          return function() {
            const r3 = n2.color[u2[t4]][e3].apply(null, arguments), o3 = { open: r3, close: n2.color.close, closeRe: n2.color.closeRe };
            return f2.call(this, this._styles ? this._styles.concat(o3) : [o3], this._empty, e3);
          };
        } });
      n2.bgColor.closeRe = new RegExp(t3(n2.bgColor.close), "g");
      for (const e3 of Object.keys(n2.bgColor.ansi)) {
        if (s2.has(e3))
          continue;
        a2["bg" + e3[0].toUpperCase() + e3.slice(1)] = { get() {
          const t4 = this.level;
          return function() {
            const r3 = n2.bgColor[u2[t4]][e3].apply(null, arguments), o3 = { open: r3, close: n2.bgColor.close, closeRe: n2.bgColor.closeRe };
            return f2.call(this, this._styles ? this._styles.concat(o3) : [o3], this._empty, e3);
          };
        } };
      }
      const p2 = Object.defineProperties(() => {
      }, a2);
      function f2(e3, t4, n3) {
        const r3 = function() {
          return d2.apply(r3, arguments);
        };
        r3._styles = e3, r3._empty = t4;
        const o3 = this;
        return Object.defineProperty(r3, "level", { enumerable: true, get: () => o3.level, set(e4) {
          o3.level = e4;
        } }), Object.defineProperty(r3, "enabled", { enumerable: true, get: () => o3.enabled, set(e4) {
          o3.enabled = e4;
        } }), r3.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r3.__proto__ = p2, r3;
      }
      function d2() {
        const e3 = arguments, t4 = e3.length;
        let r3 = String(arguments[0]);
        if (t4 === 0)
          return "";
        if (t4 > 1)
          for (let n3 = 1; n3 < t4; n3++)
            r3 += " " + e3[n3];
        if (!this.enabled || this.level <= 0 || !r3)
          return this._empty ? "" : r3;
        const o3 = n2.dim.open;
        for (const e4 of this._styles.slice().reverse())
          r3 = e4.open + r3.replace(e4.closeRe, e4.open) + e4.close, r3 = r3.replace(/\r?\n/g, "".concat(e4.close, "$&").concat(e4.open));
        return n2.dim.open = o3, r3;
      }
      function h2(e3, t4) {
        if (!Array.isArray(t4))
          return [].slice.call(arguments, 1).join(" ");
        const n3 = [].slice.call(arguments, 2), r3 = [t4.raw[0]];
        for (let e4 = 1; e4 < t4.length; e4++)
          r3.push(String(n3[e4 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t4.raw[e4]));
        return o2(e3, r3.join(""));
      }
      Object.defineProperties(l2.prototype, a2), e2.exports = l2(), e2.exports.supportsColor = r2, e2.exports.default = e2.exports;
    }(Op), Object.defineProperty(Pp, "__esModule", { value: true });
    const If = Op.exports;
    Pp.commonDeprecatedHandler = (e2, t3, n2) => {
      let { descriptor: r2 } = n2;
      const o2 = ["".concat(If.default.yellow(typeof e2 == "string" ? r2.key(e2) : r2.pair(e2)), " is deprecated")];
      return t3 && o2.push("we now treat it as ".concat(If.default.blue(typeof t3 == "string" ? r2.key(t3) : r2.pair(t3)))), o2.join("; ") + ".";
    }, function(e2) {
      Object.defineProperty(e2, "__esModule", { value: true });
      wp2.__exportStar(Pp, e2);
    }(kp);
    var Lf = {}, jf = {};
    Object.defineProperty(jf, "__esModule", { value: true });
    const _f = Op.exports;
    jf.commonInvalidHandler = (e2, t3, n2) => ["Invalid ".concat(_f.default.red(n2.descriptor.key(e2)), " value."), "Expected ".concat(_f.default.blue(n2.schemas[e2].expected(n2)), ","), "but received ".concat(_f.default.red(n2.descriptor.value(t3)), ".")].join(" "), function(e2) {
      Object.defineProperty(e2, "__esModule", { value: true });
      wp2.__exportStar(jf, e2);
    }(Lf);
    var Mf = {}, Rf = {}, Vf = [], $f = [];
    Object.defineProperty(Rf, "__esModule", { value: true });
    const Wf = Op.exports, qf = function(e2, t3) {
      if (e2 === t3)
        return 0;
      var n2 = e2;
      e2.length > t3.length && (e2 = t3, t3 = n2);
      var r2 = e2.length, o2 = t3.length;
      if (r2 === 0)
        return o2;
      if (o2 === 0)
        return r2;
      for (; r2 > 0 && e2.charCodeAt(~-r2) === t3.charCodeAt(~-o2); )
        r2--, o2--;
      if (r2 === 0)
        return o2;
      for (var i2, u2, s2, a2, c2 = 0; c2 < r2 && e2.charCodeAt(c2) === t3.charCodeAt(c2); )
        c2++;
      if (o2 -= c2, (r2 -= c2) === 0)
        return o2;
      for (var l2 = 0, p2 = 0; l2 < r2; )
        $f[c2 + l2] = e2.charCodeAt(c2 + l2), Vf[l2] = ++l2;
      for (; p2 < o2; )
        for (i2 = t3.charCodeAt(c2 + p2), s2 = p2++, u2 = p2, l2 = 0; l2 < r2; l2++)
          a2 = i2 === $f[c2 + l2] ? s2 : s2 + 1, s2 = Vf[l2], u2 = Vf[l2] = s2 > u2 ? a2 > u2 ? u2 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
      return u2;
    };
    Rf.levenUnknownHandler = (e2, t3, n2) => {
      let { descriptor: r2, logger: o2, schemas: i2 } = n2;
      const u2 = ["Ignored unknown option ".concat(Wf.default.yellow(r2.pair({ key: e2, value: t3 })), ".")], s2 = Object.keys(i2).sort().find((t4) => qf(e2, t4) < 3);
      s2 && u2.push("Did you mean ".concat(Wf.default.blue(r2.key(s2)), "?")), o2.warn(u2.join(" "));
    }, function(e2) {
      Object.defineProperty(e2, "__esModule", { value: true });
      wp2.__exportStar(Rf, e2);
    }(Mf), function(e2) {
      Object.defineProperty(e2, "__esModule", { value: true });
      const t3 = wp2;
      t3.__exportStar(kp, e2), t3.__exportStar(Lf, e2), t3.__exportStar(Mf, e2);
    }(Np);
    var Uf = {}, zf = {}, Gf = {};
    Object.defineProperty(Gf, "__esModule", { value: true });
    const Hf = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
    function Jf(e2, t3) {
      const n2 = new e2(t3), r2 = Object.create(n2);
      for (const e3 of Hf)
        e3 in t3 && (r2[e3] = Yf(t3[e3], n2, Xf.prototype[e3].length));
      return r2;
    }
    Gf.createSchema = Jf;
    class Xf {
      constructor(e2) {
        this.name = e2.name;
      }
      static create(e2) {
        return Jf(this, e2);
      }
      default(e2) {
      }
      expected(e2) {
        return "nothing";
      }
      validate(e2, t3) {
        return false;
      }
      deprecated(e2, t3) {
        return false;
      }
      forward(e2, t3) {
      }
      redirect(e2, t3) {
      }
      overlap(e2, t3, n2) {
        return e2;
      }
      preprocess(e2, t3) {
        return e2;
      }
      postprocess(e2, t3) {
        return e2;
      }
    }
    function Yf(e2, t3, n2) {
      return typeof e2 == "function" ? function() {
        for (var r2 = arguments.length, o2 = new Array(r2), i2 = 0; i2 < r2; i2++)
          o2[i2] = arguments[i2];
        return e2(...o2.slice(0, n2 - 1), t3, ...o2.slice(n2 - 1));
      } : () => e2;
    }
    Gf.Schema = Xf, Object.defineProperty(zf, "__esModule", { value: true });
    const Kf = Gf;
    class Qf extends Kf.Schema {
      constructor(e2) {
        super(e2), this._sourceName = e2.sourceName;
      }
      expected(e2) {
        return e2.schemas[this._sourceName].expected(e2);
      }
      validate(e2, t3) {
        return t3.schemas[this._sourceName].validate(e2, t3);
      }
      redirect(e2, t3) {
        return this._sourceName;
      }
    }
    zf.AliasSchema = Qf;
    var Zf = {};
    Object.defineProperty(Zf, "__esModule", { value: true });
    const ed = Gf;
    class td extends ed.Schema {
      expected() {
        return "anything";
      }
      validate() {
        return true;
      }
    }
    Zf.AnySchema = td;
    var nd = {};
    Object.defineProperty(nd, "__esModule", { value: true });
    const rd = wp2, od = Gf;
    class id2 extends od.Schema {
      constructor(e2) {
        var { valueSchema: t3, name: n2 = t3.name } = e2, r2 = rd.__rest(e2, ["valueSchema", "name"]);
        super(Object.assign({}, r2, { name: n2 })), this._valueSchema = t3;
      }
      expected(e2) {
        return "an array of ".concat(this._valueSchema.expected(e2));
      }
      validate(e2, t3) {
        if (!Array.isArray(e2))
          return false;
        const n2 = [];
        for (const r2 of e2) {
          const e3 = t3.normalizeValidateResult(this._valueSchema.validate(r2, t3), r2);
          e3 !== true && n2.push(e3.value);
        }
        return n2.length === 0 || { value: n2 };
      }
      deprecated(e2, t3) {
        const n2 = [];
        for (const r2 of e2) {
          const e3 = t3.normalizeDeprecatedResult(this._valueSchema.deprecated(r2, t3), r2);
          e3 !== false && n2.push(...e3.map((e4) => {
            let { value: t4 } = e4;
            return { value: [t4] };
          }));
        }
        return n2;
      }
      forward(e2, t3) {
        const n2 = [];
        for (const r2 of e2) {
          const e3 = t3.normalizeForwardResult(this._valueSchema.forward(r2, t3), r2);
          n2.push(...e3.map(ud));
        }
        return n2;
      }
      redirect(e2, t3) {
        const n2 = [], r2 = [];
        for (const o2 of e2) {
          const e3 = t3.normalizeRedirectResult(this._valueSchema.redirect(o2, t3), o2);
          "remain" in e3 && n2.push(e3.remain), r2.push(...e3.redirect.map(ud));
        }
        return n2.length === 0 ? { redirect: r2 } : { redirect: r2, remain: n2 };
      }
      overlap(e2, t3) {
        return e2.concat(t3);
      }
    }
    function ud(e2) {
      let { from: t3, to: n2 } = e2;
      return { from: [t3], to: n2 };
    }
    nd.ArraySchema = id2;
    var sd = {};
    Object.defineProperty(sd, "__esModule", { value: true });
    const ad = Gf;
    class cd extends ad.Schema {
      expected() {
        return "true or false";
      }
      validate(e2) {
        return typeof e2 == "boolean";
      }
    }
    sd.BooleanSchema = cd;
    var ld = {}, pd = {};
    function fd(e2, t3) {
      return typeof e2 == "string" || "key" in e2 ? { from: t3, to: e2 } : "from" in e2 ? { from: e2.from, to: e2.to } : { from: t3, to: e2.to };
    }
    function dd2(e2, t3) {
      return e2 === void 0 ? [] : Array.isArray(e2) ? e2.map((e3) => fd(e3, t3)) : [fd(e2, t3)];
    }
    Object.defineProperty(pd, "__esModule", { value: true }), pd.recordFromArray = function(e2, t3) {
      const n2 = /* @__PURE__ */ Object.create(null);
      for (const r2 of e2) {
        const e3 = r2[t3];
        if (n2[e3])
          throw new Error("Duplicate ".concat(t3, " ").concat(JSON.stringify(e3)));
        n2[e3] = r2;
      }
      return n2;
    }, pd.mapFromArray = function(e2, t3) {
      const n2 = /* @__PURE__ */ new Map();
      for (const r2 of e2) {
        const e3 = r2[t3];
        if (n2.has(e3))
          throw new Error("Duplicate ".concat(t3, " ").concat(JSON.stringify(e3)));
        n2.set(e3, r2);
      }
      return n2;
    }, pd.createAutoChecklist = function() {
      const e2 = /* @__PURE__ */ Object.create(null);
      return (t3) => {
        const n2 = JSON.stringify(t3);
        return !!e2[n2] || (e2[n2] = true, false);
      };
    }, pd.partition = function(e2, t3) {
      const n2 = [], r2 = [];
      for (const o2 of e2)
        t3(o2) ? n2.push(o2) : r2.push(o2);
      return [n2, r2];
    }, pd.isInt = function(e2) {
      return e2 === Math.floor(e2);
    }, pd.comparePrimitive = function(e2, t3) {
      if (e2 === t3)
        return 0;
      const n2 = typeof e2, r2 = typeof t3, o2 = ["undefined", "object", "boolean", "number", "string"];
      return n2 !== r2 ? o2.indexOf(n2) - o2.indexOf(r2) : n2 !== "string" ? Number(e2) - Number(t3) : e2.localeCompare(t3);
    }, pd.normalizeDefaultResult = function(e2) {
      return e2 === void 0 ? {} : e2;
    }, pd.normalizeValidateResult = function(e2, t3) {
      return e2 === true || (e2 === false ? { value: t3 } : e2);
    }, pd.normalizeDeprecatedResult = function(e2, t3) {
      let n2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
      return e2 !== false && (e2 === true ? !!n2 || [{ value: t3 }] : "value" in e2 ? [e2] : e2.length !== 0 && e2);
    }, pd.normalizeTransferResult = fd, pd.normalizeForwardResult = dd2, pd.normalizeRedirectResult = function(e2, t3) {
      const n2 = dd2(typeof e2 == "object" && "redirect" in e2 ? e2.redirect : e2, t3);
      return n2.length === 0 ? { remain: t3, redirect: n2 } : typeof e2 == "object" && "remain" in e2 ? { remain: e2.remain, redirect: n2 } : { redirect: n2 };
    }, Object.defineProperty(ld, "__esModule", { value: true });
    const hd = Gf, gd = pd;
    class md extends hd.Schema {
      constructor(e2) {
        super(e2), this._choices = gd.mapFromArray(e2.choices.map((e3) => e3 && typeof e3 == "object" ? e3 : { value: e3 }), "value");
      }
      expected(e2) {
        let { descriptor: t3 } = e2;
        const n2 = Array.from(this._choices.keys()).map((e3) => this._choices.get(e3)).filter((e3) => !e3.deprecated).map((e3) => e3.value).sort(gd.comparePrimitive).map(t3.value), r2 = n2.slice(0, -2), o2 = n2.slice(-2);
        return r2.concat(o2.join(" or ")).join(", ");
      }
      validate(e2) {
        return this._choices.has(e2);
      }
      deprecated(e2) {
        const t3 = this._choices.get(e2);
        return !(!t3 || !t3.deprecated) && { value: e2 };
      }
      forward(e2) {
        const t3 = this._choices.get(e2);
        return t3 ? t3.forward : void 0;
      }
      redirect(e2) {
        const t3 = this._choices.get(e2);
        return t3 ? t3.redirect : void 0;
      }
    }
    ld.ChoiceSchema = md;
    var yd = {}, Dd = {};
    Object.defineProperty(Dd, "__esModule", { value: true });
    const Ed = Gf;
    class Cd extends Ed.Schema {
      expected() {
        return "a number";
      }
      validate(e2, t3) {
        return typeof e2 == "number";
      }
    }
    Dd.NumberSchema = Cd, Object.defineProperty(yd, "__esModule", { value: true });
    const bd = pd, vd = Dd;
    class Ad extends vd.NumberSchema {
      expected() {
        return "an integer";
      }
      validate(e2, t3) {
        return t3.normalizeValidateResult(super.validate(e2, t3), e2) === true && bd.isInt(e2);
      }
    }
    yd.IntegerSchema = Ad;
    var Fd = {};
    Object.defineProperty(Fd, "__esModule", { value: true });
    const xd = Gf;
    class Sd extends xd.Schema {
      expected() {
        return "a string";
      }
      validate(e2) {
        return typeof e2 == "string";
      }
    }
    Fd.StringSchema = Sd, function(e2) {
      Object.defineProperty(e2, "__esModule", { value: true });
      const t3 = wp2;
      t3.__exportStar(zf, e2), t3.__exportStar(Zf, e2), t3.__exportStar(nd, e2), t3.__exportStar(sd, e2), t3.__exportStar(ld, e2), t3.__exportStar(yd, e2), t3.__exportStar(Dd, e2), t3.__exportStar(Fd, e2);
    }(Uf);
    var wd = {}, Td = {};
    Object.defineProperty(Td, "__esModule", { value: true });
    const Bd = Bp, Nd = Pp, kd = Lf, Pd = Rf;
    Td.defaultDescriptor = Bd.apiDescriptor, Td.defaultUnknownHandler = Pd.levenUnknownHandler, Td.defaultInvalidHandler = kd.commonInvalidHandler, Td.defaultDeprecatedHandler = Nd.commonDeprecatedHandler, Object.defineProperty(wd, "__esModule", { value: true });
    const Od = Td, Id = pd;
    wd.normalize = (e2, t3, n2) => new Ld(t3, n2).normalize(e2);
    class Ld {
      constructor(e2, t3) {
        const { logger: n2 = console, descriptor: r2 = Od.defaultDescriptor, unknown: o2 = Od.defaultUnknownHandler, invalid: i2 = Od.defaultInvalidHandler, deprecated: u2 = Od.defaultDeprecatedHandler } = t3 || {};
        this._utils = { descriptor: r2, logger: n2 || { warn: () => {
        } }, schemas: Id.recordFromArray(e2, "name"), normalizeDefaultResult: Id.normalizeDefaultResult, normalizeDeprecatedResult: Id.normalizeDeprecatedResult, normalizeForwardResult: Id.normalizeForwardResult, normalizeRedirectResult: Id.normalizeRedirectResult, normalizeValidateResult: Id.normalizeValidateResult }, this._unknownHandler = o2, this._invalidHandler = i2, this._deprecatedHandler = u2, this.cleanHistory();
      }
      cleanHistory() {
        this._hasDeprecationWarned = Id.createAutoChecklist();
      }
      normalize(e2) {
        const t3 = {}, n2 = [e2], r2 = () => {
          for (; n2.length !== 0; ) {
            const e3 = n2.shift(), r3 = this._applyNormalization(e3, t3);
            n2.push(...r3);
          }
        };
        r2();
        for (const e3 of Object.keys(this._utils.schemas)) {
          const r3 = this._utils.schemas[e3];
          if (!(e3 in t3)) {
            const t4 = Id.normalizeDefaultResult(r3.default(this._utils));
            "value" in t4 && n2.push({ [e3]: t4.value });
          }
        }
        r2();
        for (const e3 of Object.keys(this._utils.schemas)) {
          const n3 = this._utils.schemas[e3];
          e3 in t3 && (t3[e3] = n3.postprocess(t3[e3], this._utils));
        }
        return t3;
      }
      _applyNormalization(e2, t3) {
        const n2 = [], [r2, o2] = Id.partition(Object.keys(e2), (e3) => e3 in this._utils.schemas);
        for (const o3 of r2) {
          const r3 = this._utils.schemas[o3], i2 = r3.preprocess(e2[o3], this._utils), u2 = Id.normalizeValidateResult(r3.validate(i2, this._utils), i2);
          if (u2 !== true) {
            const { value: e3 } = u2, t4 = this._invalidHandler(o3, e3, this._utils);
            throw typeof t4 == "string" ? new Error(t4) : t4;
          }
          const s2 = (e3) => {
            let { from: t4, to: r4 } = e3;
            n2.push(typeof r4 == "string" ? { [r4]: t4 } : { [r4.key]: r4.value });
          }, a2 = (e3) => {
            let { value: t4, redirectTo: n3 } = e3;
            const u3 = Id.normalizeDeprecatedResult(r3.deprecated(t4, this._utils), i2, true);
            if (u3 !== false)
              if (u3 === true)
                this._hasDeprecationWarned(o3) || this._utils.logger.warn(this._deprecatedHandler(o3, n3, this._utils));
              else
                for (const { value: e4 } of u3) {
                  const t5 = { key: o3, value: e4 };
                  if (!this._hasDeprecationWarned(t5)) {
                    const r4 = typeof n3 == "string" ? { key: n3, value: e4 } : n3;
                    this._utils.logger.warn(this._deprecatedHandler(t5, r4, this._utils));
                  }
                }
          };
          Id.normalizeForwardResult(r3.forward(i2, this._utils), i2).forEach(s2);
          const c2 = Id.normalizeRedirectResult(r3.redirect(i2, this._utils), i2);
          if (c2.redirect.forEach(s2), "remain" in c2) {
            const e3 = c2.remain;
            t3[o3] = o3 in t3 ? r3.overlap(t3[o3], e3, this._utils) : e3, a2({ value: e3 });
          }
          for (const { from: e3, to: t4 } of c2.redirect)
            a2({ value: e3, redirectTo: t4 });
        }
        for (const r3 of o2) {
          const o3 = e2[r3], i2 = this._unknownHandler(r3, o3, this._utils);
          if (i2)
            for (const e3 of Object.keys(i2)) {
              const r4 = { [e3]: i2[e3] };
              e3 in this._utils.schemas ? n2.push(r4) : Object.assign(t3, r4);
            }
        }
        return n2;
      }
    }
    wd.Normalizer = Ld, function(e2) {
      Object.defineProperty(e2, "__esModule", { value: true });
      const t3 = wp2;
      t3.__exportStar(Tp, e2), t3.__exportStar(Np, e2), t3.__exportStar(Uf, e2), t3.__exportStar(wd, e2), t3.__exportStar(Gf, e2);
    }(bp);
    var jd = { exports: {} };
    const _d = [], Md = [], Rd = (e2, t3) => {
      if (e2 === t3)
        return 0;
      const n2 = e2;
      e2.length > t3.length && (e2 = t3, t3 = n2);
      let r2 = e2.length, o2 = t3.length;
      for (; r2 > 0 && e2.charCodeAt(~-r2) === t3.charCodeAt(~-o2); )
        r2--, o2--;
      let i2, u2, s2, a2, c2 = 0;
      for (; c2 < r2 && e2.charCodeAt(c2) === t3.charCodeAt(c2); )
        c2++;
      if (r2 -= c2, o2 -= c2, r2 === 0)
        return o2;
      let l2 = 0, p2 = 0;
      for (; l2 < r2; )
        Md[l2] = e2.charCodeAt(c2 + l2), _d[l2] = ++l2;
      for (; p2 < o2; )
        for (i2 = t3.charCodeAt(c2 + p2), s2 = p2++, u2 = p2, l2 = 0; l2 < r2; l2++)
          a2 = i2 === Md[l2] ? s2 : s2 + 1, s2 = _d[l2], u2 = _d[l2] = s2 > u2 ? a2 > u2 ? u2 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
      return u2;
    };
    jd.exports = Rd, jd.exports.default = Rd;
    var Vd = { exports: {} };
    const $d = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Wd = {};
    for (const e2 of Object.keys($d))
      Wd[$d[e2]] = e2;
    const qd = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
    var Ud = qd;
    for (const e2 of Object.keys(qd)) {
      if (!("channels" in qd[e2]))
        throw new Error("missing channels property: " + e2);
      if (!("labels" in qd[e2]))
        throw new Error("missing channel labels property: " + e2);
      if (qd[e2].labels.length !== qd[e2].channels)
        throw new Error("channel and label counts mismatch: " + e2);
      const { channels: t3, labels: n2 } = qd[e2];
      delete qd[e2].channels, delete qd[e2].labels, Object.defineProperty(qd[e2], "channels", { value: t3 }), Object.defineProperty(qd[e2], "labels", { value: n2 });
    }
    qd.rgb.hsl = function(e2) {
      const t3 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, o2 = Math.min(t3, n2, r2), i2 = Math.max(t3, n2, r2), u2 = i2 - o2;
      let s2, a2;
      i2 === o2 ? s2 = 0 : t3 === i2 ? s2 = (n2 - r2) / u2 : n2 === i2 ? s2 = 2 + (r2 - t3) / u2 : r2 === i2 && (s2 = 4 + (t3 - n2) / u2), s2 = Math.min(60 * s2, 360), s2 < 0 && (s2 += 360);
      const c2 = (o2 + i2) / 2;
      return a2 = i2 === o2 ? 0 : c2 <= 0.5 ? u2 / (i2 + o2) : u2 / (2 - i2 - o2), [s2, 100 * a2, 100 * c2];
    }, qd.rgb.hsv = function(e2) {
      let t3, n2, r2, o2, i2;
      const u2 = e2[0] / 255, s2 = e2[1] / 255, a2 = e2[2] / 255, c2 = Math.max(u2, s2, a2), l2 = c2 - Math.min(u2, s2, a2), p2 = function(e3) {
        return (c2 - e3) / 6 / l2 + 0.5;
      };
      return l2 === 0 ? (o2 = 0, i2 = 0) : (i2 = l2 / c2, t3 = p2(u2), n2 = p2(s2), r2 = p2(a2), u2 === c2 ? o2 = r2 - n2 : s2 === c2 ? o2 = 1 / 3 + t3 - r2 : a2 === c2 && (o2 = 2 / 3 + n2 - t3), o2 < 0 ? o2 += 1 : o2 > 1 && (o2 -= 1)), [360 * o2, 100 * i2, 100 * c2];
    }, qd.rgb.hwb = function(e2) {
      const t3 = e2[0], n2 = e2[1];
      let r2 = e2[2];
      const o2 = qd.rgb.hsl(e2)[0], i2 = 1 / 255 * Math.min(t3, Math.min(n2, r2));
      return r2 = 1 - 1 / 255 * Math.max(t3, Math.max(n2, r2)), [o2, 100 * i2, 100 * r2];
    }, qd.rgb.cmyk = function(e2) {
      const t3 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, o2 = Math.min(1 - t3, 1 - n2, 1 - r2);
      return [100 * ((1 - t3 - o2) / (1 - o2) || 0), 100 * ((1 - n2 - o2) / (1 - o2) || 0), 100 * ((1 - r2 - o2) / (1 - o2) || 0), 100 * o2];
    }, qd.rgb.keyword = function(e2) {
      const t3 = Wd[e2];
      if (t3)
        return t3;
      let n2, r2 = 1 / 0;
      for (const t4 of Object.keys($d)) {
        const u2 = (i2 = $d[t4], ((o2 = e2)[0] - i2[0]) ** 2 + (o2[1] - i2[1]) ** 2 + (o2[2] - i2[2]) ** 2);
        u2 < r2 && (r2 = u2, n2 = t4);
      }
      var o2, i2;
      return n2;
    }, qd.keyword.rgb = function(e2) {
      return $d[e2];
    }, qd.rgb.xyz = function(e2) {
      let t3 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255;
      t3 = t3 > 0.04045 ? ((t3 + 0.055) / 1.055) ** 2.4 : t3 / 12.92, n2 = n2 > 0.04045 ? ((n2 + 0.055) / 1.055) ** 2.4 : n2 / 12.92, r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
      return [100 * (0.4124 * t3 + 0.3576 * n2 + 0.1805 * r2), 100 * (0.2126 * t3 + 0.7152 * n2 + 0.0722 * r2), 100 * (0.0193 * t3 + 0.1192 * n2 + 0.9505 * r2)];
    }, qd.rgb.lab = function(e2) {
      const t3 = qd.rgb.xyz(e2);
      let n2 = t3[0], r2 = t3[1], o2 = t3[2];
      n2 /= 95.047, r2 /= 100, o2 /= 108.883, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116, o2 = o2 > 8856e-6 ? o2 ** (1 / 3) : 7.787 * o2 + 16 / 116;
      return [116 * r2 - 16, 500 * (n2 - r2), 200 * (r2 - o2)];
    }, qd.hsl.rgb = function(e2) {
      const t3 = e2[0] / 360, n2 = e2[1] / 100, r2 = e2[2] / 100;
      let o2, i2, u2;
      if (n2 === 0)
        return u2 = 255 * r2, [u2, u2, u2];
      o2 = r2 < 0.5 ? r2 * (1 + n2) : r2 + n2 - r2 * n2;
      const s2 = 2 * r2 - o2, a2 = [0, 0, 0];
      for (let e3 = 0; e3 < 3; e3++)
        i2 = t3 + 1 / 3 * -(e3 - 1), i2 < 0 && i2++, i2 > 1 && i2--, u2 = 6 * i2 < 1 ? s2 + 6 * (o2 - s2) * i2 : 2 * i2 < 1 ? o2 : 3 * i2 < 2 ? s2 + (o2 - s2) * (2 / 3 - i2) * 6 : s2, a2[e3] = 255 * u2;
      return a2;
    }, qd.hsl.hsv = function(e2) {
      const t3 = e2[0];
      let n2 = e2[1] / 100, r2 = e2[2] / 100, o2 = n2;
      const i2 = Math.max(r2, 0.01);
      r2 *= 2, n2 *= r2 <= 1 ? r2 : 2 - r2, o2 *= i2 <= 1 ? i2 : 2 - i2;
      return [t3, 100 * (r2 === 0 ? 2 * o2 / (i2 + o2) : 2 * n2 / (r2 + n2)), 100 * ((r2 + n2) / 2)];
    }, qd.hsv.rgb = function(e2) {
      const t3 = e2[0] / 60, n2 = e2[1] / 100;
      let r2 = e2[2] / 100;
      const o2 = Math.floor(t3) % 6, i2 = t3 - Math.floor(t3), u2 = 255 * r2 * (1 - n2), s2 = 255 * r2 * (1 - n2 * i2), a2 = 255 * r2 * (1 - n2 * (1 - i2));
      switch (r2 *= 255, o2) {
        case 0:
          return [r2, a2, u2];
        case 1:
          return [s2, r2, u2];
        case 2:
          return [u2, r2, a2];
        case 3:
          return [u2, s2, r2];
        case 4:
          return [a2, u2, r2];
        case 5:
          return [r2, u2, s2];
      }
    }, qd.hsv.hsl = function(e2) {
      const t3 = e2[0], n2 = e2[1] / 100, r2 = e2[2] / 100, o2 = Math.max(r2, 0.01);
      let i2, u2;
      u2 = (2 - n2) * r2;
      const s2 = (2 - n2) * o2;
      return i2 = n2 * o2, i2 /= s2 <= 1 ? s2 : 2 - s2, i2 = i2 || 0, u2 /= 2, [t3, 100 * i2, 100 * u2];
    }, qd.hwb.rgb = function(e2) {
      const t3 = e2[0] / 360;
      let n2 = e2[1] / 100, r2 = e2[2] / 100;
      const o2 = n2 + r2;
      let i2;
      o2 > 1 && (n2 /= o2, r2 /= o2);
      const u2 = Math.floor(6 * t3), s2 = 1 - r2;
      i2 = 6 * t3 - u2, (1 & u2) != 0 && (i2 = 1 - i2);
      const a2 = n2 + i2 * (s2 - n2);
      let c2, l2, p2;
      switch (u2) {
        default:
        case 6:
        case 0:
          c2 = s2, l2 = a2, p2 = n2;
          break;
        case 1:
          c2 = a2, l2 = s2, p2 = n2;
          break;
        case 2:
          c2 = n2, l2 = s2, p2 = a2;
          break;
        case 3:
          c2 = n2, l2 = a2, p2 = s2;
          break;
        case 4:
          c2 = a2, l2 = n2, p2 = s2;
          break;
        case 5:
          c2 = s2, l2 = n2, p2 = a2;
      }
      return [255 * c2, 255 * l2, 255 * p2];
    }, qd.cmyk.rgb = function(e2) {
      const t3 = e2[0] / 100, n2 = e2[1] / 100, r2 = e2[2] / 100, o2 = e2[3] / 100;
      return [255 * (1 - Math.min(1, t3 * (1 - o2) + o2)), 255 * (1 - Math.min(1, n2 * (1 - o2) + o2)), 255 * (1 - Math.min(1, r2 * (1 - o2) + o2))];
    }, qd.xyz.rgb = function(e2) {
      const t3 = e2[0] / 100, n2 = e2[1] / 100, r2 = e2[2] / 100;
      let o2, i2, u2;
      return o2 = 3.2406 * t3 + -1.5372 * n2 + -0.4986 * r2, i2 = -0.9689 * t3 + 1.8758 * n2 + 0.0415 * r2, u2 = 0.0557 * t3 + -0.204 * n2 + 1.057 * r2, o2 = o2 > 31308e-7 ? 1.055 * o2 ** (1 / 2.4) - 0.055 : 12.92 * o2, i2 = i2 > 31308e-7 ? 1.055 * i2 ** (1 / 2.4) - 0.055 : 12.92 * i2, u2 = u2 > 31308e-7 ? 1.055 * u2 ** (1 / 2.4) - 0.055 : 12.92 * u2, o2 = Math.min(Math.max(0, o2), 1), i2 = Math.min(Math.max(0, i2), 1), u2 = Math.min(Math.max(0, u2), 1), [255 * o2, 255 * i2, 255 * u2];
    }, qd.xyz.lab = function(e2) {
      let t3 = e2[0], n2 = e2[1], r2 = e2[2];
      t3 /= 95.047, n2 /= 100, r2 /= 108.883, t3 = t3 > 8856e-6 ? t3 ** (1 / 3) : 7.787 * t3 + 16 / 116, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116;
      return [116 * n2 - 16, 500 * (t3 - n2), 200 * (n2 - r2)];
    }, qd.lab.xyz = function(e2) {
      let t3, n2, r2;
      n2 = (e2[0] + 16) / 116, t3 = e2[1] / 500 + n2, r2 = n2 - e2[2] / 200;
      const o2 = n2 ** 3, i2 = t3 ** 3, u2 = r2 ** 3;
      return n2 = o2 > 8856e-6 ? o2 : (n2 - 16 / 116) / 7.787, t3 = i2 > 8856e-6 ? i2 : (t3 - 16 / 116) / 7.787, r2 = u2 > 8856e-6 ? u2 : (r2 - 16 / 116) / 7.787, t3 *= 95.047, n2 *= 100, r2 *= 108.883, [t3, n2, r2];
    }, qd.lab.lch = function(e2) {
      const t3 = e2[0], n2 = e2[1], r2 = e2[2];
      let o2;
      o2 = 360 * Math.atan2(r2, n2) / 2 / Math.PI, o2 < 0 && (o2 += 360);
      return [t3, Math.sqrt(n2 * n2 + r2 * r2), o2];
    }, qd.lch.lab = function(e2) {
      const t3 = e2[0], n2 = e2[1], r2 = e2[2] / 360 * 2 * Math.PI;
      return [t3, n2 * Math.cos(r2), n2 * Math.sin(r2)];
    }, qd.rgb.ansi16 = function(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      const [n2, r2, o2] = e2;
      let i2 = t3 === null ? qd.rgb.hsv(e2)[2] : t3;
      if (i2 = Math.round(i2 / 50), i2 === 0)
        return 30;
      let u2 = 30 + (Math.round(o2 / 255) << 2 | Math.round(r2 / 255) << 1 | Math.round(n2 / 255));
      return i2 === 2 && (u2 += 60), u2;
    }, qd.hsv.ansi16 = function(e2) {
      return qd.rgb.ansi16(qd.hsv.rgb(e2), e2[2]);
    }, qd.rgb.ansi256 = function(e2) {
      const t3 = e2[0], n2 = e2[1], r2 = e2[2];
      if (t3 === n2 && n2 === r2)
        return t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232;
      return 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n2 / 255 * 5) + Math.round(r2 / 255 * 5);
    }, qd.ansi16.rgb = function(e2) {
      let t3 = e2 % 10;
      if (t3 === 0 || t3 === 7)
        return e2 > 50 && (t3 += 3.5), t3 = t3 / 10.5 * 255, [t3, t3, t3];
      const n2 = 0.5 * (1 + ~~(e2 > 50));
      return [(1 & t3) * n2 * 255, (t3 >> 1 & 1) * n2 * 255, (t3 >> 2 & 1) * n2 * 255];
    }, qd.ansi256.rgb = function(e2) {
      if (e2 >= 232) {
        const t4 = 10 * (e2 - 232) + 8;
        return [t4, t4, t4];
      }
      let t3;
      e2 -= 16;
      return [Math.floor(e2 / 36) / 5 * 255, Math.floor((t3 = e2 % 36) / 6) / 5 * 255, t3 % 6 / 5 * 255];
    }, qd.rgb.hex = function(e2) {
      const t3 = (((255 & Math.round(e2[0])) << 16) + ((255 & Math.round(e2[1])) << 8) + (255 & Math.round(e2[2]))).toString(16).toUpperCase();
      return "000000".substring(t3.length) + t3;
    }, qd.hex.rgb = function(e2) {
      const t3 = e2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!t3)
        return [0, 0, 0];
      let n2 = t3[0];
      t3[0].length === 3 && (n2 = n2.split("").map((e3) => e3 + e3).join(""));
      const r2 = parseInt(n2, 16);
      return [r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2];
    }, qd.rgb.hcg = function(e2) {
      const t3 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, o2 = Math.max(Math.max(t3, n2), r2), i2 = Math.min(Math.min(t3, n2), r2), u2 = o2 - i2;
      let s2, a2;
      return s2 = u2 < 1 ? i2 / (1 - u2) : 0, a2 = u2 <= 0 ? 0 : o2 === t3 ? (n2 - r2) / u2 % 6 : o2 === n2 ? 2 + (r2 - t3) / u2 : 4 + (t3 - n2) / u2, a2 /= 6, a2 %= 1, [360 * a2, 100 * u2, 100 * s2];
    }, qd.hsl.hcg = function(e2) {
      const t3 = e2[1] / 100, n2 = e2[2] / 100, r2 = n2 < 0.5 ? 2 * t3 * n2 : 2 * t3 * (1 - n2);
      let o2 = 0;
      return r2 < 1 && (o2 = (n2 - 0.5 * r2) / (1 - r2)), [e2[0], 100 * r2, 100 * o2];
    }, qd.hsv.hcg = function(e2) {
      const t3 = e2[1] / 100, n2 = e2[2] / 100, r2 = t3 * n2;
      let o2 = 0;
      return r2 < 1 && (o2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * o2];
    }, qd.hcg.rgb = function(e2) {
      const t3 = e2[0] / 360, n2 = e2[1] / 100, r2 = e2[2] / 100;
      if (n2 === 0)
        return [255 * r2, 255 * r2, 255 * r2];
      const o2 = [0, 0, 0], i2 = t3 % 1 * 6, u2 = i2 % 1, s2 = 1 - u2;
      let a2 = 0;
      switch (Math.floor(i2)) {
        case 0:
          o2[0] = 1, o2[1] = u2, o2[2] = 0;
          break;
        case 1:
          o2[0] = s2, o2[1] = 1, o2[2] = 0;
          break;
        case 2:
          o2[0] = 0, o2[1] = 1, o2[2] = u2;
          break;
        case 3:
          o2[0] = 0, o2[1] = s2, o2[2] = 1;
          break;
        case 4:
          o2[0] = u2, o2[1] = 0, o2[2] = 1;
          break;
        default:
          o2[0] = 1, o2[1] = 0, o2[2] = s2;
      }
      return a2 = (1 - n2) * r2, [255 * (n2 * o2[0] + a2), 255 * (n2 * o2[1] + a2), 255 * (n2 * o2[2] + a2)];
    }, qd.hcg.hsv = function(e2) {
      const t3 = e2[1] / 100, n2 = t3 + e2[2] / 100 * (1 - t3);
      let r2 = 0;
      return n2 > 0 && (r2 = t3 / n2), [e2[0], 100 * r2, 100 * n2];
    }, qd.hcg.hsl = function(e2) {
      const t3 = e2[1] / 100, n2 = e2[2] / 100 * (1 - t3) + 0.5 * t3;
      let r2 = 0;
      return n2 > 0 && n2 < 0.5 ? r2 = t3 / (2 * n2) : n2 >= 0.5 && n2 < 1 && (r2 = t3 / (2 * (1 - n2))), [e2[0], 100 * r2, 100 * n2];
    }, qd.hcg.hwb = function(e2) {
      const t3 = e2[1] / 100, n2 = t3 + e2[2] / 100 * (1 - t3);
      return [e2[0], 100 * (n2 - t3), 100 * (1 - n2)];
    }, qd.hwb.hcg = function(e2) {
      const t3 = e2[1] / 100, n2 = 1 - e2[2] / 100, r2 = n2 - t3;
      let o2 = 0;
      return r2 < 1 && (o2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * o2];
    }, qd.apple.rgb = function(e2) {
      return [e2[0] / 65535 * 255, e2[1] / 65535 * 255, e2[2] / 65535 * 255];
    }, qd.rgb.apple = function(e2) {
      return [e2[0] / 255 * 65535, e2[1] / 255 * 65535, e2[2] / 255 * 65535];
    }, qd.gray.rgb = function(e2) {
      return [e2[0] / 100 * 255, e2[0] / 100 * 255, e2[0] / 100 * 255];
    }, qd.gray.hsl = function(e2) {
      return [0, 0, e2[0]];
    }, qd.gray.hsv = qd.gray.hsl, qd.gray.hwb = function(e2) {
      return [0, 100, e2[0]];
    }, qd.gray.cmyk = function(e2) {
      return [0, 0, 0, e2[0]];
    }, qd.gray.lab = function(e2) {
      return [e2[0], 0, 0];
    }, qd.gray.hex = function(e2) {
      const t3 = 255 & Math.round(e2[0] / 100 * 255), n2 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
      return "000000".substring(n2.length) + n2;
    }, qd.rgb.gray = function(e2) {
      return [(e2[0] + e2[1] + e2[2]) / 3 / 255 * 100];
    };
    const zd = Ud;
    function Gd(e2) {
      const t3 = function() {
        const e3 = {}, t4 = Object.keys(zd);
        for (let n3 = t4.length, r2 = 0; r2 < n3; r2++)
          e3[t4[r2]] = { distance: -1, parent: null };
        return e3;
      }(), n2 = [e2];
      for (t3[e2].distance = 0; n2.length; ) {
        const e3 = n2.pop(), r2 = Object.keys(zd[e3]);
        for (let o2 = r2.length, i2 = 0; i2 < o2; i2++) {
          const o3 = r2[i2], u2 = t3[o3];
          u2.distance === -1 && (u2.distance = t3[e3].distance + 1, u2.parent = e3, n2.unshift(o3));
        }
      }
      return t3;
    }
    function Hd(e2, t3) {
      return function(n2) {
        return t3(e2(n2));
      };
    }
    function Jd(e2, t3) {
      const n2 = [t3[e2].parent, e2];
      let r2 = zd[t3[e2].parent][e2], o2 = t3[e2].parent;
      for (; t3[o2].parent; )
        n2.unshift(t3[o2].parent), r2 = Hd(zd[t3[o2].parent][o2], r2), o2 = t3[o2].parent;
      return r2.conversion = n2, r2;
    }
    const Xd = Ud, Yd = function(e2) {
      const t3 = Gd(e2), n2 = {}, r2 = Object.keys(t3);
      for (let e3 = r2.length, o2 = 0; o2 < e3; o2++) {
        const e4 = r2[o2];
        t3[e4].parent !== null && (n2[e4] = Jd(e4, t3));
      }
      return n2;
    }, Kd = {};
    Object.keys(Xd).forEach((e2) => {
      Kd[e2] = {}, Object.defineProperty(Kd[e2], "channels", { value: Xd[e2].channels }), Object.defineProperty(Kd[e2], "labels", { value: Xd[e2].labels });
      const t3 = Yd(e2);
      Object.keys(t3).forEach((n2) => {
        const r2 = t3[n2];
        Kd[e2][n2] = function(e3) {
          const t4 = function() {
            for (var t5 = arguments.length, n3 = new Array(t5), r3 = 0; r3 < t5; r3++)
              n3[r3] = arguments[r3];
            const o2 = n3[0];
            if (o2 == null)
              return o2;
            o2.length > 1 && (n3 = o2);
            const i2 = e3(n3);
            if (typeof i2 == "object")
              for (let e4 = i2.length, t6 = 0; t6 < e4; t6++)
                i2[t6] = Math.round(i2[t6]);
            return i2;
          };
          return "conversion" in e3 && (t4.conversion = e3.conversion), t4;
        }(r2), Kd[e2][n2].raw = function(e3) {
          const t4 = function() {
            for (var t5 = arguments.length, n3 = new Array(t5), r3 = 0; r3 < t5; r3++)
              n3[r3] = arguments[r3];
            const o2 = n3[0];
            return o2 == null ? o2 : (o2.length > 1 && (n3 = o2), e3(n3));
          };
          return "conversion" in e3 && (t4.conversion = e3.conversion), t4;
        }(r2);
      });
    });
    var Qd = Kd;
    function Zd() {
      return false;
    }
    function eh() {
      throw new Error("tty.ReadStream is not implemented");
    }
    function th() {
      throw new Error("tty.ReadStream is not implemented");
    }
    !function(e2) {
      const t3 = (e3, t4) => function() {
        const n3 = e3(...arguments);
        return "\x1B[".concat(n3 + t4, "m");
      }, n2 = (e3, t4) => function() {
        const n3 = e3(...arguments);
        return "\x1B[".concat(38 + t4, ";5;").concat(n3, "m");
      }, r2 = (e3, t4) => function() {
        const n3 = e3(...arguments);
        return "\x1B[".concat(38 + t4, ";2;").concat(n3[0], ";").concat(n3[1], ";").concat(n3[2], "m");
      }, o2 = (e3) => e3, i2 = (e3, t4, n3) => [e3, t4, n3], u2 = (e3, t4, n3) => {
        Object.defineProperty(e3, t4, { get: () => {
          const r3 = n3();
          return Object.defineProperty(e3, t4, { value: r3, enumerable: true, configurable: true }), r3;
        }, enumerable: true, configurable: true });
      };
      let s2;
      const a2 = (e3, t4, n3, r3) => {
        s2 === void 0 && (s2 = Qd);
        const o3 = r3 ? 10 : 0, i3 = {};
        for (const [r4, u3] of Object.entries(s2)) {
          const s3 = r4 === "ansi16" ? "ansi" : r4;
          r4 === t4 ? i3[s3] = e3(n3, o3) : typeof u3 == "object" && (i3[s3] = e3(u3[t4], o3));
        }
        return i3;
      };
      Object.defineProperty(e2, "exports", { enumerable: true, get: function() {
        const e3 = /* @__PURE__ */ new Map(), s3 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
        s3.color.gray = s3.color.blackBright, s3.bgColor.bgGray = s3.bgColor.bgBlackBright, s3.color.grey = s3.color.blackBright, s3.bgColor.bgGrey = s3.bgColor.bgBlackBright;
        for (const [t4, n3] of Object.entries(s3)) {
          for (const [t5, r3] of Object.entries(n3))
            s3[t5] = { open: "\x1B[".concat(r3[0], "m"), close: "\x1B[".concat(r3[1], "m") }, n3[t5] = s3[t5], e3.set(r3[0], r3[1]);
          Object.defineProperty(s3, t4, { value: n3, enumerable: false });
        }
        return Object.defineProperty(s3, "codes", { value: e3, enumerable: false }), s3.color.close = "\x1B[39m", s3.bgColor.close = "\x1B[49m", u2(s3.color, "ansi", () => a2(t3, "ansi16", o2, false)), u2(s3.color, "ansi256", () => a2(n2, "ansi256", o2, false)), u2(s3.color, "ansi16m", () => a2(r2, "rgb", i2, false)), u2(s3.bgColor, "ansi", () => a2(t3, "ansi16", o2, true)), u2(s3.bgColor, "ansi256", () => a2(n2, "ansi256", o2, true)), u2(s3.bgColor, "ansi16m", () => a2(r2, "rgb", i2, true)), s3;
      } });
    }(Vd);
    var nh = { isatty: Zd, ReadStream: eh, WriteStream: th };
    const oh = t2(Object.freeze({ __proto__: null, isatty: Zd, ReadStream: eh, WriteStream: th, default: nh })), ih = function(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ta.argv;
      const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t3.indexOf(n2 + e2), o2 = t3.indexOf("--");
      return r2 !== -1 && (o2 === -1 || r2 < o2);
    }, { env: uh } = ta;
    let sh;
    function ah(e2) {
      return e2 !== 0 && { level: e2, hasBasic: true, has256: e2 >= 2, has16m: e2 >= 3 };
    }
    function ch(e2, t3) {
      if (sh === 0)
        return 0;
      if (ih("color=16m") || ih("color=full") || ih("color=truecolor"))
        return 3;
      if (ih("color=256"))
        return 2;
      if (e2 && !t3 && sh === void 0)
        return 0;
      const n2 = sh || 0;
      if (uh.TERM === "dumb")
        return n2;
      if ("CI" in uh)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((e3) => e3 in uh) || uh.CI_NAME === "codeship" ? 1 : n2;
      if ("TEAMCITY_VERSION" in uh)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(uh.TEAMCITY_VERSION) ? 1 : 0;
      if (uh.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in uh) {
        const e3 = parseInt((uh.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (uh.TERM_PROGRAM) {
          case "iTerm.app":
            return e3 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(uh.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(uh.TERM) || "COLORTERM" in uh ? 1 : n2;
    }
    ih("no-color") || ih("no-colors") || ih("color=false") || ih("color=never") ? sh = 0 : (ih("color") || ih("colors") || ih("color=true") || ih("color=always")) && (sh = 1), "FORCE_COLOR" in uh && (sh = uh.FORCE_COLOR === "true" ? 1 : uh.FORCE_COLOR === "false" ? 0 : uh.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(uh.FORCE_COLOR, 10), 3));
    var lh = { supportsColor: function(e2) {
      return ah(ch(e2, e2 && e2.isTTY));
    }, stdout: ah(ch(true, oh.isatty(1))), stderr: ah(ch(true, oh.isatty(2))) };
    var ph = { stringReplaceAll: (e2, t3, n2) => {
      let r2 = e2.indexOf(t3);
      if (r2 === -1)
        return e2;
      const o2 = t3.length;
      let i2 = 0, u2 = "";
      do {
        u2 += e2.substr(i2, r2 - i2) + t3 + n2, i2 = r2 + o2, r2 = e2.indexOf(t3, i2);
      } while (r2 !== -1);
      return u2 += e2.substr(i2), u2;
    }, stringEncaseCRLFWithFirstIndex: (e2, t3, n2, r2) => {
      let o2 = 0, i2 = "";
      do {
        const u2 = e2[r2 - 1] === "\r";
        i2 += e2.substr(o2, (u2 ? r2 - 1 : r2) - o2) + t3 + (u2 ? "\r\n" : "\n") + n2, o2 = r2 + 1, r2 = e2.indexOf("\n", o2);
      } while (r2 !== -1);
      return i2 += e2.substr(o2), i2;
    } };
    const fh = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, dh = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, hh = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, gh = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, mh = /* @__PURE__ */ new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", "\x1B"], ["a", "\x07"]]);
    function yh(e2) {
      const t3 = e2[0] === "u", n2 = e2[1] === "{";
      return t3 && !n2 && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : t3 && n2 ? String.fromCodePoint(parseInt(e2.slice(2, -1), 16)) : mh.get(e2) || e2;
    }
    function Dh(e2, t3) {
      const n2 = [], r2 = t3.trim().split(/\s*,\s*/g);
      let o2;
      for (const t4 of r2) {
        const r3 = Number(t4);
        if (Number.isNaN(r3)) {
          if (!(o2 = t4.match(hh)))
            throw new Error("Invalid Chalk template style argument: ".concat(t4, " (in style '").concat(e2, "')"));
          n2.push(o2[2].replace(gh, (e3, t5, n3) => t5 ? yh(t5) : n3));
        } else
          n2.push(r3);
      }
      return n2;
    }
    function Eh(e2) {
      dh.lastIndex = 0;
      const t3 = [];
      let n2;
      for (; (n2 = dh.exec(e2)) !== null; ) {
        const e3 = n2[1];
        if (n2[2]) {
          const r2 = Dh(e3, n2[2]);
          t3.push([e3].concat(r2));
        } else
          t3.push([e3]);
      }
      return t3;
    }
    function Ch(e2, t3) {
      const n2 = {};
      for (const e3 of t3)
        for (const t4 of e3.styles)
          n2[t4[0]] = e3.inverse ? null : t4.slice(1);
      let r2 = e2;
      for (const [e3, t4] of Object.entries(n2))
        if (Array.isArray(t4)) {
          if (!(e3 in r2))
            throw new Error("Unknown Chalk style: ".concat(e3));
          r2 = t4.length > 0 ? r2[e3](...t4) : r2[e3];
        }
      return r2;
    }
    var bh = (e2, t3) => {
      const n2 = [], r2 = [];
      let o2 = [];
      if (t3.replace(fh, (t4, i2, u2, s2, a2, c2) => {
        if (i2)
          o2.push(yh(i2));
        else if (s2) {
          const t5 = o2.join("");
          o2 = [], r2.push(n2.length === 0 ? t5 : Ch(e2, n2)(t5)), n2.push({ inverse: u2, styles: Eh(s2) });
        } else if (a2) {
          if (n2.length === 0)
            throw new Error("Found extraneous } in Chalk template literal");
          r2.push(Ch(e2, n2)(o2.join(""))), o2 = [], n2.pop();
        } else
          o2.push(c2);
      }), r2.push(o2.join("")), n2.length > 0) {
        const e3 = "Chalk template literal is missing ".concat(n2.length, " closing bracket").concat(n2.length === 1 ? "" : "s", " (`}`)");
        throw new Error(e3);
      }
      return r2.join("");
    };
    const vh = Vd.exports, { stdout: Ah, stderr: Fh } = lh, { stringReplaceAll: xh, stringEncaseCRLFWithFirstIndex: Sh } = ph, { isArray: wh } = Array, Th = ["ansi", "ansi", "ansi256", "ansi16m"], Bh = /* @__PURE__ */ Object.create(null);
    class Nh {
      constructor(e2) {
        return kh(e2);
      }
    }
    const kh = (e2) => {
      const t3 = {};
      return function(e3) {
        let t4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (t4.level && !(Number.isInteger(t4.level) && t4.level >= 0 && t4.level <= 3))
          throw new Error("The `level` option should be an integer from 0 to 3");
        const n2 = Ah ? Ah.level : 0;
        e3.level = t4.level === void 0 ? n2 : t4.level;
      }(t3, e2), t3.template = function() {
        for (var e3 = arguments.length, n2 = new Array(e3), r2 = 0; r2 < e3; r2++)
          n2[r2] = arguments[r2];
        return Rh(t3.template, ...n2);
      }, Object.setPrototypeOf(t3, Ph.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      }, t3.template.Instance = Nh, t3.template;
    };
    function Ph(e2) {
      return kh(e2);
    }
    for (const [e2, t3] of Object.entries(vh))
      Bh[e2] = { get() {
        const n2 = jh(this, Lh(t3.open, t3.close, this._styler), this._isEmpty);
        return Object.defineProperty(this, e2, { value: n2 }), n2;
      } };
    Bh.visible = { get() {
      const e2 = jh(this, this._styler, true);
      return Object.defineProperty(this, "visible", { value: e2 }), e2;
    } };
    const Oh = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const e2 of Oh)
      Bh[e2] = { get() {
        const { level: t3 } = this;
        return function() {
          const n2 = Lh(vh.color[Th[t3]][e2](...arguments), vh.color.close, this._styler);
          return jh(this, n2, this._isEmpty);
        };
      } };
    for (const e2 of Oh) {
      Bh["bg" + e2[0].toUpperCase() + e2.slice(1)] = { get() {
        const { level: t3 } = this;
        return function() {
          const n2 = Lh(vh.bgColor[Th[t3]][e2](...arguments), vh.bgColor.close, this._styler);
          return jh(this, n2, this._isEmpty);
        };
      } };
    }
    const Ih = Object.defineProperties(() => {
    }, Object.assign(Object.assign({}, Bh), {}, { level: { enumerable: true, get() {
      return this._generator.level;
    }, set(e2) {
      this._generator.level = e2;
    } } })), Lh = (e2, t3, n2) => {
      let r2, o2;
      return n2 === void 0 ? (r2 = e2, o2 = t3) : (r2 = n2.openAll + e2, o2 = t3 + n2.closeAll), { open: e2, close: t3, openAll: r2, closeAll: o2, parent: n2 };
    }, jh = (e2, t3, n2) => {
      const r2 = function() {
        for (var e3 = arguments.length, t4 = new Array(e3), n3 = 0; n3 < e3; n3++)
          t4[n3] = arguments[n3];
        return wh(t4[0]) && wh(t4[0].raw) ? _h(r2, Rh(r2, ...t4)) : _h(r2, t4.length === 1 ? "" + t4[0] : t4.join(" "));
      };
      return Object.setPrototypeOf(r2, Ih), r2._generator = e2, r2._styler = t3, r2._isEmpty = n2, r2;
    }, _h = (e2, t3) => {
      if (e2.level <= 0 || !t3)
        return e2._isEmpty ? "" : t3;
      let n2 = e2._styler;
      if (n2 === void 0)
        return t3;
      const { openAll: r2, closeAll: o2 } = n2;
      if (t3.indexOf("\x1B") !== -1)
        for (; n2 !== void 0; )
          t3 = xh(t3, n2.close, n2.open), n2 = n2.parent;
      const i2 = t3.indexOf("\n");
      return i2 !== -1 && (t3 = Sh(t3, o2, r2, i2)), r2 + t3 + o2;
    };
    let Mh;
    const Rh = function(e2) {
      for (var t3 = arguments.length, n2 = new Array(t3 > 1 ? t3 - 1 : 0), r2 = 1; r2 < t3; r2++)
        n2[r2 - 1] = arguments[r2];
      const [o2] = n2;
      if (!wh(o2) || !wh(o2.raw))
        return n2.join(" ");
      const i2 = n2.slice(1), u2 = [o2.raw[0]];
      for (let e3 = 1; e3 < o2.length; e3++)
        u2.push(String(i2[e3 - 1]).replace(/[{}\\]/g, "\\$&"), String(o2.raw[e3]));
      return Mh === void 0 && (Mh = bh), Mh(e2, u2.join(""));
    };
    Object.defineProperties(Ph.prototype, Bh);
    const Vh = Ph();
    Vh.supportsColor = Ah, Vh.stderr = Ph({ level: Fh ? Fh.level : 0 }), Vh.stderr.supportsColor = Fh;
    var $h = Vh;
    const Wh = ["_"], qh = bp, Uh = jd.exports, zh = $h, Gh = au, Hh = { key: (e2) => e2.length === 1 ? "-".concat(e2) : "--".concat(e2), value: (e2) => qh.apiDescriptor.value(e2), pair: (e2) => {
      let { key: t3, value: n2 } = e2;
      return n2 === false ? "--no-".concat(t3) : n2 === true ? Hh.key(t3) : n2 === "" ? "".concat(Hh.key(t3), " without an argument") : "".concat(Hh.key(t3), "=").concat(n2);
    } };
    class Jh extends qh.ChoiceSchema {
      constructor(e2) {
        let { name: t3, flags: n2 } = e2;
        super({ name: t3, choices: n2 }), this._flags = [...n2].sort();
      }
      preprocess(e2, t3) {
        if (typeof e2 == "string" && e2.length > 0 && !this._flags.includes(e2)) {
          const n2 = this._flags.find((t4) => Uh(t4, e2) < 3);
          if (n2)
            return t3.logger.warn(["Unknown flag ".concat(zh.yellow(t3.descriptor.value(e2)), ","), "did you mean ".concat(zh.blue(t3.descriptor.value(n2)), "?")].join(" ")), n2;
        }
        return e2;
      }
      expected() {
        return "a flag";
      }
    }
    let Xh;
    function Yh(e2, t3) {
      let { logger: n2, isCLI: r2 = false, passThrough: o2 = false } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const i2 = o2 ? Array.isArray(o2) ? (e3, t4) => o2.includes(e3) ? { [e3]: t4 } : void 0 : (e3, t4) => ({ [e3]: t4 }) : (e3, t4, n3) => {
        const r3 = cu(n3.schemas, Wh);
        return qh.levenUnknownHandler(e3, t4, Object.assign(Object.assign({}, n3), {}, { schemas: r3 }));
      }, u2 = r2 ? Hh : qh.apiDescriptor, s2 = Kh(t3, { isCLI: r2 }), a2 = new qh.Normalizer(s2, { logger: n2, unknown: i2, descriptor: u2 }), c2 = n2 !== false;
      c2 && Xh && (a2._hasDeprecationWarned = Xh);
      const l2 = a2.normalize(e2);
      return c2 && (Xh = a2._hasDeprecationWarned), l2;
    }
    function Kh(e2, t3) {
      let { isCLI: n2 } = t3;
      const r2 = [];
      n2 && r2.push(qh.AnySchema.create({ name: "_" }));
      for (const t4 of e2)
        r2.push(Qh(t4, { isCLI: n2, optionInfos: e2 })), t4.alias && n2 && r2.push(qh.AliasSchema.create({ name: t4.alias, sourceName: t4.name }));
      return r2;
    }
    function Qh(e2, t3) {
      let n2, { isCLI: r2, optionInfos: o2 } = t3;
      const i2 = { name: e2.name }, u2 = {};
      switch (e2.type) {
        case "int":
          n2 = qh.IntegerSchema, r2 && (i2.preprocess = (e3) => Number(e3));
          break;
        case "string":
        case "path":
          n2 = qh.StringSchema;
          break;
        case "choice":
          n2 = qh.ChoiceSchema, i2.choices = e2.choices.map((t4) => typeof t4 == "object" && t4.redirect ? Object.assign(Object.assign({}, t4), {}, { redirect: { to: { key: e2.name, value: t4.redirect } } }) : t4);
          break;
        case "boolean":
          n2 = qh.BooleanSchema;
          break;
        case "flag":
          n2 = Jh, i2.flags = o2.flatMap((e3) => [e3.alias, e3.description && e3.name, e3.oppositeDescription && "no-".concat(e3.name)].filter(Boolean));
          break;
        default:
          throw new Error("Unexpected type ".concat(e2.type));
      }
      if (e2.exception ? i2.validate = (t4, n3, r3) => e2.exception(t4) || n3.validate(t4, r3) : i2.validate = (e3, t4, n3) => e3 === void 0 || t4.validate(e3, n3), e2.redirect && (u2.redirect = (t4) => t4 ? { to: { key: e2.redirect.option, value: e2.redirect.value } } : void 0), e2.deprecated && (u2.deprecated = true), r2 && !e2.array) {
        const e3 = i2.preprocess || ((e4) => e4);
        i2.preprocess = (t4, n3, r3) => n3.preprocess(e3(Array.isArray(t4) ? Gh(t4) : t4), r3);
      }
      return e2.array ? qh.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, r2 ? { preprocess: (e3) => Array.isArray(e3) ? e3 : [e3] } : {}), u2), {}, { valueSchema: n2.create(i2) })) : n2.create(Object.assign(Object.assign({}, i2), u2));
    }
    var Zh = { normalizeApiOptions: function(e2, t3, n2) {
      return Yh(e2, t3, n2);
    }, normalizeCliOptions: function(e2, t3, n2) {
      return Yh(e2, t3, Object.assign({ isCLI: true }, n2));
    } };
    const { isNonEmptyArray: eg2 } = dc;
    function tg(e2, t3) {
      const { ignoreDecorators: n2 } = t3 || {};
      if (!n2) {
        const t4 = e2.declaration && e2.declaration.decorators || e2.decorators;
        if (eg2(t4))
          return tg(t4[0]);
      }
      return e2.range ? e2.range[0] : e2.start;
    }
    function ng(e2) {
      return e2.range ? e2.range[1] : e2.end;
    }
    function rg(e2, t3) {
      return tg(e2) === tg(t3);
    }
    var og = { locStart: tg, locEnd: ng, hasSameLocStart: rg, hasSameLoc: function(e2, t3) {
      return rg(e2, t3) && function(e3, t4) {
        return ng(e3) === ng(t4);
      }(e2, t3);
    } }, ig = {}, ug = {}, sg = {};
    Object.defineProperty(sg, "__esModule", { value: true }), sg.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, sg.matchToToken = function(e2) {
      var t3 = { type: "invalid", value: e2[0], closed: void 0 };
      return e2[1] ? (t3.type = "string", t3.closed = !(!e2[3] && !e2[4])) : e2[5] ? t3.type = "comment" : e2[6] ? (t3.type = "comment", t3.closed = !!e2[7]) : e2[8] ? t3.type = "regex" : e2[9] ? t3.type = "number" : e2[10] ? t3.type = "name" : e2[11] ? t3.type = "punctuator" : e2[12] && (t3.type = "whitespace"), t3;
    };
    var ag = {}, cg = {};
    Object.defineProperty(cg, "__esModule", { value: true }), cg.isIdentifierStart = yg, cg.isIdentifierChar = Dg, cg.isIdentifierName = function(e2) {
      let t3 = true;
      for (let n2 = 0; n2 < e2.length; n2++) {
        let r2 = e2.charCodeAt(n2);
        if ((64512 & r2) == 55296 && n2 + 1 < e2.length) {
          const t4 = e2.charCodeAt(++n2);
          (64512 & t4) == 56320 && (r2 = 65536 + ((1023 & r2) << 10) + (1023 & t4));
        }
        if (t3) {
          if (t3 = false, !yg(r2))
            return false;
        } else if (!Dg(r2))
          return false;
      }
      return !t3;
    };
    let lg2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", pg = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    const fg = new RegExp("[" + lg2 + "]"), dg = new RegExp("[" + lg2 + pg + "]");
    lg2 = pg = null;
    const hg = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], gg2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function mg(e2, t3) {
      let n2 = 65536;
      for (let r2 = 0, o2 = t3.length; r2 < o2; r2 += 2) {
        if (n2 += t3[r2], n2 > e2)
          return false;
        if (n2 += t3[r2 + 1], n2 >= e2)
          return true;
      }
      return false;
    }
    function yg(e2) {
      return e2 < 65 ? e2 === 36 : e2 <= 90 || (e2 < 97 ? e2 === 95 : e2 <= 122 || (e2 <= 65535 ? e2 >= 170 && fg.test(String.fromCharCode(e2)) : mg(e2, hg)));
    }
    function Dg(e2) {
      return e2 < 48 ? e2 === 36 : e2 < 58 || !(e2 < 65) && (e2 <= 90 || (e2 < 97 ? e2 === 95 : e2 <= 122 || (e2 <= 65535 ? e2 >= 170 && dg.test(String.fromCharCode(e2)) : mg(e2, hg) || mg(e2, gg2))));
    }
    var Eg = {};
    Object.defineProperty(Eg, "__esModule", { value: true }), Eg.isReservedWord = xg, Eg.isStrictReservedWord = Sg, Eg.isStrictBindOnlyReservedWord = wg, Eg.isStrictBindReservedWord = function(e2, t3) {
      return Sg(e2, t3) || wg(e2);
    }, Eg.isKeyword = function(e2) {
      return vg.has(e2);
    };
    const Cg = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], bg = ["eval", "arguments"], vg = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), Ag = new Set(Cg), Fg = new Set(bg);
    function xg(e2, t3) {
      return t3 && e2 === "await" || e2 === "enum";
    }
    function Sg(e2, t3) {
      return xg(e2, t3) || Ag.has(e2);
    }
    function wg(e2) {
      return Fg.has(e2);
    }
    !function(e2) {
      Object.defineProperty(e2, "__esModule", { value: true }), Object.defineProperty(e2, "isIdentifierName", { enumerable: true, get: function() {
        return t3.isIdentifierName;
      } }), Object.defineProperty(e2, "isIdentifierChar", { enumerable: true, get: function() {
        return t3.isIdentifierChar;
      } }), Object.defineProperty(e2, "isIdentifierStart", { enumerable: true, get: function() {
        return t3.isIdentifierStart;
      } }), Object.defineProperty(e2, "isReservedWord", { enumerable: true, get: function() {
        return n2.isReservedWord;
      } }), Object.defineProperty(e2, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
        return n2.isStrictBindOnlyReservedWord;
      } }), Object.defineProperty(e2, "isStrictBindReservedWord", { enumerable: true, get: function() {
        return n2.isStrictBindReservedWord;
      } }), Object.defineProperty(e2, "isStrictReservedWord", { enumerable: true, get: function() {
        return n2.isStrictReservedWord;
      } }), Object.defineProperty(e2, "isKeyword", { enumerable: true, get: function() {
        return n2.isKeyword;
      } });
      var t3 = cg, n2 = Eg;
    }(ag);
    var Tg = { exports: {} }, Bg = /[|\\{}()[\]^$+*?.]/g, Ng = function(e2) {
      if (typeof e2 != "string")
        throw new TypeError("Expected a string");
      return e2.replace(Bg, "\\$&");
    };
    const Pg = (e2, t3) => {
      t3 = t3 || ta.argv;
      const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t3.indexOf(n2 + e2), o2 = t3.indexOf("--");
      return r2 !== -1 && (o2 === -1 || r2 < o2);
    }, Og = ta.env;
    let Ig;
    function Lg(e2) {
      const t3 = function(e3) {
        if (Ig === false)
          return 0;
        if (Pg("color=16m") || Pg("color=full") || Pg("color=truecolor"))
          return 3;
        if (Pg("color=256"))
          return 2;
        if (e3 && !e3.isTTY && Ig !== true)
          return 0;
        const t4 = Ig ? 1 : 0;
        if ("CI" in Og)
          return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e4) => e4 in Og) || Og.CI_NAME === "codeship" ? 1 : t4;
        if ("TEAMCITY_VERSION" in Og)
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Og.TEAMCITY_VERSION) ? 1 : 0;
        if (Og.COLORTERM === "truecolor")
          return 3;
        if ("TERM_PROGRAM" in Og) {
          const e4 = parseInt((Og.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (Og.TERM_PROGRAM) {
            case "iTerm.app":
              return e4 >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(Og.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Og.TERM) || "COLORTERM" in Og ? 1 : (Og.TERM, t4);
      }(e2);
      return function(e3) {
        return e3 !== 0 && { level: e3, hasBasic: true, has256: e3 >= 2, has16m: e3 >= 3 };
      }(t3);
    }
    Pg("no-color") || Pg("no-colors") || Pg("color=false") ? Ig = false : (Pg("color") || Pg("colors") || Pg("color=true") || Pg("color=always")) && (Ig = true), "FORCE_COLOR" in Og && (Ig = Og.FORCE_COLOR.length === 0 || parseInt(Og.FORCE_COLOR, 10) !== 0);
    var jg = { supportsColor: Lg, stdout: Lg(ta.stdout), stderr: Lg(ta.stderr) };
    const _g = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Mg = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Rg = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Vg = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, $g = /* @__PURE__ */ new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", "\x1B"], ["a", "\x07"]]);
    function Wg(e2) {
      return e2[0] === "u" && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : $g.get(e2) || e2;
    }
    function qg(e2, t3) {
      const n2 = [], r2 = t3.trim().split(/\s*,\s*/g);
      let o2;
      for (const t4 of r2)
        if (isNaN(t4)) {
          if (!(o2 = t4.match(Rg)))
            throw new Error("Invalid Chalk template style argument: ".concat(t4, " (in style '").concat(e2, "')"));
          n2.push(o2[2].replace(Vg, (e3, t5, n3) => t5 ? Wg(t5) : n3));
        } else
          n2.push(Number(t4));
      return n2;
    }
    function Ug(e2) {
      Mg.lastIndex = 0;
      const t3 = [];
      let n2;
      for (; (n2 = Mg.exec(e2)) !== null; ) {
        const e3 = n2[1];
        if (n2[2]) {
          const r2 = qg(e3, n2[2]);
          t3.push([e3].concat(r2));
        } else
          t3.push([e3]);
      }
      return t3;
    }
    function zg(e2, t3) {
      const n2 = {};
      for (const e3 of t3)
        for (const t4 of e3.styles)
          n2[t4[0]] = e3.inverse ? null : t4.slice(1);
      let r2 = e2;
      for (const e3 of Object.keys(n2))
        if (Array.isArray(n2[e3])) {
          if (!(e3 in r2))
            throw new Error("Unknown Chalk style: ".concat(e3));
          r2 = n2[e3].length > 0 ? r2[e3].apply(r2, n2[e3]) : r2[e3];
        }
      return r2;
    }
    var Gg2 = (e2, t3) => {
      const n2 = [], r2 = [];
      let o2 = [];
      if (t3.replace(_g, (t4, i2, u2, s2, a2, c2) => {
        if (i2)
          o2.push(Wg(i2));
        else if (s2) {
          const t5 = o2.join("");
          o2 = [], r2.push(n2.length === 0 ? t5 : zg(e2, n2)(t5)), n2.push({ inverse: u2, styles: Ug(s2) });
        } else if (a2) {
          if (n2.length === 0)
            throw new Error("Found extraneous } in Chalk template literal");
          r2.push(zg(e2, n2)(o2.join(""))), o2 = [], n2.pop();
        } else
          o2.push(c2);
      }), r2.push(o2.join("")), n2.length > 0) {
        const e3 = "Chalk template literal is missing ".concat(n2.length, " closing bracket").concat(n2.length === 1 ? "" : "s", " (`}`)");
        throw new Error(e3);
      }
      return r2.join("");
    };
    !function(e2) {
      const t3 = Ng, n2 = jp.exports, r2 = jg.stdout, o2 = Gg2, u2 = ["ansi", "ansi", "ansi256", "ansi16m"], s2 = /* @__PURE__ */ new Set(["gray"]), a2 = /* @__PURE__ */ Object.create(null);
      function c2(e3, t4) {
        t4 = t4 || {};
        const n3 = r2 ? r2.level : 0;
        e3.level = t4.level === void 0 ? n3 : t4.level, e3.enabled = "enabled" in t4 ? t4.enabled : e3.level > 0;
      }
      function l2(e3) {
        if (!this || !(this instanceof l2) || this.template) {
          const t4 = {};
          return c2(t4, e3), t4.template = function() {
            const e4 = [].slice.call(arguments);
            return h2.apply(null, [t4.template].concat(e4));
          }, Object.setPrototypeOf(t4, l2.prototype), Object.setPrototypeOf(t4.template, t4), t4.template.constructor = l2, t4.template;
        }
        c2(this, e3);
      }
      for (const e3 of Object.keys(n2))
        n2[e3].closeRe = new RegExp(t3(n2[e3].close), "g"), a2[e3] = { get() {
          const t4 = n2[e3];
          return f2.call(this, this._styles ? this._styles.concat(t4) : [t4], this._empty, e3);
        } };
      a2.visible = { get() {
        return f2.call(this, this._styles || [], true, "visible");
      } }, n2.color.closeRe = new RegExp(t3(n2.color.close), "g");
      for (const e3 of Object.keys(n2.color.ansi))
        s2.has(e3) || (a2[e3] = { get() {
          const t4 = this.level;
          return function() {
            const r3 = n2.color[u2[t4]][e3].apply(null, arguments), o3 = { open: r3, close: n2.color.close, closeRe: n2.color.closeRe };
            return f2.call(this, this._styles ? this._styles.concat(o3) : [o3], this._empty, e3);
          };
        } });
      n2.bgColor.closeRe = new RegExp(t3(n2.bgColor.close), "g");
      for (const e3 of Object.keys(n2.bgColor.ansi)) {
        if (s2.has(e3))
          continue;
        a2["bg" + e3[0].toUpperCase() + e3.slice(1)] = { get() {
          const t4 = this.level;
          return function() {
            const r3 = n2.bgColor[u2[t4]][e3].apply(null, arguments), o3 = { open: r3, close: n2.bgColor.close, closeRe: n2.bgColor.closeRe };
            return f2.call(this, this._styles ? this._styles.concat(o3) : [o3], this._empty, e3);
          };
        } };
      }
      const p2 = Object.defineProperties(() => {
      }, a2);
      function f2(e3, t4, n3) {
        const r3 = function() {
          return d2.apply(r3, arguments);
        };
        r3._styles = e3, r3._empty = t4;
        const o3 = this;
        return Object.defineProperty(r3, "level", { enumerable: true, get: () => o3.level, set(e4) {
          o3.level = e4;
        } }), Object.defineProperty(r3, "enabled", { enumerable: true, get: () => o3.enabled, set(e4) {
          o3.enabled = e4;
        } }), r3.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r3.__proto__ = p2, r3;
      }
      function d2() {
        const e3 = arguments, t4 = e3.length;
        let r3 = String(arguments[0]);
        if (t4 === 0)
          return "";
        if (t4 > 1)
          for (let n3 = 1; n3 < t4; n3++)
            r3 += " " + e3[n3];
        if (!this.enabled || this.level <= 0 || !r3)
          return this._empty ? "" : r3;
        const o3 = n2.dim.open;
        for (const e4 of this._styles.slice().reverse())
          r3 = e4.open + r3.replace(e4.closeRe, e4.open) + e4.close, r3 = r3.replace(/\r?\n/g, "".concat(e4.close, "$&").concat(e4.open));
        return n2.dim.open = o3, r3;
      }
      function h2(e3, t4) {
        if (!Array.isArray(t4))
          return [].slice.call(arguments, 1).join(" ");
        const n3 = [].slice.call(arguments, 2), r3 = [t4.raw[0]];
        for (let e4 = 1; e4 < t4.length; e4++)
          r3.push(String(n3[e4 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t4.raw[e4]));
        return o2(e3, r3.join(""));
      }
      Object.defineProperties(l2.prototype, a2), e2.exports = l2(), e2.exports.supportsColor = r2, e2.exports.default = e2.exports;
    }(Tg), Object.defineProperty(ug, "__esModule", { value: true }), ug.default = function(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (nm(t3)) {
        const n2 = rm2(t3);
        return tm(Kg(n2), e2);
      }
      return e2;
    }, ug.getChalk = rm2, ug.shouldHighlight = nm;
    var Hg = sg, Jg = ag, Xg = Tg.exports;
    const Yg = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function Kg(e2) {
      return { keyword: e2.cyan, capitalized: e2.yellow, jsxIdentifier: e2.yellow, punctuator: e2.yellow, number: e2.magenta, string: e2.green, regex: e2.magenta, comment: e2.grey, invalid: e2.white.bgRed.bold };
    }
    const Qg = /\r\n|[\n\r\u2028\u2029]/, Zg = /^[()[\]{}]$/;
    let em;
    {
      const e2 = /^[a-z][\w-]*$/i, t3 = function(t4, n2, r2) {
        if (t4.type === "name") {
          if ((0, Jg.isKeyword)(t4.value) || (0, Jg.isStrictReservedWord)(t4.value, true) || Yg.has(t4.value))
            return "keyword";
          if (e2.test(t4.value) && (r2[n2 - 1] === "<" || r2.substr(n2 - 2, 2) == "</"))
            return "jsxIdentifier";
          if (t4.value[0] !== t4.value[0].toLowerCase())
            return "capitalized";
        }
        return t4.type === "punctuator" && Zg.test(t4.value) ? "bracket" : t4.type !== "invalid" || t4.value !== "@" && t4.value !== "#" ? t4.type : "punctuator";
      };
      em = function* (e3) {
        let n2;
        for (; n2 = Hg.default.exec(e3); ) {
          const r2 = Hg.matchToToken(n2);
          yield { type: t3(r2, n2.index, e3), value: r2.value };
        }
      };
    }
    function tm(e2, t3) {
      let n2 = "";
      for (const { type: r2, value: o2 } of em(t3)) {
        const t4 = e2[r2];
        n2 += t4 ? o2.split(Qg).map((e3) => t4(e3)).join("\n") : o2;
      }
      return n2;
    }
    function nm(e2) {
      return !!Xg.supportsColor || e2.forceColor;
    }
    function rm2(e2) {
      return e2.forceColor ? new Xg.constructor({ enabled: true, level: 1 }) : Xg;
    }
    Object.defineProperty(ig, "__esModule", { value: true }), ig.codeFrameColumns = cm, ig.default = function(e2, t3, n2) {
      let r2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (!im) {
        im = true;
        const e3 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        {
          new Error(e3).name = "DeprecationWarning", console.warn(new Error(e3));
        }
      }
      const o2 = { start: { column: n2 = Math.max(n2, 0), line: t3 } };
      return cm(e2, o2, r2);
    };
    var om = ug;
    let im = false;
    function um(e2) {
      return { gutter: e2.grey, marker: e2.red.bold, message: e2.red.bold };
    }
    const sm = /\r\n|[\n\r\u2028\u2029]/;
    function am(e2, t3, n2) {
      const r2 = Object.assign({ column: 0, line: -1 }, e2.start), o2 = Object.assign({}, r2, e2.end), { linesAbove: i2 = 2, linesBelow: u2 = 3 } = n2 || {}, s2 = r2.line, a2 = r2.column, c2 = o2.line, l2 = o2.column;
      let p2 = Math.max(s2 - (i2 + 1), 0), f2 = Math.min(t3.length, c2 + u2);
      s2 === -1 && (p2 = 0), c2 === -1 && (f2 = t3.length);
      const d2 = c2 - s2, h2 = {};
      if (d2)
        for (let e3 = 0; e3 <= d2; e3++) {
          const n3 = e3 + s2;
          if (a2)
            if (e3 === 0) {
              const e4 = t3[n3 - 1].length;
              h2[n3] = [a2, e4 - a2 + 1];
            } else if (e3 === d2)
              h2[n3] = [0, l2];
            else {
              const r3 = t3[n3 - e3].length;
              h2[n3] = [0, r3];
            }
          else
            h2[n3] = true;
        }
      else
        h2[s2] = a2 === l2 ? !a2 || [a2, 0] : [a2, l2 - a2];
      return { start: p2, end: f2, markerLines: h2 };
    }
    function cm(e2, t3) {
      let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const r2 = (n2.highlightCode || n2.forceColor) && (0, om.shouldHighlight)(n2), o2 = (0, om.getChalk)(n2), i2 = um(o2), u2 = (e3, t4) => r2 ? e3(t4) : t4, s2 = e2.split(sm), { start: a2, end: c2, markerLines: l2 } = am(t3, s2, n2), p2 = t3.start && typeof t3.start.column == "number", f2 = String(c2).length, d2 = r2 ? (0, om.default)(e2, n2) : e2;
      let h2 = d2.split(sm, c2).slice(a2, c2).map((e3, t4) => {
        const r3 = a2 + 1 + t4, o3 = " ".concat(r3).slice(-f2), s3 = " ".concat(o3, " |"), c3 = l2[r3], p3 = !l2[r3 + 1];
        if (c3) {
          let t5 = "";
          if (Array.isArray(c3)) {
            const r4 = e3.slice(0, Math.max(c3[0] - 1, 0)).replace(/[^\t]/g, " "), o4 = c3[1] || 1;
            t5 = ["\n ", u2(i2.gutter, s3.replace(/\d/g, " ")), " ", r4, u2(i2.marker, "^").repeat(o4)].join(""), p3 && n2.message && (t5 += " " + u2(i2.message, n2.message));
          }
          return [u2(i2.marker, ">"), u2(i2.gutter, s3), e3.length > 0 ? " ".concat(e3) : "", t5].join("");
        }
        return " ".concat(u2(i2.gutter, s3)).concat(e3.length > 0 ? " ".concat(e3) : "");
      }).join("\n");
      return n2.message && !p2 && (h2 = "".concat(" ".repeat(f2 + 1)).concat(n2.message, "\n").concat(h2)), r2 ? o2.reset(h2) : h2;
    }
    const { ConfigError: lm } = Cp, pm2 = og, { locStart: fm, locEnd: dm } = pm2, hm = Object.getOwnPropertyNames, gm = Object.getOwnPropertyDescriptor;
    function mm(e2) {
      const t3 = {};
      for (const n2 of e2.plugins)
        if (n2.parsers)
          for (const e3 of hm(n2.parsers))
            Object.defineProperty(t3, e3, gm(n2.parsers, e3));
      return t3;
    }
    function ym(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : mm(e2);
      if (typeof e2.parser == "function")
        return { parse: e2.parser, astFormat: "estree", locStart: fm, locEnd: dm };
      if (typeof e2.parser == "string") {
        if (Object.prototype.hasOwnProperty.call(t3, e2.parser))
          return t3[e2.parser];
        throw new lm(`Couldn't resolve parser "`.concat(e2.parser, '". Parsers must be explicitly added to the standalone bundle.'));
      }
    }
    var Dm = { parse: function(e2, t3) {
      const n2 = mm(t3), r2 = Object.defineProperties({}, Object.fromEntries(Object.keys(n2).map((e3) => [e3, { enumerable: true, get: () => n2[e3].parse }]))), o2 = ym(t3, n2);
      try {
        return o2.preprocess && (e2 = o2.preprocess(e2, t3)), { text: e2, ast: o2.parse(e2, r2, t3) };
      } catch (t4) {
        const { loc: n3 } = t4;
        if (n3) {
          const { codeFrameColumns: r3 } = ig;
          throw t4.codeFrame = r3(e2, n3, { highlightCode: true }), t4.message += "\n" + t4.codeFrame, t4;
        }
        throw t4.stack;
      }
    }, resolveParser: ym };
    const Em = el2, Cm = gl2, bm = gp, { UndefinedParserError: vm } = Cp, { getSupportInfo: Am } = za, Fm = Zh, { resolveParser: xm } = Dm, Sm = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
    function wm(e2) {
      const { astFormat: t3 } = e2;
      if (!t3)
        throw new Error("getPlugin() requires astFormat to be set");
      const n2 = e2.plugins.find((e3) => e3.printers && e3.printers[t3]);
      if (!n2)
        throw new Error(`Couldn't find plugin for AST format "`.concat(t3, '"'));
      return n2;
    }
    function Tm(e2, t3) {
      const n2 = Cm.basename(e2).toLowerCase(), r2 = Am({ plugins: t3 }).languages.filter((e3) => e3.since !== null);
      let o2 = r2.find((e3) => e3.extensions && e3.extensions.some((e4) => n2.endsWith(e4)) || e3.filenames && e3.filenames.some((e4) => e4.toLowerCase() === n2));
      if (!o2 && !n2.includes(".")) {
        const t4 = function(e3) {
          if (typeof e3 != "string")
            return "";
          let t5;
          try {
            t5 = Em.openSync(e3, "r");
          } catch {
            return "";
          }
          try {
            const e4 = new bm(t5).next().toString("utf8"), n3 = e4.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
            if (n3)
              return n3[1];
            const r3 = e4.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
            return r3 ? r3[1] : "";
          } catch {
            return "";
          } finally {
            try {
              Em.closeSync(t5);
            } catch {
            }
          }
        }(e2);
        o2 = r2.find((e3) => e3.interpreters && e3.interpreters.includes(t4));
      }
      return o2 && o2.parsers[0];
    }
    var Bm = { normalize: function(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const n2 = Object.assign({}, e2), r2 = Am({ plugins: e2.plugins, showUnreleased: true, showDeprecated: true }).options, o2 = Object.assign(Object.assign({}, Sm), Object.fromEntries(r2.filter((e3) => e3.default !== void 0).map((e3) => [e3.name, e3.default])));
      if (!n2.parser)
        if (n2.filepath) {
          if (n2.parser = Tm(n2.filepath, n2.plugins), !n2.parser)
            throw new vm("No parser could be inferred for file: ".concat(n2.filepath));
        } else {
          (t3.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n2.parser = "babel";
        }
      const i2 = xm(Fm.normalizeApiOptions(n2, [r2.find((e3) => e3.name === "parser")], { passThrough: true, logger: false }));
      n2.astFormat = i2.astFormat, n2.locEnd = i2.locEnd, n2.locStart = i2.locStart;
      const u2 = wm(n2);
      n2.printer = u2.printers[n2.astFormat];
      const s2 = Object.fromEntries(r2.filter((e3) => e3.pluginDefaults && e3.pluginDefaults[u2.name] !== void 0).map((e3) => [e3.name, e3.pluginDefaults[u2.name]])), a2 = Object.assign(Object.assign({}, o2), s2);
      for (const [e3, t4] of Object.entries(a2))
        n2[e3] !== null && n2[e3] !== void 0 || (n2[e3] = t4);
      return n2.parser === "json" && (n2.trailingComma = "none"), Fm.normalizeApiOptions(n2, r2, Object.assign({ passThrough: Object.keys(Sm) }, t3));
    }, hiddenDefaults: Sm, inferParser: Tm };
    var Nm = function e2(t3, n2, r2) {
      if (Array.isArray(t3))
        return t3.map((t4) => e2(t4, n2, r2)).filter(Boolean);
      if (!t3 || typeof t3 != "object")
        return t3;
      const o2 = n2.printer.massageAstNode;
      let i2;
      i2 = o2 && o2.ignoredProperties ? o2.ignoredProperties : /* @__PURE__ */ new Set();
      const u2 = {};
      for (const [r3, o3] of Object.entries(t3))
        i2.has(r3) || typeof o3 == "function" || (u2[r3] = e2(o3, n2, t3));
      if (o2) {
        const e3 = o2(t3, u2, r2);
        if (e3 === null)
          return;
        if (e3)
          return e3;
      }
      return u2;
    }, km = typeof Object.create == "function" ? function(e2, t3) {
      e2.super_ = t3, e2.prototype = Object.create(t3.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } });
    } : function(e2, t3) {
      e2.super_ = t3;
      var n2 = function() {
      };
      n2.prototype = t3.prototype, e2.prototype = new n2(), e2.prototype.constructor = e2;
    };
    function Pm(e2, t3) {
      var n2 = { seen: [], stylize: Im2 };
      return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), Mm(t3) ? n2.showHidden = t3 : t3 && Xm(n2, t3), $m(n2.showHidden) && (n2.showHidden = false), $m(n2.depth) && (n2.depth = 2), $m(n2.colors) && (n2.colors = false), $m(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = Om), Lm(n2, e2, n2.depth);
    }
    function Om(e2, t3) {
      var n2 = Pm.styles[t3];
      return n2 ? "\x1B[" + Pm.colors[n2][0] + "m" + e2 + "\x1B[" + Pm.colors[n2][1] + "m" : e2;
    }
    function Im2(e2, t3) {
      return e2;
    }
    function Lm(e2, t3, n2) {
      if (e2.customInspect && t3 && Gm(t3.inspect) && t3.inspect !== Pm && (!t3.constructor || t3.constructor.prototype !== t3)) {
        var r2 = t3.inspect(n2, e2);
        return Vm(r2) || (r2 = Lm(e2, r2, n2)), r2;
      }
      var o2 = function(e3, t4) {
        if ($m(t4))
          return e3.stylize("undefined", "undefined");
        if (Vm(t4)) {
          var n3 = "'" + JSON.stringify(t4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return e3.stylize(n3, "string");
        }
        if (r3 = t4, typeof r3 == "number")
          return e3.stylize("" + t4, "number");
        var r3;
        if (Mm(t4))
          return e3.stylize("" + t4, "boolean");
        if (Rm(t4))
          return e3.stylize("null", "null");
      }(e2, t3);
      if (o2)
        return o2;
      var i2 = Object.keys(t3), u2 = function(e3) {
        var t4 = {};
        return e3.forEach(function(e4, n3) {
          t4[e4] = true;
        }), t4;
      }(i2);
      if (e2.showHidden && (i2 = Object.getOwnPropertyNames(t3)), zm(t3) && (i2.indexOf("message") >= 0 || i2.indexOf("description") >= 0))
        return jm(t3);
      if (i2.length === 0) {
        if (Gm(t3)) {
          var s2 = t3.name ? ": " + t3.name : "";
          return e2.stylize("[Function" + s2 + "]", "special");
        }
        if (Wm(t3))
          return e2.stylize(RegExp.prototype.toString.call(t3), "regexp");
        if (Um(t3))
          return e2.stylize(Date.prototype.toString.call(t3), "date");
        if (zm(t3))
          return jm(t3);
      }
      var a2, c2, l2 = "", p2 = false, f2 = ["{", "}"];
      (a2 = t3, Array.isArray(a2) && (p2 = true, f2 = ["[", "]"]), Gm(t3)) && (l2 = " [Function" + (t3.name ? ": " + t3.name : "") + "]");
      return Wm(t3) && (l2 = " " + RegExp.prototype.toString.call(t3)), Um(t3) && (l2 = " " + Date.prototype.toUTCString.call(t3)), zm(t3) && (l2 = " " + jm(t3)), i2.length !== 0 || p2 && t3.length != 0 ? n2 < 0 ? Wm(t3) ? e2.stylize(RegExp.prototype.toString.call(t3), "regexp") : e2.stylize("[Object]", "special") : (e2.seen.push(t3), c2 = p2 ? function(e3, t4, n3, r3, o3) {
        for (var i3 = [], u3 = 0, s3 = t4.length; u3 < s3; ++u3)
          Ym(t4, String(u3)) ? i3.push(_m(e3, t4, n3, r3, String(u3), true)) : i3.push("");
        return o3.forEach(function(o4) {
          o4.match(/^\d+$/) || i3.push(_m(e3, t4, n3, r3, o4, true));
        }), i3;
      }(e2, t3, n2, u2, i2) : i2.map(function(r3) {
        return _m(e2, t3, n2, u2, r3, p2);
      }), e2.seen.pop(), function(e3, t4, n3) {
        if (e3.reduce(function(e4, t5) {
          return t5.indexOf("\n"), e4 + t5.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0) > 60)
          return n3[0] + (t4 === "" ? "" : t4 + "\n ") + " " + e3.join(",\n  ") + " " + n3[1];
        return n3[0] + t4 + " " + e3.join(", ") + " " + n3[1];
      }(c2, l2, f2)) : f2[0] + l2 + f2[1];
    }
    function jm(e2) {
      return "[" + Error.prototype.toString.call(e2) + "]";
    }
    function _m(e2, t3, n2, r2, o2, i2) {
      var u2, s2, a2;
      if ((a2 = Object.getOwnPropertyDescriptor(t3, o2) || { value: t3[o2] }).get ? s2 = a2.set ? e2.stylize("[Getter/Setter]", "special") : e2.stylize("[Getter]", "special") : a2.set && (s2 = e2.stylize("[Setter]", "special")), Ym(r2, o2) || (u2 = "[" + o2 + "]"), s2 || (e2.seen.indexOf(a2.value) < 0 ? (s2 = Rm(n2) ? Lm(e2, a2.value, null) : Lm(e2, a2.value, n2 - 1)).indexOf("\n") > -1 && (s2 = i2 ? s2.split("\n").map(function(e3) {
        return "  " + e3;
      }).join("\n").substr(2) : "\n" + s2.split("\n").map(function(e3) {
        return "   " + e3;
      }).join("\n")) : s2 = e2.stylize("[Circular]", "special")), $m(u2)) {
        if (i2 && o2.match(/^\d+$/))
          return s2;
        (u2 = JSON.stringify("" + o2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u2 = u2.substr(1, u2.length - 2), u2 = e2.stylize(u2, "name")) : (u2 = u2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u2 = e2.stylize(u2, "string"));
      }
      return u2 + ": " + s2;
    }
    function Mm(e2) {
      return typeof e2 == "boolean";
    }
    function Rm(e2) {
      return e2 === null;
    }
    function Vm(e2) {
      return typeof e2 == "string";
    }
    function $m(e2) {
      return e2 === void 0;
    }
    function Wm(e2) {
      return qm(e2) && Jm(e2) === "[object RegExp]";
    }
    function qm(e2) {
      return typeof e2 == "object" && e2 !== null;
    }
    function Um(e2) {
      return qm(e2) && Jm(e2) === "[object Date]";
    }
    function zm(e2) {
      return qm(e2) && (Jm(e2) === "[object Error]" || e2 instanceof Error);
    }
    function Gm(e2) {
      return typeof e2 == "function";
    }
    function Hm(e2) {
      return e2 === null || typeof e2 == "boolean" || typeof e2 == "number" || typeof e2 == "string" || typeof e2 == "symbol" || e2 === void 0;
    }
    function Jm(e2) {
      return Object.prototype.toString.call(e2);
    }
    function Xm(e2, t3) {
      if (!t3 || !qm(t3))
        return e2;
      for (var n2 = Object.keys(t3), r2 = n2.length; r2--; )
        e2[n2[r2]] = t3[n2[r2]];
      return e2;
    }
    function Ym(e2, t3) {
      return Object.prototype.hasOwnProperty.call(e2, t3);
    }
    function Km(e2, t3) {
      if (e2 === t3)
        return 0;
      for (var n2 = e2.length, r2 = t3.length, o2 = 0, i2 = Math.min(n2, r2); o2 < i2; ++o2)
        if (e2[o2] !== t3[o2]) {
          n2 = e2[o2], r2 = t3[o2];
          break;
        }
      return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
    }
    Pm.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, Pm.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
    var Qm, Zm = Object.prototype.hasOwnProperty, ey = Object.keys || function(e2) {
      var t3 = [];
      for (var n2 in e2)
        Zm.call(e2, n2) && t3.push(n2);
      return t3;
    }, ty = Array.prototype.slice;
    function ny() {
      return Qm !== void 0 ? Qm : Qm = function() {
      }.name === "foo";
    }
    function ry(e2) {
      return Object.prototype.toString.call(e2);
    }
    function oy(e2) {
      return !fp(e2) && (typeof Ns.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e2) : !!e2 && (e2 instanceof DataView || !!(e2.buffer && e2.buffer instanceof ArrayBuffer))));
    }
    function iy(e2, t3) {
      e2 || py(e2, true, t3, "==", fy);
    }
    var uy = /\s*function\s+([^\(\s]*)\s*/;
    function sy(e2) {
      if (Gm(e2)) {
        if (ny())
          return e2.name;
        var t3 = e2.toString().match(uy);
        return t3 && t3[1];
      }
    }
    function ay(e2) {
      this.name = "AssertionError", this.actual = e2.actual, this.expected = e2.expected, this.operator = e2.operator, e2.message ? (this.message = e2.message, this.generatedMessage = false) : (this.message = function(e3) {
        return cy(ly(e3.actual), 128) + " " + e3.operator + " " + cy(ly(e3.expected), 128);
      }(this), this.generatedMessage = true);
      var t3 = e2.stackStartFunction || py;
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, t3);
      else {
        var n2 = new Error();
        if (n2.stack) {
          var r2 = n2.stack, o2 = sy(t3), i2 = r2.indexOf("\n" + o2);
          if (i2 >= 0) {
            var u2 = r2.indexOf("\n", i2 + 1);
            r2 = r2.substring(u2 + 1);
          }
          this.stack = r2;
        }
      }
    }
    function cy(e2, t3) {
      return typeof e2 == "string" ? e2.length < t3 ? e2 : e2.slice(0, t3) : e2;
    }
    function ly(e2) {
      if (ny() || !Gm(e2))
        return Pm(e2);
      var t3 = sy(e2);
      return "[Function" + (t3 ? ": " + t3 : "") + "]";
    }
    function py(e2, t3, n2, r2, o2) {
      throw new ay({ message: n2, actual: e2, expected: t3, operator: r2, stackStartFunction: o2 });
    }
    function fy(e2, t3) {
      e2 || py(e2, true, t3, "==", fy);
    }
    function dy(e2, t3, n2) {
      e2 != t3 && py(e2, t3, n2, "==", dy);
    }
    function hy(e2, t3, n2) {
      e2 == t3 && py(e2, t3, n2, "!=", hy);
    }
    function gy(e2, t3, n2) {
      yy(e2, t3, false) || py(e2, t3, n2, "deepEqual", gy);
    }
    function my(e2, t3, n2) {
      yy(e2, t3, true) || py(e2, t3, n2, "deepStrictEqual", my);
    }
    function yy(e2, t3, n2, r2) {
      if (e2 === t3)
        return true;
      if (fp(e2) && fp(t3))
        return Km(e2, t3) === 0;
      if (Um(e2) && Um(t3))
        return e2.getTime() === t3.getTime();
      if (Wm(e2) && Wm(t3))
        return e2.source === t3.source && e2.global === t3.global && e2.multiline === t3.multiline && e2.lastIndex === t3.lastIndex && e2.ignoreCase === t3.ignoreCase;
      if (e2 !== null && typeof e2 == "object" || t3 !== null && typeof t3 == "object") {
        if (oy(e2) && oy(t3) && ry(e2) === ry(t3) && !(e2 instanceof Float32Array || e2 instanceof Float64Array))
          return Km(new Uint8Array(e2.buffer), new Uint8Array(t3.buffer)) === 0;
        if (fp(e2) !== fp(t3))
          return false;
        var o2 = (r2 = r2 || { actual: [], expected: [] }).actual.indexOf(e2);
        return o2 !== -1 && o2 === r2.expected.indexOf(t3) || (r2.actual.push(e2), r2.expected.push(t3), function(e3, t4, n3, r3) {
          if (e3 == null || t4 == null)
            return false;
          if (Hm(e3) || Hm(t4))
            return e3 === t4;
          if (n3 && Object.getPrototypeOf(e3) !== Object.getPrototypeOf(t4))
            return false;
          var o3 = Dy(e3), i2 = Dy(t4);
          if (o3 && !i2 || !o3 && i2)
            return false;
          if (o3)
            return yy(e3 = ty.call(e3), t4 = ty.call(t4), n3);
          var u2, s2, a2 = ey(e3), c2 = ey(t4);
          if (a2.length !== c2.length)
            return false;
          for (a2.sort(), c2.sort(), s2 = a2.length - 1; s2 >= 0; s2--)
            if (a2[s2] !== c2[s2])
              return false;
          for (s2 = a2.length - 1; s2 >= 0; s2--)
            if (!yy(e3[u2 = a2[s2]], t4[u2], n3, r3))
              return false;
          return true;
        }(e2, t3, n2, r2));
      }
      return n2 ? e2 === t3 : e2 == t3;
    }
    function Dy(e2) {
      return Object.prototype.toString.call(e2) == "[object Arguments]";
    }
    function Ey(e2, t3, n2) {
      yy(e2, t3, false) && py(e2, t3, n2, "notDeepEqual", Ey);
    }
    function Cy(e2, t3, n2) {
      yy(e2, t3, true) && py(e2, t3, n2, "notDeepStrictEqual", Cy);
    }
    function by(e2, t3, n2) {
      e2 !== t3 && py(e2, t3, n2, "===", by);
    }
    function vy(e2, t3, n2) {
      e2 === t3 && py(e2, t3, n2, "!==", vy);
    }
    function Ay(e2, t3) {
      if (!e2 || !t3)
        return false;
      if (Object.prototype.toString.call(t3) == "[object RegExp]")
        return t3.test(e2);
      try {
        if (e2 instanceof t3)
          return true;
      } catch (e3) {
      }
      return !Error.isPrototypeOf(t3) && t3.call({}, e2) === true;
    }
    function Fy(e2, t3, n2, r2) {
      var o2;
      if (typeof t3 != "function")
        throw new TypeError('"block" argument must be a function');
      typeof n2 == "string" && (r2 = n2, n2 = null), o2 = function(e3) {
        var t4;
        try {
          e3();
        } catch (e4) {
          t4 = e4;
        }
        return t4;
      }(t3), r2 = (n2 && n2.name ? " (" + n2.name + ")." : ".") + (r2 ? " " + r2 : "."), e2 && !o2 && py(o2, n2, "Missing expected exception" + r2);
      var i2 = typeof r2 == "string", u2 = !e2 && o2 && !n2;
      if ((!e2 && zm(o2) && i2 && Ay(o2, n2) || u2) && py(o2, n2, "Got unwanted exception" + r2), e2 && o2 && n2 && !Ay(o2, n2) || !e2 && o2)
        throw o2;
    }
    function xy(e2, t3, n2) {
      Fy(true, e2, t3, n2);
    }
    function Sy(e2, t3, n2) {
      Fy(false, e2, t3, n2);
    }
    function wy(e2) {
      if (e2)
        throw e2;
    }
    iy.AssertionError = ay, km(ay, Error), iy.fail = py, iy.ok = fy, iy.equal = dy, iy.notEqual = hy, iy.deepEqual = gy, iy.deepStrictEqual = my, iy.notDeepEqual = Ey, iy.notDeepStrictEqual = Cy, iy.strictEqual = by, iy.notStrictEqual = vy, iy.throws = xy, iy.doesNotThrow = Sy, iy.ifError = wy;
    var Ty = t2(Object.freeze({ __proto__: null, default: iy, AssertionError: ay, fail: py, ok: fy, assert: fy, equal: dy, notEqual: hy, deepEqual: gy, deepStrictEqual: my, notDeepEqual: Ey, notDeepStrictEqual: Cy, strictEqual: by, notStrictEqual: vy, throws: xy, doesNotThrow: Sy, ifError: wy }));
    const By = Ty, { builders: { line: Ny, hardline: ky, breakParent: Py, indent: Oy, lineSuffix: Iy, join: Ly, cursor: jy } } = Zc, { hasNewline: _y, skipNewline: My, skipSpaces: Ry, isPreviousLineEmpty: Vy, addLeadingComment: $y, addDanglingComment: Wy, addTrailingComment: qy } = dc, Uy = /* @__PURE__ */ new WeakMap();
    function zy(e2, t3, n2) {
      if (!e2)
        return;
      const { printer: r2, locStart: o2, locEnd: i2 } = t3;
      if (n2) {
        if (r2.canAttachComment && r2.canAttachComment(e2)) {
          let t4;
          for (t4 = n2.length - 1; t4 >= 0 && !(o2(n2[t4]) <= o2(e2) && i2(n2[t4]) <= i2(e2)); --t4)
            ;
          return void n2.splice(t4 + 1, 0, e2);
        }
      } else if (Uy.has(e2))
        return Uy.get(e2);
      const u2 = r2.getCommentChildNodes && r2.getCommentChildNodes(e2, t3) || typeof e2 == "object" && Object.entries(e2).filter((e3) => {
        let [t4] = e3;
        return t4 !== "enclosingNode" && t4 !== "precedingNode" && t4 !== "followingNode" && t4 !== "tokens" && t4 !== "comments";
      }).map((e3) => {
        let [, t4] = e3;
        return t4;
      });
      if (u2) {
        n2 || (n2 = [], Uy.set(e2, n2));
        for (const e3 of u2)
          zy(e3, t3, n2);
        return n2;
      }
    }
    function Gy(e2, t3, n2, r2) {
      const { locStart: o2, locEnd: i2 } = n2, u2 = o2(t3), s2 = i2(t3), a2 = zy(e2, n2);
      let c2, l2, p2 = 0, f2 = a2.length;
      for (; p2 < f2; ) {
        const e3 = p2 + f2 >> 1, r3 = a2[e3], d2 = o2(r3), h2 = i2(r3);
        if (d2 <= u2 && s2 <= h2)
          return Gy(r3, t3, n2, r3);
        if (h2 <= u2)
          c2 = r3, p2 = e3 + 1;
        else {
          if (!(s2 <= d2))
            throw new Error("Comment location overlaps with node location");
          l2 = r3, f2 = e3;
        }
      }
      if (r2 && r2.type === "TemplateLiteral") {
        const { quasis: e3 } = r2, o3 = Zy(e3, t3, n2);
        c2 && Zy(e3, c2, n2) !== o3 && (c2 = null), l2 && Zy(e3, l2, n2) !== o3 && (l2 = null);
      }
      return { enclosingNode: r2, precedingNode: c2, followingNode: l2 };
    }
    const Hy = () => false;
    const Jy = (e2) => !/[\S\n\u2028\u2029]/.test(e2);
    function Xy(e2, t3, n2, r2) {
      const { comment: o2, precedingNode: i2 } = n2[r2], { locStart: u2, locEnd: s2 } = t3;
      let a2 = u2(o2);
      if (i2)
        for (let t4 = r2 - 1; t4 >= 0; t4--) {
          const { comment: r3, precedingNode: o3 } = n2[t4];
          if (o3 !== i2 || !Jy(e2.slice(s2(r3), a2)))
            break;
          a2 = u2(r3);
        }
      return _y(e2, a2, { backwards: true });
    }
    function Yy(e2, t3, n2, r2) {
      const { comment: o2, followingNode: i2 } = n2[r2], { locStart: u2, locEnd: s2 } = t3;
      let a2 = s2(o2);
      if (i2)
        for (let t4 = r2 + 1; t4 < n2.length; t4++) {
          const { comment: r3, followingNode: o3 } = n2[t4];
          if (o3 !== i2 || !Jy(e2.slice(a2, u2(r3))))
            break;
          a2 = s2(r3);
        }
      return _y(e2, a2);
    }
    function Ky(e2, t3, n2) {
      const r2 = e2.length;
      if (r2 === 0)
        return;
      const { precedingNode: o2, followingNode: i2, enclosingNode: u2 } = e2[0], s2 = n2.printer.getGapRegex && n2.printer.getGapRegex(u2) || /^[\s(]*$/;
      let a2, c2 = n2.locStart(i2);
      for (a2 = r2; a2 > 0; --a2) {
        const { comment: r3, precedingNode: u3, followingNode: l2 } = e2[a2 - 1];
        By.strictEqual(u3, o2), By.strictEqual(l2, i2);
        const p2 = t3.slice(n2.locEnd(r3), c2);
        if (!s2.test(p2))
          break;
        c2 = n2.locStart(r3);
      }
      for (const [t4, { comment: n3 }] of e2.entries())
        t4 < a2 ? qy(o2, n3) : $y(i2, n3);
      for (const e3 of [o2, i2])
        e3.comments && e3.comments.length > 1 && e3.comments.sort((e4, t4) => n2.locStart(e4) - n2.locStart(t4));
      e2.length = 0;
    }
    function Qy(e2, t3) {
      return e2.getValue().printed = true, t3.printer.printComment(e2, t3);
    }
    function Zy(e2, t3, n2) {
      const r2 = n2.locStart(t3) - 1;
      for (let t4 = 1; t4 < e2.length; ++t4)
        if (r2 < n2.locStart(e2[t4]))
          return t4 - 1;
      return 0;
    }
    function eD(e2, t3, n2) {
      const r2 = e2.getValue();
      if (!r2)
        return {};
      let o2 = r2.comments || [];
      n2 && (o2 = o2.filter((e3) => !n2.has(e3)));
      const i2 = r2 === t3.cursorNode;
      if (o2.length === 0) {
        const e3 = i2 ? jy : "";
        return { leading: e3, trailing: e3 };
      }
      const u2 = [], s2 = [];
      return e2.each(() => {
        const r3 = e2.getValue();
        if (n2 && n2.has(r3))
          return;
        const { leading: o3, trailing: i3 } = r3;
        o3 ? u2.push(function(e3, t4) {
          const n3 = e3.getValue(), r4 = [Qy(e3, t4)], { printer: o4, originalText: i4, locStart: u3, locEnd: s3 } = t4;
          if (o4.isBlockComment && o4.isBlockComment(n3)) {
            const e4 = _y(i4, s3(n3)) ? _y(i4, u3(n3), { backwards: true }) ? ky : Ny : " ";
            r4.push(e4);
          } else
            r4.push(ky);
          const a2 = My(i4, Ry(i4, s3(n3)));
          return a2 !== false && _y(i4, a2) && r4.push(ky), r4;
        }(e2, t3)) : i3 && s2.push(function(e3, t4) {
          const n3 = e3.getValue(), r4 = Qy(e3, t4), { printer: o4, originalText: i4, locStart: u3 } = t4, s3 = o4.isBlockComment && o4.isBlockComment(n3);
          if (_y(i4, u3(n3), { backwards: true })) {
            const e4 = Vy(i4, n3, u3);
            return Iy([ky, e4 ? ky : "", r4]);
          }
          let a2 = [" ", r4];
          return s3 || (a2 = [Iy(a2), Py]), a2;
        }(e2, t3));
      }, "comments"), i2 && (u2.unshift(jy), s2.push(jy)), { leading: u2, trailing: s2 };
    }
    var tD = { attach: function(e2, t3, n2, r2) {
      if (!Array.isArray(e2))
        return;
      const o2 = [], { locStart: i2, locEnd: u2, printer: { handleComments: s2 = {} } } = r2, { avoidAstMutation: a2, ownLine: c2 = Hy, endOfLine: l2 = Hy, remaining: p2 = Hy } = s2, f2 = e2.map((o3, i3) => Object.assign(Object.assign({}, Gy(t3, o3, r2)), {}, { comment: o3, text: n2, options: r2, ast: t3, isLastComment: e2.length - 1 === i3 }));
      for (const [e3, t4] of f2.entries()) {
        const { comment: n3, precedingNode: r3, enclosingNode: s3, followingNode: d2, text: h2, options: g2, ast: m2, isLastComment: y2 } = t4;
        if (g2.parser === "json" || g2.parser === "json5" || g2.parser === "__js_expression" || g2.parser === "__vue_expression") {
          if (i2(n3) - i2(m2) <= 0) {
            $y(m2, n3);
            continue;
          }
          if (u2(n3) - u2(m2) >= 0) {
            qy(m2, n3);
            continue;
          }
        }
        let D2;
        if (a2 ? D2 = [t4] : (n3.enclosingNode = s3, n3.precedingNode = r3, n3.followingNode = d2, D2 = [n3, h2, g2, m2, y2]), Xy(h2, g2, f2, e3))
          n3.placement = "ownLine", c2(...D2) || (d2 ? $y(d2, n3) : r3 ? qy(r3, n3) : Wy(s3 || m2, n3));
        else if (Yy(h2, g2, f2, e3))
          n3.placement = "endOfLine", l2(...D2) || (r3 ? qy(r3, n3) : d2 ? $y(d2, n3) : Wy(s3 || m2, n3));
        else if (n3.placement = "remaining", p2(...D2))
          ;
        else if (r3 && d2) {
          const e4 = o2.length;
          if (e4 > 0) {
            o2[e4 - 1].followingNode !== d2 && Ky(o2, h2, g2);
          }
          o2.push(t4);
        } else
          r3 ? qy(r3, n3) : d2 ? $y(d2, n3) : Wy(s3 || m2, n3);
      }
      if (Ky(o2, n2, r2), !a2)
        for (const t4 of e2)
          delete t4.precedingNode, delete t4.enclosingNode, delete t4.followingNode;
    }, printComments: function(e2, t3, n2, r2) {
      const { leading: o2, trailing: i2 } = eD(e2, n2, r2);
      return o2 || i2 ? [o2, t3, i2] : t3;
    }, printCommentsSeparately: eD, printDanglingComments: function(e2, t3, n2, r2) {
      const o2 = [], i2 = e2.getValue();
      return i2 && i2.comments ? (e2.each(() => {
        const n3 = e2.getValue();
        n3.leading || n3.trailing || r2 && !r2(n3) || o2.push(Qy(e2, t3));
      }, "comments"), o2.length === 0 ? "" : n2 ? Ly(ky, o2) : Oy([ky, Ly(ky, o2)])) : "";
    }, getSortedChildNodes: zy, ensureAllCommentsPrinted: function(e2) {
      if (e2)
        for (const t3 of e2) {
          if (!t3.printed)
            throw new Error('Comment "' + t3.value.trim() + '" was not printed. Please report this error!');
          delete t3.printed;
        }
    } };
    const nD = au;
    function rD(e2, t3) {
      const n2 = oD(e2.stack, t3);
      return n2 === -1 ? null : e2.stack[n2];
    }
    function oD(e2, t3) {
      for (let n2 = e2.length - 1; n2 >= 0; n2 -= 2) {
        const r2 = e2[n2];
        if (r2 && !Array.isArray(r2) && --t3 < 0)
          return n2;
      }
      return -1;
    }
    var iD = class {
      constructor(e2) {
        this.stack = [e2];
      }
      getName() {
        const { stack: e2 } = this, { length: t3 } = e2;
        return t3 > 1 ? e2[t3 - 2] : null;
      }
      getValue() {
        return nD(this.stack);
      }
      getNode() {
        return rD(this, arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0);
      }
      getParentNode() {
        return rD(this, (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0) + 1);
      }
      call(e2) {
        const { stack: t3 } = this, { length: n2 } = t3;
        let r2 = nD(t3);
        for (var o2 = arguments.length, i2 = new Array(o2 > 1 ? o2 - 1 : 0), u2 = 1; u2 < o2; u2++)
          i2[u2 - 1] = arguments[u2];
        for (const e3 of i2)
          r2 = r2[e3], t3.push(e3, r2);
        const s2 = e2(this);
        return t3.length = n2, s2;
      }
      callParent(e2) {
        let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        const n2 = oD(this.stack, t3 + 1), r2 = this.stack.splice(n2 + 1), o2 = e2(this);
        return this.stack.push(...r2), o2;
      }
      each(e2) {
        const { stack: t3 } = this, { length: n2 } = t3;
        let r2 = nD(t3);
        for (var o2 = arguments.length, i2 = new Array(o2 > 1 ? o2 - 1 : 0), u2 = 1; u2 < o2; u2++)
          i2[u2 - 1] = arguments[u2];
        for (const e3 of i2)
          r2 = r2[e3], t3.push(e3, r2);
        for (let n3 = 0; n3 < r2.length; ++n3)
          t3.push(n3, r2[n3]), e2(this, n3, r2), t3.length -= 2;
        t3.length = n2;
      }
      map(e2) {
        const t3 = [];
        for (var n2 = arguments.length, r2 = new Array(n2 > 1 ? n2 - 1 : 0), o2 = 1; o2 < n2; o2++)
          r2[o2 - 1] = arguments[o2];
        return this.each((n3, r3, o3) => {
          t3[r3] = e2(n3, r3, o3);
        }, ...r2), t3;
      }
      try(e2) {
        const { stack: t3 } = this, n2 = [...t3];
        try {
          return e2();
        } finally {
          t3.length = 0, t3.push(...n2);
        }
      }
      match() {
        let e2 = this.stack.length - 1, t3 = null, n2 = this.stack[e2--];
        for (var r2 = arguments.length, o2 = new Array(r2), i2 = 0; i2 < r2; i2++)
          o2[i2] = arguments[i2];
        for (const r3 of o2) {
          if (n2 === void 0)
            return false;
          let o3 = null;
          if (typeof t3 == "number" && (o3 = t3, t3 = this.stack[e2--], n2 = this.stack[e2--]), r3 && !r3(n2, t3, o3))
            return false;
          t3 = this.stack[e2--], n2 = this.stack[e2--];
        }
        return true;
      }
      findAncestor(e2) {
        let t3 = this.stack.length - 1, n2 = null, r2 = this.stack[t3--];
        for (; r2; ) {
          let o2 = null;
          if (typeof n2 == "number" && (o2 = n2, n2 = this.stack[t3--], r2 = this.stack[t3--]), n2 !== null && e2(r2, n2, o2))
            return r2;
          n2 = this.stack[t3--], r2 = this.stack[t3--];
        }
      }
    };
    const { utils: { stripTrailingHardline: uD } } = Zc, { normalize: sD } = Bm, aD = tD;
    var cD = { printSubtree: function(e2, t3, n2, r2) {
      if (n2.printer.embed && n2.embeddedLanguageFormatting === "auto")
        return n2.printer.embed(e2, t3, (e3, t4, o2) => function(e4, t5, n3, r3) {
          let { stripTrailingHardline: o3 = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
          const i2 = sD(Object.assign(Object.assign(Object.assign({}, n3), t5), {}, { parentParser: n3.parser, originalText: e4 }), { passThrough: true }), u2 = Dm.parse(e4, i2), { ast: s2 } = u2;
          e4 = u2.text;
          const a2 = s2.comments;
          delete s2.comments, aD.attach(a2, s2, e4, i2), i2[Symbol.for("comments")] = a2 || [], i2[Symbol.for("tokens")] = s2.tokens || [];
          const c2 = r3(s2, i2);
          if (aD.ensureAllCommentsPrinted(a2), o3)
            return typeof c2 == "string" ? c2.replace(/(?:\r?\n)*$/, "") : uD(c2);
          return c2;
        }(e3, t4, n2, r2, o2), n2);
    } };
    const lD = iD, { builders: { hardline: pD, addAlignmentToDoc: fD }, utils: { propagateBreaks: dD } } = Zc, { printComments: hD } = tD, gD = cD;
    function mD(e2, t3) {
      let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      const { printer: r2 } = t3;
      r2.preprocess && (e2 = r2.preprocess(e2, t3));
      const o2 = /* @__PURE__ */ new Map(), i2 = new lD(e2);
      let u2 = s2();
      return n2 > 0 && (u2 = fD([pD, u2], n2, t3.tabWidth)), dD(u2), u2;
      function s2(e3, t4) {
        return e3 === void 0 || e3 === i2 ? a2(t4) : Array.isArray(e3) ? i2.call(() => a2(t4), ...e3) : i2.call(() => a2(t4), e3);
      }
      function a2(e3) {
        const n3 = i2.getValue(), r3 = n3 && typeof n3 == "object" && e3 === void 0;
        if (r3 && o2.has(n3))
          return o2.get(n3);
        const u3 = yD(i2, t3, s2, e3);
        return r3 && o2.set(n3, u3), u3;
      }
    }
    function yD(t3, n2, r2, o2) {
      const i2 = t3.getValue(), { printer: u2 } = n2;
      let s2, a2;
      if (u2.hasPrettierIgnore && u2.hasPrettierIgnore(t3))
        ({ doc: s2, printedComments: a2 } = function(e2, t4) {
          const { originalText: n3, [Symbol.for("comments")]: r3, locStart: o3, locEnd: i3 } = t4, u3 = o3(e2), s3 = i3(e2), a3 = /* @__PURE__ */ new Set();
          for (const e3 of r3)
            o3(e3) >= u3 && i3(e3) <= s3 && (e3.printed = true, a3.add(e3));
          return { doc: n3.slice(u3, s3), printedComments: a3 };
        }(i2, n2));
      else {
        if (i2)
          try {
            s2 = gD.printSubtree(t3, r2, n2, mD);
          } catch (t4) {
            if (e.PRETTIER_DEBUG)
              throw t4;
          }
        s2 || (s2 = u2.print(t3, n2, r2, o2));
      }
      return u2.willPrintOwnComments && u2.willPrintOwnComments(t3, n2) || (s2 = hD(t3, s2, n2, a2)), s2;
    }
    var DD2 = mD;
    const ED = Ty, CD = tD;
    function bD(e2) {
      let t3 = e2.length - 1;
      for (; ; ) {
        const n2 = e2[t3];
        if (!n2 || n2.type !== "Program" && n2.type !== "File")
          break;
        t3--;
      }
      return e2.slice(0, t3 + 1);
    }
    function vD(e2, t3, n2, r2) {
      let o2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], i2 = arguments.length > 5 ? arguments[5] : void 0;
      const { locStart: u2, locEnd: s2 } = n2, a2 = u2(e2), c2 = s2(e2);
      if (!(t3 > c2 || t3 < a2 || i2 === "rangeEnd" && t3 === a2 || i2 === "rangeStart" && t3 === c2)) {
        for (const u3 of CD.getSortedChildNodes(e2, n2)) {
          const s3 = vD(u3, t3, n2, r2, [e2, ...o2], i2);
          if (s3)
            return s3;
        }
        return !r2 || r2(e2, o2[0]) ? { node: e2, parentNodes: o2 } : void 0;
      }
    }
    const AD = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), FD = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
    function xD(e2, t3, n2) {
      if (!t3)
        return false;
      switch (e2.parser) {
        case "flow":
        case "babel":
        case "babel-flow":
        case "babel-ts":
        case "typescript":
        case "espree":
        case "meriyah":
        case "__babel_estree":
          return function(e3, t4) {
            return t4 !== "DeclareExportDeclaration" && e3 !== "TypeParameterDeclaration" && (e3 === "Directive" || e3 === "TypeAlias" || e3 === "TSExportAssignment" || e3.startsWith("Declare") || e3.startsWith("TSDeclare") || e3.endsWith("Statement") || e3.endsWith("Declaration"));
          }(t3.type, n2 && n2.type);
        case "json":
        case "json5":
        case "json-stringify":
          return AD.has(t3.type);
        case "graphql":
          return FD.has(t3.kind);
        case "vue":
          return t3.tag !== "root";
      }
      return false;
    }
    var SD = { calculateRange: function(e2, t3, n2) {
      let { rangeStart: r2, rangeEnd: o2, locStart: i2, locEnd: u2 } = t3;
      ED.ok(o2 > r2);
      const s2 = e2.slice(r2, o2).search(/\S/), a2 = s2 === -1;
      if (!a2)
        for (r2 += s2; o2 > r2 && !/\S/.test(e2[o2 - 1]); --o2)
          ;
      const c2 = vD(n2, r2, t3, (e3, n3) => xD(t3, e3, n3), [], "rangeStart"), l2 = a2 ? c2 : vD(n2, o2, t3, (e3) => xD(t3, e3), [], "rangeEnd");
      if (!c2 || !l2)
        return { rangeStart: 0, rangeEnd: 0 };
      let p2, f2;
      if (((e3) => {
        let { parser: t4 } = e3;
        return t4 === "json" || t4 === "json5" || t4 === "json-stringify";
      })(t3)) {
        const e3 = function(e4, t4) {
          const n3 = [e4.node, ...e4.parentNodes], r3 = /* @__PURE__ */ new Set([t4.node, ...t4.parentNodes]);
          return n3.find((e5) => AD.has(e5.type) && r3.has(e5));
        }(c2, l2);
        p2 = e3, f2 = e3;
      } else
        ({ startNode: p2, endNode: f2 } = function(e3, t4, n3) {
          let { locStart: r3, locEnd: o3 } = n3, i3 = e3.node, u3 = t4.node;
          if (i3 === u3)
            return { startNode: i3, endNode: u3 };
          const s3 = r3(e3.node);
          for (const e4 of bD(t4.parentNodes)) {
            if (!(r3(e4) >= s3))
              break;
            u3 = e4;
          }
          const a3 = o3(t4.node);
          for (const t5 of bD(e3.parentNodes)) {
            if (!(o3(t5) <= a3))
              break;
            i3 = t5;
          }
          return { startNode: i3, endNode: u3 };
        }(c2, l2, t3));
      return { rangeStart: Math.min(i2(p2), i2(f2)), rangeEnd: Math.max(u2(p2), u2(f2)) };
    }, findNodeAtOffset: vD };
    const wD = r, { printer: { printDocToString: TD }, debug: { printDocToDebug: BD } } = Zc, { getAlignmentSize: ND } = dc, { guessEndOfLine: kD, convertEndOfLineToChars: PD, countEndOfLineChars: OD, normalizeEndOfLine: ID } = hc, LD = Bm.normalize, jD = Nm, _D = tD, MD = Dm, RD = DD2, VD = SD, $D = Symbol("cursor");
    function WD(e2, t3, n2) {
      const r2 = t3.comments;
      return r2 && (delete t3.comments, _D.attach(r2, t3, e2, n2)), n2[Symbol.for("comments")] = r2 || [], n2[Symbol.for("tokens")] = t3.tokens || [], n2.originalText = e2, r2;
    }
    function qD(e2, t3) {
      let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      if (!e2 || e2.trim().length === 0)
        return { formatted: "", cursorOffset: -1, comments: [] };
      const { ast: r2, text: o2 } = MD.parse(e2, t3);
      if (t3.cursorOffset >= 0) {
        const e3 = VD.findNodeAtOffset(r2, t3.cursorOffset, t3);
        e3 && e3.node && (t3.cursorNode = e3.node);
      }
      const i2 = WD(o2, r2, t3), u2 = RD(r2, t3, n2), s2 = TD(u2, t3);
      if (_D.ensureAllCommentsPrinted(i2), n2 > 0) {
        const e3 = s2.formatted.trim();
        s2.cursorNodeStart !== void 0 && (s2.cursorNodeStart -= s2.formatted.indexOf(e3)), s2.formatted = e3 + PD(t3.endOfLine);
      }
      if (t3.cursorOffset >= 0) {
        let e3, n3, r3, u3, a2;
        if (t3.cursorNode && s2.cursorNodeText ? (e3 = t3.locStart(t3.cursorNode), n3 = o2.slice(e3, t3.locEnd(t3.cursorNode)), r3 = t3.cursorOffset - e3, u3 = s2.cursorNodeStart, a2 = s2.cursorNodeText) : (e3 = 0, n3 = o2, r3 = t3.cursorOffset, u3 = 0, a2 = s2.formatted), n3 === a2)
          return { formatted: s2.formatted, cursorOffset: u3 + r3, comments: i2 };
        const c2 = [...n3];
        c2.splice(r3, 0, $D);
        const l2 = [...a2], p2 = wD.diffArrays(c2, l2);
        let f2 = u3;
        for (const e4 of p2)
          if (e4.removed) {
            if (e4.value.includes($D))
              break;
          } else
            f2 += e4.count;
        return { formatted: s2.formatted, cursorOffset: f2, comments: i2 };
      }
      return { formatted: s2.formatted, cursorOffset: -1, comments: i2 };
    }
    function UD(e2, t3, n2) {
      return typeof t3 != "number" || Number.isNaN(t3) || t3 < 0 || t3 > e2.length ? n2 : t3;
    }
    function zD(e2, t3) {
      let { cursorOffset: n2, rangeStart: r2, rangeEnd: o2 } = t3;
      return n2 = UD(e2, n2, -1), r2 = UD(e2, r2, 0), o2 = UD(e2, o2, e2.length), Object.assign(Object.assign({}, t3), {}, { cursorOffset: n2, rangeStart: r2, rangeEnd: o2 });
    }
    function GD(e2, t3) {
      let { cursorOffset: n2, rangeStart: r2, rangeEnd: o2, endOfLine: i2 } = zD(e2, t3);
      const u2 = e2.charAt(0) === "\uFEFF";
      if (u2 && (e2 = e2.slice(1), n2--, r2--, o2--), i2 === "auto" && (i2 = kD(e2)), e2.includes("\r")) {
        const t4 = (t5) => OD(e2.slice(0, Math.max(t5, 0)), "\r\n");
        n2 -= t4(n2), r2 -= t4(r2), o2 -= t4(o2), e2 = ID(e2);
      }
      return { hasBOM: u2, text: e2, options: zD(e2, Object.assign(Object.assign({}, t3), {}, { cursorOffset: n2, rangeStart: r2, rangeEnd: o2, endOfLine: i2 })) };
    }
    function HD(e2, t3) {
      const n2 = MD.resolveParser(t3);
      return !n2.hasPragma || n2.hasPragma(e2);
    }
    function JD(e2, t3) {
      let n2, { hasBOM: r2, text: o2, options: i2 } = GD(e2, LD(t3));
      return i2.rangeStart >= i2.rangeEnd && o2 !== "" || i2.requirePragma && !HD(o2, i2) ? { formatted: e2, cursorOffset: t3.cursorOffset, comments: [] } : (i2.rangeStart > 0 || i2.rangeEnd < o2.length ? n2 = function(e3, t4) {
        const { ast: n3, text: r3 } = MD.parse(e3, t4), { rangeStart: o3, rangeEnd: i3 } = VD.calculateRange(r3, t4, n3), u2 = r3.slice(o3, i3), s2 = Math.min(o3, r3.lastIndexOf("\n", o3) + 1), a2 = r3.slice(s2, o3).match(/^\s*/)[0], c2 = ND(a2, t4.tabWidth), l2 = qD(u2, Object.assign(Object.assign({}, t4), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t4.cursorOffset > o3 && t4.cursorOffset <= i3 ? t4.cursorOffset - o3 : -1, endOfLine: "lf" }), c2), p2 = l2.formatted.trimEnd();
        let { cursorOffset: f2 } = t4;
        f2 > i3 ? f2 += p2.length - u2.length : l2.cursorOffset >= 0 && (f2 = l2.cursorOffset + o3);
        let d2 = r3.slice(0, o3) + p2 + r3.slice(i3);
        if (t4.endOfLine !== "lf") {
          const e4 = PD(t4.endOfLine);
          f2 >= 0 && e4 === "\r\n" && (f2 += OD(d2.slice(0, f2), "\n")), d2 = d2.replace(/\n/g, e4);
        }
        return { formatted: d2, cursorOffset: f2, comments: l2.comments };
      }(o2, i2) : (!i2.requirePragma && i2.insertPragma && i2.printer.insertPragma && !HD(o2, i2) && (o2 = i2.printer.insertPragma(o2)), n2 = qD(o2, i2)), r2 && (n2.formatted = "\uFEFF" + n2.formatted, n2.cursorOffset >= 0 && n2.cursorOffset++), n2);
    }
    var XD = { formatWithCursor: JD, parse(e2, t3, n2) {
      const { text: r2, options: o2 } = GD(e2, LD(t3)), i2 = MD.parse(r2, o2);
      return n2 && (i2.ast = jD(i2.ast, o2)), i2;
    }, formatAST(e2, t3) {
      t3 = LD(t3);
      const n2 = RD(e2, t3);
      return TD(n2, t3);
    }, formatDoc: (e2, t3) => JD(BD(e2), Object.assign(Object.assign({}, t3), {}, { parser: "__js_expression" })).formatted, printToDoc(e2, t3) {
      t3 = LD(t3);
      const { ast: n2, text: r2 } = MD.parse(e2, t3);
      return WD(r2, n2, t3), RD(n2, t3);
    }, printDocToString: (e2, t3) => TD(e2, LD(t3)) };
    const { getMaxContinuousCount: YD, getStringWidth: KD, getAlignmentSize: QD, getIndentSize: ZD, skip: eE, skipWhitespace: tE, skipSpaces: nE, skipNewline: rE, skipToLineEnd: oE, skipEverythingButNewLine: iE, skipInlineComment: uE, skipTrailingComment: sE, hasNewline: aE, hasNewlineInRange: cE, hasSpaces: lE2, isNextLineEmpty: pE, isNextLineEmptyAfterIndex: fE, isPreviousLineEmpty: dE, getNextNonSpaceNonCommentCharacterIndex: hE, makeString: gE2, addLeadingComment: mE, addDanglingComment: yE, addTrailingComment: DE } = dc;
    var EE = { getMaxContinuousCount: YD, getStringWidth: KD, getAlignmentSize: QD, getIndentSize: ZD, skip: eE, skipWhitespace: tE, skipSpaces: nE, skipNewline: rE, skipToLineEnd: oE, skipEverythingButNewLine: iE, skipInlineComment: uE, skipTrailingComment: sE, hasNewline: aE, hasNewlineInRange: cE, hasSpaces: lE2, isNextLineEmpty: pE, isNextLineEmptyAfterIndex: fE, isPreviousLineEmpty: dE, getNextNonSpaceNonCommentCharacterIndex: hE, makeString: gE2, addLeadingComment: mE, addDanglingComment: yE, addTrailingComment: DE };
    const CE = ["languageId"];
    var bE = function(e2, t3) {
      const { languageId: n2 } = e2, r2 = cu(e2, CE);
      return Object.assign(Object.assign({ linguistLanguageId: n2 }, r2), t3(e2));
    }, vE = {}, AE = { exports: {} };
    !function() {
      function e2(e3) {
        if (e3 == null)
          return false;
        switch (e3.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function t3(e3) {
        switch (e3.type) {
          case "IfStatement":
            return e3.alternate != null ? e3.alternate : e3.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return e3.body;
        }
        return null;
      }
      AE.exports = { isExpression: function(e3) {
        if (e3 == null)
          return false;
        switch (e3.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }, isStatement: e2, isIterationStatement: function(e3) {
        if (e3 == null)
          return false;
        switch (e3.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }, isSourceElement: function(t4) {
        return e2(t4) || t4 != null && t4.type === "FunctionDeclaration";
      }, isProblematicIfStatement: function(e3) {
        var n2;
        if (e3.type !== "IfStatement")
          return false;
        if (e3.alternate == null)
          return false;
        n2 = e3.consequent;
        do {
          if (n2.type === "IfStatement" && n2.alternate == null)
            return true;
          n2 = t3(n2);
        } while (n2);
        return false;
      }, trailingStatement: t3 };
    }();
    var FE = { exports: {} };
    !function() {
      var e2, t3, n2, r2, o2, i2;
      function u2(e3) {
        return e3 <= 65535 ? String.fromCharCode(e3) : String.fromCharCode(Math.floor((e3 - 65536) / 1024) + 55296) + String.fromCharCode((e3 - 65536) % 1024 + 56320);
      }
      for (t3 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, e2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, n2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], r2 = new Array(128), i2 = 0; i2 < 128; ++i2)
        r2[i2] = i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 === 36 || i2 === 95;
      for (o2 = new Array(128), i2 = 0; i2 < 128; ++i2)
        o2[i2] = i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 >= 48 && i2 <= 57 || i2 === 36 || i2 === 95;
      FE.exports = { isDecimalDigit: function(e3) {
        return 48 <= e3 && e3 <= 57;
      }, isHexDigit: function(e3) {
        return 48 <= e3 && e3 <= 57 || 97 <= e3 && e3 <= 102 || 65 <= e3 && e3 <= 70;
      }, isOctalDigit: function(e3) {
        return e3 >= 48 && e3 <= 55;
      }, isWhiteSpace: function(e3) {
        return e3 === 32 || e3 === 9 || e3 === 11 || e3 === 12 || e3 === 160 || e3 >= 5760 && n2.indexOf(e3) >= 0;
      }, isLineTerminator: function(e3) {
        return e3 === 10 || e3 === 13 || e3 === 8232 || e3 === 8233;
      }, isIdentifierStartES5: function(e3) {
        return e3 < 128 ? r2[e3] : t3.NonAsciiIdentifierStart.test(u2(e3));
      }, isIdentifierPartES5: function(e3) {
        return e3 < 128 ? o2[e3] : t3.NonAsciiIdentifierPart.test(u2(e3));
      }, isIdentifierStartES6: function(t4) {
        return t4 < 128 ? r2[t4] : e2.NonAsciiIdentifierStart.test(u2(t4));
      }, isIdentifierPartES6: function(t4) {
        return t4 < 128 ? o2[t4] : e2.NonAsciiIdentifierPart.test(u2(t4));
      } };
    }();
    var xE = { exports: {} };
    !function() {
      var e2 = FE.exports;
      function t3(e3, t4) {
        return !(!t4 && e3 === "yield") && n2(e3, t4);
      }
      function n2(e3, t4) {
        if (t4 && function(e4) {
          switch (e4) {
            case "implements":
            case "interface":
            case "package":
            case "private":
            case "protected":
            case "public":
            case "static":
            case "let":
              return true;
            default:
              return false;
          }
        }(e3))
          return true;
        switch (e3.length) {
          case 2:
            return e3 === "if" || e3 === "in" || e3 === "do";
          case 3:
            return e3 === "var" || e3 === "for" || e3 === "new" || e3 === "try";
          case 4:
            return e3 === "this" || e3 === "else" || e3 === "case" || e3 === "void" || e3 === "with" || e3 === "enum";
          case 5:
            return e3 === "while" || e3 === "break" || e3 === "catch" || e3 === "throw" || e3 === "const" || e3 === "yield" || e3 === "class" || e3 === "super";
          case 6:
            return e3 === "return" || e3 === "typeof" || e3 === "delete" || e3 === "switch" || e3 === "export" || e3 === "import";
          case 7:
            return e3 === "default" || e3 === "finally" || e3 === "extends";
          case 8:
            return e3 === "function" || e3 === "continue" || e3 === "debugger";
          case 10:
            return e3 === "instanceof";
          default:
            return false;
        }
      }
      function r2(e3, n3) {
        return e3 === "null" || e3 === "true" || e3 === "false" || t3(e3, n3);
      }
      function o2(e3, t4) {
        return e3 === "null" || e3 === "true" || e3 === "false" || n2(e3, t4);
      }
      function i2(t4) {
        var n3, r3, o3;
        if (t4.length === 0)
          return false;
        if (o3 = t4.charCodeAt(0), !e2.isIdentifierStartES5(o3))
          return false;
        for (n3 = 1, r3 = t4.length; n3 < r3; ++n3)
          if (o3 = t4.charCodeAt(n3), !e2.isIdentifierPartES5(o3))
            return false;
        return true;
      }
      function u2(t4) {
        var n3, r3, o3, i3, u3;
        if (t4.length === 0)
          return false;
        for (u3 = e2.isIdentifierStartES6, n3 = 0, r3 = t4.length; n3 < r3; ++n3) {
          if (55296 <= (o3 = t4.charCodeAt(n3)) && o3 <= 56319) {
            if (++n3 >= r3)
              return false;
            if (!(56320 <= (i3 = t4.charCodeAt(n3)) && i3 <= 57343))
              return false;
            o3 = 1024 * (o3 - 55296) + (i3 - 56320) + 65536;
          }
          if (!u3(o3))
            return false;
          u3 = e2.isIdentifierPartES6;
        }
        return true;
      }
      xE.exports = { isKeywordES5: t3, isKeywordES6: n2, isReservedWordES5: r2, isReservedWordES6: o2, isRestrictedWord: function(e3) {
        return e3 === "eval" || e3 === "arguments";
      }, isIdentifierNameES5: i2, isIdentifierNameES6: u2, isIdentifierES5: function(e3, t4) {
        return i2(e3) && !r2(e3, t4);
      }, isIdentifierES6: function(e3, t4) {
        return u2(e3) && !o2(e3, t4);
      } };
    }(), vE.ast = AE.exports, vE.code = FE.exports, vE.keyword = xE.exports;
    const SE = vE.keyword.isIdentifierNameES5, { getLast: wE, hasNewline: TE, skipWhitespace: BE, isNonEmptyArray: NE, isNextLineEmptyAfterIndex: kE, getStringWidth: PE } = dc, { locStart: OE, locEnd: IE, hasSameLocStart: LE } = og, jE = "(?:(?=.)\\s)", _E = new RegExp("^".concat(jE, "*:")), ME = new RegExp("^".concat(jE, "*::"));
    function RE(e2) {
      return e2.type === "Block" || e2.type === "CommentBlock" || e2.type === "MultiLine";
    }
    function VE(e2) {
      return e2.type === "Line" || e2.type === "CommentLine" || e2.type === "SingleLine" || e2.type === "HashbangComment" || e2.type === "HTMLOpen" || e2.type === "HTMLClose";
    }
    const $E = /* @__PURE__ */ new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
    function WE(e2) {
      return e2 && $E.has(e2.type);
    }
    function qE(e2) {
      return e2.type === "NumericLiteral" || e2.type === "Literal" && typeof e2.value == "number";
    }
    function UE(e2) {
      return e2.type === "StringLiteral" || e2.type === "Literal" && typeof e2.value == "string";
    }
    function zE(e2) {
      return e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression";
    }
    function GE(e2) {
      return ZE(e2) && e2.callee.type === "Identifier" && (e2.callee.name === "async" || e2.callee.name === "inject" || e2.callee.name === "fakeAsync");
    }
    function HE(e2) {
      return e2.type === "JSXElement" || e2.type === "JSXFragment";
    }
    function JE(e2) {
      return e2.kind === "get" || e2.kind === "set";
    }
    function XE(e2) {
      return JE(e2) || LE(e2, e2.value);
    }
    const YE = /* @__PURE__ */ new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
    const KE = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
    const QE = /^(?:skip|[fx]?(?:it|describe|test))$/;
    function ZE(e2) {
      return e2 && (e2.type === "CallExpression" || e2.type === "OptionalCallExpression");
    }
    function eC(e2) {
      return e2 && (e2.type === "MemberExpression" || e2.type === "OptionalMemberExpression");
    }
    function tC(e2) {
      return /^(?:\d+|\d+\.\d+)$/.test(e2);
    }
    function nC(e2) {
      return e2.quasis.some((e3) => e3.value.raw.includes("\n"));
    }
    function rC(e2) {
      return e2.extra ? e2.extra.raw : e2.raw;
    }
    const oC = { "==": true, "!=": true, "===": true, "!==": true }, iC = { "*": true, "/": true, "%": true }, uC = { ">>": true, ">>>": true, "<<": true };
    const sC = {};
    for (const [e2, t3] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
      for (const n2 of t3)
        sC[n2] = e2;
    function aC(e2) {
      return sC[e2];
    }
    const cC = /* @__PURE__ */ new WeakMap();
    function lC(e2) {
      if (cC.has(e2))
        return cC.get(e2);
      const t3 = [];
      return e2.this && t3.push(e2.this), Array.isArray(e2.parameters) ? t3.push(...e2.parameters) : Array.isArray(e2.params) && t3.push(...e2.params), e2.rest && t3.push(e2.rest), cC.set(e2, t3), t3;
    }
    const pC = /* @__PURE__ */ new WeakMap();
    function fC(e2) {
      if (pC.has(e2))
        return pC.get(e2);
      let t3 = e2.arguments;
      return e2.type === "ImportExpression" && (t3 = [e2.source], e2.attributes && t3.push(e2.attributes)), pC.set(e2, t3), t3;
    }
    function dC(e2) {
      return e2.value.trim() === "prettier-ignore" && !e2.unignore;
    }
    function hC(e2) {
      return e2 && (e2.prettierIgnore || yC(e2, gC.PrettierIgnore));
    }
    const gC = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, mC = (e2, t3) => {
      if (typeof e2 == "function" && (t3 = e2, e2 = 0), e2 || t3)
        return (n2, r2, o2) => !(e2 & gC.Leading && !n2.leading || e2 & gC.Trailing && !n2.trailing || e2 & gC.Dangling && (n2.leading || n2.trailing) || e2 & gC.Block && !RE(n2) || e2 & gC.Line && !VE(n2) || e2 & gC.First && r2 !== 0 || e2 & gC.Last && r2 !== o2.length - 1 || e2 & gC.PrettierIgnore && !dC(n2) || t3 && !t3(n2));
    };
    function yC(e2, t3, n2) {
      if (!e2 || !NE(e2.comments))
        return false;
      const r2 = mC(t3, n2);
      return !r2 || e2.comments.some(r2);
    }
    function DC(e2, t3, n2) {
      if (!e2 || !Array.isArray(e2.comments))
        return [];
      const r2 = mC(t3, n2);
      return r2 ? e2.comments.filter(r2) : e2.comments;
    }
    function EC(e2) {
      return ZE(e2) || e2.type === "NewExpression" || e2.type === "ImportExpression";
    }
    var CC = { getFunctionParameters: lC, iterateFunctionParametersPath: function(e2, t3) {
      const n2 = e2.getValue();
      let r2 = 0;
      const o2 = (e3) => t3(e3, r2++);
      n2.this && e2.call(o2, "this"), Array.isArray(n2.parameters) ? e2.each(o2, "parameters") : Array.isArray(n2.params) && e2.each(o2, "params"), n2.rest && e2.call(o2, "rest");
    }, getCallArguments: fC, iterateCallArgumentsPath: function(e2, t3) {
      const n2 = e2.getValue();
      n2.type === "ImportExpression" ? (e2.call((e3) => t3(e3, 0), "source"), n2.attributes && e2.call((e3) => t3(e3, 1), "attributes")) : e2.each(t3, "arguments");
    }, hasRestParameter: function(e2) {
      if (e2.rest)
        return true;
      const t3 = lC(e2);
      return t3.length > 0 && wE(t3).type === "RestElement";
    }, getLeftSide: function(e2) {
      return e2.expressions ? e2.expressions[0] : e2.left || e2.test || e2.callee || e2.object || e2.tag || e2.argument || e2.expression;
    }, getLeftSidePathName: function(e2, t3) {
      if (t3.expressions)
        return ["expressions", 0];
      if (t3.left)
        return ["left"];
      if (t3.test)
        return ["test"];
      if (t3.object)
        return ["object"];
      if (t3.callee)
        return ["callee"];
      if (t3.tag)
        return ["tag"];
      if (t3.argument)
        return ["argument"];
      if (t3.expression)
        return ["expression"];
      throw new Error("Unexpected node has no left side.");
    }, getParentExportDeclaration: function(e2) {
      const t3 = e2.getParentNode();
      return e2.getName() === "declaration" && WE(t3) ? t3 : null;
    }, getTypeScriptMappedTypeModifier: function(e2, t3) {
      return e2 === "+" ? "+" + t3 : e2 === "-" ? "-" + t3 : t3;
    }, hasFlowAnnotationComment: function(e2) {
      return NE(e2) && RE(e2[0]) && ME.test(e2[0].value);
    }, hasFlowShorthandAnnotationComment: function(e2) {
      return e2.extra && e2.extra.parenthesized && NE(e2.trailingComments) && RE(e2.trailingComments[0]) && _E.test(e2.trailingComments[0].value);
    }, hasLeadingOwnLineComment: function(e2, t3) {
      return HE(t3) ? hC(t3) : yC(t3, gC.Leading, (t4) => TE(e2, IE(t4)));
    }, hasNakedLeftSide: function(e2) {
      return e2.type === "AssignmentExpression" || e2.type === "BinaryExpression" || e2.type === "LogicalExpression" || e2.type === "NGPipeExpression" || e2.type === "ConditionalExpression" || ZE(e2) || eC(e2) || e2.type === "SequenceExpression" || e2.type === "TaggedTemplateExpression" || e2.type === "BindExpression" || e2.type === "UpdateExpression" && !e2.prefix || e2.type === "TSAsExpression" || e2.type === "TSNonNullExpression";
    }, hasNode: function e2(t3, n2) {
      if (!t3 || typeof t3 != "object")
        return false;
      if (Array.isArray(t3))
        return t3.some((t4) => e2(t4, n2));
      const r2 = n2(t3);
      return typeof r2 == "boolean" ? r2 : Object.values(t3).some((t4) => e2(t4, n2));
    }, hasIgnoreComment: function(e2) {
      return hC(e2.getValue());
    }, hasNodeIgnoreComment: hC, identity: function(e2) {
      return e2;
    }, isBinaryish: function(e2) {
      return YE.has(e2.type);
    }, isBlockComment: RE, isCallLikeExpression: EC, isEnabledHackPipeline: function(e2) {
      return Boolean(e2.__isUsingHackPipeline);
    }, isLineComment: VE, isPrettierIgnoreComment: dC, isCallExpression: ZE, isMemberExpression: eC, isExportDeclaration: WE, isFlowAnnotationComment: function(e2, t3) {
      const n2 = OE(t3), r2 = BE(e2, IE(t3));
      return r2 !== false && e2.slice(n2, n2 + 2) === "/*" && e2.slice(r2, r2 + 2) === "*/";
    }, isFunctionCompositionArgs: function(e2) {
      if (e2.length <= 1)
        return false;
      let t3 = 0;
      for (const n2 of e2)
        if (zE(n2)) {
          if (t3 += 1, t3 > 1)
            return true;
        } else if (ZE(n2)) {
          for (const e3 of n2.arguments)
            if (zE(e3))
              return true;
        }
      return false;
    }, isFunctionNotation: XE, isFunctionOrArrowExpression: zE, isGetterOrSetter: JE, isJestEachTemplateLiteral: function(e2, t3) {
      const n2 = /^[fx]?(?:describe|it|test)$/;
      return t3.type === "TaggedTemplateExpression" && t3.quasi === e2 && t3.tag.type === "MemberExpression" && t3.tag.property.type === "Identifier" && t3.tag.property.name === "each" && (t3.tag.object.type === "Identifier" && n2.test(t3.tag.object.name) || t3.tag.object.type === "MemberExpression" && t3.tag.object.property.type === "Identifier" && (t3.tag.object.property.name === "only" || t3.tag.object.property.name === "skip") && t3.tag.object.object.type === "Identifier" && n2.test(t3.tag.object.object.name));
    }, isJsxNode: HE, isLiteral: function(e2) {
      return e2.type === "BooleanLiteral" || e2.type === "DirectiveLiteral" || e2.type === "Literal" || e2.type === "NullLiteral" || e2.type === "NumericLiteral" || e2.type === "BigIntLiteral" || e2.type === "DecimalLiteral" || e2.type === "RegExpLiteral" || e2.type === "StringLiteral" || e2.type === "TemplateLiteral" || e2.type === "TSTypeLiteral" || e2.type === "JSXText";
    }, isLongCurriedCallExpression: function(e2) {
      const t3 = e2.getValue(), n2 = e2.getParentNode();
      return ZE(t3) && ZE(n2) && n2.callee === t3 && t3.arguments.length > n2.arguments.length && n2.arguments.length > 0;
    }, isSimpleCallArgument: function e2(t3, n2) {
      if (n2 >= 2)
        return false;
      const r2 = (t4) => e2(t4, n2 + 1), o2 = t3.type === "Literal" && "regex" in t3 && t3.regex.pattern || t3.type === "RegExpLiteral" && t3.pattern;
      return !(o2 && PE(o2) > 5) && (t3.type === "Literal" || t3.type === "BigIntLiteral" || t3.type === "DecimalLiteral" || t3.type === "BooleanLiteral" || t3.type === "NullLiteral" || t3.type === "NumericLiteral" || t3.type === "RegExpLiteral" || t3.type === "StringLiteral" || t3.type === "Identifier" || t3.type === "ThisExpression" || t3.type === "Super" || t3.type === "PrivateName" || t3.type === "PrivateIdentifier" || t3.type === "ArgumentPlaceholder" || t3.type === "Import" || (t3.type === "TemplateLiteral" ? t3.quasis.every((e3) => !e3.value.raw.includes("\n")) && t3.expressions.every(r2) : t3.type === "ObjectExpression" ? t3.properties.every((e3) => !e3.computed && (e3.shorthand || e3.value && r2(e3.value))) : t3.type === "ArrayExpression" ? t3.elements.every((e3) => e3 === null || r2(e3)) : EC(t3) ? (t3.type === "ImportExpression" || e2(t3.callee, n2)) && fC(t3).every(r2) : eC(t3) ? e2(t3.object, n2) && e2(t3.property, n2) : t3.type !== "UnaryExpression" || t3.operator !== "!" && t3.operator !== "-" ? t3.type === "TSNonNullExpression" && e2(t3.expression, n2) : e2(t3.argument, n2)));
    }, isMemberish: function(e2) {
      return eC(e2) || e2.type === "BindExpression" && Boolean(e2.object);
    }, isNumericLiteral: qE, isSignedNumericLiteral: function(e2) {
      return e2.type === "UnaryExpression" && (e2.operator === "+" || e2.operator === "-") && qE(e2.argument);
    }, isObjectProperty: function(e2) {
      return e2 && (e2.type === "ObjectProperty" || e2.type === "Property" && !e2.method && e2.kind === "init");
    }, isObjectType: function(e2) {
      return e2.type === "ObjectTypeAnnotation" || e2.type === "TSTypeLiteral" || e2.type === "TSMappedType";
    }, isObjectTypePropertyAFunction: function(e2) {
      return !(e2.type !== "ObjectTypeProperty" && e2.type !== "ObjectTypeInternalSlot" || e2.value.type !== "FunctionTypeAnnotation" || e2.static || XE(e2));
    }, isSimpleType: function(e2) {
      return !!e2 && (!(e2.type !== "GenericTypeAnnotation" && e2.type !== "TSTypeReference" || e2.typeParameters) || !!KE.has(e2.type));
    }, isSimpleNumber: tC, isSimpleTemplateLiteral: function(e2) {
      let t3 = "expressions";
      e2.type === "TSTemplateLiteralType" && (t3 = "types");
      const n2 = e2[t3];
      return n2.length !== 0 && n2.every((e3) => {
        if (yC(e3))
          return false;
        if (e3.type === "Identifier" || e3.type === "ThisExpression")
          return true;
        if (eC(e3)) {
          let t4 = e3;
          for (; eC(t4); ) {
            if (t4.property.type !== "Identifier" && t4.property.type !== "Literal" && t4.property.type !== "StringLiteral" && t4.property.type !== "NumericLiteral")
              return false;
            if (t4 = t4.object, yC(t4))
              return false;
          }
          return t4.type === "Identifier" || t4.type === "ThisExpression";
        }
        return false;
      });
    }, isStringLiteral: UE, isStringPropSafeToUnquote: function(e2, t3) {
      return t3.parser !== "json" && UE(e2.key) && rC(e2.key).slice(1, -1) === e2.key.value && (SE(e2.key.value) && !(t3.parser === "babel-ts" && e2.type === "ClassProperty" || t3.parser === "typescript" && e2.type === "PropertyDefinition") || tC(e2.key.value) && String(Number(e2.key.value)) === e2.key.value && (t3.parser === "babel" || t3.parser === "espree" || t3.parser === "meriyah" || t3.parser === "__babel_estree"));
    }, isTemplateOnItsOwnLine: function(e2, t3) {
      return (e2.type === "TemplateLiteral" && nC(e2) || e2.type === "TaggedTemplateExpression" && nC(e2.quasi)) && !TE(t3, OE(e2), { backwards: true });
    }, isTestCall: function e2(t3, n2) {
      if (t3.type !== "CallExpression")
        return false;
      if (t3.arguments.length === 1) {
        if (GE(t3) && n2 && e2(n2))
          return zE(t3.arguments[0]);
        if (function(e3) {
          return e3.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e3.callee.name) && e3.arguments.length === 1;
        }(t3))
          return GE(t3.arguments[0]);
      } else if ((t3.arguments.length === 2 || t3.arguments.length === 3) && (t3.callee.type === "Identifier" && QE.test(t3.callee.name) || function(e3) {
        return eC(e3.callee) && e3.callee.object.type === "Identifier" && e3.callee.property.type === "Identifier" && QE.test(e3.callee.object.name) && (e3.callee.property.name === "only" || e3.callee.property.name === "skip");
      }(t3)) && (function(e3) {
        return e3.type === "TemplateLiteral";
      }(t3.arguments[0]) || UE(t3.arguments[0])))
        return !(t3.arguments[2] && !qE(t3.arguments[2])) && ((t3.arguments.length === 2 ? zE(t3.arguments[1]) : function(e3) {
          return e3.type === "FunctionExpression" || e3.type === "ArrowFunctionExpression" && e3.body.type === "BlockStatement";
        }(t3.arguments[1]) && lC(t3.arguments[1]).length <= 1) || GE(t3.arguments[1]));
      return false;
    }, isTheOnlyJsxElementInMarkdown: function(e2, t3) {
      if (e2.parentParser !== "markdown" && e2.parentParser !== "mdx")
        return false;
      const n2 = t3.getNode();
      if (!n2.expression || !HE(n2.expression))
        return false;
      const r2 = t3.getParentNode();
      return r2.type === "Program" && r2.body.length === 1;
    }, isTSXFile: function(e2) {
      return e2.filepath && /\.tsx$/i.test(e2.filepath);
    }, isTypeAnnotationAFunction: function(e2) {
      return !(e2.type !== "TypeAnnotation" && e2.type !== "TSTypeAnnotation" || e2.typeAnnotation.type !== "FunctionTypeAnnotation" || e2.static || LE(e2, e2.typeAnnotation));
    }, isNextLineEmpty: (e2, t3) => {
      let { originalText: n2 } = t3;
      return kE(n2, IE(e2));
    }, needsHardlineAfterDanglingComment: function(e2) {
      if (!yC(e2))
        return false;
      const t3 = wE(DC(e2, gC.Dangling));
      return t3 && !RE(t3);
    }, rawText: rC, shouldPrintComma: function(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
      return e2.trailingComma === "es5" && t3 === "es5" || e2.trailingComma === "all" && (t3 === "all" || t3 === "es5");
    }, isBitwiseOperator: function(e2) {
      return Boolean(uC[e2]) || e2 === "|" || e2 === "^" || e2 === "&";
    }, shouldFlatten: function(e2, t3) {
      return aC(t3) === aC(e2) && (e2 !== "**" && ((!oC[e2] || !oC[t3]) && (!(t3 === "%" && iC[e2] || e2 === "%" && iC[t3]) && ((t3 === e2 || !iC[t3] || !iC[e2]) && (!uC[e2] || !uC[t3])))));
    }, startsWithNoLookaheadToken: function e2(t3, n2) {
      switch ((t3 = function(e3) {
        for (; e3.left; )
          e3 = e3.left;
        return e3;
      }(t3)).type) {
        case "FunctionExpression":
        case "ClassExpression":
        case "DoExpression":
          return n2;
        case "ObjectExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return e2(t3.object, n2);
        case "TaggedTemplateExpression":
          return t3.tag.type !== "FunctionExpression" && e2(t3.tag, n2);
        case "CallExpression":
        case "OptionalCallExpression":
          return t3.callee.type !== "FunctionExpression" && e2(t3.callee, n2);
        case "ConditionalExpression":
          return e2(t3.test, n2);
        case "UpdateExpression":
          return !t3.prefix && e2(t3.argument, n2);
        case "BindExpression":
          return t3.object && e2(t3.object, n2);
        case "SequenceExpression":
          return e2(t3.expressions[0], n2);
        case "TSAsExpression":
        case "TSNonNullExpression":
          return e2(t3.expression, n2);
        default:
          return false;
      }
    }, getPrecedence: aC, hasComment: yC, getComments: DC, CommentCheckFlags: gC };
    const bC = au, { getStringWidth: vC, getIndentSize: AC } = dc, { builders: { join: FC, hardline: xC, softline: SC, group: wC, indent: TC, align: BC, lineSuffixBoundary: NC, addAlignmentToDoc: kC }, printer: { printDocToString: PC }, utils: { mapDoc: OC } } = Zc, { isBinaryish: IC, isJestEachTemplateLiteral: LC, isSimpleTemplateLiteral: jC, hasComment: _C, isMemberExpression: MC } = CC;
    function RC(e2) {
      return e2.replace(/([\\`]|\${)/g, "\\$1");
    }
    var VC = { printTemplateLiteral: function(e2, t3, n2) {
      const r2 = e2.getValue();
      if (r2.type === "TemplateLiteral" && LC(r2, e2.getParentNode())) {
        const r3 = function(e3, t4, n3) {
          const r4 = e3.getNode(), o3 = r4.quasis[0].value.raw.trim().split(/\s*\|\s*/);
          if (o3.length > 1 || o3.some((e4) => e4.length > 0)) {
            t4.__inJestEach = true;
            const i3 = e3.map(n3, "expressions");
            t4.__inJestEach = false;
            const u3 = [], s3 = i3.map((e4) => "${" + PC(e4, Object.assign(Object.assign({}, t4), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), a2 = [{ hasLineBreak: false, cells: [] }];
            for (let e4 = 1; e4 < r4.quasis.length; e4++) {
              const t5 = bC(a2), n4 = s3[e4 - 1];
              t5.cells.push(n4), n4.includes("\n") && (t5.hasLineBreak = true), r4.quasis[e4].value.raw.includes("\n") && a2.push({ hasLineBreak: false, cells: [] });
            }
            const c2 = Math.max(o3.length, ...a2.map((e4) => e4.cells.length)), l2 = Array.from({ length: c2 }).fill(0), p2 = [{ cells: o3 }, ...a2.filter((e4) => e4.cells.length > 0)];
            for (const { cells: e4 } of p2.filter((e5) => !e5.hasLineBreak))
              for (const [t5, n4] of e4.entries())
                l2[t5] = Math.max(l2[t5], vC(n4));
            return u3.push(NC, "`", TC([xC, FC(xC, p2.map((e4) => FC(" | ", e4.cells.map((t5, n4) => e4.hasLineBreak ? t5 : t5 + " ".repeat(l2[n4] - vC(t5))))))]), xC, "`"), u3;
          }
        }(e2, n2, t3);
        if (r3)
          return r3;
      }
      let o2 = "expressions";
      r2.type === "TSTemplateLiteralType" && (o2 = "types");
      const i2 = [];
      let u2 = e2.map(t3, o2);
      const s2 = jC(r2);
      return s2 && (u2 = u2.map((e3) => PC(e3, Object.assign(Object.assign({}, n2), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), i2.push(NC, "`"), e2.each((e3) => {
        const a2 = e3.getName();
        if (i2.push(t3()), a2 < u2.length) {
          const { tabWidth: t4 } = n2, c2 = e3.getValue(), l2 = AC(c2.value.raw, t4);
          let p2 = u2[a2];
          if (!s2) {
            const e4 = r2[o2][a2];
            (_C(e4) || MC(e4) || e4.type === "ConditionalExpression" || e4.type === "SequenceExpression" || e4.type === "TSAsExpression" || IC(e4)) && (p2 = [TC([SC, p2]), SC]);
          }
          const f2 = l2 === 0 && c2.value.raw.endsWith("\n") ? BC(Number.NEGATIVE_INFINITY, p2) : kC(p2, l2, t4);
          i2.push(wC(["${", f2, NC, "}"]));
        }
      }, "quasis"), i2.push("`"), i2;
    }, printTemplateExpressions: function(e2, t3) {
      return e2.map((e3) => function(e4, t4) {
        const n2 = e4.getValue();
        let r2 = t4();
        return _C(n2) && (r2 = wC([TC([SC, r2]), SC])), ["${", r2, NC, "}"];
      }(e3, t3), "expressions");
    }, escapeTemplateCharacters: function(e2, t3) {
      return OC(e2, (e3) => typeof e3 == "string" ? t3 ? e3.replace(/(\\*)`/g, "$1$1\\`") : RC(e3) : e3);
    }, uncookTemplateElementValue: RC };
    const { builders: { indent: $C, softline: WC, literalline: qC, dedentToRoot: UC } } = Zc, { escapeTemplateCharacters: zC } = VC;
    var GC = function(e2, t3, n2) {
      let r2 = e2.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (e3, t4) => "\\".repeat(t4.length / 2) + "`");
      const o2 = function(e3) {
        const t4 = e3.match(/^([^\S\n]*)\S/m);
        return t4 === null ? "" : t4[1];
      }(r2), i2 = o2 !== "";
      i2 && (r2 = r2.replace(new RegExp("^".concat(o2), "gm"), ""));
      const u2 = zC(n2(r2, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
      return ["`", i2 ? $C([WC, u2]) : [qC, UC(u2)], WC, "`"];
    };
    const { isNonEmptyArray: HC } = dc, { builders: { indent: JC, hardline: XC, softline: YC }, utils: { mapDoc: KC, replaceEndOfLine: QC, cleanDoc: ZC } } = Zc, { printTemplateExpressions: eb } = VC;
    var tb = function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = r2.quasis.map((e3) => e3.value.raw);
      let i2 = 0;
      return function(e3, t4, n3) {
        if (t4.quasis.length === 1 && !t4.quasis[0].value.raw.trim())
          return "``";
        const r3 = function(e4, t5) {
          if (!HC(t5))
            return e4;
          let n4 = 0;
          const r4 = KC(ZC(e4), (e5) => typeof e5 == "string" && e5.includes("@prettier-placeholder") ? e5.split(/@prettier-placeholder-(\d+)-id/).map((e6, r5) => r5 % 2 == 0 ? QC(e6) : (n4++, t5[e6])) : e5);
          return t5.length === n4 ? r4 : null;
        }(e3, n3);
        if (!r3)
          throw new Error("Couldn't insert all the expressions");
        return ["`", JC([XC, r3]), YC, "`"];
      }(n2(o2.reduce((e3, t4, n3) => n3 === 0 ? t4 : e3 + "@prettier-placeholder-" + i2++ + "-id" + t4, ""), { parser: "scss" }, { stripTrailingHardline: true }), r2, eb(e2, t3));
    };
    const { builders: { indent: nb, join: rb, hardline: ob } } = Zc, { escapeTemplateCharacters: ib, printTemplateExpressions: ub } = VC;
    function sb(e2) {
      const t3 = [];
      let n2 = false;
      const r2 = e2.map((e3) => e3.trim());
      for (const [e3, o2] of r2.entries())
        o2 !== "" && (r2[e3 - 1] === "" && n2 ? t3.push([ob, o2]) : t3.push(o2), n2 = true);
      return t3.length === 0 ? null : rb(ob, t3);
    }
    var ab = function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = r2.quasis.length;
      if (o2 === 1 && r2.quasis[0].value.raw.trim() === "")
        return "``";
      const i2 = ub(e2, t3), u2 = [];
      for (let e3 = 0; e3 < o2; e3++) {
        const t4 = e3 === 0, s2 = e3 === o2 - 1, a2 = r2.quasis[e3].value.cooked, c2 = a2.split("\n"), l2 = c2.length, p2 = i2[e3], f2 = l2 > 2 && c2[0].trim() === "" && c2[1].trim() === "", d2 = l2 > 2 && c2[l2 - 1].trim() === "" && c2[l2 - 2].trim() === "", h2 = c2.every((e4) => /^\s*(?:#[^\n\r]*)?$/.test(e4));
        if (!s2 && /#[^\n\r]*$/.test(c2[l2 - 1]))
          return null;
        let g2 = null;
        g2 = h2 ? sb(c2) : n2(a2, { parser: "graphql" }, { stripTrailingHardline: true }), g2 ? (g2 = ib(g2, false), !t4 && f2 && u2.push(""), u2.push(g2), !s2 && d2 && u2.push("")) : t4 || s2 || !f2 || u2.push(""), p2 && u2.push(p2);
      }
      return ["`", nb([ob, rb(ob, u2)]), ob, "`"];
    };
    const { builders: { indent: cb, line: lb, hardline: pb, group: fb }, utils: { mapDoc: db } } = Zc, { printTemplateExpressions: hb, uncookTemplateElementValue: gb } = VC;
    let mb = 0;
    var yb = function(e2, t3, n2, r2, o2) {
      let { parser: i2 } = o2;
      const u2 = e2.getValue(), s2 = mb;
      mb = mb + 1 >>> 0;
      const a2 = (e3) => "PRETTIER_HTML_PLACEHOLDER_".concat(e3, "_").concat(s2, "_IN_JS"), c2 = u2.quasis.map((e3, t4, n3) => t4 === n3.length - 1 ? e3.value.cooked : e3.value.cooked + a2(t4)).join(""), l2 = hb(e2, t3);
      if (l2.length === 0 && c2.trim().length === 0)
        return "``";
      const p2 = new RegExp(a2("(\\d+)"), "g");
      let f2 = 0;
      const d2 = n2(c2, { parser: i2, __onHtmlRoot(e3) {
        f2 = e3.children.length;
      } }, { stripTrailingHardline: true }), h2 = db(d2, (e3) => {
        if (typeof e3 != "string")
          return e3;
        const t4 = [], n3 = e3.split(p2);
        for (let e4 = 0; e4 < n3.length; e4++) {
          let o3 = n3[e4];
          if (e4 % 2 == 0) {
            o3 && (o3 = gb(o3), r2.__embeddedInHtml && (o3 = o3.replace(/<\/(script)\b/gi, "<\\/$1")), t4.push(o3));
            continue;
          }
          const i3 = Number(o3);
          t4.push(l2[i3]);
        }
        return t4;
      }), g2 = /^\s/.test(c2) ? " " : "", m2 = /\s$/.test(c2) ? " " : "", y2 = r2.htmlWhitespaceSensitivity === "ignore" ? pb : g2 && m2 ? lb : null;
      return fb(y2 ? ["`", cb([y2, fb(h2)]), y2, "`"] : ["`", g2, f2 > 1 ? cb(fb(h2)) : fb(h2), m2, "`"]);
    };
    const { hasComment: Db, CommentCheckFlags: Eb, isObjectProperty: Cb } = CC, bb = GC, vb = tb, Ab = ab, Fb = yb;
    function xb(e2) {
      return function(e3) {
        const t3 = e3.getValue(), n2 = e3.getParentNode(), r2 = e3.getParentNode(1);
        return r2 && t3.quasis && n2.type === "JSXExpressionContainer" && r2.type === "JSXElement" && r2.openingElement.name.name === "style" && r2.openingElement.attributes.some((e4) => e4.name.name === "jsx") || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "Identifier" && n2.tag.name === "css" || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "MemberExpression" && n2.tag.object.name === "css" && (n2.tag.property.name === "global" || n2.tag.property.name === "resolve");
      }(e2) || function(e3) {
        const t3 = e3.getParentNode();
        if (!t3 || t3.type !== "TaggedTemplateExpression")
          return false;
        const n2 = t3.tag.type === "ParenthesizedExpression" ? t3.tag.expression : t3.tag;
        switch (n2.type) {
          case "MemberExpression":
            return wb(n2.object) || Tb(n2);
          case "CallExpression":
            return wb(n2.callee) || n2.callee.type === "MemberExpression" && (n2.callee.object.type === "MemberExpression" && (wb(n2.callee.object.object) || Tb(n2.callee.object)) || n2.callee.object.type === "CallExpression" && wb(n2.callee.object.callee));
          case "Identifier":
            return n2.name === "css";
          default:
            return false;
        }
      }(e2) || function(e3) {
        const t3 = e3.getParentNode(), n2 = e3.getParentNode(1);
        return n2 && t3.type === "JSXExpressionContainer" && n2.type === "JSXAttribute" && n2.name.type === "JSXIdentifier" && n2.name.name === "css";
      }(e2) || function(e3) {
        return e3.match((e4) => e4.type === "TemplateLiteral", (e4, t3) => e4.type === "ArrayExpression" && t3 === "elements", (e4, t3) => Cb(e4) && e4.key.type === "Identifier" && e4.key.name === "styles" && t3 === "value", ...Sb);
      }(e2) ? "css" : function(e3) {
        const t3 = e3.getValue(), n2 = e3.getParentNode();
        return Bb(t3, "GraphQL") || n2 && (n2.type === "TaggedTemplateExpression" && (n2.tag.type === "MemberExpression" && n2.tag.object.name === "graphql" && n2.tag.property.name === "experimental" || n2.tag.type === "Identifier" && (n2.tag.name === "gql" || n2.tag.name === "graphql")) || n2.type === "CallExpression" && n2.callee.type === "Identifier" && n2.callee.name === "graphql");
      }(e2) ? "graphql" : function(e3) {
        return Bb(e3.getValue(), "HTML") || e3.match((e4) => e4.type === "TemplateLiteral", (e4, t3) => e4.type === "TaggedTemplateExpression" && e4.tag.type === "Identifier" && e4.tag.name === "html" && t3 === "quasi");
      }(e2) ? "html" : function(e3) {
        return e3.match((e4) => e4.type === "TemplateLiteral", (e4, t3) => Cb(e4) && e4.key.type === "Identifier" && e4.key.name === "template" && t3 === "value", ...Sb);
      }(e2) ? "angular" : function(e3) {
        const t3 = e3.getValue(), n2 = e3.getParentNode();
        return n2 && n2.type === "TaggedTemplateExpression" && t3.quasis.length === 1 && n2.tag.type === "Identifier" && (n2.tag.name === "md" || n2.tag.name === "markdown");
      }(e2) ? "markdown" : void 0;
    }
    const Sb = [(e2, t3) => e2.type === "ObjectExpression" && t3 === "properties", (e2, t3) => e2.type === "CallExpression" && e2.callee.type === "Identifier" && e2.callee.name === "Component" && t3 === "arguments", (e2, t3) => e2.type === "Decorator" && t3 === "expression"];
    function wb(e2) {
      return e2.type === "Identifier" && e2.name === "styled";
    }
    function Tb(e2) {
      return /^[A-Z]/.test(e2.object.name) && e2.property.name === "extend";
    }
    function Bb(e2, t3) {
      return Db(e2, Eb.Block | Eb.Leading, (e3) => {
        let { value: n2 } = e3;
        return n2 === " ".concat(t3, " ");
      });
    }
    var Nb = function(e2, t3, n2, r2) {
      const o2 = e2.getValue();
      if (o2.type !== "TemplateLiteral" || function(e3) {
        let { quasis: t4 } = e3;
        return t4.some((e4) => {
          let { value: { cooked: t5 } } = e4;
          return t5 === null;
        });
      }(o2))
        return;
      const i2 = xb(e2);
      return i2 ? i2 === "markdown" ? bb(e2, t3, n2) : i2 === "css" ? vb(e2, t3, n2) : i2 === "graphql" ? Ab(e2, t3, n2) : i2 === "html" || i2 === "angular" ? Fb(e2, t3, n2, r2, { parser: i2 }) : void 0 : void 0;
    };
    const { isBlockComment: kb } = CC, Pb = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), Ob = (e2) => {
      for (const t3 of e2.quasis)
        delete t3.value;
    };
    function Ib(e2, t3, n2) {
      if (e2.type === "Program" && delete t3.sourceType, e2.type !== "BigIntLiteral" && e2.type !== "BigIntLiteralTypeAnnotation" || t3.value && (t3.value = t3.value.toLowerCase()), e2.type !== "BigIntLiteral" && e2.type !== "Literal" || t3.bigint && (t3.bigint = t3.bigint.toLowerCase()), e2.type === "DecimalLiteral" && (t3.value = Number(t3.value)), e2.type === "Literal" && t3.decimal && (t3.decimal = Number(t3.decimal)), e2.type === "EmptyStatement")
        return null;
      if (e2.type === "JSXText")
        return null;
      if (e2.type === "JSXExpressionContainer" && (e2.expression.type === "Literal" || e2.expression.type === "StringLiteral") && e2.expression.value === " ")
        return null;
      if (e2.type !== "Property" && e2.type !== "ObjectProperty" && e2.type !== "MethodDefinition" && e2.type !== "ClassProperty" && e2.type !== "ClassMethod" && e2.type !== "PropertyDefinition" && e2.type !== "TSDeclareMethod" && e2.type !== "TSPropertySignature" && e2.type !== "ObjectTypeProperty" || typeof e2.key != "object" || !e2.key || e2.key.type !== "Literal" && e2.key.type !== "NumericLiteral" && e2.key.type !== "StringLiteral" && e2.key.type !== "Identifier" || delete t3.key, e2.type === "JSXElement" && e2.openingElement.name.name === "style" && e2.openingElement.attributes.some((e3) => e3.name.name === "jsx"))
        for (const { type: e3, expression: n3 } of t3.children)
          e3 === "JSXExpressionContainer" && n3.type === "TemplateLiteral" && Ob(n3);
      e2.type === "JSXAttribute" && e2.name.name === "css" && e2.value.type === "JSXExpressionContainer" && e2.value.expression.type === "TemplateLiteral" && Ob(t3.value.expression), e2.type === "JSXAttribute" && e2.value && e2.value.type === "Literal" && /["']|&quot;|&apos;/.test(e2.value.value) && (t3.value.value = t3.value.value.replace(/["']|&quot;|&apos;/g, '"'));
      const r2 = e2.expression || e2.callee;
      if (e2.type === "Decorator" && r2.type === "CallExpression" && r2.callee.name === "Component" && r2.arguments.length === 1) {
        const n3 = e2.expression.arguments[0].properties;
        for (const [e3, r3] of t3.expression.arguments[0].properties.entries())
          switch (n3[e3].key.name) {
            case "styles":
              r3.value.type === "ArrayExpression" && Ob(r3.value.elements[0]);
              break;
            case "template":
              r3.value.type === "TemplateLiteral" && Ob(r3.value);
          }
      }
      if (e2.type !== "TaggedTemplateExpression" || e2.tag.type !== "MemberExpression" && (e2.tag.type !== "Identifier" || e2.tag.name !== "gql" && e2.tag.name !== "graphql" && e2.tag.name !== "css" && e2.tag.name !== "md" && e2.tag.name !== "markdown" && e2.tag.name !== "html") && e2.tag.type !== "CallExpression" || Ob(t3.quasi), e2.type === "TemplateLiteral") {
        const r3 = e2.leadingComments && e2.leadingComments.some((e3) => kb(e3) && ["GraphQL", "HTML"].some((t4) => e3.value === " ".concat(t4, " ")));
        (r3 || n2.type === "CallExpression" && n2.callee.name === "graphql" || !e2.leadingComments) && Ob(t3);
      }
      return e2.type === "InterpreterDirective" && (t3.value = t3.value.trimEnd()), e2.type !== "TSIntersectionType" && e2.type !== "TSUnionType" || e2.types.length !== 1 ? void 0 : t3.types[0];
    }
    Ib.ignoredProperties = Pb;
    var Lb = Ib, jb = {}, _b = { exports: {} };
    const Mb = (e2) => {
      if (typeof e2 != "string")
        throw new TypeError("Expected a string");
      const t3 = e2.match(/(?:\r?\n)/g) || [];
      if (t3.length === 0)
        return;
      const n2 = t3.filter((e3) => e3 === "\r\n").length;
      return n2 > t3.length - n2 ? "\r\n" : "\n";
    };
    function Rb() {
      const e2 = yf;
      return Rb = function() {
        return e2;
      }, e2;
    }
    function Vb() {
      const e2 = function(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }(_b.exports);
      return Vb = function() {
        return e2;
      }, e2;
    }
    _b.exports = Mb, _b.exports.graceful = (e2) => typeof e2 == "string" && Mb(e2) || "\n", Object.defineProperty(jb, "__esModule", { value: true }), jb.extract = function(e2) {
      const t3 = e2.match(qb);
      return t3 ? t3[0].trimLeft() : "";
    }, jb.strip = function(e2) {
      const t3 = e2.match(qb);
      return t3 && t3[0] ? e2.substring(t3[0].length) : e2;
    }, jb.parse = function(e2) {
      return Yb(e2).pragmas;
    }, jb.parseWithComments = Yb, jb.print = function(e2) {
      let { comments: t3 = "", pragmas: n2 = {} } = e2;
      const r2 = (0, Vb().default)(t3) || Rb().EOL, o2 = " *", i2 = Object.keys(n2), u2 = i2.map((e3) => Kb(e3, n2[e3])).reduce((e3, t4) => e3.concat(t4), []).map((e3) => " * " + e3 + r2).join("");
      if (!t3) {
        if (i2.length === 0)
          return "";
        if (i2.length === 1 && !Array.isArray(n2[i2[0]])) {
          const e3 = n2[i2[0]];
          return "".concat("/**", " ").concat(Kb(i2[0], e3)[0]).concat(" */");
        }
      }
      const s2 = t3.split(r2).map((e3) => "".concat(o2, " ").concat(e3)).join(r2) + r2;
      return "/**" + r2 + (t3 ? s2 : "") + (t3 && i2.length ? o2 + r2 : "") + u2 + " */";
    };
    const $b = /\*\/$/, Wb = /^\/\*\*/, qb = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, Ub = /(^|\s+)\/\/([^\r\n]*)/g, zb = /^(\r?\n)+/, Gb = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Hb = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, Jb = /(\r?\n|^) *\* ?/g, Xb = [];
    function Yb(e2) {
      const t3 = (0, Vb().default)(e2) || Rb().EOL;
      e2 = e2.replace(Wb, "").replace($b, "").replace(Jb, "$1");
      let n2 = "";
      for (; n2 !== e2; )
        n2 = e2, e2 = e2.replace(Gb, "".concat(t3, "$1 $2").concat(t3));
      e2 = e2.replace(zb, "").trimRight();
      const r2 = /* @__PURE__ */ Object.create(null), o2 = e2.replace(Hb, "").replace(zb, "").trimRight();
      let i2;
      for (; i2 = Hb.exec(e2); ) {
        const e3 = i2[2].replace(Ub, "");
        typeof r2[i2[1]] == "string" || Array.isArray(r2[i2[1]]) ? r2[i2[1]] = Xb.concat(r2[i2[1]], e3) : r2[i2[1]] = e3;
      }
      return { comments: o2, pragmas: r2 };
    }
    function Kb(e2, t3) {
      return Xb.concat(t3).map((t4) => "@".concat(e2, " ").concat(t4).trim());
    }
    const { parseWithComments: Qb, strip: Zb, extract: ev, print: tv } = jb, { getShebang: nv } = dc, { normalizeEndOfLine: rv } = hc;
    function ov(e2) {
      const t3 = nv(e2);
      t3 && (e2 = e2.slice(t3.length + 1));
      const n2 = ev(e2), { pragmas: r2, comments: o2 } = Qb(n2);
      return { shebang: t3, text: e2, pragmas: r2, comments: o2 };
    }
    var iv = { hasPragma: function(e2) {
      const t3 = Object.keys(ov(e2).pragmas);
      return t3.includes("prettier") || t3.includes("format");
    }, insertPragma: function(e2) {
      const { shebang: t3, text: n2, pragmas: r2, comments: o2 } = ov(e2), i2 = Zb(n2), u2 = tv({ pragmas: Object.assign({ format: "" }, r2), comments: o2.trimStart() });
      return (t3 ? "".concat(t3, "\n") : "") + rv(u2) + (i2.startsWith("\n") ? "\n" : "\n\n") + i2;
    } };
    const { getLast: uv, hasNewline: sv, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: av, getNextNonSpaceNonCommentCharacter: cv, hasNewlineInRange: lv, addLeadingComment: pv, addTrailingComment: fv, addDanglingComment: dv, getNextNonSpaceNonCommentCharacterIndex: hv, isNonEmptyArray: gv } = dc, { isBlockComment: mv, getFunctionParameters: yv, isPrettierIgnoreComment: Dv, isJsxNode: Ev, hasFlowShorthandAnnotationComment: Cv, hasFlowAnnotationComment: bv, hasIgnoreComment: vv, isCallLikeExpression: Av, getCallArguments: Fv, isCallExpression: xv, isMemberExpression: Sv, isObjectProperty: wv, getComments: Tv, CommentCheckFlags: Bv } = CC, { locStart: Nv, locEnd: kv } = og;
    function Pv(e2, t3) {
      const n2 = (e2.body || e2.properties).find((e3) => {
        let { type: t4 } = e3;
        return t4 !== "EmptyStatement";
      });
      n2 ? pv(n2, t3) : dv(e2, t3);
    }
    function Ov(e2, t3) {
      e2.type === "BlockStatement" ? Pv(e2, t3) : pv(e2, t3);
    }
    function Iv(e2) {
      let { comment: t3, followingNode: n2 } = e2;
      return !(!n2 || !cA(t3)) && (pv(n2, t3), true);
    }
    function Lv(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2, followingNode: o2, text: i2 } = e2;
      if (!r2 || r2.type !== "IfStatement" || !o2)
        return false;
      return cv(i2, t3, kv) === ")" ? (fv(n2, t3), true) : n2 === r2.consequent && o2 === r2.alternate ? (n2.type === "BlockStatement" ? fv(n2, t3) : dv(r2, t3), true) : o2.type === "BlockStatement" ? (Pv(o2, t3), true) : o2.type === "IfStatement" ? (Ov(o2.consequent, t3), true) : r2.consequent === o2 && (pv(o2, t3), true);
    }
    function jv(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2, followingNode: o2, text: i2 } = e2;
      if (!r2 || r2.type !== "WhileStatement" || !o2)
        return false;
      return cv(i2, t3, kv) === ")" ? (fv(n2, t3), true) : o2.type === "BlockStatement" ? (Pv(o2, t3), true) : r2.body === o2 && (pv(o2, t3), true);
    }
    function _v(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2, followingNode: o2 } = e2;
      return !(!r2 || r2.type !== "TryStatement" && r2.type !== "CatchClause" || !o2) && (r2.type === "CatchClause" && n2 ? (fv(n2, t3), true) : o2.type === "BlockStatement" ? (Pv(o2, t3), true) : o2.type === "TryStatement" ? (Ov(o2.finalizer, t3), true) : o2.type === "CatchClause" && (Ov(o2.body, t3), true));
    }
    function Mv(e2) {
      let { comment: t3, enclosingNode: n2, followingNode: r2 } = e2;
      return !(!Sv(n2) || !r2 || r2.type !== "Identifier") && (pv(n2, t3), true);
    }
    function Rv(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2, followingNode: o2, text: i2 } = e2;
      const u2 = n2 && !lv(i2, kv(n2), Nv(t3));
      return !(n2 && u2 || !r2 || r2.type !== "ConditionalExpression" && r2.type !== "TSConditionalType" || !o2) && (pv(o2, t3), true);
    }
    function Vv(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2 } = e2;
      return !(!wv(r2) || !r2.shorthand || r2.key !== n2 || r2.value.type !== "AssignmentPattern") && (fv(r2.value.left, t3), true);
    }
    function $v(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2, followingNode: o2 } = e2;
      if (r2 && (r2.type === "ClassDeclaration" || r2.type === "ClassExpression" || r2.type === "DeclareClass" || r2.type === "DeclareInterface" || r2.type === "InterfaceDeclaration" || r2.type === "TSInterfaceDeclaration")) {
        if (gv(r2.decorators) && (!o2 || o2.type !== "Decorator"))
          return fv(uv(r2.decorators), t3), true;
        if (r2.body && o2 === r2.body)
          return Pv(r2.body, t3), true;
        if (o2) {
          for (const e3 of ["implements", "extends", "mixins"])
            if (r2[e3] && o2 === r2[e3][0])
              return !n2 || n2 !== r2.id && n2 !== r2.typeParameters && n2 !== r2.superClass ? dv(r2, t3, e3) : fv(n2, t3), true;
        }
      }
      return false;
    }
    function Wv(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2, text: o2 } = e2;
      return (r2 && n2 && (r2.type === "Property" || r2.type === "TSDeclareMethod" || r2.type === "TSAbstractMethodDefinition") && n2.type === "Identifier" && r2.key === n2 && cv(o2, n2, kv) !== ":" || !(!n2 || !r2 || n2.type !== "Decorator" || r2.type !== "ClassMethod" && r2.type !== "ClassProperty" && r2.type !== "PropertyDefinition" && r2.type !== "TSAbstractPropertyDefinition" && r2.type !== "TSAbstractMethodDefinition" && r2.type !== "TSDeclareMethod" && r2.type !== "MethodDefinition")) && (fv(n2, t3), true);
    }
    function qv(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2, text: o2 } = e2;
      return cv(o2, t3, kv) === "(" && (!(!n2 || !r2 || r2.type !== "FunctionDeclaration" && r2.type !== "FunctionExpression" && r2.type !== "ClassMethod" && r2.type !== "MethodDefinition" && r2.type !== "ObjectMethod") && (fv(n2, t3), true));
    }
    function Uv(e2) {
      let { comment: t3, enclosingNode: n2, text: r2 } = e2;
      if (!n2 || n2.type !== "ArrowFunctionExpression")
        return false;
      const o2 = hv(r2, t3, kv);
      return o2 !== false && r2.slice(o2, o2 + 2) === "=>" && (dv(n2, t3), true);
    }
    function zv(e2) {
      let { comment: t3, enclosingNode: n2, text: r2 } = e2;
      return cv(r2, t3, kv) === ")" && (n2 && (aA(n2) && yv(n2).length === 0 || Av(n2) && Fv(n2).length === 0) ? (dv(n2, t3), true) : !(!n2 || n2.type !== "MethodDefinition" && n2.type !== "TSAbstractMethodDefinition" || yv(n2.value).length !== 0) && (dv(n2.value, t3), true));
    }
    function Gv(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2, followingNode: o2, text: i2 } = e2;
      if (n2 && n2.type === "FunctionTypeParam" && r2 && r2.type === "FunctionTypeAnnotation" && o2 && o2.type !== "FunctionTypeParam")
        return fv(n2, t3), true;
      if (n2 && (n2.type === "Identifier" || n2.type === "AssignmentPattern") && r2 && aA(r2) && cv(i2, t3, kv) === ")")
        return fv(n2, t3), true;
      if (r2 && r2.type === "FunctionDeclaration" && o2 && o2.type === "BlockStatement") {
        const e3 = (() => {
          const e4 = yv(r2);
          if (e4.length > 0)
            return av(i2, kv(uv(e4)));
          const t4 = av(i2, kv(r2.id));
          return t4 !== false && av(i2, t4 + 1);
        })();
        if (Nv(t3) > e3)
          return Pv(o2, t3), true;
      }
      return false;
    }
    function Hv(e2) {
      let { comment: t3, enclosingNode: n2 } = e2;
      return !(!n2 || n2.type !== "ImportSpecifier") && (pv(n2, t3), true);
    }
    function Jv(e2) {
      let { comment: t3, enclosingNode: n2 } = e2;
      return !(!n2 || n2.type !== "LabeledStatement") && (pv(n2, t3), true);
    }
    function Xv(e2) {
      let { comment: t3, enclosingNode: n2 } = e2;
      return !(!n2 || n2.type !== "ContinueStatement" && n2.type !== "BreakStatement" || n2.label) && (fv(n2, t3), true);
    }
    function Yv(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2 } = e2;
      return !!(xv(r2) && n2 && r2.callee === n2 && r2.arguments.length > 0) && (pv(r2.arguments[0], t3), true);
    }
    function Kv(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2, followingNode: o2 } = e2;
      return !r2 || r2.type !== "UnionTypeAnnotation" && r2.type !== "TSUnionType" ? (o2 && (o2.type === "UnionTypeAnnotation" || o2.type === "TSUnionType") && Dv(t3) && (o2.types[0].prettierIgnore = true, t3.unignore = true), false) : (Dv(t3) && (o2.prettierIgnore = true, t3.unignore = true), !!n2 && (fv(n2, t3), true));
    }
    function Qv(e2) {
      let { comment: t3, enclosingNode: n2 } = e2;
      return !!wv(n2) && (pv(n2, t3), true);
    }
    function Zv(e2) {
      let { comment: t3, enclosingNode: n2, followingNode: r2, ast: o2, isLastComment: i2 } = e2;
      return o2 && o2.body && o2.body.length === 0 ? (i2 ? dv(o2, t3) : pv(o2, t3), true) : n2 && n2.type === "Program" && n2.body.length === 0 && !gv(n2.directives) ? (i2 ? dv(n2, t3) : pv(n2, t3), true) : !(!r2 || r2.type !== "Program" || r2.body.length !== 0 || !n2 || n2.type !== "ModuleExpression") && (dv(r2, t3), true);
    }
    function eA(e2) {
      let { comment: t3, enclosingNode: n2 } = e2;
      return !(!n2 || n2.type !== "ForInStatement" && n2.type !== "ForOfStatement") && (pv(n2, t3), true);
    }
    function tA(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2, text: o2 } = e2;
      return !!(n2 && n2.type === "ImportSpecifier" && r2 && r2.type === "ImportDeclaration" && sv(o2, kv(t3))) && (fv(n2, t3), true);
    }
    function nA(e2) {
      let { comment: t3, enclosingNode: n2 } = e2;
      return !(!n2 || n2.type !== "AssignmentPattern") && (pv(n2, t3), true);
    }
    function rA(e2) {
      let { comment: t3, enclosingNode: n2 } = e2;
      return !(!n2 || n2.type !== "TypeAlias") && (pv(n2, t3), true);
    }
    function oA(e2) {
      let { comment: t3, enclosingNode: n2, followingNode: r2 } = e2;
      return !(!n2 || n2.type !== "VariableDeclarator" && n2.type !== "AssignmentExpression" || !r2 || r2.type !== "ObjectExpression" && r2.type !== "ArrayExpression" && r2.type !== "TemplateLiteral" && r2.type !== "TaggedTemplateExpression" && !mv(t3)) && (pv(r2, t3), true);
    }
    function iA(e2) {
      let { comment: t3, enclosingNode: n2, followingNode: r2, text: o2 } = e2;
      return !(r2 || !n2 || n2.type !== "TSMethodSignature" && n2.type !== "TSDeclareFunction" && n2.type !== "TSAbstractMethodDefinition" || cv(o2, t3, kv) !== ";") && (fv(n2, t3), true);
    }
    function uA(e2) {
      let { comment: t3, enclosingNode: n2, followingNode: r2 } = e2;
      if (Dv(t3) && n2 && n2.type === "TSMappedType" && r2 && r2.type === "TSTypeParameter" && r2.constraint)
        return n2.prettierIgnore = true, t3.unignore = true, true;
    }
    function sA(e2) {
      let { comment: t3, precedingNode: n2, enclosingNode: r2, followingNode: o2 } = e2;
      return !(!r2 || r2.type !== "TSMappedType") && (o2 && o2.type === "TSTypeParameter" && o2.name ? (pv(o2.name, t3), true) : !(!n2 || n2.type !== "TSTypeParameter" || !n2.constraint) && (fv(n2.constraint, t3), true));
    }
    function aA(e2) {
      return e2.type === "ArrowFunctionExpression" || e2.type === "FunctionExpression" || e2.type === "FunctionDeclaration" || e2.type === "ObjectMethod" || e2.type === "ClassMethod" || e2.type === "TSDeclareFunction" || e2.type === "TSCallSignatureDeclaration" || e2.type === "TSConstructSignatureDeclaration" || e2.type === "TSMethodSignature" || e2.type === "TSConstructorType" || e2.type === "TSFunctionType" || e2.type === "TSDeclareMethod";
    }
    function cA(e2) {
      return mv(e2) && e2.value[0] === "*" && /@type\b/.test(e2.value);
    }
    var lA = { handleOwnLineComment: function(e2) {
      return [uA, Gv, Mv, Lv, jv, _v, $v, Hv, eA, Kv, Zv, tA, nA, Wv, Jv].some((t3) => t3(e2));
    }, handleEndOfLineComment: function(e2) {
      return [Iv, Gv, Rv, Hv, Lv, jv, _v, $v, Jv, Yv, Qv, Zv, rA, oA].some((t3) => t3(e2));
    }, handleRemainingComment: function(e2) {
      return [uA, Lv, jv, Vv, zv, Wv, Zv, Uv, qv, sA, Xv, iA].some((t3) => t3(e2));
    }, isTypeCastComment: cA, getCommentChildNodes: function(e2, t3) {
      if ((t3.parser === "typescript" || t3.parser === "flow" || t3.parser === "espree" || t3.parser === "meriyah" || t3.parser === "__babel_estree") && e2.type === "MethodDefinition" && e2.value && e2.value.type === "FunctionExpression" && yv(e2.value).length === 0 && !e2.value.returnType && !gv(e2.value.typeParameters) && e2.value.body)
        return [...e2.decorators || [], e2.key, e2.value.body];
    }, willPrintOwnComments: function(e2) {
      const t3 = e2.getValue(), n2 = e2.getParentNode();
      return (t3 && (Ev(t3) || Cv(t3) || xv(n2) && ((e3) => bv(Tv(e3, Bv.Leading)) || bv(Tv(e3, Bv.Trailing)))(t3)) || n2 && (n2.type === "JSXSpreadAttribute" || n2.type === "JSXSpreadChild" || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType" || (n2.type === "ClassDeclaration" || n2.type === "ClassExpression") && n2.superClass === t3)) && (!vv(e2) || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType");
    } };
    const pA = au, { getFunctionParameters: fA, getLeftSidePathName: dA, hasFlowShorthandAnnotationComment: hA, hasNakedLeftSide: gA, hasNode: mA, isBitwiseOperator: yA, startsWithNoLookaheadToken: DA, shouldFlatten: EA, getPrecedence: CA, isCallExpression: bA, isMemberExpression: vA, isObjectProperty: AA } = CC;
    function FA(e2, t3) {
      const n2 = e2.getParentNode();
      if (!n2)
        return false;
      const r2 = e2.getName(), o2 = e2.getNode();
      if (t3.__isInHtmlInterpolation && !t3.bracketSpacing && function(e3) {
        if (e3.type === "ObjectExpression")
          return true;
        return false;
      }(o2) && xA(e2))
        return true;
      if (function(e3) {
        return e3.type === "BlockStatement" || e3.type === "BreakStatement" || e3.type === "ClassBody" || e3.type === "ClassDeclaration" || e3.type === "ClassMethod" || e3.type === "ClassProperty" || e3.type === "PropertyDefinition" || e3.type === "ClassPrivateProperty" || e3.type === "ContinueStatement" || e3.type === "DebuggerStatement" || e3.type === "DeclareClass" || e3.type === "DeclareExportAllDeclaration" || e3.type === "DeclareExportDeclaration" || e3.type === "DeclareFunction" || e3.type === "DeclareInterface" || e3.type === "DeclareModule" || e3.type === "DeclareModuleExports" || e3.type === "DeclareVariable" || e3.type === "DoWhileStatement" || e3.type === "EnumDeclaration" || e3.type === "ExportAllDeclaration" || e3.type === "ExportDefaultDeclaration" || e3.type === "ExportNamedDeclaration" || e3.type === "ExpressionStatement" || e3.type === "ForInStatement" || e3.type === "ForOfStatement" || e3.type === "ForStatement" || e3.type === "FunctionDeclaration" || e3.type === "IfStatement" || e3.type === "ImportDeclaration" || e3.type === "InterfaceDeclaration" || e3.type === "LabeledStatement" || e3.type === "MethodDefinition" || e3.type === "ReturnStatement" || e3.type === "SwitchStatement" || e3.type === "ThrowStatement" || e3.type === "TryStatement" || e3.type === "TSDeclareFunction" || e3.type === "TSEnumDeclaration" || e3.type === "TSImportEqualsDeclaration" || e3.type === "TSInterfaceDeclaration" || e3.type === "TSModuleDeclaration" || e3.type === "TSNamespaceExportDeclaration" || e3.type === "TypeAlias" || e3.type === "VariableDeclaration" || e3.type === "WhileStatement" || e3.type === "WithStatement";
      }(o2))
        return false;
      if (t3.parser !== "flow" && hA(e2.getValue()))
        return true;
      if (o2.type === "Identifier")
        return !!(o2.extra && o2.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o2.name)) || r2 === "left" && o2.name === "async" && n2.type === "ForOfStatement" && !n2.await;
      switch (n2.type) {
        case "ParenthesizedExpression":
          return false;
        case "ClassDeclaration":
        case "ClassExpression":
          if (r2 === "superClass" && (o2.type === "ArrowFunctionExpression" || o2.type === "AssignmentExpression" || o2.type === "AwaitExpression" || o2.type === "BinaryExpression" || o2.type === "ConditionalExpression" || o2.type === "LogicalExpression" || o2.type === "NewExpression" || o2.type === "ObjectExpression" || o2.type === "ParenthesizedExpression" || o2.type === "SequenceExpression" || o2.type === "TaggedTemplateExpression" || o2.type === "UnaryExpression" || o2.type === "UpdateExpression" || o2.type === "YieldExpression" || o2.type === "TSNonNullExpression"))
            return true;
          break;
        case "ExportDefaultDeclaration":
          return SA(e2, t3) || o2.type === "SequenceExpression";
        case "Decorator":
          if (r2 === "expression") {
            let e3 = false, n3 = false, r3 = o2;
            for (; r3; )
              switch (r3.type) {
                case "MemberExpression":
                  n3 = true, r3 = r3.object;
                  break;
                case "CallExpression":
                  if (n3 || e3)
                    return t3.parser !== "typescript";
                  e3 = true, r3 = r3.callee;
                  break;
                case "Identifier":
                  return false;
                case "TaggedTemplateExpression":
                  return t3.parser !== "typescript";
                default:
                  return true;
              }
            return true;
          }
          break;
        case "ExpressionStatement":
          if (DA(o2, true))
            return true;
          break;
        case "ArrowFunctionExpression":
          if (r2 === "body" && o2.type !== "SequenceExpression" && DA(o2, false))
            return true;
      }
      switch (o2.type) {
        case "UpdateExpression":
          if (n2.type === "UnaryExpression")
            return o2.prefix && (o2.operator === "++" && n2.operator === "+" || o2.operator === "--" && n2.operator === "-");
        case "UnaryExpression":
          switch (n2.type) {
            case "UnaryExpression":
              return o2.operator === n2.operator && (o2.operator === "+" || o2.operator === "-");
            case "BindExpression":
            case "TaggedTemplateExpression":
            case "TSNonNullExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
              return r2 === "object";
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return r2 === "callee";
            case "BinaryExpression":
              return r2 === "left" && n2.operator === "**";
            default:
              return false;
          }
        case "BinaryExpression":
          if (n2.type === "UpdateExpression")
            return true;
          if (o2.operator === "in" && function(e3) {
            let t4 = 0, n3 = e3.getValue();
            for (; n3; ) {
              const r3 = e3.getParentNode(t4++);
              if (r3 && r3.type === "ForStatement" && r3.init === n3)
                return true;
              n3 = r3;
            }
            return false;
          }(e2))
            return true;
          if (o2.operator === "|>" && o2.extra && o2.extra.parenthesized) {
            const t4 = e2.getParentNode(1);
            if (t4.type === "BinaryExpression" && t4.operator === "|>")
              return true;
          }
        case "TSTypeAssertion":
        case "TSAsExpression":
        case "LogicalExpression":
          switch (n2.type) {
            case "TSAsExpression":
              return o2.type !== "TSAsExpression";
            case "ConditionalExpression":
              return o2.type === "TSAsExpression";
            case "CallExpression":
            case "NewExpression":
            case "OptionalCallExpression":
              return r2 === "callee";
            case "ClassExpression":
            case "ClassDeclaration":
              return r2 === "superClass";
            case "TSTypeAssertion":
            case "TaggedTemplateExpression":
            case "UnaryExpression":
            case "JSXSpreadAttribute":
            case "SpreadElement":
            case "SpreadProperty":
            case "BindExpression":
            case "AwaitExpression":
            case "TSNonNullExpression":
            case "UpdateExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
              return r2 === "object";
            case "AssignmentExpression":
            case "AssignmentPattern":
              return r2 === "left" && (o2.type === "TSTypeAssertion" || o2.type === "TSAsExpression");
            case "LogicalExpression":
              if (o2.type === "LogicalExpression")
                return n2.operator !== o2.operator;
            case "BinaryExpression": {
              const { operator: e3, type: t4 } = o2;
              if (!e3 && t4 !== "TSTypeAssertion")
                return true;
              const i2 = CA(e3), u2 = n2.operator, s2 = CA(u2);
              return s2 > i2 || (r2 === "right" && s2 === i2 || (s2 === i2 && !EA(u2, e3) || (s2 < i2 && e3 === "%" ? u2 === "+" || u2 === "-" : !!yA(u2))));
            }
            default:
              return false;
          }
        case "SequenceExpression":
          switch (n2.type) {
            case "ReturnStatement":
            case "ForStatement":
              return false;
            case "ExpressionStatement":
              return r2 !== "expression";
            case "ArrowFunctionExpression":
              return r2 !== "body";
            default:
              return true;
          }
        case "YieldExpression":
          if (n2.type === "UnaryExpression" || n2.type === "AwaitExpression" || n2.type === "TSAsExpression" || n2.type === "TSNonNullExpression")
            return true;
        case "AwaitExpression":
          switch (n2.type) {
            case "TaggedTemplateExpression":
            case "UnaryExpression":
            case "LogicalExpression":
            case "SpreadElement":
            case "SpreadProperty":
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "BindExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
              return r2 === "object";
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return r2 === "callee";
            case "ConditionalExpression":
              return r2 === "test";
            case "BinaryExpression":
              return !(!o2.argument && n2.operator === "|>");
            default:
              return false;
          }
        case "TSConditionalType":
          if (r2 === "extendsType" && n2.type === "TSConditionalType")
            return true;
        case "TSFunctionType":
        case "TSConstructorType":
          if (r2 === "checkType" && n2.type === "TSConditionalType")
            return true;
        case "TSUnionType":
        case "TSIntersectionType":
          if ((n2.type === "TSUnionType" || n2.type === "TSIntersectionType") && n2.types.length > 1 && (!o2.types || o2.types.length > 1))
            return true;
        case "TSInferType":
          if (o2.type === "TSInferType" && n2.type === "TSRestType")
            return false;
        case "TSTypeOperator":
          return n2.type === "TSArrayType" || n2.type === "TSOptionalType" || n2.type === "TSRestType" || r2 === "objectType" && n2.type === "TSIndexedAccessType" || n2.type === "TSTypeOperator" || n2.type === "TSTypeAnnotation" && e2.getParentNode(1).type.startsWith("TSJSDoc");
        case "ArrayTypeAnnotation":
          return n2.type === "NullableTypeAnnotation";
        case "IntersectionTypeAnnotation":
        case "UnionTypeAnnotation":
          return n2.type === "ArrayTypeAnnotation" || n2.type === "NullableTypeAnnotation" || n2.type === "IntersectionTypeAnnotation" || n2.type === "UnionTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
        case "NullableTypeAnnotation":
          return n2.type === "ArrayTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
        case "FunctionTypeAnnotation": {
          const t4 = n2.type === "NullableTypeAnnotation" ? e2.getParentNode(1) : n2;
          return t4.type === "UnionTypeAnnotation" || t4.type === "IntersectionTypeAnnotation" || t4.type === "ArrayTypeAnnotation" || r2 === "objectType" && (t4.type === "IndexedAccessType" || t4.type === "OptionalIndexedAccessType") || t4.type === "NullableTypeAnnotation" || n2.type === "FunctionTypeParam" && n2.name === null && fA(o2).some((e3) => e3.typeAnnotation && e3.typeAnnotation.type === "NullableTypeAnnotation");
        }
        case "OptionalIndexedAccessType":
          return r2 === "objectType" && n2.type === "IndexedAccessType";
        case "TypeofTypeAnnotation":
          return r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
        case "StringLiteral":
        case "NumericLiteral":
        case "Literal":
          if (typeof o2.value == "string" && n2.type === "ExpressionStatement" && !n2.directive) {
            const t4 = e2.getParentNode(1);
            return t4.type === "Program" || t4.type === "BlockStatement";
          }
          return r2 === "object" && n2.type === "MemberExpression" && typeof o2.value == "number";
        case "AssignmentExpression": {
          const t4 = e2.getParentNode(1);
          return r2 === "body" && n2.type === "ArrowFunctionExpression" || (r2 !== "key" || n2.type !== "ClassProperty" && n2.type !== "PropertyDefinition" || !n2.computed) && ((r2 !== "init" && r2 !== "update" || n2.type !== "ForStatement") && (n2.type === "ExpressionStatement" ? o2.left.type === "ObjectPattern" : (r2 !== "key" || n2.type !== "TSPropertySignature") && (n2.type !== "AssignmentExpression" && ((n2.type !== "SequenceExpression" || !t4 || t4.type !== "ForStatement" || t4.init !== n2 && t4.update !== n2) && ((r2 !== "value" || n2.type !== "Property" || !t4 || t4.type !== "ObjectPattern" || !t4.properties.includes(n2)) && n2.type !== "NGChainedExpression")))));
        }
        case "ConditionalExpression":
          switch (n2.type) {
            case "TaggedTemplateExpression":
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
            case "BinaryExpression":
            case "LogicalExpression":
            case "NGPipeExpression":
            case "ExportDefaultDeclaration":
            case "AwaitExpression":
            case "JSXSpreadAttribute":
            case "TSTypeAssertion":
            case "TypeCastExpression":
            case "TSAsExpression":
            case "TSNonNullExpression":
              return true;
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return r2 === "callee";
            case "ConditionalExpression":
              return r2 === "test";
            case "MemberExpression":
            case "OptionalMemberExpression":
              return r2 === "object";
            default:
              return false;
          }
        case "FunctionExpression":
          switch (n2.type) {
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return r2 === "callee";
            case "TaggedTemplateExpression":
              return true;
            default:
              return false;
          }
        case "ArrowFunctionExpression":
          switch (n2.type) {
            case "BinaryExpression":
              return n2.operator !== "|>" || o2.extra && o2.extra.parenthesized;
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return r2 === "callee";
            case "MemberExpression":
            case "OptionalMemberExpression":
              return r2 === "object";
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "BindExpression":
            case "TaggedTemplateExpression":
            case "UnaryExpression":
            case "LogicalExpression":
            case "AwaitExpression":
            case "TSTypeAssertion":
              return true;
            case "ConditionalExpression":
              return r2 === "test";
            default:
              return false;
          }
        case "ClassExpression":
          return n2.type === "NewExpression" && r2 === "callee";
        case "OptionalMemberExpression":
        case "OptionalCallExpression": {
          const t4 = e2.getParentNode(1);
          if (r2 === "object" && n2.type === "MemberExpression" || r2 === "callee" && (n2.type === "CallExpression" || n2.type === "NewExpression") || n2.type === "TSNonNullExpression" && t4.type === "MemberExpression" && t4.object === n2)
            return true;
        }
        case "CallExpression":
        case "MemberExpression":
        case "TaggedTemplateExpression":
        case "TSNonNullExpression":
          if (r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression")) {
            let e3 = o2;
            for (; e3; )
              switch (e3.type) {
                case "CallExpression":
                case "OptionalCallExpression":
                  return true;
                case "MemberExpression":
                case "OptionalMemberExpression":
                case "BindExpression":
                  e3 = e3.object;
                  break;
                case "TaggedTemplateExpression":
                  e3 = e3.tag;
                  break;
                case "TSNonNullExpression":
                  e3 = e3.expression;
                  break;
                default:
                  return false;
              }
          }
          return false;
        case "BindExpression":
          return r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression") || r2 === "object" && vA(n2);
        case "NGPipeExpression":
          return !(n2.type === "NGRoot" || n2.type === "NGMicrosyntaxExpression" || n2.type === "ObjectProperty" && (!o2.extra || !o2.extra.parenthesized) || n2.type === "ArrayExpression" || bA(n2) && n2.arguments[r2] === o2 || r2 === "right" && n2.type === "NGPipeExpression" || r2 === "property" && n2.type === "MemberExpression" || n2.type === "AssignmentExpression");
        case "JSXFragment":
        case "JSXElement":
          return r2 === "callee" || r2 === "left" && n2.type === "BinaryExpression" && n2.operator === "<" || n2.type !== "ArrayExpression" && n2.type !== "ArrowFunctionExpression" && n2.type !== "AssignmentExpression" && n2.type !== "AssignmentPattern" && n2.type !== "BinaryExpression" && n2.type !== "NewExpression" && n2.type !== "ConditionalExpression" && n2.type !== "ExpressionStatement" && n2.type !== "JsExpressionRoot" && n2.type !== "JSXAttribute" && n2.type !== "JSXElement" && n2.type !== "JSXExpressionContainer" && n2.type !== "JSXFragment" && n2.type !== "LogicalExpression" && !bA(n2) && !AA(n2) && n2.type !== "ReturnStatement" && n2.type !== "ThrowStatement" && n2.type !== "TypeCastExpression" && n2.type !== "VariableDeclarator" && n2.type !== "YieldExpression";
        case "TypeAnnotation":
          return r2 === "returnType" && n2.type === "ArrowFunctionExpression" && function(e3) {
            return mA(e3, (e4) => e4.type === "ObjectTypeAnnotation" && mA(e4, (e5) => e5.type === "FunctionTypeAnnotation" || void 0) || void 0);
          }(o2);
      }
      return false;
    }
    function xA(e2) {
      const t3 = e2.getValue(), n2 = e2.getParentNode(), r2 = e2.getName();
      switch (n2.type) {
        case "NGPipeExpression":
          if (typeof r2 == "number" && n2.arguments[r2] === t3 && n2.arguments.length - 1 === r2)
            return e2.callParent(xA);
          break;
        case "ObjectProperty":
          if (r2 === "value") {
            const t4 = e2.getParentNode(1);
            return pA(t4.properties) === n2;
          }
          break;
        case "BinaryExpression":
        case "LogicalExpression":
          if (r2 === "right")
            return e2.callParent(xA);
          break;
        case "ConditionalExpression":
          if (r2 === "alternate")
            return e2.callParent(xA);
          break;
        case "UnaryExpression":
          if (n2.prefix)
            return e2.callParent(xA);
      }
      return false;
    }
    function SA(e2, t3) {
      const n2 = e2.getValue(), r2 = e2.getParentNode();
      return n2.type === "FunctionExpression" || n2.type === "ClassExpression" ? r2.type === "ExportDefaultDeclaration" || !FA(e2, t3) : !(!gA(n2) || r2.type !== "ExportDefaultDeclaration" && FA(e2, t3)) && e2.call((e3) => SA(e3, t3), ...dA(e2, n2));
    }
    var wA = FA;
    var TA = function(e2, t3) {
      switch (t3.parser) {
        case "json":
        case "json5":
        case "json-stringify":
        case "__js_expression":
        case "__vue_expression":
          return Object.assign(Object.assign({}, e2), {}, { type: t3.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: e2, comments: [], rootMarker: t3.rootMarker });
        default:
          return e2;
      }
    };
    const { builders: { join: BA, line: NA, group: kA, softline: PA, indent: OA } } = Zc;
    var IA = { isVueEventBindingExpression: function e2(t3) {
      switch (t3.type) {
        case "MemberExpression":
          switch (t3.property.type) {
            case "Identifier":
            case "NumericLiteral":
            case "StringLiteral":
              return e2(t3.object);
          }
          return false;
        case "Identifier":
          return true;
        default:
          return false;
      }
    }, printHtmlBinding: function(e2, t3, n2) {
      const r2 = e2.getValue();
      if (t3.__onHtmlBindingRoot && e2.getName() === null && t3.__onHtmlBindingRoot(r2, t3), r2.type === "File")
        return t3.__isVueForBindingLeft ? e2.call((e3) => {
          const t4 = BA([",", NA], e3.map(n2, "params")), { params: r3 } = e3.getValue();
          return r3.length === 1 ? t4 : ["(", OA([PA, kA(t4)]), PA, ")"];
        }, "program", "body", 0) : t3.__isVueBindings ? e2.call((e3) => BA([",", NA], e3.map(n2, "params")), "program", "body", 0) : void 0;
    } };
    const { printComments: LA } = tD, { getLast: jA } = dc, { builders: { join: _A, line: MA, softline: RA, group: VA, indent: $A, align: WA, ifBreak: qA, indentIfBreak: UA }, utils: { cleanDoc: zA, getDocParts: GA, isConcat: HA } } = Zc, { hasLeadingOwnLineComment: JA, isBinaryish: XA, isJsxNode: YA, shouldFlatten: KA, hasComment: QA, CommentCheckFlags: ZA, isCallExpression: eF, isMemberExpression: tF, isObjectProperty: nF, isEnabledHackPipeline: rF } = CC;
    let oF = 0;
    function iF(e2, t3, n2, r2, o2) {
      const i2 = e2.getValue();
      if (!XA(i2))
        return [VA(t3())];
      let u2 = [];
      KA(i2.operator, i2.left.operator) ? u2 = e2.call((e3) => iF(e3, t3, n2, true, o2), "left") : u2.push(VA(t3("left")));
      const s2 = uF(i2), a2 = (i2.operator === "|>" || i2.type === "NGPipeExpression" || i2.operator === "|" && n2.parser === "__vue_expression") && !JA(n2.originalText, i2.right), c2 = i2.type === "NGPipeExpression" ? "|" : i2.operator, l2 = i2.type === "NGPipeExpression" && i2.arguments.length > 0 ? VA($A([RA, ": ", _A([RA, ":", qA(" ")], e2.map(t3, "arguments").map((e3) => WA(2, VA(e3))))])) : "";
      let p2;
      if (s2)
        p2 = [c2, " ", t3("right"), l2];
      else {
        const r3 = rF(n2) && c2 === "|>" ? e2.call((e3) => iF(e3, t3, n2, true, o2), "right") : t3("right");
        p2 = [a2 ? MA : "", c2, a2 ? " " : MA, r3, l2];
      }
      const f2 = e2.getParentNode(), d2 = QA(i2.left, ZA.Trailing | ZA.Line), h2 = d2 || !(o2 && i2.type === "LogicalExpression") && f2.type !== i2.type && i2.left.type !== i2.type && i2.right.type !== i2.type;
      if (u2.push(a2 ? "" : " ", h2 ? VA(p2, { shouldBreak: d2 }) : p2), r2 && QA(i2)) {
        const t4 = zA(LA(e2, u2, n2));
        return HA(t4) || t4.type === "fill" ? GA(t4) : [t4];
      }
      return u2;
    }
    function uF(e2) {
      return e2.type === "LogicalExpression" && (e2.right.type === "ObjectExpression" && e2.right.properties.length > 0 || (e2.right.type === "ArrayExpression" && e2.right.elements.length > 0 || !!YA(e2.right)));
    }
    var sF = { printBinaryishExpression: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = e2.getParentNode(), i2 = e2.getParentNode(1), u2 = r2 !== o2.body && (o2.type === "IfStatement" || o2.type === "WhileStatement" || o2.type === "SwitchStatement" || o2.type === "DoWhileStatement"), s2 = rF(t3) && r2.operator === "|>", a2 = iF(e2, n2, t3, false, u2);
      if (u2)
        return a2;
      if (s2)
        return VA(a2);
      if (eF(o2) && o2.callee === r2 || o2.type === "UnaryExpression" || tF(o2) && !o2.computed)
        return VA([$A([RA, ...a2]), RA]);
      const c2 = o2.type === "ReturnStatement" || o2.type === "ThrowStatement" || o2.type === "JSXExpressionContainer" && i2.type === "JSXAttribute" || r2.operator !== "|" && o2.type === "JsExpressionRoot" || r2.type !== "NGPipeExpression" && (o2.type === "NGRoot" && t3.parser === "__ng_binding" || o2.type === "NGMicrosyntaxExpression" && i2.type === "NGMicrosyntax" && i2.body.length === 1) || r2 === o2.body && o2.type === "ArrowFunctionExpression" || r2 !== o2.body && o2.type === "ForStatement" || o2.type === "ConditionalExpression" && i2.type !== "ReturnStatement" && i2.type !== "ThrowStatement" && !eF(i2) || o2.type === "TemplateLiteral", l2 = o2.type === "AssignmentExpression" || o2.type === "VariableDeclarator" || o2.type === "ClassProperty" || o2.type === "PropertyDefinition" || o2.type === "TSAbstractPropertyDefinition" || o2.type === "ClassPrivateProperty" || nF(o2), p2 = XA(r2.left) && KA(r2.operator, r2.left.operator);
      if (c2 || uF(r2) && !p2 || !uF(r2) && l2)
        return VA(a2);
      if (a2.length === 0)
        return "";
      const f2 = YA(r2.right), d2 = a2.findIndex((e3) => typeof e3 != "string" && !Array.isArray(e3) && e3.type === "group"), h2 = a2.slice(0, d2 === -1 ? 1 : d2 + 1), g2 = a2.slice(h2.length, f2 ? -1 : void 0), m2 = Symbol("logicalChain-" + ++oF), y2 = VA([...h2, $A(g2)], { id: m2 });
      if (!f2)
        return y2;
      const D2 = jA(a2);
      return VA([y2, UA(D2, { groupId: m2 })]);
    }, shouldInlineLogicalExpression: uF };
    const { builders: { join: aF, line: cF, group: lF } } = Zc, { hasNode: pF, hasComment: fF, getComments: dF } = CC, { printBinaryishExpression: hF } = sF;
    function gF(e2, t3, n2) {
      return e2.type === "NGMicrosyntaxKeyedExpression" && e2.key.name === "of" && t3 === 1 && n2.body[0].type === "NGMicrosyntaxLet" && n2.body[0].value === null;
    }
    var mF = { printAngular: function(e2, t3, n2) {
      const r2 = e2.getValue();
      if (r2.type.startsWith("NG"))
        switch (r2.type) {
          case "NGRoot":
            return [n2("node"), fF(r2.node) ? " //" + dF(r2.node)[0].value.trimEnd() : ""];
          case "NGPipeExpression":
            return hF(e2, t3, n2);
          case "NGChainedExpression":
            return lF(aF([";", cF], e2.map((e3) => function(e4) {
              return pF(e4.getValue(), (e5) => {
                switch (e5.type) {
                  case void 0:
                    return false;
                  case "CallExpression":
                  case "OptionalCallExpression":
                  case "AssignmentExpression":
                    return true;
                }
              });
            }(e3) ? n2() : ["(", n2(), ")"], "expressions")));
          case "NGEmptyExpression":
            return "";
          case "NGQuotedExpression":
            return [r2.prefix, ": ", r2.value.trim()];
          case "NGMicrosyntax":
            return e2.map((e3, t4) => [t4 === 0 ? "" : gF(e3.getValue(), t4, r2) ? " " : [";", cF], n2()], "body");
          case "NGMicrosyntaxKey":
            return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(r2.name) ? r2.name : JSON.stringify(r2.name);
          case "NGMicrosyntaxExpression":
            return [n2("expression"), r2.alias === null ? "" : [" as ", n2("alias")]];
          case "NGMicrosyntaxKeyedExpression": {
            const t4 = e2.getName(), o2 = e2.getParentNode(), i2 = gF(r2, t4, o2) || (t4 === 1 && (r2.key.name === "then" || r2.key.name === "else") || t4 === 2 && r2.key.name === "else" && o2.body[t4 - 1].type === "NGMicrosyntaxKeyedExpression" && o2.body[t4 - 1].key.name === "then") && o2.body[0].type === "NGMicrosyntaxExpression";
            return [n2("key"), i2 ? " " : ": ", n2("expression")];
          }
          case "NGMicrosyntaxLet":
            return ["let ", n2("key"), r2.value === null ? "" : [" = ", n2("value")]];
          case "NGMicrosyntaxAs":
            return [n2("key"), " as ", n2("alias")];
          default:
            throw new Error("Unknown Angular node type: ".concat(JSON.stringify(r2.type), "."));
        }
    } };
    const { printComments: yF, printDanglingComments: DF } = tD, { builders: { line: EF, hardline: CF, softline: bF, group: vF, indent: AF, conditionalGroup: FF, fill: xF, ifBreak: SF, lineSuffixBoundary: wF, join: TF }, utils: { willBreak: BF } } = Zc, { getLast: NF, getPreferredQuote: kF } = dc, { isJsxNode: PF, rawText: OF, isLiteral: IF, isCallExpression: LF, isStringLiteral: jF, isBinaryish: _F, hasComment: MF, CommentCheckFlags: RF, hasNodeIgnoreComment: VF } = CC, $F = wA, { willPrintOwnComments: WF } = lA, qF = (e2) => e2 === "" || e2 === EF || e2 === CF || e2 === bF;
    function UF(e2, t3, n2) {
      const r2 = e2.getValue();
      if (r2.type === "JSXElement" && function(e3) {
        if (e3.children.length === 0)
          return true;
        if (e3.children.length > 1)
          return false;
        const t4 = e3.children[0];
        return IF(t4) && !QF(t4);
      }(r2))
        return [n2("openingElement"), n2("closingElement")];
      const o2 = r2.type === "JSXElement" ? n2("openingElement") : n2("openingFragment"), i2 = r2.type === "JSXElement" ? n2("closingElement") : n2("closingFragment");
      if (r2.children.length === 1 && r2.children[0].type === "JSXExpressionContainer" && (r2.children[0].expression.type === "TemplateLiteral" || r2.children[0].expression.type === "TaggedTemplateExpression"))
        return [o2, ...e2.map(n2, "children"), i2];
      r2.children = r2.children.map((e3) => function(e4) {
        return e4.type === "JSXExpressionContainer" && IF(e4.expression) && e4.expression.value === " " && !MF(e4.expression);
      }(e3) ? { type: "JSXText", value: " ", raw: " " } : e3);
      const u2 = r2.children.some(PF), s2 = r2.children.filter((e3) => e3.type === "JSXExpressionContainer").length > 1, a2 = r2.type === "JSXElement" && r2.openingElement.attributes.length > 1;
      let c2 = BF(o2) || u2 || a2 || s2;
      const l2 = e2.getParentNode().rootMarker === "mdx", p2 = t3.singleQuote ? "{' '}" : '{" "}', f2 = l2 ? " " : SF([p2, bF], " "), d2 = function(e3, t4, n3, r3, o3) {
        const i3 = [];
        return e3.each((e4, t5, u3) => {
          const s3 = e4.getValue();
          if (IF(s3)) {
            const e5 = OF(s3);
            if (QF(s3)) {
              const n4 = e5.split(XF);
              if (n4[0] === "") {
                if (i3.push(""), n4.shift(), /\n/.test(n4[0])) {
                  const e6 = u3[t5 + 1];
                  i3.push(GF(o3, n4[1], s3, e6));
                } else
                  i3.push(r3);
                n4.shift();
              }
              let a3;
              if (NF(n4) === "" && (n4.pop(), a3 = n4.pop()), n4.length === 0)
                return;
              for (const [e6, t6] of n4.entries())
                e6 % 2 == 1 ? i3.push(EF) : i3.push(t6);
              if (a3 !== void 0)
                if (/\n/.test(a3)) {
                  const e6 = u3[t5 + 1];
                  i3.push(GF(o3, NF(i3), s3, e6));
                } else
                  i3.push(r3);
              else {
                const e6 = u3[t5 + 1];
                i3.push(zF(o3, NF(i3), s3, e6));
              }
            } else
              /\n/.test(e5) ? e5.match(/\n/g).length > 1 && i3.push("", CF) : i3.push("", r3);
          } else {
            const e5 = n3();
            i3.push(e5);
            const r4 = u3[t5 + 1];
            if (r4 && QF(r4)) {
              const e6 = KF(OF(r4)).split(XF)[0];
              i3.push(zF(o3, e6, s3, r4));
            } else
              i3.push(CF);
          }
        }, "children"), i3;
      }(e2, 0, n2, f2, r2.openingElement && r2.openingElement.name && r2.openingElement.name.name === "fbt"), h2 = r2.children.some((e3) => QF(e3));
      for (let e3 = d2.length - 2; e3 >= 0; e3--) {
        const t4 = d2[e3] === "" && d2[e3 + 1] === "", n3 = d2[e3] === CF && d2[e3 + 1] === "" && d2[e3 + 2] === CF, r3 = (d2[e3] === bF || d2[e3] === CF) && d2[e3 + 1] === "" && d2[e3 + 2] === f2, o3 = d2[e3] === f2 && d2[e3 + 1] === "" && (d2[e3 + 2] === bF || d2[e3 + 2] === CF), i3 = d2[e3] === f2 && d2[e3 + 1] === "" && d2[e3 + 2] === f2, u3 = d2[e3] === bF && d2[e3 + 1] === "" && d2[e3 + 2] === CF || d2[e3] === CF && d2[e3 + 1] === "" && d2[e3 + 2] === bF;
        n3 && h2 || t4 || r3 || i3 || u3 ? d2.splice(e3, 2) : o3 && d2.splice(e3 + 1, 2);
      }
      for (; d2.length > 0 && qF(NF(d2)); )
        d2.pop();
      for (; d2.length > 1 && qF(d2[0]) && qF(d2[1]); )
        d2.shift(), d2.shift();
      const g2 = [];
      for (const [e3, t4] of d2.entries()) {
        if (t4 === f2) {
          if (e3 === 1 && d2[e3 - 1] === "") {
            if (d2.length === 2) {
              g2.push(p2);
              continue;
            }
            g2.push([p2, CF]);
            continue;
          }
          if (e3 === d2.length - 1) {
            g2.push(p2);
            continue;
          }
          if (d2[e3 - 1] === "" && d2[e3 - 2] === CF) {
            g2.push(p2);
            continue;
          }
        }
        g2.push(t4), BF(t4) && (c2 = true);
      }
      const m2 = h2 ? xF(g2) : vF(g2, { shouldBreak: true });
      if (l2)
        return m2;
      const y2 = vF([o2, AF([CF, m2]), CF, i2]);
      return c2 ? y2 : FF([vF([o2, ...d2, i2]), y2]);
    }
    function zF(e2, t3, n2, r2) {
      return e2 ? "" : n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? t3.length === 1 ? bF : CF : bF;
    }
    function GF(e2, t3, n2, r2) {
      return e2 ? CF : t3.length === 1 ? n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? CF : bF : CF;
    }
    function HF(e2, t3, n2) {
      return function(e3, t4, n3) {
        const r2 = e3.getParentNode();
        if (!r2)
          return t4;
        if ({ ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[r2.type])
          return t4;
        const o2 = e3.match(void 0, (e4) => e4.type === "ArrowFunctionExpression", LF, (e4) => e4.type === "JSXExpressionContainer"), i2 = $F(e3, n3);
        return vF([i2 ? "" : SF("("), AF([bF, t4]), bF, i2 ? "" : SF(")")], { shouldBreak: o2 });
      }(e2, yF(e2, UF(e2, t3, n2), t3), t3);
    }
    function JF(e2, t3, n2) {
      const r2 = e2.getValue();
      return ["{", e2.call((e3) => {
        const r3 = ["...", n2()], o2 = e3.getValue();
        return MF(o2) && WF(e3) ? [AF([bF, yF(e3, r3, t3)]), bF] : r3;
      }, r2.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
    }
    const XF = new RegExp("([ \n\r	]+)"), YF = new RegExp("[^ \n\r	]"), KF = (e2) => e2.replace(new RegExp("(?:^" + XF.source + "|" + XF.source + "$)"), "");
    function QF(e2) {
      return IF(e2) && (YF.test(OF(e2)) || !/\n/.test(OF(e2)));
    }
    var ZF = { hasJsxIgnoreComment: function(e2) {
      const t3 = e2.getValue(), n2 = e2.getParentNode();
      if (!(n2 && t3 && PF(t3) && PF(n2)))
        return false;
      let r2 = null;
      for (let e3 = n2.children.indexOf(t3); e3 > 0; e3--) {
        const t4 = n2.children[e3 - 1];
        if (t4.type !== "JSXText" || QF(t4)) {
          r2 = t4;
          break;
        }
      }
      return r2 && r2.type === "JSXExpressionContainer" && r2.expression.type === "JSXEmptyExpression" && VF(r2.expression);
    }, printJsx: function(e2, t3, n2) {
      const r2 = e2.getValue();
      if (r2.type.startsWith("JSX"))
        switch (r2.type) {
          case "JSXAttribute":
            return function(e3, t4, n3) {
              const r3 = e3.getValue(), o2 = [];
              if (o2.push(n3("name")), r3.value) {
                let e4;
                if (jF(r3.value)) {
                  let n4 = OF(r3.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                  const { escaped: o3, quote: i2, regex: u2 } = kF(n4, t4.jsxSingleQuote ? "'" : '"');
                  n4 = n4.replace(u2, o3), e4 = [i2, n4, i2];
                } else
                  e4 = n3("value");
                o2.push("=", e4);
              }
              return o2;
            }(e2, t3, n2);
          case "JSXIdentifier":
            return String(r2.name);
          case "JSXNamespacedName":
            return TF(":", [n2("namespace"), n2("name")]);
          case "JSXMemberExpression":
            return TF(".", [n2("object"), n2("property")]);
          case "JSXSpreadAttribute":
            return JF(e2, t3, n2);
          case "JSXSpreadChild":
            return JF(e2, t3, n2);
          case "JSXExpressionContainer":
            return function(e3, t4, n3) {
              const r3 = e3.getValue(), o2 = e3.getParentNode(0), i2 = r3.expression.type === "JSXEmptyExpression" || !MF(r3.expression) && (r3.expression.type === "ArrayExpression" || r3.expression.type === "ObjectExpression" || r3.expression.type === "ArrowFunctionExpression" || LF(r3.expression) || r3.expression.type === "FunctionExpression" || r3.expression.type === "TemplateLiteral" || r3.expression.type === "TaggedTemplateExpression" || r3.expression.type === "DoExpression" || PF(o2) && (r3.expression.type === "ConditionalExpression" || _F(r3.expression)));
              return vF(i2 ? ["{", n3("expression"), wF, "}"] : ["{", AF([bF, n3("expression")]), bF, wF, "}"]);
            }(e2, 0, n2);
          case "JSXFragment":
          case "JSXElement":
            return HF(e2, t3, n2);
          case "JSXOpeningElement":
            return function(e3, t4, n3) {
              const r3 = e3.getValue(), o2 = r3.name && MF(r3.name) || r3.typeParameters && MF(r3.typeParameters);
              if (r3.selfClosing && r3.attributes.length === 0 && !o2)
                return ["<", n3("name"), n3("typeParameters"), " />"];
              if (r3.attributes && r3.attributes.length === 1 && r3.attributes[0].value && jF(r3.attributes[0].value) && !r3.attributes[0].value.value.includes("\n") && !o2 && !MF(r3.attributes[0]))
                return vF(["<", n3("name"), n3("typeParameters"), " ", ...e3.map(n3, "attributes"), r3.selfClosing ? " />" : ">"]);
              const i2 = r3.attributes.length > 0 && MF(NF(r3.attributes), RF.Trailing), u2 = r3.attributes.length === 0 && !o2 || (t4.bracketSameLine || t4.jsxBracketSameLine) && (!o2 || r3.attributes.length > 0) && !i2, s2 = r3.attributes && r3.attributes.some((e4) => e4.value && jF(e4.value) && e4.value.value.includes("\n"));
              return vF(["<", n3("name"), n3("typeParameters"), AF(e3.map(() => [EF, n3()], "attributes")), r3.selfClosing ? EF : u2 ? ">" : bF, r3.selfClosing ? "/>" : u2 ? "" : ">"], { shouldBreak: s2 });
            }(e2, t3, n2);
          case "JSXClosingElement":
            return function(e3, t4, n3) {
              const r3 = e3.getValue(), o2 = [];
              o2.push("</");
              const i2 = n3("name");
              return MF(r3.name, RF.Leading | RF.Line) ? o2.push(AF([CF, i2]), CF) : MF(r3.name, RF.Leading | RF.Block) ? o2.push(" ", i2) : o2.push(i2), o2.push(">"), o2;
            }(e2, 0, n2);
          case "JSXOpeningFragment":
          case "JSXClosingFragment":
            return function(e3, t4) {
              const n3 = e3.getValue(), r3 = MF(n3), o2 = MF(n3, RF.Line), i2 = n3.type === "JSXOpeningFragment";
              return [i2 ? "<" : "</", AF([o2 ? CF : r3 && !i2 ? " " : "", DF(e3, t4, true)]), o2 ? CF : "", ">"];
            }(e2, t3);
          case "JSXEmptyExpression":
            return function(e3, t4) {
              const n3 = e3.getValue(), r3 = MF(n3, RF.Line);
              return [DF(e3, t4, !r3), r3 ? CF : ""];
            }(e2, t3);
          case "JSXText":
            throw new Error("JSXTest should be handled by JSXElement");
          default:
            throw new Error("Unknown JSX node type: ".concat(JSON.stringify(r2.type), "."));
        }
    } }, ex = bu, tx = Ze, nx = gr, rx2 = ar, ox = Wu;
    ro({ target: "Array", proto: true }, { flat: function() {
      var e2 = arguments.length ? arguments[0] : void 0, t3 = tx(this), n2 = nx(t3), r2 = ox(t3, 0);
      return r2.length = ex(r2, t3, t3, n2, 0, e2 === void 0 ? 1 : rx2(e2)), r2;
    } });
    var ix, ux = Sr, sx = wr2, ax = Object.keys || function(e2) {
      return ux(e2, sx);
    }, cx = zt, lx = Yt, px = oe, fx = ax, dx = B ? Object.defineProperties : function(e2, t3) {
      lx(e2);
      for (var n2, r2 = px(t3), o2 = fx(t3), i2 = o2.length, u2 = 0; i2 > u2; )
        cx.f(e2, n2 = o2[u2++], r2[n2]);
      return e2;
    }, hx = pe("document", "documentElement"), gx = Yt, mx = dx, yx = wr2, Dx = An, Ex = hx, Cx = Ot, bx = vn("IE_PROTO"), vx = function() {
    }, Ax = function(e2) {
      return "<script>" + e2 + "<\/script>";
    }, Fx = function(e2) {
      e2.write(Ax("")), e2.close();
      var t3 = e2.parentWindow.Object;
      return e2 = null, t3;
    }, xx = function() {
      try {
        ix = new ActiveXObject("htmlfile");
      } catch (e3) {
      }
      xx = typeof document != "undefined" ? document.domain && ix ? Fx(ix) : function() {
        var e3, t3 = Cx("iframe");
        return t3.style.display = "none", Ex.appendChild(t3), t3.src = String("javascript:"), (e3 = t3.contentWindow.document).open(), e3.write(Ax("document.F=Object")), e3.close(), e3.F;
      }() : Fx(ix);
      for (var e2 = yx.length; e2--; )
        delete xx.prototype[yx[e2]];
      return xx();
    };
    Dx[bx] = true;
    var Sx = Object.create || function(e2, t3) {
      var n2;
      return e2 !== null ? (vx.prototype = gx(e2), n2 = new vx(), vx.prototype = null, n2[bx] = e2) : n2 = xx(), t3 === void 0 ? n2 : mx(n2, t3);
    }, wx = zt, Tx = Dt("unscopables"), Bx = Array.prototype;
    Bx[Tx] == null && wx.f(Bx, Tx, { configurable: true, value: Sx(null) });
    var Nx = function(e2) {
      Bx[Tx][e2] = true;
    };
    Nx("flat");
    const { isNonEmptyArray: kx } = dc, { builders: { indent: Px, join: Ox, line: Ix } } = Zc, { isFlowAnnotationComment: Lx } = CC;
    function jx(e2, t3, n2) {
      const r2 = e2.getValue();
      if (!r2.typeAnnotation)
        return "";
      const o2 = e2.getParentNode(), i2 = r2.definite || o2 && o2.type === "VariableDeclarator" && o2.definite, u2 = o2.type === "DeclareFunction" && o2.id === r2;
      return Lx(t3.originalText, r2.typeAnnotation) ? [" /*: ", n2("typeAnnotation"), " */"] : [u2 ? "" : i2 ? "!: " : ": ", n2("typeAnnotation")];
    }
    var _x = { printOptionalToken: function(e2) {
      const t3 = e2.getValue();
      return !t3.optional || t3.type === "Identifier" && t3 === e2.getParentNode().key ? "" : t3.type === "OptionalCallExpression" || t3.type === "OptionalMemberExpression" && t3.computed ? "?." : "?";
    }, printFunctionTypeParameters: function(e2, t3, n2) {
      const r2 = e2.getValue();
      return r2.typeArguments ? n2("typeArguments") : r2.typeParameters ? n2("typeParameters") : "";
    }, printBindExpressionCallee: function(e2, t3, n2) {
      return ["::", n2("callee")];
    }, printTypeScriptModifiers: function(e2, t3, n2) {
      const r2 = e2.getValue();
      return kx(r2.modifiers) ? [Ox(" ", e2.map(n2, "modifiers")), " "] : "";
    }, printTypeAnnotation: jx, printRestSpread: function(e2, t3, n2) {
      return ["...", n2("argument"), jx(e2, t3, n2)];
    }, adjustClause: function(e2, t3, n2) {
      return e2.type === "EmptyStatement" ? ";" : e2.type === "BlockStatement" || n2 ? [" ", t3] : Px([Ix, t3]);
    } };
    const { printDanglingComments: Mx } = tD, { builders: { line: Rx, softline: Vx, hardline: $x, group: Wx, indent: qx, ifBreak: Ux, fill: zx } } = Zc, { getLast: Gx, hasNewline: Hx } = dc, { shouldPrintComma: Jx, hasComment: Xx, CommentCheckFlags: Yx, isNextLineEmpty: Kx, isNumericLiteral: Qx, isSignedNumericLiteral: Zx } = CC, { locStart: eS } = og, { printOptionalToken: tS, printTypeAnnotation: nS } = _x;
    function rS(e2, t3) {
      return e2.elements.length > 1 && e2.elements.every((e3) => e3 && (Qx(e3) || Zx(e3) && !Xx(e3.argument)) && !Xx(e3, Yx.Trailing | Yx.Line, (e4) => !Hx(t3.originalText, eS(e4), { backwards: true })));
    }
    function oS2(e2, t3, n2, r2) {
      const o2 = [];
      let i2 = [];
      return e2.each((e3) => {
        o2.push(i2, Wx(r2())), i2 = [",", Rx], e3.getValue() && Kx(e3.getValue(), t3) && i2.push(Vx);
      }, n2), o2;
    }
    function iS(e2, t3, n2, r2) {
      const o2 = [];
      return e2.each((e3, i2, u2) => {
        const s2 = i2 === u2.length - 1;
        o2.push([n2(), s2 ? r2 : ","]), s2 || o2.push(Kx(e3.getValue(), t3) ? [$x, $x] : Xx(u2[i2 + 1], Yx.Leading | Yx.Line) ? $x : Rx);
      }, "elements"), zx(o2);
    }
    var uS = { printArray: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = [], i2 = r2.type === "TupleExpression" ? "#[" : "[";
      if (r2.elements.length === 0)
        Xx(r2, Yx.Dangling) ? o2.push(Wx([i2, Mx(e2, t3), Vx, "]"])) : o2.push(i2, "]");
      else {
        const u2 = Gx(r2.elements), s2 = !(u2 && u2.type === "RestElement"), a2 = u2 === null, c2 = Symbol("array"), l2 = !t3.__inJestEach && r2.elements.length > 1 && r2.elements.every((e3, t4, n3) => {
          const r3 = e3 && e3.type;
          if (r3 !== "ArrayExpression" && r3 !== "ObjectExpression")
            return false;
          const o3 = n3[t4 + 1];
          if (o3 && r3 !== o3.type)
            return false;
          const i3 = r3 === "ArrayExpression" ? "elements" : "properties";
          return e3[i3] && e3[i3].length > 1;
        }), p2 = rS(r2, t3), f2 = s2 ? a2 ? "," : Jx(t3) ? p2 ? Ux(",", "", { groupId: c2 }) : Ux(",") : "" : "";
        o2.push(Wx([i2, qx([Vx, p2 ? iS(e2, t3, n2, f2) : [oS2(e2, t3, "elements", n2), f2], Mx(e2, t3, true)]), Vx, "]"], { shouldBreak: l2, id: c2 }));
      }
      return o2.push(tS(e2), nS(e2, t3, n2)), o2;
    }, printArrayItems: oS2, isConciselyPrintedArray: rS };
    const { printDanglingComments: sS } = tD, { getLast: aS, getPenultimate: cS } = dc, { getFunctionParameters: lS, hasComment: pS, CommentCheckFlags: fS, isFunctionCompositionArgs: dS, isJsxNode: hS, isLongCurriedCallExpression: gS, shouldPrintComma: mS, getCallArguments: yS, iterateCallArgumentsPath: DS, isNextLineEmpty: ES, isCallExpression: CS, isStringLiteral: bS, isObjectProperty: vS } = CC, { builders: { line: AS, hardline: FS, softline: xS, group: SS, indent: wS, conditionalGroup: TS, ifBreak: BS, breakParent: NS }, utils: { willBreak: kS } } = Zc, { ArgExpansionBailout: PS } = Cp, { isConciselyPrintedArray: OS } = uS;
    function IS(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
      return e2.type === "ObjectExpression" && (e2.properties.length > 0 || pS(e2)) || e2.type === "ArrayExpression" && (e2.elements.length > 0 || pS(e2)) || e2.type === "TSTypeAssertion" && IS(e2.expression) || e2.type === "TSAsExpression" && IS(e2.expression) || e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression" && (!e2.returnType || !e2.returnType.typeAnnotation || e2.returnType.typeAnnotation.type !== "TSTypeReference" || LS(e2.body)) && (e2.body.type === "BlockStatement" || e2.body.type === "ArrowFunctionExpression" && IS(e2.body, true) || e2.body.type === "ObjectExpression" || e2.body.type === "ArrayExpression" || !t3 && (CS(e2.body) || e2.body.type === "ConditionalExpression") || hS(e2.body)) || e2.type === "DoExpression" || e2.type === "ModuleExpression";
    }
    function LS(e2) {
      return e2.type === "BlockStatement" && (e2.body.some((e3) => e3.type !== "EmptyStatement") || pS(e2, fS.Dangling));
    }
    var jS = function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = r2.type === "ImportExpression", i2 = yS(r2);
      if (i2.length === 0)
        return ["(", sS(e2, t3, true), ")"];
      if (function(e3) {
        return e3.length === 2 && e3[0].type === "ArrowFunctionExpression" && lS(e3[0]).length === 0 && e3[0].body.type === "BlockStatement" && e3[1].type === "ArrayExpression" && !e3.some((e4) => pS(e4));
      }(i2))
        return ["(", n2(["arguments", 0]), ", ", n2(["arguments", 1]), ")"];
      let u2 = false, s2 = false;
      const a2 = i2.length - 1, c2 = [];
      DS(e2, (e3, r3) => {
        const o3 = e3.getNode(), i3 = [n2()];
        r3 === a2 || (ES(o3, t3) ? (r3 === 0 && (s2 = true), u2 = true, i3.push(",", FS, FS)) : i3.push(",", AS)), c2.push(i3);
      });
      const l2 = o2 || r2.callee && r2.callee.type === "Import" || !mS(t3, "all") ? "" : ",";
      function p2() {
        return SS(["(", wS([AS, ...c2]), l2, AS, ")"], { shouldBreak: true });
      }
      if (u2 || e2.getParentNode().type !== "Decorator" && dS(i2))
        return p2();
      const f2 = function(e3) {
        if (e3.length !== 2)
          return false;
        const [t4, n3] = e3;
        if (t4.type === "ModuleExpression" && function(e4) {
          return e4.type === "ObjectExpression" && e4.properties.length === 1 && vS(e4.properties[0]) && e4.properties[0].key.type === "Identifier" && e4.properties[0].key.name === "type" && bS(e4.properties[0].value) && e4.properties[0].value.value === "module";
        }(n3))
          return true;
        return !pS(t4) && (t4.type === "FunctionExpression" || t4.type === "ArrowFunctionExpression" && t4.body.type === "BlockStatement") && n3.type !== "FunctionExpression" && n3.type !== "ArrowFunctionExpression" && n3.type !== "ConditionalExpression" && !IS(n3);
      }(i2), d2 = function(e3, t4) {
        const n3 = aS(e3), r3 = cS(e3);
        return !pS(n3, fS.Leading) && !pS(n3, fS.Trailing) && IS(n3) && (!r3 || r3.type !== n3.type) && (e3.length !== 2 || r3.type !== "ArrowFunctionExpression" || n3.type !== "ArrayExpression") && !(e3.length > 1 && n3.type === "ArrayExpression" && OS(n3, t4));
      }(i2, t3);
      if (f2 || d2) {
        if (f2 ? c2.slice(1).some(kS) : c2.slice(0, -1).some(kS))
          return p2();
        let t4 = [];
        try {
          e2.try(() => {
            DS(e2, (e3, r3) => {
              f2 && r3 === 0 && (t4 = [[n2([], { expandFirstArg: true }), c2.length > 1 ? "," : "", s2 ? FS : AS, s2 ? FS : ""], ...c2.slice(1)]), d2 && r3 === a2 && (t4 = [...c2.slice(0, -1), n2([], { expandLastArg: true })]);
            });
          });
        } catch (e3) {
          if (e3 instanceof PS)
            return p2();
          throw e3;
        }
        return [c2.some(kS) ? NS : "", TS([["(", ...t4, ")"], f2 ? ["(", SS(t4[0], { shouldBreak: true }), ...t4.slice(1), ")"] : ["(", ...c2.slice(0, -1), SS(aS(t4), { shouldBreak: true }), ")"], p2()])];
      }
      const h2 = ["(", wS([xS, ...c2]), BS(l2), xS, ")"];
      return gS(e2) ? h2 : SS(h2, { shouldBreak: c2.some(kS) || u2 });
    };
    const { builders: { softline: _S, group: MS, indent: RS, label: VS } } = Zc, { isNumericLiteral: $S, isMemberExpression: WS, isCallExpression: qS } = CC, { printOptionalToken: US } = _x;
    function zS(e2, t3, n2) {
      const r2 = n2("property"), o2 = e2.getValue(), i2 = US(e2);
      return o2.computed ? !o2.property || $S(o2.property) ? [i2, "[", r2, "]"] : MS([i2, "[", RS([_S, r2]), _S, "]"]) : [i2, ".", r2];
    }
    var GS = { printMemberExpression: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = e2.getParentNode();
      let i2, u2 = 0;
      do {
        i2 = e2.getParentNode(u2), u2++;
      } while (i2 && (WS(i2) || i2.type === "TSNonNullExpression"));
      const s2 = n2("object"), a2 = zS(e2, t3, n2), c2 = i2 && (i2.type === "NewExpression" || i2.type === "BindExpression" || i2.type === "AssignmentExpression" && i2.left.type !== "Identifier") || r2.computed || r2.object.type === "Identifier" && r2.property.type === "Identifier" && !WS(o2) || (o2.type === "AssignmentExpression" || o2.type === "VariableDeclarator") && (qS(r2.object) && r2.object.arguments.length > 0 || r2.object.type === "TSNonNullExpression" && qS(r2.object.expression) && r2.object.expression.arguments.length > 0 || s2.label === "member-chain");
      return VS(s2.label === "member-chain" ? "member-chain" : "member", [s2, c2 ? a2 : MS(RS([_S, a2]))]);
    }, printMemberLookup: zS };
    const { printComments: HS } = tD, { getLast: JS, isNextLineEmptyAfterIndex: XS, getNextNonSpaceNonCommentCharacterIndex: YS } = dc, KS = wA, { isCallExpression: QS, isMemberExpression: ZS, isFunctionOrArrowExpression: ew, isLongCurriedCallExpression: tw, isMemberish: nw, isNumericLiteral: rw, isSimpleCallArgument: ow, hasComment: iw, CommentCheckFlags: uw, isNextLineEmpty: sw } = CC, { locEnd: aw } = og, { builders: { join: cw, hardline: lw, group: pw, indent: fw, conditionalGroup: dw, breakParent: hw, label: gw }, utils: { willBreak: mw } } = Zc, yw = jS, { printMemberLookup: Dw } = GS, { printOptionalToken: Ew, printFunctionTypeParameters: Cw, printBindExpressionCallee: bw } = _x;
    var vw = function(e2, t3, n2) {
      const r2 = e2.getParentNode(), o2 = !r2 || r2.type === "ExpressionStatement", i2 = [];
      function u2(e3) {
        const { originalText: n3 } = t3, r3 = YS(n3, e3, aw);
        return n3.charAt(r3) === ")" ? r3 !== false && XS(n3, r3 + 1) : sw(e3, t3);
      }
      function s2(e3) {
        const r3 = e3.getValue();
        QS(r3) && (nw(r3.callee) || QS(r3.callee)) ? (i2.unshift({ node: r3, printed: [HS(e3, [Ew(e3), Cw(e3, t3, n2), yw(e3, t3, n2)], t3), u2(r3) ? lw : ""] }), e3.call((e4) => s2(e4), "callee")) : nw(r3) ? (i2.unshift({ node: r3, needsParens: KS(e3, t3), printed: HS(e3, ZS(r3) ? Dw(e3, t3, n2) : bw(e3, t3, n2), t3) }), e3.call((e4) => s2(e4), "object")) : r3.type === "TSNonNullExpression" ? (i2.unshift({ node: r3, printed: HS(e3, "!", t3) }), e3.call((e4) => s2(e4), "expression")) : i2.unshift({ node: r3, printed: n2() });
      }
      const a2 = e2.getValue();
      i2.unshift({ node: a2, printed: [Ew(e2), Cw(e2, t3, n2), yw(e2, t3, n2)] }), a2.callee && e2.call((e3) => s2(e3), "callee");
      const c2 = [];
      let l2 = [i2[0]], p2 = 1;
      for (; p2 < i2.length && (i2[p2].node.type === "TSNonNullExpression" || QS(i2[p2].node) || ZS(i2[p2].node) && i2[p2].node.computed && rw(i2[p2].node.property)); ++p2)
        l2.push(i2[p2]);
      if (!QS(i2[0].node))
        for (; p2 + 1 < i2.length && (nw(i2[p2].node) && nw(i2[p2 + 1].node)); ++p2)
          l2.push(i2[p2]);
      c2.push(l2), l2 = [];
      let f2 = false;
      for (; p2 < i2.length; ++p2) {
        if (f2 && nw(i2[p2].node)) {
          if (i2[p2].node.computed && rw(i2[p2].node.property)) {
            l2.push(i2[p2]);
            continue;
          }
          c2.push(l2), l2 = [], f2 = false;
        }
        (QS(i2[p2].node) || i2[p2].node.type === "ImportExpression") && (f2 = true), l2.push(i2[p2]), iw(i2[p2].node, uw.Trailing) && (c2.push(l2), l2 = [], f2 = false);
      }
      function d2(e3) {
        return /^[A-Z]|^[$_]+$/.test(e3);
      }
      l2.length > 0 && c2.push(l2);
      const h2 = c2.length >= 2 && !iw(c2[1][0].node) && function(e3) {
        const n3 = e3[1].length > 0 && e3[1][0].node.computed;
        if (e3[0].length === 1) {
          const r4 = e3[0][0].node;
          return r4.type === "ThisExpression" || r4.type === "Identifier" && (d2(r4.name) || o2 && function(e4) {
            return e4.length <= t3.tabWidth;
          }(r4.name) || n3);
        }
        const r3 = JS(e3[0]).node;
        return ZS(r3) && r3.property.type === "Identifier" && (d2(r3.property.name) || n3);
      }(c2);
      function g2(e3) {
        const t4 = e3.map((e4) => e4.printed);
        return e3.length > 0 && JS(e3).needsParens ? ["(", ...t4, ")"] : t4;
      }
      const m2 = c2.map(g2), y2 = m2, D2 = h2 ? 3 : 2, E2 = c2.flat(), C3 = E2.slice(1, -1).some((e3) => iw(e3.node, uw.Leading)) || E2.slice(0, -1).some((e3) => iw(e3.node, uw.Trailing)) || c2[D2] && iw(c2[D2][0].node, uw.Leading);
      if (c2.length <= D2 && !C3)
        return tw(e2) ? y2 : pw(y2);
      const b2 = JS(c2[h2 ? 1 : 0]).node, v2 = !QS(b2) && u2(b2), A2 = [g2(c2[0]), h2 ? c2.slice(1, 2).map(g2) : "", v2 ? lw : "", function(e3) {
        return e3.length === 0 ? "" : fw(pw([lw, cw(lw, e3.map(g2))]));
      }(c2.slice(h2 ? 2 : 1))], F2 = i2.map((e3) => {
        let { node: t4 } = e3;
        return t4;
      }).filter(QS);
      let x2;
      return x2 = C3 || F2.length > 2 && F2.some((e3) => !e3.arguments.every((e4) => ow(e4, 0))) || m2.slice(0, -1).some(mw) || function() {
        const e3 = JS(JS(c2)).node, t4 = JS(m2);
        return QS(e3) && mw(t4) && F2.slice(0, -1).some((e4) => e4.arguments.some(ew));
      }() ? pw(A2) : [mw(y2) || v2 ? hw : "", dw([y2, A2])], gw("member-chain", x2);
    };
    const { builders: { join: Aw, group: Fw } } = Zc, xw = wA, { getCallArguments: Sw, hasFlowAnnotationComment: ww, isCallExpression: Tw, isMemberish: Bw, isStringLiteral: Nw, isTemplateOnItsOwnLine: kw, isTestCall: Pw, iterateCallArgumentsPath: Ow } = CC, Iw = vw, Lw = jS, { printOptionalToken: jw, printFunctionTypeParameters: _w } = _x;
    var Mw = { printCallExpression: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = e2.getParentNode(), i2 = r2.type === "NewExpression", u2 = r2.type === "ImportExpression", s2 = jw(e2), a2 = Sw(r2);
      if (a2.length > 0 && (!u2 && !i2 && function(e3, t4) {
        if (e3.callee.type !== "Identifier")
          return false;
        if (e3.callee.name === "require")
          return true;
        if (e3.callee.name === "define") {
          const n3 = Sw(e3);
          return t4.type === "ExpressionStatement" && (n3.length === 1 || n3.length === 2 && n3[0].type === "ArrayExpression" || n3.length === 3 && Nw(n3[0]) && n3[1].type === "ArrayExpression");
        }
        return false;
      }(r2, o2) || a2.length === 1 && kw(a2[0], t3.originalText) || !i2 && Pw(r2, o2))) {
        const r3 = [];
        return Ow(e2, () => {
          r3.push(n2());
        }), [i2 ? "new " : "", n2("callee"), s2, _w(e2, t3, n2), "(", Aw(", ", r3), ")"];
      }
      const c2 = (t3.parser === "babel" || t3.parser === "babel-flow") && r2.callee && r2.callee.type === "Identifier" && ww(r2.callee.trailingComments);
      if (c2 && (r2.callee.trailingComments[0].printed = true), !u2 && !i2 && Bw(r2.callee) && !e2.call((e3) => xw(e3, t3), "callee"))
        return Iw(e2, t3, n2);
      const l2 = [i2 ? "new " : "", u2 ? "import" : n2("callee"), s2, c2 ? "/*:: ".concat(r2.callee.trailingComments[0].value.slice(2).trim(), " */") : "", _w(e2, t3, n2), Lw(e2, t3, n2)];
      return u2 || Tw(r2.callee) ? Fw(l2) : l2;
    } };
    const { isNonEmptyArray: Rw, getStringWidth: Vw } = dc, { builders: { line: $w, group: Ww, indent: qw, indentIfBreak: Uw }, utils: { cleanDoc: zw, willBreak: Gw, canBreak: Hw } } = Zc, { hasLeadingOwnLineComment: Jw, isBinaryish: Xw, isStringLiteral: Yw, isLiteral: Kw, isNumericLiteral: Qw, isCallExpression: Zw, isMemberExpression: eT, getCallArguments: tT, rawText: nT, hasComment: rT, isSignedNumericLiteral: oT, isObjectProperty: iT } = CC, { shouldInlineLogicalExpression: uT } = sF, { printCallExpression: sT } = Mw;
    function aT(e2, t3, n2, r2, o2, i2) {
      const u2 = function(e3, t4, n3, r3, o3) {
        const i3 = e3.getValue(), u3 = i3[o3];
        if (!u3)
          return "only-left";
        const s3 = !cT(u3), a2 = e3.match(cT, lT, (e4) => !s3 || e4.type !== "ExpressionStatement" && e4.type !== "VariableDeclaration");
        if (a2)
          return s3 ? u3.type === "ArrowFunctionExpression" && u3.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
        if (!s3 && cT(u3.right) || Jw(t4.originalText, u3))
          return "break-after-operator";
        if (u3.type === "CallExpression" && u3.callee.name === "require" || t4.parser === "json5" || t4.parser === "json")
          return "never-break-after-operator";
        if (function(e4) {
          if (lT(e4)) {
            const t5 = e4.left || e4.id;
            return t5.type === "ObjectPattern" && t5.properties.length > 2 && t5.properties.some((e5) => iT(e5) && (!e5.shorthand || e5.value && e5.value.type === "AssignmentPattern"));
          }
          return false;
        }(i3) || function(e4) {
          const t5 = function(e5) {
            if (function(e6) {
              return e6.type === "TSTypeAliasDeclaration" || e6.type === "TypeAlias";
            }(e5) && e5.typeParameters && e5.typeParameters.params)
              return e5.typeParameters.params;
            return null;
          }(e4);
          if (Rw(t5)) {
            const n4 = e4.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
            if (t5.length > 1 && t5.some((e5) => e5[n4] || e5.default))
              return true;
          }
          return false;
        }(i3) || function(e4) {
          if (e4.type !== "VariableDeclarator")
            return false;
          const { typeAnnotation: t5 } = e4.id;
          if (!t5 || !t5.typeAnnotation)
            return false;
          const n4 = fT(t5.typeAnnotation);
          return Rw(n4) && n4.length > 1 && n4.some((e5) => Rw(fT(e5)) || e5.type === "TSConditionalType");
        }(i3) || pT(i3) && Hw(r3))
          return "break-lhs";
        const c2 = function(e4, t5, n4) {
          if (!iT(e4))
            return false;
          t5 = zw(t5);
          const r4 = 3;
          return typeof t5 == "string" && Vw(t5) < n4.tabWidth + r4;
        }(i3, r3, t4);
        if (e3.call(() => function(e4, t5, n4, r4) {
          const o4 = e4.getValue();
          if (Xw(o4) && !uT(o4))
            return true;
          switch (o4.type) {
            case "StringLiteralTypeAnnotation":
            case "SequenceExpression":
              return true;
            case "ConditionalExpression": {
              const { test: e5 } = o4;
              return Xw(e5) && !uT(e5);
            }
            case "ClassExpression":
              return Rw(o4.decorators);
          }
          if (r4)
            return false;
          let i4 = o4;
          const u4 = [];
          for (; ; )
            if (i4.type === "UnaryExpression")
              i4 = i4.argument, u4.push("argument");
            else {
              if (i4.type !== "TSNonNullExpression")
                break;
              i4 = i4.expression, u4.push("expression");
            }
          if (Yw(i4) || e4.call(() => dT(e4, t5, n4), ...u4))
            return true;
          return false;
        }(e3, t4, n3, c2), o3))
          return "break-after-operator";
        if (c2 || u3.type === "TemplateLiteral" || u3.type === "TaggedTemplateExpression" || u3.type === "BooleanLiteral" || Qw(u3) || u3.type === "ClassExpression")
          return "never-break-after-operator";
        return "fluid";
      }(e2, t3, n2, r2, i2), s2 = n2(i2, { assignmentLayout: u2 });
      switch (u2) {
        case "break-after-operator":
          return Ww([Ww(r2), o2, Ww(qw([$w, s2]))]);
        case "never-break-after-operator":
          return Ww([Ww(r2), o2, " ", s2]);
        case "fluid": {
          const e3 = Symbol("assignment");
          return Ww([Ww(r2), o2, Ww(qw($w), { id: e3 }), Uw(s2, { groupId: e3 })]);
        }
        case "break-lhs":
          return Ww([r2, o2, " ", Ww(s2)]);
        case "chain":
          return [Ww(r2), o2, $w, s2];
        case "chain-tail":
          return [Ww(r2), o2, qw([$w, s2])];
        case "chain-tail-arrow-chain":
          return [Ww(r2), o2, s2];
        case "only-left":
          return r2;
      }
    }
    function cT(e2) {
      return e2.type === "AssignmentExpression";
    }
    function lT(e2) {
      return cT(e2) || e2.type === "VariableDeclarator";
    }
    function pT(e2) {
      return e2.type === "VariableDeclarator" && e2.init && e2.init.type === "ArrowFunctionExpression";
    }
    function fT(e2) {
      return function(e3) {
        return e3.type === "TSTypeReference" || e3.type === "GenericTypeAnnotation";
      }(e2) && e2.typeParameters && e2.typeParameters.params ? e2.typeParameters.params : null;
    }
    function dT(e2, t3, n2) {
      let r2 = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
      const o2 = e2.getValue(), i2 = () => dT(e2, t3, n2, true);
      if (o2.type === "TSNonNullExpression")
        return e2.call(i2, "expression");
      if (Zw(o2)) {
        if (sT(e2, t3, n2).label === "member-chain")
          return false;
        const r3 = tT(o2);
        return !!(r3.length === 0 || r3.length === 1 && hT(r3[0], t3)) && (!gT(o2, n2) && e2.call(i2, "callee"));
      }
      return eT(o2) ? e2.call(i2, "object") : r2 && (o2.type === "Identifier" || o2.type === "ThisExpression");
    }
    function hT(e2, t3) {
      let { printWidth: n2 } = t3;
      if (rT(e2))
        return false;
      const r2 = 0.25 * n2;
      if (e2.type === "ThisExpression" || e2.type === "Identifier" && e2.name.length <= r2 || oT(e2) && !rT(e2.argument))
        return true;
      const o2 = e2.type === "Literal" && "regex" in e2 && e2.regex.pattern || e2.type === "RegExpLiteral" && e2.pattern;
      return o2 ? o2.length <= r2 : Yw(e2) ? nT(e2).length <= r2 : e2.type === "TemplateLiteral" ? e2.expressions.length === 0 && e2.quasis[0].value.raw.length <= r2 && !e2.quasis[0].value.raw.includes("\n") : Kw(e2);
    }
    function gT(e2, t3) {
      const n2 = function(e3) {
        return e3.typeParameters && e3.typeParameters.params || e3.typeArguments && e3.typeArguments.params;
      }(e2);
      if (Rw(n2)) {
        if (n2.length > 1)
          return true;
        if (n2.length === 1) {
          const e3 = n2[0];
          if (e3.type === "TSUnionType" || e3.type === "UnionTypeAnnotation" || e3.type === "TSIntersectionType" || e3.type === "IntersectionTypeAnnotation")
            return true;
        }
        const r2 = e2.typeParameters ? "typeParameters" : "typeArguments";
        if (Gw(t3(r2)))
          return true;
      }
      return false;
    }
    var mT = { printVariableDeclarator: function(e2, t3, n2) {
      return aT(e2, t3, n2, n2("id"), " =", "init");
    }, printAssignmentExpression: function(e2, t3, n2) {
      const r2 = e2.getValue();
      return aT(e2, t3, n2, n2("left"), [" ", r2.operator], "right");
    }, printAssignment: aT, isArrowFunctionVariableDeclarator: pT };
    const { getNextNonSpaceNonCommentCharacter: yT } = dc, { printDanglingComments: DT } = tD, { builders: { line: ET, hardline: CT, softline: bT, group: vT, indent: AT, ifBreak: FT }, utils: { removeLines: xT, willBreak: ST } } = Zc, { getFunctionParameters: wT, iterateFunctionParametersPath: TT, isSimpleType: BT, isTestCall: NT, isTypeAnnotationAFunction: kT, isObjectType: PT, isObjectTypePropertyAFunction: OT, hasRestParameter: IT, shouldPrintComma: LT2, hasComment: jT, isNextLineEmpty: _T } = CC, { locEnd: MT } = og, { ArgExpansionBailout: RT } = Cp, { printFunctionTypeParameters: VT } = _x;
    function $T(e2) {
      if (!e2)
        return false;
      const t3 = wT(e2);
      if (t3.length !== 1)
        return false;
      const [n2] = t3;
      return !jT(n2) && (n2.type === "ObjectPattern" || n2.type === "ArrayPattern" || n2.type === "Identifier" && n2.typeAnnotation && (n2.typeAnnotation.type === "TypeAnnotation" || n2.typeAnnotation.type === "TSTypeAnnotation") && PT(n2.typeAnnotation.typeAnnotation) || n2.type === "FunctionTypeParam" && PT(n2.typeAnnotation) || n2.type === "AssignmentPattern" && (n2.left.type === "ObjectPattern" || n2.left.type === "ArrayPattern") && (n2.right.type === "Identifier" || n2.right.type === "ObjectExpression" && n2.right.properties.length === 0 || n2.right.type === "ArrayExpression" && n2.right.elements.length === 0));
    }
    var WT = { printFunctionParameters: function(e2, t3, n2, r2, o2) {
      const i2 = e2.getValue(), u2 = wT(i2), s2 = o2 ? VT(e2, n2, t3) : "";
      if (u2.length === 0)
        return [s2, "(", DT(e2, n2, true, (e3) => yT(n2.originalText, e3, MT) === ")"), ")"];
      const a2 = e2.getParentNode(), c2 = NT(a2), l2 = $T(i2), p2 = [];
      if (TT(e2, (e3, r3) => {
        const o3 = r3 === u2.length - 1;
        o3 && i2.rest && p2.push("..."), p2.push(t3()), o3 || (p2.push(","), c2 || l2 ? p2.push(" ") : _T(u2[r3], n2) ? p2.push(CT, CT) : p2.push(ET));
      }), r2) {
        if (ST(s2) || ST(p2))
          throw new RT();
        return vT([xT(s2), "(", xT(p2), ")"]);
      }
      const f2 = u2.every((e3) => !e3.decorators);
      return l2 && f2 || c2 ? [s2, "(", ...p2, ")"] : (OT(a2) || kT(a2) || a2.type === "TypeAlias" || a2.type === "UnionTypeAnnotation" || a2.type === "TSUnionType" || a2.type === "IntersectionTypeAnnotation" || a2.type === "FunctionTypeAnnotation" && a2.returnType === i2) && u2.length === 1 && u2[0].name === null && i2.this !== u2[0] && u2[0].typeAnnotation && i2.typeParameters === null && BT(u2[0].typeAnnotation) && !i2.rest ? n2.arrowParens === "always" ? ["(", ...p2, ")"] : p2 : [s2, "(", AT([bT, ...p2]), FT(!IT(i2) && LT2(n2, "all") ? "," : ""), bT, ")"];
    }, shouldHugFunctionParameters: $T, shouldGroupFunctionParameters: function(e2, t3) {
      const n2 = function(e3) {
        let t4;
        return e3.returnType ? (t4 = e3.returnType, t4.typeAnnotation && (t4 = t4.typeAnnotation)) : e3.typeAnnotation && (t4 = e3.typeAnnotation), t4;
      }(e2);
      if (!n2)
        return false;
      const r2 = e2.typeParameters && e2.typeParameters.params;
      if (r2) {
        if (r2.length > 1)
          return false;
        if (r2.length === 1) {
          const e3 = r2[0];
          if (e3.constraint || e3.default)
            return false;
        }
      }
      return wT(e2).length === 1 && (PT(n2) || ST(t3));
    } };
    const { printComments: qT, printDanglingComments: UT } = tD, { getLast: zT, isNonEmptyArray: GT2 } = dc, { builders: { group: HT, join: JT, line: XT, softline: YT, indent: KT, align: QT, ifBreak: ZT } } = Zc, eB = wA, { locStart: tB } = og, { isSimpleType: nB, isObjectType: rB, hasLeadingOwnLineComment: oB, isObjectTypePropertyAFunction: iB, shouldPrintComma: uB } = CC, { printAssignment: sB } = mT, { printFunctionParameters: aB, shouldGroupFunctionParameters: cB } = WT, { printArrayItems: lB } = uS;
    function pB(e2) {
      if (nB(e2) || rB(e2))
        return true;
      if (e2.type === "UnionTypeAnnotation" || e2.type === "TSUnionType") {
        const t3 = e2.types.filter((e3) => e3.type === "VoidTypeAnnotation" || e3.type === "TSVoidKeyword" || e3.type === "NullLiteralTypeAnnotation" || e3.type === "TSNullKeyword").length, n2 = e2.types.some((e3) => e3.type === "ObjectTypeAnnotation" || e3.type === "TSTypeLiteral" || e3.type === "GenericTypeAnnotation" || e3.type === "TSTypeReference");
        if (e2.types.length - 1 === t3 && n2)
          return true;
      }
      return false;
    }
    var fB = { printOpaqueType: function(e2, t3, n2) {
      const r2 = t3.semi ? ";" : "", o2 = e2.getValue(), i2 = [];
      return i2.push("opaque type ", n2("id"), n2("typeParameters")), o2.supertype && i2.push(": ", n2("supertype")), o2.impltype && i2.push(" = ", n2("impltype")), i2.push(r2), i2;
    }, printTypeAlias: function(e2, t3, n2) {
      const r2 = t3.semi ? ";" : "", o2 = e2.getValue(), i2 = [];
      o2.declare && i2.push("declare "), i2.push("type ", n2("id"), n2("typeParameters"));
      const u2 = o2.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
      return [sB(e2, t3, n2, i2, " =", u2), r2];
    }, printIntersectionType: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = e2.map(n2, "types"), i2 = [];
      let u2 = false;
      for (let e3 = 0; e3 < o2.length; ++e3)
        e3 === 0 ? i2.push(o2[e3]) : rB(r2.types[e3 - 1]) && rB(r2.types[e3]) ? i2.push([" & ", u2 ? KT(o2[e3]) : o2[e3]]) : rB(r2.types[e3 - 1]) || rB(r2.types[e3]) ? (e3 > 1 && (u2 = true), i2.push(" & ", e3 > 1 ? KT(o2[e3]) : o2[e3])) : i2.push(KT([" &", XT, o2[e3]]));
      return HT(i2);
    }, printUnionType: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = e2.getParentNode(), i2 = !(o2.type === "TypeParameterInstantiation" || o2.type === "TSTypeParameterInstantiation" || o2.type === "GenericTypeAnnotation" || o2.type === "TSTypeReference" || o2.type === "TSTypeAssertion" || o2.type === "TupleTypeAnnotation" || o2.type === "TSTupleType" || o2.type === "FunctionTypeParam" && !o2.name && e2.getParentNode(1).this !== o2 || (o2.type === "TypeAlias" || o2.type === "VariableDeclarator" || o2.type === "TSTypeAliasDeclaration") && oB(t3.originalText, r2)), u2 = pB(r2), s2 = e2.map((e3) => {
        let r3 = n2();
        return u2 || (r3 = QT(2, r3)), qT(e3, r3, t3);
      }, "types");
      if (u2)
        return JT(" | ", s2);
      const a2 = i2 && !oB(t3.originalText, r2), c2 = [ZT([a2 ? XT : "", "| "]), JT([XT, "| "], s2)];
      return eB(e2, t3) ? HT([KT(c2), YT]) : o2.type === "TupleTypeAnnotation" && o2.types.length > 1 || o2.type === "TSTupleType" && o2.elementTypes.length > 1 ? HT([KT([ZT(["(", YT]), c2]), YT, ZT(")")]) : HT(i2 ? KT(c2) : c2);
    }, printFunctionType: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = [], i2 = e2.getParentNode(0), u2 = e2.getParentNode(1), s2 = e2.getParentNode(2);
      let a2 = r2.type === "TSFunctionType" || !((i2.type === "ObjectTypeProperty" || i2.type === "ObjectTypeInternalSlot") && !i2.variance && !i2.optional && tB(i2) === tB(r2) || i2.type === "ObjectTypeCallProperty" || s2 && s2.type === "DeclareFunction"), c2 = a2 && (i2.type === "TypeAnnotation" || i2.type === "TSTypeAnnotation");
      const l2 = c2 && a2 && (i2.type === "TypeAnnotation" || i2.type === "TSTypeAnnotation") && u2.type === "ArrowFunctionExpression";
      iB(i2) && (a2 = true, c2 = true), l2 && o2.push("(");
      const p2 = aB(e2, n2, t3, false, true), f2 = r2.returnType || r2.predicate || r2.typeAnnotation ? [a2 ? " => " : ": ", n2("returnType"), n2("predicate"), n2("typeAnnotation")] : "", d2 = cB(r2, f2);
      return o2.push(d2 ? HT(p2) : p2), f2 && o2.push(f2), l2 && o2.push(")"), HT(o2);
    }, printTupleType: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = r2.type === "TSTupleType" ? "elementTypes" : "types", i2 = r2[o2], u2 = GT2(i2), s2 = u2 && zT(i2).type === "TSRestType", a2 = u2 ? YT : "";
      return HT(["[", KT([a2, lB(e2, t3, o2, n2)]), ZT(u2 && uB(t3, "all") && !s2 ? "," : ""), UT(e2, t3, true), a2, "]"]);
    }, printIndexedAccessType: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = r2.type === "OptionalIndexedAccessType" && r2.optional ? "?.[" : "[";
      return [n2("objectType"), o2, n2("indexType"), "]"];
    }, shouldHugType: pB };
    const { printDanglingComments: dB } = tD, { builders: { join: hB, line: gB, hardline: mB, softline: yB, group: DB, indent: EB, ifBreak: CB } } = Zc, { isTestCall: bB, hasComment: vB, CommentCheckFlags: AB, isTSXFile: FB, shouldPrintComma: xB, getFunctionParameters: SB, isObjectType: wB } = CC, { createGroupIdMapper: TB } = dc, { shouldHugType: BB } = fB, { isArrowFunctionVariableDeclarator: NB } = mT, kB = TB("typeParameters");
    function PB(e2, t3) {
      const n2 = e2.getValue();
      if (!vB(n2, AB.Dangling))
        return "";
      const r2 = !vB(n2, AB.Line), o2 = dB(e2, t3, r2);
      return r2 ? o2 : [o2, mB];
    }
    var OB = { printTypeParameter: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = [], i2 = e2.getParentNode();
      return i2.type === "TSMappedType" ? (o2.push("[", n2("name")), r2.constraint && o2.push(" in ", n2("constraint")), i2.nameType && o2.push(" as ", e2.callParent(() => n2("nameType"))), o2.push("]"), o2) : (r2.variance && o2.push(n2("variance")), o2.push(n2("name")), r2.bound && o2.push(": ", n2("bound")), r2.constraint && o2.push(" extends ", n2("constraint")), r2.default && o2.push(" = ", n2("default")), o2);
    }, printTypeParameters: function(e2, t3, n2, r2) {
      const o2 = e2.getValue();
      if (!o2[r2])
        return "";
      if (!Array.isArray(o2[r2]))
        return n2(r2);
      const i2 = e2.getNode(2), u2 = i2 && bB(i2), s2 = e2.match((e3) => !(e3[r2].length === 1 && wB(e3[r2][0])), void 0, (e3, t4) => t4 === "typeAnnotation", (e3) => e3.type === "Identifier", NB);
      if (!s2 && (u2 || o2[r2].length === 0 || o2[r2].length === 1 && (o2[r2][0].type === "NullableTypeAnnotation" || BB(o2[r2][0]))))
        return ["<", hB(", ", e2.map(n2, r2)), PB(e2, t3), ">"];
      const a2 = o2.type === "TSTypeParameterInstantiation" ? "" : SB(o2).length === 1 && FB(t3) && !o2[r2][0].constraint && e2.getParentNode().type === "ArrowFunctionExpression" ? "," : xB(t3, "all") ? CB(",") : "";
      return DB(["<", EB([yB, hB([",", gB], e2.map(n2, r2))]), a2, yB, ">"], { id: kB(o2) });
    }, getTypeParametersGroupId: kB };
    const { printComments: IB } = tD, { printString: LB, printNumber: jB } = dc, { isNumericLiteral: _B, isSimpleNumber: MB, isStringLiteral: RB, isStringPropSafeToUnquote: VB, rawText: $B } = CC, { printAssignment: WB } = mT, qB = /* @__PURE__ */ new WeakMap();
    function UB(e2, t3, n2) {
      const r2 = e2.getNode();
      if (r2.computed)
        return ["[", n2("key"), "]"];
      const o2 = e2.getParentNode(), { key: i2 } = r2;
      if (r2.type === "ClassPrivateProperty" && i2.type === "Identifier")
        return ["#", n2("key")];
      if (t3.quoteProps === "consistent" && !qB.has(o2)) {
        const e3 = (o2.properties || o2.body || o2.members).some((e4) => !e4.computed && e4.key && RB(e4.key) && !VB(e4, t3));
        qB.set(o2, e3);
      }
      if ((i2.type === "Identifier" || _B(i2) && MB(jB($B(i2))) && String(i2.value) === jB($B(i2)) && t3.parser !== "typescript" && t3.parser !== "babel-ts") && (t3.parser === "json" || t3.quoteProps === "consistent" && qB.get(o2))) {
        const n3 = LB(JSON.stringify(i2.type === "Identifier" ? i2.name : i2.value.toString()), t3);
        return e2.call((e3) => IB(e3, n3, t3), "key");
      }
      return VB(r2, t3) && (t3.quoteProps === "as-needed" || t3.quoteProps === "consistent" && !qB.get(o2)) ? e2.call((e3) => IB(e3, /^\d/.test(i2.value) ? jB(i2.value) : i2.value, t3), "key") : n2("key");
    }
    var zB = { printProperty: function(e2, t3, n2) {
      return e2.getValue().shorthand ? n2("value") : WB(e2, t3, n2, UB(e2, t3, n2), ":", "value");
    }, printPropertyKey: UB };
    const GB = Ty, { printDanglingComments: HB, printCommentsSeparately: JB } = tD, XB = au, { getNextNonSpaceNonCommentCharacterIndex: YB } = dc, { builders: { line: KB, softline: QB, group: ZB, indent: eN, ifBreak: tN, hardline: nN, join: rN, indentIfBreak: oN }, utils: { removeLines: iN, willBreak: uN } } = Zc, { ArgExpansionBailout: sN } = Cp, { getFunctionParameters: aN, hasLeadingOwnLineComment: cN, isFlowAnnotationComment: lN, isJsxNode: pN, isTemplateOnItsOwnLine: fN, shouldPrintComma: dN, startsWithNoLookaheadToken: hN, isBinaryish: gN, isLineComment: mN, hasComment: yN, getComments: DN, CommentCheckFlags: EN, isCallLikeExpression: CN, isCallExpression: bN, getCallArguments: vN, hasNakedLeftSide: AN, getLeftSide: FN } = CC, { locEnd: xN } = og, { printFunctionParameters: SN, shouldGroupFunctionParameters: wN } = WT, { printPropertyKey: TN } = zB, { printFunctionTypeParameters: BN } = _x;
    function NN(e2, t3, n2) {
      const r2 = e2.getNode(), o2 = SN(e2, n2, t3), i2 = PN(e2, n2, t3), u2 = wN(r2, i2), s2 = [BN(e2, t3, n2), ZB([u2 ? ZB(o2) : o2, i2])];
      return r2.body ? s2.push(" ", n2("body")) : s2.push(t3.semi ? ";" : ""), s2;
    }
    function kN(e2, t3) {
      if (t3.arrowParens === "always")
        return false;
      if (t3.arrowParens === "avoid") {
        return function(e3) {
          const t4 = aN(e3);
          return !(t4.length !== 1 || e3.typeParameters || yN(e3, EN.Dangling) || t4[0].type !== "Identifier" || t4[0].typeAnnotation || yN(t4[0]) || t4[0].optional || e3.predicate || e3.returnType);
        }(e2.getValue());
      }
      return false;
    }
    function PN(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = t3("returnType");
      if (r2.returnType && lN(n2.originalText, r2.returnType))
        return [" /*: ", o2, " */"];
      const i2 = [o2];
      return r2.returnType && r2.returnType.typeAnnotation && i2.unshift(": "), r2.predicate && i2.push(r2.returnType ? " " : ": ", t3("predicate")), i2;
    }
    function ON(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = t3.semi ? ";" : "", i2 = [];
      r2.argument && (!function(e3, t4) {
        if (cN(e3.originalText, t4))
          return true;
        if (AN(t4)) {
          let n3, r3 = t4;
          for (; n3 = FN(r3); )
            if (r3 = n3, cN(e3.originalText, r3))
              return true;
        }
        return false;
      }(t3, r2.argument) ? gN(r2.argument) || r2.argument.type === "SequenceExpression" ? i2.push(ZB([tN(" (", " "), eN([QB, n2("argument")]), QB, tN(")")])) : i2.push(" ", n2("argument")) : i2.push([" (", eN([nN, n2("argument")]), nN, ")"]));
      const u2 = DN(r2), s2 = XB(u2), a2 = s2 && mN(s2);
      return a2 && i2.push(o2), yN(r2, EN.Dangling) && i2.push(" ", HB(e2, t3, true)), a2 || i2.push(o2), i2;
    }
    var IN = { printFunction: function(e2, t3, n2, r2) {
      const o2 = e2.getValue();
      let i2 = false;
      if ((o2.type === "FunctionDeclaration" || o2.type === "FunctionExpression") && r2 && r2.expandLastArg) {
        const t4 = e2.getParentNode();
        bN(t4) && vN(t4).length > 1 && (i2 = true);
      }
      const u2 = [];
      o2.type === "TSDeclareFunction" && o2.declare && u2.push("declare "), o2.async && u2.push("async "), o2.generator ? u2.push("function* ") : u2.push("function "), o2.id && u2.push(t3("id"));
      const s2 = SN(e2, t3, n2, i2), a2 = PN(e2, t3, n2), c2 = wN(o2, a2);
      return u2.push(BN(e2, n2, t3), ZB([c2 ? ZB(s2) : s2, a2]), o2.body ? " " : "", t3("body")), !n2.semi || !o2.declare && o2.body || u2.push(";"), u2;
    }, printArrowFunction: function(e2, t3, n2, r2) {
      let o2 = e2.getValue();
      const i2 = [], u2 = [];
      let s2 = false;
      if (function a3() {
        const c3 = function(e3, t4, n3, r3) {
          const o3 = [];
          if (e3.getValue().async && o3.push("async "), kN(e3, t4))
            o3.push(n3(["params", 0]));
          else {
            const i4 = r3 && (r3.expandLastArg || r3.expandFirstArg);
            let u3 = PN(e3, n3, t4);
            if (i4) {
              if (uN(u3))
                throw new sN();
              u3 = ZB(iN(u3));
            }
            o3.push(ZB([SN(e3, n3, t4, i4, true), u3]));
          }
          const i3 = HB(e3, t4, true, (e4) => {
            const n4 = YB(t4.originalText, e4, xN);
            return n4 !== false && t4.originalText.slice(n4, n4 + 2) === "=>";
          });
          return i3 && o3.push(" ", i3), o3;
        }(e2, t3, n2, r2);
        if (i2.length === 0)
          i2.push(c3);
        else {
          const { leading: n3, trailing: r3 } = JB(e2, t3);
          i2.push([n3, c3]), u2.unshift(r3);
        }
        s2 = s2 || o2.returnType && aN(o2).length > 0 || o2.typeParameters || aN(o2).some((e3) => e3.type !== "Identifier"), o2.body.type !== "ArrowFunctionExpression" || r2 && r2.expandLastArg ? u2.unshift(n2("body", r2)) : (o2 = o2.body, e2.call(a3, "body"));
      }(), i2.length > 1)
        return function(e3, t4, n3, r3, o3, i3) {
          const u3 = e3.getName(), s3 = e3.getParentNode(), a3 = CN(s3) && u3 === "callee", c3 = Boolean(t4 && t4.assignmentLayout), l3 = i3.body.type !== "BlockStatement" && i3.body.type !== "ObjectExpression" && i3.body.type !== "SequenceExpression", p3 = a3 && l3 || t4 && t4.assignmentLayout === "chain-tail-arrow-chain", f2 = Symbol("arrow-chain");
          return i3.body.type === "SequenceExpression" && (o3 = ZB(["(", eN([QB, o3]), QB, ")"])), ZB([ZB(eN([a3 || c3 ? QB : "", ZB(rN([" =>", KB], n3), { shouldBreak: r3 })]), { id: f2, shouldBreak: p3 }), " =>", oN(l3 ? eN([KB, o3]) : [" ", o3], { groupId: f2 }), a3 ? tN(QB, "", { groupId: f2 }) : ""]);
        }(e2, r2, i2, s2, u2, o2);
      const a2 = i2;
      if (a2.push(" =>"), !cN(t3.originalText, o2.body) && (o2.body.type === "ArrayExpression" || o2.body.type === "ObjectExpression" || o2.body.type === "BlockStatement" || pN(o2.body) || fN(o2.body, t3.originalText) || o2.body.type === "ArrowFunctionExpression" || o2.body.type === "DoExpression"))
        return ZB([...a2, " ", u2]);
      if (o2.body.type === "SequenceExpression")
        return ZB([...a2, ZB([" (", eN([QB, u2]), QB, ")"])]);
      const c2 = (r2 && r2.expandLastArg || e2.getParentNode().type === "JSXExpressionContainer") && !yN(o2), l2 = r2 && r2.expandLastArg && dN(t3, "all"), p2 = o2.body.type === "ConditionalExpression" && !hN(o2.body, false);
      return ZB([...a2, ZB([eN([KB, p2 ? tN("", "(") : "", u2, p2 ? tN("", ")") : ""]), c2 ? [tN(l2 ? "," : ""), QB] : ""])]);
    }, printMethod: function(e2, t3, n2) {
      const r2 = e2.getNode(), { kind: o2 } = r2, i2 = r2.value || r2, u2 = [];
      return o2 && o2 !== "init" && o2 !== "method" && o2 !== "constructor" ? (GB.ok(o2 === "get" || o2 === "set"), u2.push(o2, " ")) : i2.async && u2.push("async "), i2.generator && u2.push("*"), u2.push(TN(e2, t3, n2), r2.optional || r2.key.optional ? "?" : ""), r2 === i2 ? u2.push(NN(e2, t3, n2)) : i2.type === "FunctionExpression" ? u2.push(e2.call((e3) => NN(e3, t3, n2), "value")) : u2.push(n2("value")), u2;
    }, printReturnStatement: function(e2, t3, n2) {
      return ["return", ON(e2, t3, n2)];
    }, printThrowStatement: function(e2, t3, n2) {
      return ["throw", ON(e2, t3, n2)];
    }, printMethodInternal: NN, shouldPrintParamsWithoutParens: kN };
    const { isNonEmptyArray: LN, hasNewline: jN } = dc, { builders: { line: _N, hardline: MN, join: RN, breakParent: VN, group: $N } } = Zc, { locStart: WN, locEnd: qN } = og, { getParentExportDeclaration: UN } = CC;
    function zN(e2, t3) {
      return e2.decorators.some((e3) => jN(t3.originalText, qN(e3)));
    }
    function GN(e2) {
      if (e2.type !== "ExportDefaultDeclaration" && e2.type !== "ExportNamedDeclaration" && e2.type !== "DeclareExportDeclaration")
        return false;
      const t3 = e2.declaration && e2.declaration.decorators;
      return LN(t3) && WN(e2, { ignoreDecorators: true }) > WN(t3[0]);
    }
    var HN = { printDecorators: function(e2, t3, n2) {
      const r2 = e2.getValue(), { decorators: o2 } = r2;
      if (!LN(o2) || GN(e2.getParentNode()))
        return;
      const i2 = r2.type === "ClassExpression" || r2.type === "ClassDeclaration" || zN(r2, t3);
      return [UN(e2) ? MN : i2 ? VN : "", RN(_N, e2.map(n2, "decorators")), _N];
    }, printClassMemberDecorators: function(e2, t3, n2) {
      const r2 = e2.getValue();
      return $N([RN(_N, e2.map(n2, "decorators")), zN(r2, t3) ? MN : _N]);
    }, printDecoratorsBeforeExport: function(e2, t3, n2) {
      return [RN(MN, e2.map(n2, "declaration", "decorators")), MN];
    }, hasDecoratorsBeforeExport: GN };
    const { isNonEmptyArray: JN, createGroupIdMapper: XN } = dc, { printComments: YN, printDanglingComments: KN } = tD, { builders: { join: QN, line: ZN, hardline: ek, softline: tk, group: nk, indent: rk, ifBreak: ok } } = Zc, { hasComment: ik, CommentCheckFlags: uk } = CC, { getTypeParametersGroupId: sk } = OB, { printMethod: ak } = IN, { printOptionalToken: ck, printTypeAnnotation: lk } = _x, { printPropertyKey: pk } = zB, { printAssignment: fk } = mT, { printClassMemberDecorators: dk } = HN;
    const hk = XN("heritageGroup");
    function gk(e2) {
      return e2.typeParameters && !ik(e2.typeParameters, uk.Trailing | uk.Line) && !function(e3) {
        return ["superClass", "extends", "mixins", "implements"].filter((t3) => Boolean(e3[t3])).length > 1;
      }(e2);
    }
    function mk(e2, t3, n2, r2) {
      const o2 = e2.getValue();
      if (!JN(o2[r2]))
        return "";
      const i2 = KN(e2, t3, true, (e3) => {
        let { marker: t4 } = e3;
        return t4 === r2;
      });
      return [gk(o2) ? ok(" ", ZN, { groupId: sk(o2.typeParameters) }) : ZN, i2, i2 && ek, r2, nk(rk([ZN, QN([",", ZN], e2.map(n2, r2))]))];
    }
    function yk(e2, t3, n2) {
      const r2 = n2("superClass");
      return e2.getParentNode().type === "AssignmentExpression" ? nk(ok(["(", rk([tk, r2]), tk, ")"], r2)) : r2;
    }
    var Dk = { printClass: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = [];
      r2.declare && o2.push("declare "), r2.abstract && o2.push("abstract "), o2.push("class");
      const i2 = r2.id && ik(r2.id, uk.Trailing) || r2.superClass && ik(r2.superClass) || JN(r2.extends) || JN(r2.mixins) || JN(r2.implements), u2 = [], s2 = [];
      if (r2.id && u2.push(" ", n2("id")), u2.push(n2("typeParameters")), r2.superClass) {
        const r3 = ["extends ", yk(e2, t3, n2), n2("superTypeParameters")], o3 = e2.call((e3) => YN(e3, r3, t3), "superClass");
        i2 ? s2.push(ZN, nk(o3)) : s2.push(" ", o3);
      } else
        s2.push(mk(e2, t3, n2, "extends"));
      if (s2.push(mk(e2, t3, n2, "mixins"), mk(e2, t3, n2, "implements")), i2) {
        let e3;
        e3 = gk(r2) ? [...u2, rk(s2)] : rk([...u2, s2]), o2.push(nk(e3, { id: hk(r2) }));
      } else
        o2.push(...u2, ...s2);
      return o2.push(" ", n2("body")), o2;
    }, printClassMethod: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = [];
      return JN(r2.decorators) && o2.push(dk(e2, t3, n2)), r2.accessibility && o2.push(r2.accessibility + " "), r2.readonly && o2.push("readonly "), r2.declare && o2.push("declare "), r2.static && o2.push("static "), (r2.type === "TSAbstractMethodDefinition" || r2.abstract) && o2.push("abstract "), r2.override && o2.push("override "), o2.push(ak(e2, t3, n2)), o2;
    }, printClassProperty: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = [], i2 = t3.semi ? ";" : "";
      return JN(r2.decorators) && o2.push(dk(e2, t3, n2)), r2.accessibility && o2.push(r2.accessibility + " "), r2.declare && o2.push("declare "), r2.static && o2.push("static "), (r2.type === "TSAbstractPropertyDefinition" || r2.abstract) && o2.push("abstract "), r2.override && o2.push("override "), r2.readonly && o2.push("readonly "), r2.variance && o2.push(n2("variance")), o2.push(pk(e2, t3, n2), ck(e2), lk(e2, t3, n2)), [fk(e2, t3, n2, o2, " =", "value"), i2];
    }, printHardlineAfterHeritage: function(e2) {
      return ok(ek, "", { groupId: hk(e2) });
    } };
    const { isNonEmptyArray: Ek } = dc, { builders: { join: Ck, line: bk, group: vk, indent: Ak, ifBreak: Fk } } = Zc, { hasComment: xk, identity: Sk, CommentCheckFlags: wk } = CC, { getTypeParametersGroupId: Tk } = OB, { printTypeScriptModifiers: Bk } = _x;
    var Nk = { printInterface: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = [];
      r2.declare && o2.push("declare "), r2.type === "TSInterfaceDeclaration" && o2.push(r2.abstract ? "abstract " : "", Bk(e2, t3, n2)), o2.push("interface");
      const i2 = [], u2 = [];
      r2.type !== "InterfaceTypeAnnotation" && i2.push(" ", n2("id"), n2("typeParameters"));
      const s2 = r2.typeParameters && !xk(r2.typeParameters, wk.Trailing | wk.Line);
      return Ek(r2.extends) && u2.push(s2 ? Fk(" ", bk, { groupId: Tk(r2.typeParameters) }) : bk, "extends ", (r2.extends.length === 1 ? Sk : Ak)(Ck([",", bk], e2.map(n2, "extends")))), r2.id && xk(r2.id, wk.Trailing) || Ek(r2.extends) ? s2 ? o2.push(vk([...i2, Ak(u2)])) : o2.push(vk(Ak([...i2, ...u2]))) : o2.push(...i2, ...u2), o2.push(" ", n2("body")), vk(o2);
    } };
    const { isNonEmptyArray: kk } = dc, { builders: { softline: Pk, group: Ok, indent: Ik, join: Lk, line: jk, ifBreak: _k, hardline: Mk } } = Zc, { printDanglingComments: Rk } = tD, { hasComment: Vk, CommentCheckFlags: $k, shouldPrintComma: Wk, needsHardlineAfterDanglingComment: qk } = CC, { locStart: Uk, hasSameLoc: zk } = og, { hasDecoratorsBeforeExport: Gk, printDecoratorsBeforeExport: Hk } = HN;
    function Jk(e2, t3, n2) {
      const r2 = e2.getValue();
      if (!r2.source)
        return "";
      const o2 = [];
      return Yk(r2, t3) || o2.push(" from"), o2.push(" ", n2("source")), o2;
    }
    function Xk(e2, t3, n2) {
      const r2 = e2.getValue();
      if (Yk(r2, t3))
        return "";
      const o2 = [" "];
      if (kk(r2.specifiers)) {
        const i2 = [], u2 = [];
        if (e2.each(() => {
          const t4 = e2.getValue().type;
          if (t4 === "ExportNamespaceSpecifier" || t4 === "ExportDefaultSpecifier" || t4 === "ImportNamespaceSpecifier" || t4 === "ImportDefaultSpecifier")
            i2.push(n2());
          else {
            if (t4 !== "ExportSpecifier" && t4 !== "ImportSpecifier")
              throw new Error("Unknown specifier type ".concat(JSON.stringify(t4)));
            u2.push(n2());
          }
        }, "specifiers"), o2.push(Lk(", ", i2)), u2.length > 0) {
          i2.length > 0 && o2.push(", ");
          u2.length > 1 || i2.length > 0 || r2.specifiers.some((e3) => Vk(e3)) ? o2.push(Ok(["{", Ik([t3.bracketSpacing ? jk : Pk, Lk([",", jk], u2)]), _k(Wk(t3) ? "," : ""), t3.bracketSpacing ? jk : Pk, "}"])) : o2.push(["{", t3.bracketSpacing ? " " : "", ...u2, t3.bracketSpacing ? " " : "", "}"]);
        }
      } else
        o2.push("{}");
      return o2;
    }
    function Yk(e2, t3) {
      const { type: n2, importKind: r2, source: o2, specifiers: i2 } = e2;
      return n2 === "ImportDeclaration" && !kk(i2) && r2 !== "type" && !/{\s*}/.test(t3.originalText.slice(Uk(e2), Uk(o2)));
    }
    function Kk(e2, t3, n2) {
      const r2 = e2.getNode();
      return kk(r2.assertions) ? [" assert {", t3.bracketSpacing ? " " : "", Lk(", ", e2.map(n2, "assertions")), t3.bracketSpacing ? " " : "", "}"] : "";
    }
    var Qk = { printImportDeclaration: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = t3.semi ? ";" : "", i2 = [], { importKind: u2 } = r2;
      return i2.push("import"), u2 && u2 !== "value" && i2.push(" ", u2), i2.push(Xk(e2, t3, n2), Jk(e2, t3, n2), Kk(e2, t3, n2), o2), i2;
    }, printExportDeclaration: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = [];
      Gk(r2) && o2.push(Hk(e2, t3, n2));
      const { type: i2, exportKind: u2, declaration: s2 } = r2;
      return o2.push("export"), (r2.default || i2 === "ExportDefaultDeclaration") && o2.push(" default"), Vk(r2, $k.Dangling) && (o2.push(" ", Rk(e2, t3, true)), qk(r2) && o2.push(Mk)), s2 ? o2.push(" ", n2("declaration")) : o2.push(u2 === "type" ? " type" : "", Xk(e2, t3, n2), Jk(e2, t3, n2), Kk(e2, t3, n2)), function(e3, t4) {
        if (!t4.semi)
          return false;
        const { type: n3, declaration: r3 } = e3, o3 = e3.default || n3 === "ExportDefaultDeclaration";
        if (!r3)
          return true;
        const { type: i3 } = r3;
        if (o3 && i3 !== "ClassDeclaration" && i3 !== "FunctionDeclaration" && i3 !== "TSInterfaceDeclaration" && i3 !== "DeclareClass" && i3 !== "DeclareFunction" && i3 !== "TSDeclareFunction" && i3 !== "EnumDeclaration")
          return true;
        return false;
      }(r2, t3) && o2.push(";"), o2;
    }, printExportAllDeclaration: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = t3.semi ? ";" : "", i2 = [], { exportKind: u2, exported: s2 } = r2;
      return i2.push("export"), u2 === "type" && i2.push(" type"), i2.push(" *"), s2 && i2.push(" as ", n2("exported")), i2.push(Jk(e2, t3, n2), Kk(e2, t3, n2), o2), i2;
    }, printModuleSpecifier: function(e2, t3, n2) {
      const r2 = e2.getNode(), { type: o2 } = r2, i2 = [], u2 = o2 === "ImportSpecifier" ? r2.importKind : r2.exportKind;
      u2 && u2 !== "value" && i2.push(u2, " ");
      const s2 = o2.startsWith("Import"), a2 = s2 ? "imported" : "local", c2 = s2 ? "local" : "exported";
      let l2 = "", p2 = "";
      return o2 === "ExportNamespaceSpecifier" || o2 === "ImportNamespaceSpecifier" ? l2 = "*" : r2[a2] && (l2 = n2(a2)), !r2[c2] || r2[a2] && zk(r2[a2], r2[c2]) || (p2 = n2(c2)), i2.push(l2, l2 && p2 ? " as " : "", p2), i2;
    } };
    const { printDanglingComments: Zk } = tD, { builders: { line: eP, softline: tP, group: nP, indent: rP, ifBreak: oP, hardline: iP } } = Zc, { getLast: uP, hasNewlineInRange: sP, hasNewline: aP, isNonEmptyArray: cP } = dc, { shouldPrintComma: lP, hasComment: pP, getComments: fP, CommentCheckFlags: dP, isNextLineEmpty: hP } = CC, { locStart: gP, locEnd: mP } = og, { printOptionalToken: yP, printTypeAnnotation: DP } = _x, { shouldHugFunctionParameters: EP } = WT, { shouldHugType: CP } = fB, { printHardlineAfterHeritage: bP } = Dk;
    var vP = { printObject: function(e2, t3, n2) {
      const r2 = t3.semi ? ";" : "", o2 = e2.getValue();
      let i2;
      i2 = o2.type === "TSTypeLiteral" ? "members" : o2.type === "TSInterfaceBody" ? "body" : "properties";
      const u2 = o2.type === "ObjectTypeAnnotation", s2 = [i2];
      u2 && s2.push("indexers", "callProperties", "internalSlots");
      const a2 = s2.map((e3) => o2[e3][0]).sort((e3, t4) => gP(e3) - gP(t4))[0], c2 = e2.getParentNode(0), l2 = u2 && c2 && (c2.type === "InterfaceDeclaration" || c2.type === "DeclareInterface" || c2.type === "DeclareClass") && e2.getName() === "body", p2 = o2.type === "TSInterfaceBody" || l2 || o2.type === "ObjectPattern" && c2.type !== "FunctionDeclaration" && c2.type !== "FunctionExpression" && c2.type !== "ArrowFunctionExpression" && c2.type !== "ObjectMethod" && c2.type !== "ClassMethod" && c2.type !== "ClassPrivateMethod" && c2.type !== "AssignmentPattern" && c2.type !== "CatchClause" && o2.properties.some((e3) => e3.value && (e3.value.type === "ObjectPattern" || e3.value.type === "ArrayPattern")) || o2.type !== "ObjectPattern" && a2 && sP(t3.originalText, gP(o2), gP(a2)), f2 = l2 ? ";" : o2.type === "TSInterfaceBody" || o2.type === "TSTypeLiteral" ? oP(r2, ";") : ",", d2 = o2.type === "RecordExpression" ? "#{" : o2.exact ? "{|" : "{", h2 = o2.exact ? "|}" : "}", g2 = [];
      for (const t4 of s2)
        e2.each((e3) => {
          const t5 = e3.getValue();
          g2.push({ node: t5, printed: n2(), loc: gP(t5) });
        }, t4);
      s2.length > 1 && g2.sort((e3, t4) => e3.loc - t4.loc);
      let m2 = [];
      const y2 = g2.map((e3) => {
        const n3 = [...m2, nP(e3.printed)];
        return m2 = [f2, eP], e3.node.type !== "TSPropertySignature" && e3.node.type !== "TSMethodSignature" && e3.node.type !== "TSConstructSignatureDeclaration" || !pP(e3.node, dP.PrettierIgnore) || m2.shift(), hP(e3.node, t3) && m2.push(iP), n3;
      });
      if (o2.inexact) {
        let n3;
        if (pP(o2, dP.Dangling)) {
          const r3 = pP(o2, dP.Line);
          n3 = [Zk(e2, t3, true), r3 || aP(t3.originalText, mP(uP(fP(o2)))) ? iP : eP, "..."];
        } else
          n3 = ["..."];
        y2.push([...m2, ...n3]);
      }
      const D2 = uP(o2[i2]), E2 = !(o2.inexact || D2 && D2.type === "RestElement" || D2 && (D2.type === "TSPropertySignature" || D2.type === "TSCallSignatureDeclaration" || D2.type === "TSMethodSignature" || D2.type === "TSConstructSignatureDeclaration") && pP(D2, dP.PrettierIgnore));
      let C3;
      if (y2.length === 0) {
        if (!pP(o2, dP.Dangling))
          return [d2, h2, DP(e2, t3, n2)];
        C3 = nP([d2, Zk(e2, t3), tP, h2, yP(e2), DP(e2, t3, n2)]);
      } else
        C3 = [l2 && cP(o2.properties) ? bP(c2) : "", d2, rP([t3.bracketSpacing ? eP : tP, ...y2]), oP(E2 && (f2 !== "," || lP(t3)) ? f2 : ""), t3.bracketSpacing ? eP : tP, h2, yP(e2), DP(e2, t3, n2)];
      return e2.match((e3) => e3.type === "ObjectPattern" && !e3.decorators, (e3, t4, n3) => EP(e3) && (t4 === "params" || t4 === "parameters" || t4 === "this" || t4 === "rest") && n3 === 0) || e2.match(CP, (e3, t4) => t4 === "typeAnnotation", (e3, t4) => t4 === "typeAnnotation", (e3, t4, n3) => EP(e3) && (t4 === "params" || t4 === "parameters" || t4 === "this" || t4 === "rest") && n3 === 0) || !p2 && e2.match((e3) => e3.type === "ObjectPattern", (e3) => e3.type === "AssignmentExpression" || e3.type === "VariableDeclarator") ? C3 : nP(C3, { shouldBreak: p2 });
    } };
    const AP = Ty, { printDanglingComments: FP } = tD, { printString: xP, printNumber: SP } = dc, { builders: { hardline: wP, softline: TP, group: BP, indent: NP } } = Zc, { getParentExportDeclaration: kP, isFunctionNotation: PP, isGetterOrSetter: OP, rawText: IP, shouldPrintComma: LP } = CC, { locStart: jP, locEnd: _P } = og, { printClass: MP } = Dk, { printOpaqueType: RP, printTypeAlias: VP, printIntersectionType: $P, printUnionType: WP, printFunctionType: qP, printTupleType: UP, printIndexedAccessType: zP } = fB, { printInterface: GP } = Nk, { printTypeParameter: HP, printTypeParameters: JP } = OB, { printExportDeclaration: XP, printExportAllDeclaration: YP } = Qk, { printArrayItems: KP } = uS, { printObject: QP } = vP, { printPropertyKey: ZP } = zB, { printOptionalToken: eO, printTypeAnnotation: tO, printRestSpread: nO } = _x;
    function rO(e2, t3) {
      const n2 = kP(e2);
      return n2 ? (AP.strictEqual(n2.type, "DeclareExportDeclaration"), t3) : ["declare ", t3];
    }
    var oO = { printFlow: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = t3.semi ? ";" : "", i2 = [];
      switch (r2.type) {
        case "DeclareClass":
          return rO(e2, MP(e2, t3, n2));
        case "DeclareFunction":
          return rO(e2, ["function ", n2("id"), r2.predicate ? " " : "", n2("predicate"), o2]);
        case "DeclareModule":
          return rO(e2, ["module ", n2("id"), " ", n2("body")]);
        case "DeclareModuleExports":
          return rO(e2, ["module.exports", ": ", n2("typeAnnotation"), o2]);
        case "DeclareVariable":
          return rO(e2, ["var ", n2("id"), o2]);
        case "DeclareOpaqueType":
          return rO(e2, RP(e2, t3, n2));
        case "DeclareInterface":
          return rO(e2, GP(e2, t3, n2));
        case "DeclareTypeAlias":
          return rO(e2, VP(e2, t3, n2));
        case "DeclareExportDeclaration":
          return rO(e2, XP(e2, t3, n2));
        case "DeclareExportAllDeclaration":
          return rO(e2, YP(e2, t3, n2));
        case "OpaqueType":
          return RP(e2, t3, n2);
        case "TypeAlias":
          return VP(e2, t3, n2);
        case "IntersectionTypeAnnotation":
          return $P(e2, t3, n2);
        case "UnionTypeAnnotation":
          return WP(e2, t3, n2);
        case "FunctionTypeAnnotation":
          return qP(e2, t3, n2);
        case "TupleTypeAnnotation":
          return UP(e2, t3, n2);
        case "GenericTypeAnnotation":
          return [n2("id"), JP(e2, t3, n2, "typeParameters")];
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          return zP(e2, t3, n2);
        case "TypeAnnotation":
          return n2("typeAnnotation");
        case "TypeParameter":
          return HP(e2, t3, n2);
        case "TypeofTypeAnnotation":
          return ["typeof ", n2("argument")];
        case "ExistsTypeAnnotation":
          return "*";
        case "EmptyTypeAnnotation":
          return "empty";
        case "MixedTypeAnnotation":
          return "mixed";
        case "ArrayTypeAnnotation":
          return [n2("elementType"), "[]"];
        case "BooleanLiteralTypeAnnotation":
          return String(r2.value);
        case "EnumDeclaration":
          return ["enum ", n2("id"), " ", n2("body")];
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
          if (r2.type === "EnumSymbolBody" || r2.explicitType) {
            let e3 = null;
            switch (r2.type) {
              case "EnumBooleanBody":
                e3 = "boolean";
                break;
              case "EnumNumberBody":
                e3 = "number";
                break;
              case "EnumStringBody":
                e3 = "string";
                break;
              case "EnumSymbolBody":
                e3 = "symbol";
            }
            i2.push("of ", e3, " ");
          }
          if (r2.members.length !== 0 || r2.hasUnknownMembers) {
            const o3 = r2.members.length > 0 ? [wP, KP(e2, t3, "members", n2), r2.hasUnknownMembers || LP(t3) ? "," : ""] : [];
            i2.push(BP(["{", NP([...o3, ...r2.hasUnknownMembers ? [wP, "..."] : []]), FP(e2, t3, true), wP, "}"]));
          } else
            i2.push(BP(["{", FP(e2, t3), TP, "}"]));
          return i2;
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
          return [n2("id"), " = ", typeof r2.init == "object" ? n2("init") : String(r2.init)];
        case "EnumDefaultedMember":
          return n2("id");
        case "FunctionTypeParam": {
          const t4 = r2.name ? n2("name") : e2.getParentNode().this === r2 ? "this" : "";
          return [t4, eO(e2), t4 ? ": " : "", n2("typeAnnotation")];
        }
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
          return GP(e2, t3, n2);
        case "ClassImplements":
        case "InterfaceExtends":
          return [n2("id"), n2("typeParameters")];
        case "NullableTypeAnnotation":
          return ["?", n2("typeAnnotation")];
        case "Variance": {
          const { kind: e3 } = r2;
          return AP.ok(e3 === "plus" || e3 === "minus"), e3 === "plus" ? "+" : "-";
        }
        case "ObjectTypeCallProperty":
          return r2.static && i2.push("static "), i2.push(n2("value")), i2;
        case "ObjectTypeIndexer":
          return [r2.variance ? n2("variance") : "", "[", n2("id"), r2.id ? ": " : "", n2("key"), "]: ", n2("value")];
        case "ObjectTypeProperty": {
          let o3 = "";
          return r2.proto ? o3 = "proto " : r2.static && (o3 = "static "), [o3, OP(r2) ? r2.kind + " " : "", r2.variance ? n2("variance") : "", ZP(e2, t3, n2), eO(e2), PP(r2) ? "" : ": ", n2("value")];
        }
        case "ObjectTypeAnnotation":
          return QP(e2, t3, n2);
        case "ObjectTypeInternalSlot":
          return [r2.static ? "static " : "", "[[", n2("id"), "]]", eO(e2), r2.method ? "" : ": ", n2("value")];
        case "ObjectTypeSpreadProperty":
          return nO(e2, t3, n2);
        case "QualifiedTypeIdentifier":
          return [n2("qualification"), ".", n2("id")];
        case "StringLiteralTypeAnnotation":
          return xP(IP(r2), t3);
        case "NumberLiteralTypeAnnotation":
          AP.strictEqual(typeof r2.value, "number");
        case "BigIntLiteralTypeAnnotation":
          return r2.extra ? SP(r2.extra.raw) : SP(r2.raw);
        case "TypeCastExpression":
          return ["(", n2("expression"), tO(e2, t3, n2), ")"];
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation": {
          const o3 = JP(e2, t3, n2, "params");
          if (t3.parser === "flow") {
            const e3 = jP(r2), n3 = _P(r2), i3 = t3.originalText.lastIndexOf("/*", e3), u2 = t3.originalText.indexOf("*/", n3);
            if (i3 !== -1 && u2 !== -1) {
              const e4 = t3.originalText.slice(i3 + 2, u2).trim();
              if (e4.startsWith("::") && !e4.includes("/*") && !e4.includes("*/"))
                return ["/*:: ", o3, " */"];
            }
          }
          return o3;
        }
        case "InferredPredicate":
          return "%checks";
        case "DeclaredPredicate":
          return ["%checks(", n2("value"), ")"];
        case "AnyTypeAnnotation":
          return "any";
        case "BooleanTypeAnnotation":
          return "boolean";
        case "BigIntTypeAnnotation":
          return "bigint";
        case "NullLiteralTypeAnnotation":
          return "null";
        case "NumberTypeAnnotation":
          return "number";
        case "SymbolTypeAnnotation":
          return "symbol";
        case "StringTypeAnnotation":
          return "string";
        case "VoidTypeAnnotation":
          return "void";
        case "ThisTypeAnnotation":
          return "this";
        case "Node":
        case "Printable":
        case "SourceLocation":
        case "Position":
        case "Statement":
        case "Function":
        case "Pattern":
        case "Expression":
        case "Declaration":
        case "Specifier":
        case "NamedSpecifier":
        case "Comment":
        case "MemberTypeAnnotation":
        case "Type":
          throw new Error("unprintable type: " + JSON.stringify(r2.type));
      }
    } };
    const { hasNewlineInRange: iO } = dc, { isJsxNode: uO, isBlockComment: sO, getComments: aO, isCallExpression: cO, isMemberExpression: lO } = CC, { locStart: pO, locEnd: fO } = og, { builders: { line: dO, softline: hO, group: gO, indent: mO, align: yO, ifBreak: DO, dedent: EO, breakParent: CO } } = Zc;
    function bO(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = r2.type === "ConditionalExpression", i2 = o2 ? "alternate" : "falseType", u2 = e2.getParentNode(), s2 = o2 ? n2("test") : [n2("checkType"), " ", "extends", " ", n2("extendsType")];
      return u2.type === r2.type && u2[i2] === r2 ? yO(2, s2) : s2;
    }
    const vO = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
    var AO = { printTernary: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = r2.type === "ConditionalExpression", i2 = o2 ? "consequent" : "trueType", u2 = o2 ? "alternate" : "falseType", s2 = o2 ? ["test"] : ["checkType", "extendsType"], a2 = r2[i2], c2 = r2[u2], l2 = [];
      let p2 = false;
      const f2 = e2.getParentNode(), d2 = f2.type === r2.type && s2.some((e3) => f2[e3] === r2);
      let h2, g2, m2 = f2.type === r2.type && !d2, y2 = 0;
      do {
        g2 = h2 || r2, h2 = e2.getParentNode(y2), y2++;
      } while (h2 && h2.type === r2.type && s2.every((e3) => h2[e3] !== g2));
      const D2 = h2 || f2, E2 = g2;
      if (o2 && (uO(r2[s2[0]]) || uO(a2) || uO(c2) || function(e3) {
        const t4 = [e3];
        for (let e4 = 0; e4 < t4.length; e4++) {
          const n3 = t4[e4];
          for (const e5 of ["test", "consequent", "alternate"]) {
            const r3 = n3[e5];
            if (uO(r3))
              return true;
            r3.type === "ConditionalExpression" && t4.push(r3);
          }
        }
        return false;
      }(E2))) {
        p2 = true, m2 = true;
        const e3 = (e4) => [DO("("), mO([hO, e4]), hO, DO(")")], t4 = (e4) => e4.type === "NullLiteral" || e4.type === "Literal" && e4.value === null || e4.type === "Identifier" && e4.name === "undefined";
        l2.push(" ? ", t4(a2) ? n2(i2) : e3(n2(i2)), " : ", c2.type === r2.type || t4(c2) ? n2(u2) : e3(n2(u2)));
      } else {
        const e3 = [dO, "? ", a2.type === r2.type ? DO("", "(") : "", yO(2, n2(i2)), a2.type === r2.type ? DO("", ")") : "", dO, ": ", c2.type === r2.type ? n2(u2) : yO(2, n2(u2))];
        l2.push(f2.type !== r2.type || f2[u2] === r2 || d2 ? e3 : t3.useTabs ? EO(mO(e3)) : yO(Math.max(0, t3.tabWidth - 2), e3));
      }
      const C3 = [...s2.map((e3) => aO(r2[e3])), aO(a2), aO(c2)].flat().some((e3) => sO(e3) && iO(t3.originalText, pO(e3), fO(e3))), b2 = !p2 && (lO(f2) || f2.type === "NGPipeExpression" && f2.left === r2) && !f2.computed, v2 = function(e3) {
        const t4 = e3.getValue();
        if (t4.type !== "ConditionalExpression")
          return false;
        let n3, r3 = t4;
        for (let t5 = 0; !n3; t5++) {
          const o3 = e3.getParentNode(t5);
          cO(o3) && o3.callee === r3 || lO(o3) && o3.object === r3 || o3.type === "TSNonNullExpression" && o3.expression === r3 ? r3 = o3 : o3.type === "NewExpression" && o3.callee === r3 || o3.type === "TSAsExpression" && o3.expression === r3 ? (n3 = e3.getParentNode(t5 + 1), r3 = o3) : n3 = o3;
        }
        return r3 !== t4 && n3[vO.get(n3.type)] === r3;
      }(e2), A2 = ((e3) => f2 === D2 ? gO(e3, { shouldBreak: C3 }) : C3 ? [e3, CO] : e3)([bO(e2, 0, n2), m2 ? l2 : mO(l2), o2 && b2 && !v2 ? hO : ""]);
      return d2 || v2 ? gO([mO([hO, A2]), hO]) : A2;
    } };
    const { builders: { hardline: FO } } = Zc, xO = wA, { getLeftSidePathName: SO, hasNakedLeftSide: wO, isJsxNode: TO, isTheOnlyJsxElementInMarkdown: BO, hasComment: NO, CommentCheckFlags: kO, isNextLineEmpty: PO } = CC, { shouldPrintParamsWithoutParens: OO } = IN;
    function IO(e2, t3, n2, r2) {
      const o2 = e2.getValue(), i2 = [], u2 = o2.type === "ClassBody", s2 = function(e3) {
        for (let t4 = e3.length - 1; t4 >= 0; t4--) {
          const n3 = e3[t4];
          if (n3.type !== "EmptyStatement")
            return n3;
        }
      }(o2[r2]);
      return e2.each((e3, r3, o3) => {
        const a2 = e3.getValue();
        if (a2.type === "EmptyStatement")
          return;
        const c2 = n2();
        t3.semi || u2 || BO(t3, e3) || !function(e4, t4) {
          if (e4.getNode().type !== "ExpressionStatement")
            return false;
          return e4.call((e5) => LO(e5, t4), "expression");
        }(e3, t3) ? i2.push(c2) : NO(a2, kO.Leading) ? i2.push(n2([], { needsSemi: true })) : i2.push(";", c2), !t3.semi && u2 && jO(a2) && function(e4, t4) {
          const n3 = e4.key && e4.key.name;
          if (!(n3 !== "static" && n3 !== "get" && n3 !== "set" || e4.value || e4.typeAnnotation))
            return true;
          if (!t4)
            return false;
          if (t4.static || t4.accessibility)
            return false;
          if (!t4.computed) {
            const e5 = t4.key && t4.key.name;
            if (e5 === "in" || e5 === "instanceof")
              return true;
          }
          if (jO(t4) && t4.variance && !t4.static && !t4.declare)
            return true;
          switch (t4.type) {
            case "ClassProperty":
            case "PropertyDefinition":
            case "TSAbstractPropertyDefinition":
              return t4.computed;
            case "MethodDefinition":
            case "TSAbstractMethodDefinition":
            case "ClassMethod":
            case "ClassPrivateMethod": {
              if ((t4.value ? t4.value.async : t4.async) || t4.kind === "get" || t4.kind === "set")
                return false;
              const e5 = t4.value ? t4.value.generator : t4.generator;
              return !(!t4.computed && !e5);
            }
            case "TSIndexSignature":
              return true;
          }
          return false;
        }(a2, o3[r3 + 1]) && i2.push(";"), a2 !== s2 && (i2.push(FO), PO(a2, t3) && i2.push(FO));
      }, r2), i2;
    }
    function LO(e2, t3) {
      const n2 = e2.getValue();
      switch (n2.type) {
        case "ParenthesizedExpression":
        case "TypeCastExpression":
        case "ArrayExpression":
        case "ArrayPattern":
        case "TemplateLiteral":
        case "TemplateElement":
        case "RegExpLiteral":
          return true;
        case "ArrowFunctionExpression":
          if (!OO(e2, t3))
            return true;
          break;
        case "UnaryExpression": {
          const { prefix: e3, operator: t4 } = n2;
          if (e3 && (t4 === "+" || t4 === "-"))
            return true;
          break;
        }
        case "BindExpression":
          if (!n2.object)
            return true;
          break;
        case "Literal":
          if (n2.regex)
            return true;
          break;
        default:
          if (TO(n2))
            return true;
      }
      return !!xO(e2, t3) || !!wO(n2) && e2.call((e3) => LO(e3, t3), ...SO(e2, n2));
    }
    const jO = (e2) => {
      let { type: t3 } = e2;
      return t3 === "ClassProperty" || t3 === "PropertyDefinition" || t3 === "ClassPrivateProperty";
    };
    var _O = { printBody: function(e2, t3, n2) {
      return IO(e2, t3, n2, "body");
    }, printSwitchCaseConsequent: function(e2, t3, n2) {
      return IO(e2, t3, n2, "consequent");
    } };
    const { printDanglingComments: MO } = tD, { isNonEmptyArray: RO } = dc, { builders: { hardline: VO, indent: $O } } = Zc, { hasComment: WO, CommentCheckFlags: qO, isNextLineEmpty: UO } = CC, { printHardlineAfterHeritage: zO } = Dk, { printBody: GO } = _O;
    function HO(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = RO(r2.directives), i2 = r2.body.some((e3) => e3.type !== "EmptyStatement"), u2 = WO(r2, qO.Dangling);
      if (!o2 && !i2 && !u2)
        return "";
      const s2 = [];
      if (o2 && e2.each((e3, r3, o3) => {
        s2.push(n2()), (r3 < o3.length - 1 || i2 || u2) && (s2.push(VO), UO(e3.getValue(), t3) && s2.push(VO));
      }, "directives"), i2 && s2.push(GO(e2, t3, n2)), u2 && s2.push(MO(e2, t3, true)), r2.type === "Program") {
        const t4 = e2.getParentNode();
        t4 && t4.type === "ModuleExpression" || s2.push(VO);
      }
      return s2;
    }
    var JO = { printBlock: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = [];
      if (r2.type === "StaticBlock" && o2.push("static "), r2.type === "ClassBody" && RO(r2.body)) {
        const t4 = e2.getParentNode();
        o2.push(zO(t4));
      }
      o2.push("{");
      const i2 = HO(e2, t3, n2);
      if (i2)
        o2.push($O([VO, i2]), VO);
      else {
        const t4 = e2.getParentNode(), n3 = e2.getParentNode(1);
        t4.type === "ArrowFunctionExpression" || t4.type === "FunctionExpression" || t4.type === "FunctionDeclaration" || t4.type === "ObjectMethod" || t4.type === "ClassMethod" || t4.type === "ClassPrivateMethod" || t4.type === "ForStatement" || t4.type === "WhileStatement" || t4.type === "DoWhileStatement" || t4.type === "DoExpression" || t4.type === "CatchClause" && !n3.finalizer || t4.type === "TSModuleDeclaration" || t4.type === "TSDeclareFunction" || r2.type === "StaticBlock" || r2.type === "ClassBody" || o2.push(VO);
      }
      return o2.push("}"), o2;
    }, printBlockBody: HO };
    const { printDanglingComments: XO } = tD, { hasNewlineInRange: YO } = dc, { builders: { join: KO, line: QO, hardline: ZO, softline: eI, group: tI, indent: nI, conditionalGroup: rI, ifBreak: oI } } = Zc, { isLiteral: iI, getTypeScriptMappedTypeModifier: uI, shouldPrintComma: sI, isCallExpression: aI, isMemberExpression: cI } = CC, { locStart: lI, locEnd: pI } = og, { printOptionalToken: fI, printTypeScriptModifiers: dI } = _x, { printTernary: hI } = AO, { printFunctionParameters: gI, shouldGroupFunctionParameters: mI } = WT, { printTemplateLiteral: yI } = VC, { printArrayItems: DI } = uS, { printObject: EI } = vP, { printClassProperty: CI, printClassMethod: bI } = Dk, { printTypeParameter: vI, printTypeParameters: AI } = OB, { printPropertyKey: FI } = zB, { printFunction: xI, printMethodInternal: SI } = IN, { printInterface: wI } = Nk, { printBlock: TI } = JO, { printTypeAlias: BI, printIntersectionType: NI, printUnionType: kI, printFunctionType: PI, printTupleType: OI, printIndexedAccessType: II } = fB;
    var LI = { printTypescript: function(e2, t3, n2) {
      const r2 = e2.getValue();
      if (!r2.type.startsWith("TS"))
        return;
      if (r2.type.endsWith("Keyword"))
        return r2.type.slice(2, -7).toLowerCase();
      const o2 = t3.semi ? ";" : "", i2 = [];
      switch (r2.type) {
        case "TSThisType":
          return "this";
        case "TSTypeAssertion": {
          const e3 = !(r2.expression.type === "ArrayExpression" || r2.expression.type === "ObjectExpression"), t4 = tI(["<", nI([eI, n2("typeAnnotation")]), eI, ">"]), o3 = [oI("("), nI([eI, n2("expression")]), eI, oI(")")];
          return e3 ? rI([[t4, n2("expression")], [t4, tI(o3, { shouldBreak: true })], [t4, n2("expression")]]) : tI([t4, n2("expression")]);
        }
        case "TSDeclareFunction":
          return xI(e2, n2, t3);
        case "TSExportAssignment":
          return ["export = ", n2("expression"), o2];
        case "TSModuleBlock":
          return TI(e2, t3, n2);
        case "TSInterfaceBody":
        case "TSTypeLiteral":
          return EI(e2, t3, n2);
        case "TSTypeAliasDeclaration":
          return BI(e2, t3, n2);
        case "TSQualifiedName":
          return KO(".", [n2("left"), n2("right")]);
        case "TSAbstractMethodDefinition":
        case "TSDeclareMethod":
          return bI(e2, t3, n2);
        case "TSAbstractPropertyDefinition":
          return CI(e2, t3, n2);
        case "TSInterfaceHeritage":
        case "TSExpressionWithTypeArguments":
          return i2.push(n2("expression")), r2.typeParameters && i2.push(n2("typeParameters")), i2;
        case "TSTemplateLiteralType":
          return yI(e2, n2, t3);
        case "TSNamedTupleMember":
          return [n2("label"), r2.optional ? "?" : "", ": ", n2("elementType")];
        case "TSRestType":
          return ["...", n2("typeAnnotation")];
        case "TSOptionalType":
          return [n2("typeAnnotation"), "?"];
        case "TSInterfaceDeclaration":
          return wI(e2, t3, n2);
        case "TSClassImplements":
          return [n2("expression"), n2("typeParameters")];
        case "TSTypeParameterDeclaration":
        case "TSTypeParameterInstantiation":
          return AI(e2, t3, n2, "params");
        case "TSTypeParameter":
          return vI(e2, t3, n2);
        case "TSAsExpression": {
          i2.push(n2("expression"), " as ", n2("typeAnnotation"));
          const t4 = e2.getParentNode();
          return aI(t4) && t4.callee === r2 || cI(t4) && t4.object === r2 ? tI([nI([eI, ...i2]), eI]) : i2;
        }
        case "TSArrayType":
          return [n2("elementType"), "[]"];
        case "TSPropertySignature":
          return r2.readonly && i2.push("readonly "), i2.push(FI(e2, t3, n2), fI(e2)), r2.typeAnnotation && i2.push(": ", n2("typeAnnotation")), r2.initializer && i2.push(" = ", n2("initializer")), i2;
        case "TSParameterProperty":
          return r2.accessibility && i2.push(r2.accessibility + " "), r2.export && i2.push("export "), r2.static && i2.push("static "), r2.override && i2.push("override "), r2.readonly && i2.push("readonly "), i2.push(n2("parameter")), i2;
        case "TSTypeQuery":
          return ["typeof ", n2("exprName")];
        case "TSIndexSignature": {
          const i3 = e2.getParentNode(), u2 = r2.parameters.length > 1 ? oI(sI(t3) ? "," : "") : "", s2 = tI([nI([eI, KO([", ", eI], e2.map(n2, "parameters"))]), u2, eI]);
          return [r2.export ? "export " : "", r2.accessibility ? [r2.accessibility, " "] : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.declare ? "declare " : "", "[", r2.parameters ? s2 : "", r2.typeAnnotation ? "]: " : "]", r2.typeAnnotation ? n2("typeAnnotation") : "", i3.type === "ClassBody" ? o2 : ""];
        }
        case "TSTypePredicate":
          return [r2.asserts ? "asserts " : "", n2("parameterName"), r2.typeAnnotation ? [" is ", n2("typeAnnotation")] : ""];
        case "TSNonNullExpression":
          return [n2("expression"), "!"];
        case "TSImportType":
          return [r2.isTypeOf ? "typeof " : "", "import(", n2(r2.parameter ? "parameter" : "argument"), ")", r2.qualifier ? [".", n2("qualifier")] : "", AI(e2, t3, n2, "typeParameters")];
        case "TSLiteralType":
          return n2("literal");
        case "TSIndexedAccessType":
          return II(e2, t3, n2);
        case "TSConstructSignatureDeclaration":
        case "TSCallSignatureDeclaration":
        case "TSConstructorType":
          if (r2.type === "TSConstructorType" && r2.abstract && i2.push("abstract "), r2.type !== "TSCallSignatureDeclaration" && i2.push("new "), i2.push(tI(gI(e2, n2, t3, false, true))), r2.returnType || r2.typeAnnotation) {
            const e3 = r2.type === "TSConstructorType";
            i2.push(e3 ? " => " : ": ", n2("returnType"), n2("typeAnnotation"));
          }
          return i2;
        case "TSTypeOperator":
          return [r2.operator, " ", n2("typeAnnotation")];
        case "TSMappedType": {
          const i3 = YO(t3.originalText, lI(r2), pI(r2));
          return tI(["{", nI([t3.bracketSpacing ? QO : eI, r2.readonly ? [uI(r2.readonly, "readonly"), " "] : "", dI(e2, t3, n2), n2("typeParameter"), r2.optional ? uI(r2.optional, "?") : "", r2.typeAnnotation ? ": " : "", n2("typeAnnotation"), oI(o2)]), XO(e2, t3, true), t3.bracketSpacing ? QO : eI, "}"], { shouldBreak: i3 });
        }
        case "TSMethodSignature": {
          const o3 = r2.kind && r2.kind !== "method" ? "".concat(r2.kind, " ") : "";
          i2.push(r2.accessibility ? [r2.accessibility, " "] : "", o3, r2.export ? "export " : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.abstract ? "abstract " : "", r2.declare ? "declare " : "", r2.computed ? "[" : "", n2("key"), r2.computed ? "]" : "", fI(e2));
          const u2 = gI(e2, n2, t3, false, true), s2 = r2.returnType ? "returnType" : "typeAnnotation", a2 = r2[s2], c2 = a2 ? n2(s2) : "", l2 = mI(r2, c2);
          return i2.push(l2 ? tI(u2) : u2), a2 && i2.push(": ", tI(c2)), tI(i2);
        }
        case "TSNamespaceExportDeclaration":
          return i2.push("export as namespace ", n2("id")), t3.semi && i2.push(";"), tI(i2);
        case "TSEnumDeclaration":
          return r2.declare && i2.push("declare "), r2.modifiers && i2.push(dI(e2, t3, n2)), r2.const && i2.push("const "), i2.push("enum ", n2("id"), " "), r2.members.length === 0 ? i2.push(tI(["{", XO(e2, t3), eI, "}"])) : i2.push(tI(["{", nI([ZO, DI(e2, t3, "members", n2), sI(t3, "es5") ? "," : ""]), XO(e2, t3, true), ZO, "}"])), i2;
        case "TSEnumMember":
          return i2.push(n2("id")), r2.initializer && i2.push(" = ", n2("initializer")), i2;
        case "TSImportEqualsDeclaration":
          return r2.isExport && i2.push("export "), i2.push("import "), r2.importKind && r2.importKind !== "value" && i2.push(r2.importKind, " "), i2.push(n2("id"), " = ", n2("moduleReference")), t3.semi && i2.push(";"), tI(i2);
        case "TSExternalModuleReference":
          return ["require(", n2("expression"), ")"];
        case "TSModuleDeclaration": {
          const u2 = e2.getParentNode(), s2 = iI(r2.id), a2 = u2.type === "TSModuleDeclaration", c2 = r2.body && r2.body.type === "TSModuleDeclaration";
          if (a2)
            i2.push(".");
          else {
            r2.declare && i2.push("declare "), i2.push(dI(e2, t3, n2));
            const o3 = t3.originalText.slice(lI(r2), lI(r2.id));
            r2.id.type === "Identifier" && r2.id.name === "global" && !/namespace|module/.test(o3) || i2.push(s2 || /(?:^|\s)module(?:\s|$)/.test(o3) ? "module " : "namespace ");
          }
          return i2.push(n2("id")), c2 ? i2.push(n2("body")) : r2.body ? i2.push(" ", tI(n2("body"))) : i2.push(o2), i2;
        }
        case "TSConditionalType":
          return hI(e2, t3, n2);
        case "TSInferType":
          return ["infer", " ", n2("typeParameter")];
        case "TSIntersectionType":
          return NI(e2, t3, n2);
        case "TSUnionType":
          return kI(e2, t3, n2);
        case "TSFunctionType":
          return PI(e2, t3, n2);
        case "TSTupleType":
          return OI(e2, t3, n2);
        case "TSTypeReference":
          return [n2("typeName"), AI(e2, t3, n2, "typeParameters")];
        case "TSTypeAnnotation":
          return n2("typeAnnotation");
        case "TSEmptyBodyFunctionExpression":
          return SI(e2, t3, n2);
        case "TSJSDocAllType":
          return "*";
        case "TSJSDocUnknownType":
          return "?";
        case "TSJSDocNullableType":
          return ["?", n2("typeAnnotation")];
        case "TSJSDocNonNullableType":
          return ["!", n2("typeAnnotation")];
        default:
          throw new Error("Unknown TypeScript node type: ".concat(JSON.stringify(r2.type), "."));
      }
    } };
    const { hasNewline: jI } = dc, { builders: { join: _I, hardline: MI }, utils: { replaceTextEndOfLine: RI } } = Zc, { isLineComment: VI, isBlockComment: $I } = CC, { locStart: WI, locEnd: qI } = og;
    var UI = { printComment: function(e2, t3) {
      const n2 = e2.getValue();
      if (VI(n2))
        return t3.originalText.slice(WI(n2), qI(n2)).trimEnd();
      if ($I(n2)) {
        if (function(e4) {
          const t4 = "*".concat(e4.value, "*").split("\n");
          return t4.length > 1 && t4.every((e5) => e5.trim()[0] === "*");
        }(n2)) {
          const e4 = function(e5) {
            const t4 = e5.value.split("\n");
            return ["/*", _I(MI, t4.map((e6, n3) => n3 === 0 ? e6.trimEnd() : " " + (n3 < t4.length - 1 ? e6.trim() : e6.trimStart()))), "*/"];
          }(n2);
          return n2.trailing && !jI(t3.originalText, WI(n2), { backwards: true }) ? [MI, e4] : e4;
        }
        const e3 = qI(n2), r2 = t3.originalText.slice(e3 - 3, e3) === "*-/";
        return ["/*", RI(n2.value), r2 ? "*-/" : "*/"];
      }
      throw new Error("Not a comment: " + JSON.stringify(n2));
    } };
    const { printString: zI, printNumber: GI } = dc;
    function HI(e2) {
      return e2.toLowerCase();
    }
    function JI(e2) {
      let { pattern: t3, flags: n2 } = e2;
      return n2 = [...n2].sort().join(""), "/".concat(t3, "/").concat(n2);
    }
    var XI = { printLiteral: function(e2, t3) {
      const n2 = e2.getNode();
      switch (n2.type) {
        case "RegExpLiteral":
          return JI(n2);
        case "BigIntLiteral":
          return HI(n2.bigint || n2.extra.raw);
        case "NumericLiteral":
          return GI(n2.extra.raw);
        case "StringLiteral":
          return zI(n2.extra.raw, t3);
        case "NullLiteral":
          return "null";
        case "BooleanLiteral":
          return String(n2.value);
        case "DecimalLiteral":
          return GI(n2.value) + "m";
        case "Literal": {
          if (n2.regex)
            return JI(n2.regex);
          if (n2.bigint)
            return HI(n2.raw);
          if (n2.decimal)
            return GI(n2.decimal) + "m";
          const { value: e3 } = n2;
          return typeof e3 == "number" ? GI(n2.raw) : typeof e3 == "string" ? zI(n2.raw, t3) : String(e3);
        }
      }
    } };
    const { printDanglingComments: YI } = tD, { hasNewline: KI } = dc, { builders: { join: QI, line: ZI, hardline: eL, softline: tL, group: nL, indent: rL }, utils: { replaceTextEndOfLine: oL } } = Zc, iL = Nb, uL = Lb, { insertPragma: sL } = iv, aL = lA, cL = wA, lL = TA, { hasFlowShorthandAnnotationComment: pL, hasComment: fL, CommentCheckFlags: dL, isTheOnlyJsxElementInMarkdown: hL, isBlockComment: gL, isLineComment: mL, isNextLineEmpty: yL, needsHardlineAfterDanglingComment: DL, rawText: EL, hasIgnoreComment: CL, isCallExpression: bL, isMemberExpression: vL } = CC, { locStart: AL, locEnd: FL } = og, { printHtmlBinding: xL, isVueEventBindingExpression: SL } = IA, { printAngular: wL } = mF, { printJsx: TL, hasJsxIgnoreComment: BL } = ZF, { printFlow: NL } = oO, { printTypescript: kL } = LI, { printOptionalToken: PL, printBindExpressionCallee: OL, printTypeAnnotation: IL, adjustClause: LL, printRestSpread: jL } = _x, { printImportDeclaration: _L, printExportDeclaration: ML, printExportAllDeclaration: RL, printModuleSpecifier: VL } = Qk, { printTernary: $L } = AO, { printTemplateLiteral: WL } = VC, { printArray: qL } = uS, { printObject: UL } = vP, { printClass: zL, printClassMethod: GL, printClassProperty: HL } = Dk, { printProperty: JL } = zB, { printFunction: XL, printArrowFunction: YL, printMethod: KL, printReturnStatement: QL, printThrowStatement: ZL } = IN, { printCallExpression: ej } = Mw, { printVariableDeclarator: tj, printAssignmentExpression: nj } = mT, { printBinaryishExpression: rj } = sF, { printSwitchCaseConsequent: oj } = _O, { printMemberExpression: ij } = GS, { printBlock: uj, printBlockBody: sj } = JO, { printComment: aj } = UI, { printLiteral: cj } = XI, { printDecorators: lj } = HN;
    function pj(e2, t3) {
      const n2 = EL(e2), r2 = n2.slice(1, -1);
      if (r2.includes('"') || r2.includes("'"))
        return n2;
      const o2 = t3.singleQuote ? "'" : '"';
      return o2 + r2 + o2;
    }
    var fj = { preprocess: lL, print: function(e2, t3, n2, r2) {
      const o2 = function(e3, t4, n3, r3) {
        const o3 = e3.getValue(), i3 = t4.semi ? ";" : "";
        if (!o3)
          return "";
        if (typeof o3 == "string")
          return o3;
        for (const r4 of [cj, xL, wL, TL, NL, kL]) {
          const o4 = r4(e3, t4, n3);
          if (o4 !== void 0)
            return o4;
        }
        let u3 = [];
        switch (o3.type) {
          case "JsExpressionRoot":
            return n3("node");
          case "JsonRoot":
            return [n3("node"), eL];
          case "File":
            return o3.program && o3.program.interpreter && u3.push(n3(["program", "interpreter"])), u3.push(n3("program")), u3;
          case "Program":
            return sj(e3, t4, n3);
          case "EmptyStatement":
            return "";
          case "ExpressionStatement":
            if (o3.directive)
              return [pj(o3.expression, t4), i3];
            if (t4.parser === "__vue_event_binding") {
              const t5 = e3.getParentNode();
              if (t5.type === "Program" && t5.body.length === 1 && t5.body[0] === o3)
                return [n3("expression"), SL(o3.expression) ? ";" : ""];
            }
            return [n3("expression"), hL(t4, e3) ? "" : i3];
          case "ParenthesizedExpression":
            return !fL(o3.expression) && (o3.expression.type === "ObjectExpression" || o3.expression.type === "ArrayExpression") ? ["(", n3("expression"), ")"] : nL(["(", rL([tL, n3("expression")]), tL, ")"]);
          case "AssignmentExpression":
            return nj(e3, t4, n3);
          case "VariableDeclarator":
            return tj(e3, t4, n3);
          case "BinaryExpression":
          case "LogicalExpression":
            return rj(e3, t4, n3);
          case "AssignmentPattern":
            return [n3("left"), " = ", n3("right")];
          case "OptionalMemberExpression":
          case "MemberExpression":
            return ij(e3, t4, n3);
          case "MetaProperty":
            return [n3("meta"), ".", n3("property")];
          case "BindExpression":
            return o3.object && u3.push(n3("object")), u3.push(nL(rL([tL, OL(e3, t4, n3)]))), u3;
          case "Identifier":
            return [o3.name, PL(e3), IL(e3, t4, n3)];
          case "V8IntrinsicIdentifier":
            return ["%", o3.name];
          case "SpreadElement":
          case "SpreadElementPattern":
          case "SpreadProperty":
          case "SpreadPropertyPattern":
          case "RestElement":
            return jL(e3, t4, n3);
          case "FunctionDeclaration":
          case "FunctionExpression":
            return XL(e3, n3, t4, r3);
          case "ArrowFunctionExpression":
            return YL(e3, t4, n3, r3);
          case "YieldExpression":
            return u3.push("yield"), o3.delegate && u3.push("*"), o3.argument && u3.push(" ", n3("argument")), u3;
          case "AwaitExpression":
            if (u3.push("await"), o3.argument) {
              u3.push(" ", n3("argument"));
              const t5 = e3.getParentNode();
              if (bL(t5) && t5.callee === o3 || vL(t5) && t5.object === o3) {
                u3 = [rL([tL, ...u3]), tL];
                const t6 = e3.findAncestor((e4) => e4.type === "AwaitExpression" || e4.type === "BlockStatement");
                if (!t6 || t6.type !== "AwaitExpression")
                  return nL(u3);
              }
            }
            return u3;
          case "ExportDefaultDeclaration":
          case "ExportNamedDeclaration":
            return ML(e3, t4, n3);
          case "ExportAllDeclaration":
            return RL(e3, t4, n3);
          case "ImportDeclaration":
            return _L(e3, t4, n3);
          case "ImportSpecifier":
          case "ExportSpecifier":
          case "ImportNamespaceSpecifier":
          case "ExportNamespaceSpecifier":
          case "ImportDefaultSpecifier":
          case "ExportDefaultSpecifier":
            return VL(e3, t4, n3);
          case "ImportAttribute":
            return [n3("key"), ": ", n3("value")];
          case "Import":
            return "import";
          case "BlockStatement":
          case "StaticBlock":
          case "ClassBody":
            return uj(e3, t4, n3);
          case "ThrowStatement":
            return ZL(e3, t4, n3);
          case "ReturnStatement":
            return QL(e3, t4, n3);
          case "NewExpression":
          case "ImportExpression":
          case "OptionalCallExpression":
          case "CallExpression":
            return ej(e3, t4, n3);
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            return UL(e3, t4, n3);
          case "ObjectProperty":
          case "Property":
            return o3.method || o3.kind === "get" || o3.kind === "set" ? KL(e3, t4, n3) : JL(e3, t4, n3);
          case "ObjectMethod":
            return KL(e3, t4, n3);
          case "Decorator":
            return ["@", n3("expression")];
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            return qL(e3, t4, n3);
          case "SequenceExpression": {
            const t5 = e3.getParentNode(0);
            if (t5.type === "ExpressionStatement" || t5.type === "ForStatement") {
              const t6 = [];
              return e3.each((e4, r4) => {
                r4 === 0 ? t6.push(n3()) : t6.push(",", rL([ZI, n3()]));
              }, "expressions"), nL(t6);
            }
            return nL(QI([",", ZI], e3.map(n3, "expressions")));
          }
          case "ThisExpression":
            return "this";
          case "Super":
            return "super";
          case "Directive":
            return [n3("value"), i3];
          case "DirectiveLiteral":
            return pj(o3, t4);
          case "UnaryExpression":
            return u3.push(o3.operator), /[a-z]$/.test(o3.operator) && u3.push(" "), fL(o3.argument) ? u3.push(nL(["(", rL([tL, n3("argument")]), tL, ")"])) : u3.push(n3("argument")), u3;
          case "UpdateExpression":
            return u3.push(n3("argument"), o3.operator), o3.prefix && u3.reverse(), u3;
          case "ConditionalExpression":
            return $L(e3, t4, n3);
          case "VariableDeclaration": {
            const t5 = e3.map(n3, "declarations"), r4 = e3.getParentNode(), s3 = r4.type === "ForStatement" || r4.type === "ForInStatement" || r4.type === "ForOfStatement", a3 = o3.declarations.some((e4) => e4.init);
            let c2;
            return t5.length !== 1 || fL(o3.declarations[0]) ? t5.length > 0 && (c2 = rL(t5[0])) : c2 = t5[0], u3 = [o3.declare ? "declare " : "", o3.kind, c2 ? [" ", c2] : "", rL(t5.slice(1).map((e4) => [",", a3 && !s3 ? eL : ZI, e4]))], s3 && r4.body !== o3 || u3.push(i3), nL(u3);
          }
          case "WithStatement":
            return nL(["with (", n3("object"), ")", LL(o3.body, n3("body"))]);
          case "IfStatement": {
            const r4 = LL(o3.consequent, n3("consequent")), i4 = nL(["if (", nL([rL([tL, n3("test")]), tL]), ")", r4]);
            if (u3.push(i4), o3.alternate) {
              const r5 = fL(o3.consequent, dL.Trailing | dL.Line) || DL(o3), i5 = o3.consequent.type === "BlockStatement" && !r5;
              u3.push(i5 ? " " : eL), fL(o3, dL.Dangling) && u3.push(YI(e3, t4, true), r5 ? eL : " "), u3.push("else", nL(LL(o3.alternate, n3("alternate"), o3.alternate.type === "IfStatement")));
            }
            return u3;
          }
          case "ForStatement": {
            const r4 = LL(o3.body, n3("body")), i4 = YI(e3, t4, true), u4 = i4 ? [i4, tL] : "";
            return o3.init || o3.test || o3.update ? [u4, nL(["for (", nL([rL([tL, n3("init"), ";", ZI, n3("test"), ";", ZI, n3("update")]), tL]), ")", r4])] : [u4, nL(["for (;;)", r4])];
          }
          case "WhileStatement":
            return nL(["while (", nL([rL([tL, n3("test")]), tL]), ")", LL(o3.body, n3("body"))]);
          case "ForInStatement":
            return nL(["for (", n3("left"), " in ", n3("right"), ")", LL(o3.body, n3("body"))]);
          case "ForOfStatement":
            return nL(["for", o3.await ? " await" : "", " (", n3("left"), " of ", n3("right"), ")", LL(o3.body, n3("body"))]);
          case "DoWhileStatement": {
            const e4 = LL(o3.body, n3("body"));
            return u3 = [nL(["do", e4])], o3.body.type === "BlockStatement" ? u3.push(" ") : u3.push(eL), u3.push("while (", nL([rL([tL, n3("test")]), tL]), ")", i3), u3;
          }
          case "DoExpression":
            return [o3.async ? "async " : "", "do ", n3("body")];
          case "BreakStatement":
            return u3.push("break"), o3.label && u3.push(" ", n3("label")), u3.push(i3), u3;
          case "ContinueStatement":
            return u3.push("continue"), o3.label && u3.push(" ", n3("label")), u3.push(i3), u3;
          case "LabeledStatement":
            return o3.body.type === "EmptyStatement" ? [n3("label"), ":;"] : [n3("label"), ": ", n3("body")];
          case "TryStatement":
            return ["try ", n3("block"), o3.handler ? [" ", n3("handler")] : "", o3.finalizer ? [" finally ", n3("finalizer")] : ""];
          case "CatchClause":
            if (o3.param) {
              const e4 = fL(o3.param, (e5) => !gL(e5) || e5.leading && KI(t4.originalText, FL(e5)) || e5.trailing && KI(t4.originalText, AL(e5), { backwards: true })), r4 = n3("param");
              return ["catch ", e4 ? ["(", rL([tL, r4]), tL, ") "] : ["(", r4, ") "], n3("body")];
            }
            return ["catch ", n3("body")];
          case "SwitchStatement":
            return [nL(["switch (", rL([tL, n3("discriminant")]), tL, ")"]), " {", o3.cases.length > 0 ? rL([eL, QI(eL, e3.map((e4, r4, o4) => {
              const i4 = e4.getValue();
              return [n3(), r4 !== o4.length - 1 && yL(i4, t4) ? eL : ""];
            }, "cases"))]) : "", eL, "}"];
          case "SwitchCase": {
            o3.test ? u3.push("case ", n3("test"), ":") : u3.push("default:");
            const r4 = o3.consequent.filter((e4) => e4.type !== "EmptyStatement");
            if (r4.length > 0) {
              const o4 = oj(e3, t4, n3);
              u3.push(r4.length === 1 && r4[0].type === "BlockStatement" ? [" ", o4] : rL([eL, o4]));
            }
            return u3;
          }
          case "DebuggerStatement":
            return ["debugger", i3];
          case "ClassDeclaration":
          case "ClassExpression":
            return zL(e3, t4, n3);
          case "ClassMethod":
          case "ClassPrivateMethod":
          case "MethodDefinition":
            return GL(e3, t4, n3);
          case "ClassProperty":
          case "PropertyDefinition":
          case "ClassPrivateProperty":
            return HL(e3, t4, n3);
          case "TemplateElement":
            return oL(o3.value.raw);
          case "TemplateLiteral":
            return WL(e3, n3, t4);
          case "TaggedTemplateExpression":
            return [n3("tag"), n3("typeParameters"), n3("quasi")];
          case "PrivateIdentifier":
            return ["#", n3("name")];
          case "PrivateName":
            return ["#", n3("id")];
          case "InterpreterDirective":
            return u3.push("#!", o3.value, eL), yL(o3, t4) && u3.push(eL), u3;
          case "TopicReference":
            return "%";
          case "ArgumentPlaceholder":
            return "?";
          case "ModuleExpression": {
            u3.push("module {");
            const e4 = n3("body");
            return e4 && u3.push(rL([eL, e4]), eL), u3.push("}"), u3;
          }
          default:
            throw new Error("unknown type: " + JSON.stringify(o3.type));
        }
      }(e2, t3, n2, r2);
      if (!o2)
        return "";
      const i2 = e2.getValue(), { type: u2 } = i2;
      if (u2 === "ClassMethod" || u2 === "ClassPrivateMethod" || u2 === "ClassProperty" || u2 === "PropertyDefinition" || u2 === "TSAbstractPropertyDefinition" || u2 === "ClassPrivateProperty" || u2 === "MethodDefinition" || u2 === "TSAbstractMethodDefinition" || u2 === "TSDeclareMethod")
        return o2;
      const s2 = lj(e2, t3, n2);
      if (s2)
        return nL([...s2, o2]);
      if (!cL(e2, t3))
        return r2 && r2.needsSemi ? [";", o2] : o2;
      const a2 = [r2 && r2.needsSemi ? ";(" : "(", o2];
      if (pL(i2)) {
        const [e3] = i2.trailingComments;
        a2.push(" /*", e3.value.trimStart(), "*/"), e3.printed = true;
      }
      return a2.push(")"), a2;
    }, embed: iL, insertPragma: sL, massageAstNode: uL, hasPrettierIgnore: (e2) => CL(e2) || BL(e2), willPrintOwnComments: aL.willPrintOwnComments, canAttachComment: function(e2) {
      return e2.type && !gL(e2) && !mL(e2) && e2.type !== "EmptyStatement" && e2.type !== "TemplateElement" && e2.type !== "Import" && e2.type !== "TSEmptyBodyFunctionExpression";
    }, printComment: aj, isBlockComment: gL, handleComments: { avoidAstMutation: true, ownLine: aL.handleOwnLineComment, endOfLine: aL.handleEndOfLineComment, remaining: aL.handleRemainingComment }, getCommentChildNodes: aL.getCommentChildNodes };
    const { builders: { hardline: dj, indent: hj, join: gj } } = Zc, mj = TA;
    const yj = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
    function Dj(e2, t3) {
      const { type: n2 } = e2;
      if (n2 !== "ObjectProperty" || e2.key.type !== "Identifier") {
        if (n2 === "UnaryExpression" && e2.operator === "+")
          return t3.argument;
        if (n2 !== "ArrayExpression")
          return n2 === "TemplateLiteral" ? { type: "StringLiteral", value: e2.quasis[0].value.cooked } : void 0;
        for (const [n3, r2] of e2.elements.entries())
          r2 === null && t3.elements.splice(n3, 0, { type: "NullLiteral" });
      } else
        t3.key = { type: "StringLiteral", value: e2.key.name };
    }
    Dj.ignoredProperties = yj;
    var Ej = { preprocess: mj, print: function(e2, t3, n2) {
      const r2 = e2.getValue();
      switch (r2.type) {
        case "JsonRoot":
          return [n2("node"), dj];
        case "ArrayExpression": {
          if (r2.elements.length === 0)
            return "[]";
          const t4 = e2.map(() => e2.getValue() === null ? "null" : n2(), "elements");
          return ["[", hj([dj, gj([",", dj], t4)]), dj, "]"];
        }
        case "ObjectExpression":
          return r2.properties.length === 0 ? "{}" : ["{", hj([dj, gj([",", dj], e2.map(n2, "properties"))]), dj, "}"];
        case "ObjectProperty":
          return [n2("key"), ": ", n2("value")];
        case "UnaryExpression":
          return [r2.operator === "+" ? "" : r2.operator, n2("argument")];
        case "NullLiteral":
          return "null";
        case "BooleanLiteral":
          return r2.value ? "true" : "false";
        case "StringLiteral":
        case "NumericLiteral":
          return JSON.stringify(r2.value);
        case "Identifier": {
          const t4 = e2.getParentNode();
          return t4 && t4.type === "ObjectProperty" && t4.key === r2 ? JSON.stringify(r2.name) : r2.name;
        }
        case "TemplateLiteral":
          return n2(["quasis", 0]);
        case "TemplateElement":
          return JSON.stringify(r2.value.cooked);
        default:
          throw new Error("unknown type: " + JSON.stringify(r2.type));
      }
    }, massageAstNode: Dj };
    const Cj = "Common";
    var bj = { bracketSpacing: { since: "0.0.0", category: Cj, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: Cj, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: Cj, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: Cj, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." } };
    const vj = "JavaScript";
    var Aj = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".jsb", ".jscad", ".jsfl", ".jsm", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 }, Fj = { name: "TypeScript", type: "programming", color: "#2b7489", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 }, xj = { name: "TSX", type: "programming", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 }, Sj = { name: "JSON", type: "data", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", extensions: [".json", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".htmlhintrc", ".imgbotconfig", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 }, wj = { name: "JSON with Comments", type: "data", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 }, Tj = { name: "JSON5", type: "data", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
    const Bj = bE, Nj = fj, kj = Ej, Pj = { arrowParens: { since: "1.9.0", category: vj, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: bj.bracketSameLine, bracketSpacing: bj.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: vj, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: vj, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: bj.singleQuote, jsxSingleQuote: { since: "1.15.0", category: vj, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: vj, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: vj, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] } }, Oj = [Bj(Aj, (e2) => ({ since: "0.0.0", parsers: ["babel", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...e2.interpreters, "zx"], extensions: [...e2.extensions.filter((e3) => e3 !== ".jsx"), ".wxs"] })), Bj(Aj, () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), Bj(Aj, () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), Bj(Fj, (e2) => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"], extensions: [...e2.extensions, ".mts", ".cts"] })), Bj(xj, () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), Bj(Sj, () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [], filenames: ["package.json", "package-lock.json", "composer.json"] })), Bj(Sj, (e2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: e2.extensions.filter((e3) => e3 !== ".jsonl") })), Bj(wj, (e2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...e2.filenames, ".eslintrc"] })), Bj(Tj, () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))];
    var Ij = { languages: Oj, options: Pj, printers: { estree: Nj, "estree-json": kj }, parsers: void 0 };
    const { isFrontMatterNode: Lj } = dc, jj = au, _j = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
    function Mj(e2, t3, n2) {
      if (Lj(e2) && e2.lang === "yaml" && delete t3.value, e2.type === "css-comment" && n2.type === "css-root" && n2.nodes.length > 0) {
        if ((n2.nodes[0] === e2 || Lj(n2.nodes[0]) && n2.nodes[1] === e2) && (delete t3.text, /^\*\s*@(?:format|prettier)\s*$/.test(e2.text)))
          return null;
        if (n2.type === "css-root" && jj(n2.nodes) === e2)
          return null;
      }
      if (e2.type === "value-root" && delete t3.text, e2.type !== "media-query" && e2.type !== "media-query-list" && e2.type !== "media-feature-expression" || delete t3.value, e2.type === "css-rule" && delete t3.params, e2.type === "selector-combinator" && (t3.value = t3.value.replace(/\s+/g, " ")), e2.type === "media-feature" && (t3.value = t3.value.replace(/ /g, "")), (e2.type === "value-word" && (e2.isColor && e2.isHex || ["initial", "inherit", "unset", "revert"].includes(t3.value.replace().toLowerCase())) || e2.type === "media-feature" || e2.type === "selector-root-invalid" || e2.type === "selector-pseudo") && (t3.value = t3.value.toLowerCase()), e2.type === "css-decl" && (t3.prop = t3.prop.toLowerCase()), e2.type !== "css-atrule" && e2.type !== "css-import" || (t3.name = t3.name.toLowerCase()), e2.type === "value-number" && (t3.unit = t3.unit.toLowerCase()), e2.type !== "media-feature" && e2.type !== "media-keyword" && e2.type !== "media-type" && e2.type !== "media-unknown" && e2.type !== "media-url" && e2.type !== "media-value" && e2.type !== "selector-attribute" && e2.type !== "selector-string" && e2.type !== "selector-class" && e2.type !== "selector-combinator" && e2.type !== "value-string" || !t3.value || (t3.value = t3.value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1")), e2.type === "selector-attribute" && (t3.attribute = t3.attribute.trim(), t3.namespace && typeof t3.namespace == "string" && (t3.namespace = t3.namespace.trim(), t3.namespace.length === 0 && (t3.namespace = true)), t3.value && (t3.value = t3.value.trim().replace(/^["']|["']$/g, ""), delete t3.quoted)), e2.type !== "media-value" && e2.type !== "media-type" && e2.type !== "value-number" && e2.type !== "selector-root-invalid" && e2.type !== "selector-class" && e2.type !== "selector-combinator" && e2.type !== "selector-tag" || !t3.value || (t3.value = t3.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (e3, t4, n3) => {
        const r2 = Number(t4);
        return Number.isNaN(r2) ? e3 : r2 + n3.toLowerCase();
      })), e2.type === "selector-tag") {
        const n3 = e2.value.toLowerCase();
        ["from", "to"].includes(n3) && (t3.value = n3);
      }
      e2.type === "css-atrule" && e2.name.toLowerCase() === "supports" && delete t3.value, e2.type === "selector-unknown" && delete t3.value;
    }
    Mj.ignoredProperties = _j;
    var Rj = Mj;
    const { builders: { hardline: Vj, markAsRoot: $j } } = Zc;
    var Wj = function(e2, t3) {
      if (e2.lang === "yaml") {
        const n2 = e2.value.trim(), r2 = n2 ? t3(n2, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
        return $j([e2.startDelimiter, Vj, r2, r2 ? Vj : "", e2.endDelimiter]);
      }
    };
    const { builders: { hardline: qj } } = Zc, Uj = Wj;
    var zj = function(e2, t3, n2) {
      const r2 = e2.getValue();
      if (r2.type === "front-matter") {
        const e3 = Uj(r2, n2);
        return e3 ? [e3, qj] : "";
      }
    };
    const Gj = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
    var Hj = function(e2) {
      const t3 = e2.match(Gj);
      if (!t3)
        return { content: e2 };
      const { startDelimiter: n2, language: r2, value: o2 = "", endDelimiter: i2 } = t3.groups;
      let u2 = r2.trim() || "yaml";
      if (n2 === "+++" && (u2 = "toml"), u2 !== "yaml" && n2 !== i2)
        return { content: e2 };
      const [s2] = t3;
      return { frontMatter: { type: "front-matter", lang: u2, value: o2, startDelimiter: n2, endDelimiter: i2, raw: s2.replace(/\n$/, "") }, content: s2.replace(/[^\n]/g, " ") + e2.slice(s2.length) };
    };
    const Jj = iv, Xj = Hj;
    var Yj = { hasPragma: function(e2) {
      return Jj.hasPragma(Xj(e2).content);
    }, insertPragma: function(e2) {
      const { frontMatter: t3, content: n2 } = Xj(e2);
      return (t3 ? t3.raw + "\n\n" : "") + Jj.insertPragma(n2);
    } };
    const { isNonEmptyArray: Kj } = dc, Qj = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]), Zj = /* @__PURE__ */ new Set(["import", "use", "forward"]);
    function e_(e2, t3) {
      const n2 = Array.isArray(t3) ? t3 : [t3];
      let r2, o2 = -1;
      for (; r2 = e2.getParentNode(++o2); )
        if (n2.includes(r2.type))
          return o2;
      return -1;
    }
    function t_(e2, t3) {
      const n2 = e_(e2, t3);
      return n2 === -1 ? null : e2.getParentNode(n2);
    }
    function n_(e2) {
      return e2.type === "value-operator" && e2.value === "*";
    }
    function r_(e2) {
      return e2.type === "value-operator" && e2.value === "/";
    }
    function o_(e2) {
      return e2.type === "value-operator" && e2.value === "+";
    }
    function i_(e2) {
      return e2.type === "value-operator" && e2.value === "-";
    }
    function u_(e2) {
      return e2.type === "value-operator" && e2.value === "%";
    }
    function s_(e2) {
      return e2.type === "value-comma_group" && e2.groups && e2.groups[1] && e2.groups[1].type === "value-colon";
    }
    function a_(e2) {
      return e2.type === "value-paren_group" && e2.groups && e2.groups[0] && s_(e2.groups[0]);
    }
    function c_(e2) {
      return e2 && e2.type === "value-colon";
    }
    var l_ = { getAncestorCounter: e_, getAncestorNode: t_, getPropOfDeclNode: function(e2) {
      const t3 = t_(e2, "css-decl");
      return t3 && t3.prop && t3.prop.toLowerCase();
    }, hasSCSSInterpolation: function(e2) {
      if (Kj(e2)) {
        for (let t3 = e2.length - 1; t3 > 0; t3--)
          if (e2[t3].type === "word" && e2[t3].value === "{" && e2[t3 - 1].type === "word" && e2[t3 - 1].value.endsWith("#"))
            return true;
      }
      return false;
    }, hasStringOrFunction: function(e2) {
      if (Kj(e2)) {
        for (let t3 = 0; t3 < e2.length; t3++)
          if (e2[t3].type === "string" || e2[t3].type === "func")
            return true;
      }
      return false;
    }, maybeToLowerCase: function(e2) {
      return e2.includes("$") || e2.includes("@") || e2.includes("#") || e2.startsWith("%") || e2.startsWith("--") || e2.startsWith(":--") || e2.includes("(") && e2.includes(")") ? e2 : e2.toLowerCase();
    }, insideValueFunctionNode: function(e2, t3) {
      const n2 = t_(e2, "value-func");
      return n2 && n2.value && n2.value.toLowerCase() === t3;
    }, insideICSSRuleNode: function(e2) {
      const t3 = t_(e2, "css-rule");
      return t3 && t3.raws && t3.raws.selector && (t3.raws.selector.startsWith(":import") || t3.raws.selector.startsWith(":export"));
    }, insideAtRuleNode: function(e2, t3) {
      const n2 = Array.isArray(t3) ? t3 : [t3], r2 = t_(e2, "css-atrule");
      return r2 && n2.includes(r2.name.toLowerCase());
    }, insideURLFunctionInImportAtRuleNode: function(e2) {
      const t3 = e2.getValue(), n2 = t_(e2, "css-atrule");
      return n2 && n2.name === "import" && t3.groups[0].value === "url" && t3.groups.length === 2;
    }, isKeyframeAtRuleKeywords: function(e2, t3) {
      const n2 = t_(e2, "css-atrule");
      return n2 && n2.name && n2.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t3.toLowerCase());
    }, isWideKeywords: function(e2) {
      return ["initial", "inherit", "unset", "revert"].includes(e2.toLowerCase());
    }, isSCSS: function(e2, t3) {
      return e2 === "less" || e2 === "scss" ? e2 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t3);
    }, isSCSSVariable: function(e2) {
      return Boolean(e2 && e2.type === "word" && e2.value.startsWith("$"));
    }, isLastNode: function(e2, t3) {
      const n2 = e2.getParentNode();
      if (!n2)
        return false;
      const { nodes: r2 } = n2;
      return r2 && r2.indexOf(t3) === r2.length - 1;
    }, isLessParser: function(e2) {
      return e2.parser === "css" || e2.parser === "less";
    }, isSCSSControlDirectiveNode: function(e2) {
      return e2.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(e2.name);
    }, isDetachedRulesetDeclarationNode: function(e2) {
      return !!e2.selector && (typeof e2.selector == "string" && /^@.+:.*$/.test(e2.selector) || e2.selector.value && /^@.+:.*$/.test(e2.selector.value));
    }, isRelationalOperatorNode: function(e2) {
      return e2.type === "value-word" && ["<", ">", "<=", ">="].includes(e2.value);
    }, isEqualityOperatorNode: function(e2) {
      return e2.type === "value-word" && ["==", "!="].includes(e2.value);
    }, isMultiplicationNode: n_, isDivisionNode: r_, isAdditionNode: o_, isSubtractionNode: i_, isModuloNode: u_, isMathOperatorNode: function(e2) {
      return n_(e2) || r_(e2) || o_(e2) || i_(e2) || u_(e2);
    }, isEachKeywordNode: function(e2) {
      return e2.type === "value-word" && e2.value === "in";
    }, isForKeywordNode: function(e2) {
      return e2.type === "value-word" && ["from", "through", "end"].includes(e2.value);
    }, isURLFunctionNode: function(e2) {
      return e2.type === "value-func" && e2.value.toLowerCase() === "url";
    }, isIfElseKeywordNode: function(e2) {
      return e2.type === "value-word" && ["and", "or", "not"].includes(e2.value);
    }, hasComposesNode: function(e2) {
      return e2.value && e2.value.type === "value-root" && e2.value.group && e2.value.group.type === "value-value" && e2.prop.toLowerCase() === "composes";
    }, hasParensAroundNode: function(e2) {
      return e2.value && e2.value.group && e2.value.group.group && e2.value.group.group.type === "value-paren_group" && e2.value.group.group.open !== null && e2.value.group.group.close !== null;
    }, hasEmptyRawBefore: function(e2) {
      return e2.raws && e2.raws.before === "";
    }, isSCSSNestedPropertyNode: function(e2) {
      return !!e2.selector && e2.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
    }, isDetachedRulesetCallNode: function(e2) {
      return e2.raws && e2.raws.params && /^\(\s*\)$/.test(e2.raws.params);
    }, isTemplatePlaceholderNode: function(e2) {
      return e2.name.startsWith("prettier-placeholder");
    }, isTemplatePropNode: function(e2) {
      return e2.prop.startsWith("@prettier-placeholder");
    }, isPostcssSimpleVarNode: function(e2, t3) {
      return e2.value === "$$" && e2.type === "value-func" && t3 && t3.type === "value-word" && !t3.raws.before;
    }, isKeyValuePairNode: s_, isKeyValuePairInParenGroupNode: a_, isKeyInValuePairNode: function(e2, t3) {
      if (!s_(t3))
        return false;
      const { groups: n2 } = t3, r2 = n2.indexOf(e2);
      return r2 !== -1 && c_(n2[r2 + 1]);
    }, isSCSSMapItemNode: function(e2) {
      const t3 = e2.getValue();
      if (t3.groups.length === 0)
        return false;
      const n2 = e2.getParentNode(1);
      if (!(a_(t3) || n2 && a_(n2)))
        return false;
      const r2 = t_(e2, "css-decl");
      return !!(r2 && r2.prop && r2.prop.startsWith("$")) || (!!a_(n2) || n2.type === "value-func");
    }, isInlineValueCommentNode: function(e2) {
      return e2.type === "value-comment" && e2.inline;
    }, isHashNode: function(e2) {
      return e2.type === "value-word" && e2.value === "#";
    }, isLeftCurlyBraceNode: function(e2) {
      return e2.type === "value-word" && e2.value === "{";
    }, isRightCurlyBraceNode: function(e2) {
      return e2.type === "value-word" && e2.value === "}";
    }, isWordNode: function(e2) {
      return ["value-word", "value-atword"].includes(e2.type);
    }, isColonNode: c_, isMediaAndSupportsKeywords: function(e2) {
      return e2.value && ["not", "and", "or"].includes(e2.value.toLowerCase());
    }, isColorAdjusterFuncNode: function(e2) {
      return e2.type === "value-func" && Qj.has(e2.value.toLowerCase());
    }, lastLineHasInlineComment: function(e2) {
      return /\/\//.test(e2.split(/[\n\r]/).pop());
    }, stringifyNode: function e2(t3) {
      if (t3.groups) {
        return (t3.open && t3.open.value ? t3.open.value : "") + t3.groups.reduce((n3, r3, o2) => n3 + e2(r3) + (t3.groups[0].type === "comma_group" && o2 !== t3.groups.length - 1 ? "," : ""), "") + (t3.close && t3.close.value ? t3.close.value : "");
      }
      const n2 = t3.raws && t3.raws.before ? t3.raws.before : "", r2 = t3.raws && t3.raws.quote ? t3.raws.quote : "";
      return n2 + r2 + (t3.type === "atword" ? "@" : "") + (t3.value ? t3.value : "") + r2 + (t3.unit ? t3.unit : "") + (t3.group ? e2(t3.group) : "") + (t3.raws && t3.raws.after ? t3.raws.after : "");
    }, isAtWordPlaceholderNode: function(e2) {
      return e2 && e2.type === "value-atword" && e2.value.startsWith("prettier-placeholder-");
    }, isModuleRuleName: function(e2) {
      return Zj.has(e2);
    }, isConfigurationNode: function(e2, t3) {
      if (!e2.open || e2.open.value !== "(" || !e2.close || e2.close.value !== ")" || e2.groups.some((e3) => e3.type !== "value-comma_group"))
        return false;
      if (t3.type === "value-comma_group") {
        const n2 = t3.groups.indexOf(e2) - 1, r2 = t3.groups[n2];
        if (r2 && r2.type === "value-word" && r2.value === "with")
          return true;
      }
      return false;
    }, isParenGroupNode: function(e2) {
      return e2.type === "value-paren_group" && e2.open && e2.open.value === "(" && e2.close && e2.close.value === ")";
    } };
    const p_ = function(e2, t3) {
      let n2 = 0;
      for (let r2 = 0; r2 < e2.line - 1; ++r2)
        n2 = t3.indexOf("\n", n2) + 1;
      return n2 + e2.column;
    }, { getLast: f_, skipEverythingButNewLine: d_ } = dc;
    function h_(e2, t3) {
      return typeof e2.sourceIndex == "number" ? e2.sourceIndex : e2.source ? p_(e2.source.start, t3) - 1 : null;
    }
    function g_(e2, t3) {
      if (e2.type === "css-comment" && e2.inline)
        return d_(t3, e2.source.startOffset);
      const n2 = e2.nodes && f_(e2.nodes);
      return n2 && e2.source && !e2.source.end && (e2 = n2), e2.source && e2.source.end ? p_(e2.source.end, t3) : null;
    }
    function m_(e2, t3, n2) {
      e2.source && (e2.source.startOffset = h_(e2, n2) + t3, e2.source.endOffset = g_(e2, n2) + t3);
      for (const r2 in e2) {
        const o2 = e2[r2];
        r2 !== "source" && o2 && typeof o2 == "object" && m_(o2, t3, n2);
      }
    }
    function y_(e2) {
      let t3 = e2.source.startOffset;
      return typeof e2.prop == "string" && (t3 += e2.prop.length), e2.type === "css-atrule" && typeof e2.name == "string" && (t3 += 1 + e2.name.length + e2.raws.afterName.match(/^\s*:?\s*/)[0].length), e2.type !== "css-atrule" && e2.raws && typeof e2.raws.between == "string" && (t3 += e2.raws.between.length), t3;
    }
    var D_ = { locStart: function(e2) {
      return e2.source.startOffset;
    }, locEnd: function(e2) {
      return e2.source.endOffset;
    }, calculateLoc: function e2(t3, n2) {
      t3.source && (t3.source.startOffset = h_(t3, n2), t3.source.endOffset = g_(t3, n2));
      for (const r2 in t3) {
        const o2 = t3[r2];
        r2 !== "source" && o2 && typeof o2 == "object" && (o2.type === "value-root" || o2.type === "value-unknown" ? m_(o2, y_(t3), o2.text || o2.value) : e2(o2, n2));
      }
    }, replaceQuotesInInlineComments: function(e2) {
      let t3, n2 = "initial", r2 = "initial", o2 = false;
      const i2 = [];
      for (let u2 = 0; u2 < e2.length; u2++) {
        const s2 = e2[u2];
        switch (n2) {
          case "initial":
            if (s2 === "'") {
              n2 = "single-quotes";
              continue;
            }
            if (s2 === '"') {
              n2 = "double-quotes";
              continue;
            }
            if ((s2 === "u" || s2 === "U") && e2.slice(u2, u2 + 4).toLowerCase() === "url(") {
              n2 = "url", u2 += 3;
              continue;
            }
            if (s2 === "*" && e2[u2 - 1] === "/") {
              n2 = "comment-block";
              continue;
            }
            if (s2 === "/" && e2[u2 - 1] === "/") {
              n2 = "comment-inline", t3 = u2 - 1;
              continue;
            }
            continue;
          case "single-quotes":
            if (s2 === "'" && e2[u2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
              return e2;
            continue;
          case "double-quotes":
            if (s2 === '"' && e2[u2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
              return e2;
            continue;
          case "url":
            if (s2 === ")" && (n2 = "initial"), s2 === "\n" || s2 === "\r")
              return e2;
            if (s2 === "'") {
              n2 = "single-quotes", r2 = "url";
              continue;
            }
            if (s2 === '"') {
              n2 = "double-quotes", r2 = "url";
              continue;
            }
            continue;
          case "comment-block":
            s2 === "/" && e2[u2 - 1] === "*" && (n2 = "initial");
            continue;
          case "comment-inline":
            s2 !== '"' && s2 !== "'" && s2 !== "*" || (o2 = true), s2 !== "\n" && s2 !== "\r" || (o2 && i2.push([t3, u2]), n2 = "initial", o2 = false);
            continue;
        }
      }
      for (const [t4, n3] of i2)
        e2 = e2.slice(0, t4) + e2.slice(t4, n3).replace(/["'*]/g, " ") + e2.slice(n3);
      return e2;
    } };
    const E_ = au, { printNumber: C_, printString: b_, hasNewline: v_, isFrontMatterNode: A_, isNextLineEmpty: F_, isNonEmptyArray: x_ } = dc, { builders: { join: S_, line: w_, hardline: T_, softline: B_, group: N_, fill: k_, indent: P_, dedent: O_, ifBreak: I_, breakParent: L_ }, utils: { removeLines: j_, getDocParts: __ } } = Zc, M_ = Rj, R_ = zj, { insertPragma: V_ } = Yj, { getAncestorNode: $_, getPropOfDeclNode: W_, maybeToLowerCase: q_, insideValueFunctionNode: U_, insideICSSRuleNode: z_, insideAtRuleNode: G_, insideURLFunctionInImportAtRuleNode: H_, isKeyframeAtRuleKeywords: J_, isWideKeywords: X_, isSCSS: Y_, isLastNode: K_, isLessParser: Q_, isSCSSControlDirectiveNode: Z_, isDetachedRulesetDeclarationNode: eM, isRelationalOperatorNode: tM, isEqualityOperatorNode: nM, isMultiplicationNode: rM, isDivisionNode: oM, isAdditionNode: iM, isSubtractionNode: uM, isMathOperatorNode: sM, isEachKeywordNode: aM, isForKeywordNode: cM, isURLFunctionNode: lM, isIfElseKeywordNode: pM, hasComposesNode: fM, hasParensAroundNode: dM, hasEmptyRawBefore: hM, isKeyValuePairNode: gM, isKeyInValuePairNode: mM, isDetachedRulesetCallNode: yM, isTemplatePlaceholderNode: DM, isTemplatePropNode: EM, isPostcssSimpleVarNode: CM, isSCSSMapItemNode: bM, isInlineValueCommentNode: vM, isHashNode: AM, isLeftCurlyBraceNode: FM, isRightCurlyBraceNode: xM, isWordNode: SM, isColonNode: wM, isMediaAndSupportsKeywords: TM, isColorAdjusterFuncNode: BM, lastLineHasInlineComment: NM, isAtWordPlaceholderNode: kM, isConfigurationNode: PM, isParenGroupNode: OM } = l_, { locStart: IM, locEnd: LM } = D_;
    function jM(e2) {
      return e2.trailingComma === "es5" || e2.trailingComma === "all";
    }
    function _M(e2, t3, n2) {
      const r2 = [];
      return e2.each((e3, o2, i2) => {
        const u2 = i2[o2 - 1];
        if (u2 && u2.type === "css-comment" && u2.text.trim() === "prettier-ignore") {
          const n3 = e3.getValue();
          r2.push(t3.originalText.slice(IM(n3), LM(n3)));
        } else
          r2.push(n2());
        o2 !== i2.length - 1 && (i2[o2 + 1].type === "css-comment" && !v_(t3.originalText, IM(i2[o2 + 1]), { backwards: true }) && !A_(i2[o2]) || i2[o2 + 1].type === "css-atrule" && i2[o2 + 1].name === "else" && i2[o2].type !== "css-comment" ? r2.push(" ") : (r2.push(t3.__isHTMLStyleAttribute ? w_ : T_), F_(t3.originalText, e3.getValue(), LM) && !A_(i2[o2]) && r2.push(T_)));
      }, "nodes"), r2;
    }
    const MM = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, RM = new RegExp(MM.source + "|" + "(".concat(/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source, ")?") + "(".concat(/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source, ")") + "(".concat(/[A-Za-z]+/g.source, ")?"), "g");
    function VM(e2, t3) {
      return e2.replace(MM, (e3) => b_(e3, t3));
    }
    function $M(e2, t3) {
      const n2 = t3.singleQuote ? "'" : '"';
      return e2.includes('"') || e2.includes("'") ? e2 : n2 + e2 + n2;
    }
    function WM(e2) {
      return e2.replace(RM, (e3, t3, n2, r2, o2) => !n2 && r2 ? qM(r2) + q_(o2 || "") : e3);
    }
    function qM(e2) {
      return C_(e2).replace(/\.0(?=$|e)/, "");
    }
    var UM = { print: function(e2, t3, n2) {
      const r2 = e2.getValue();
      if (!r2)
        return "";
      if (typeof r2 == "string")
        return r2;
      switch (r2.type) {
        case "front-matter":
          return [r2.raw, T_];
        case "css-root": {
          const o2 = _M(e2, t3, n2), i2 = r2.raws.after.trim();
          return [o2, i2 ? " ".concat(i2) : "", __(o2).length > 0 ? T_ : ""];
        }
        case "css-comment": {
          const e3 = r2.inline || r2.raws.inline, n3 = t3.originalText.slice(IM(r2), LM(r2));
          return e3 ? n3.trimEnd() : n3;
        }
        case "css-rule":
          return [n2("selector"), r2.important ? " !important" : "", r2.nodes ? [r2.selector && r2.selector.type === "selector-unknown" && NM(r2.selector.value) ? w_ : " ", "{", r2.nodes.length > 0 ? P_([T_, _M(e2, t3, n2)]) : "", T_, "}", eM(r2) ? ";" : ""] : ";"];
        case "css-decl": {
          const o2 = e2.getParentNode(), { between: i2 } = r2.raws, u2 = i2.trim(), s2 = u2 === ":";
          let a2 = fM(r2) ? j_(n2("value")) : n2("value");
          return !s2 && NM(u2) && (a2 = P_([T_, O_(a2)])), [r2.raws.before.replace(/[\s;]/g, ""), z_(e2) ? r2.prop : q_(r2.prop), u2.startsWith("//") ? " " : "", u2, r2.extend ? "" : " ", Q_(t3) && r2.extend && r2.selector ? ["extend(", n2("selector"), ")"] : "", a2, r2.raws.important ? r2.raws.important.replace(/\s*!\s*important/i, " !important") : r2.important ? " !important" : "", r2.raws.scssDefault ? r2.raws.scssDefault.replace(/\s*!default/i, " !default") : r2.scssDefault ? " !default" : "", r2.raws.scssGlobal ? r2.raws.scssGlobal.replace(/\s*!global/i, " !global") : r2.scssGlobal ? " !global" : "", r2.nodes ? [" {", P_([B_, _M(e2, t3, n2)]), B_, "}"] : EM(r2) && !o2.raws.semicolon && t3.originalText[LM(r2) - 1] !== ";" ? "" : t3.__isHTMLStyleAttribute && K_(e2, r2) ? I_(";") : ";"];
        }
        case "css-atrule": {
          const o2 = e2.getParentNode(), i2 = DM(r2) && !o2.raws.semicolon && t3.originalText[LM(r2) - 1] !== ";";
          if (Q_(t3)) {
            if (r2.mixin)
              return [n2("selector"), r2.important ? " !important" : "", i2 ? "" : ";"];
            if (r2.function)
              return [r2.name, n2("params"), i2 ? "" : ";"];
            if (r2.variable)
              return ["@", r2.name, ": ", r2.value ? n2("value") : "", r2.raws.between.trim() ? r2.raws.between.trim() + " " : "", r2.nodes ? ["{", P_([r2.nodes.length > 0 ? B_ : "", _M(e2, t3, n2)]), B_, "}"] : "", i2 ? "" : ";"];
          }
          return ["@", yM(r2) || r2.name.endsWith(":") ? r2.name : q_(r2.name), r2.params ? [yM(r2) ? "" : DM(r2) ? r2.raws.afterName === "" ? "" : r2.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r2.raws.afterName) ? [T_, T_] : /^\s*\n/.test(r2.raws.afterName) ? T_ : " " : " ", n2("params")] : "", r2.selector ? P_([" ", n2("selector")]) : "", r2.value ? N_([" ", n2("value"), Z_(r2) ? dM(r2) ? " " : w_ : ""]) : r2.name === "else" ? " " : "", r2.nodes ? [Z_(r2) ? "" : r2.selector && !r2.selector.nodes && typeof r2.selector.value == "string" && NM(r2.selector.value) || !r2.selector && typeof r2.params == "string" && NM(r2.params) ? w_ : " ", "{", P_([r2.nodes.length > 0 ? B_ : "", _M(e2, t3, n2)]), B_, "}"] : i2 ? "" : ";"];
        }
        case "media-query-list": {
          const t4 = [];
          return e2.each((e3) => {
            const r3 = e3.getValue();
            r3.type === "media-query" && r3.value === "" || t4.push(n2());
          }, "nodes"), N_(P_(S_(w_, t4)));
        }
        case "media-query":
          return [S_(" ", e2.map(n2, "nodes")), K_(e2, r2) ? "" : ","];
        case "media-type":
        case "media-value":
          return WM(VM(r2.value, t3));
        case "media-feature-expression":
          return r2.nodes ? ["(", ...e2.map(n2, "nodes"), ")"] : r2.value;
        case "media-feature":
          return q_(VM(r2.value.replace(/ +/g, " "), t3));
        case "media-colon":
        case "value-comma":
          return [r2.value, " "];
        case "media-keyword":
        case "selector-string":
          return VM(r2.value, t3);
        case "media-url":
          return VM(r2.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), t3);
        case "media-unknown":
        case "selector-comment":
        case "selector-nesting":
        case "value-paren":
        case "value-operator":
        case "value-unicode-range":
        case "value-unknown":
          return r2.value;
        case "selector-root":
          return N_([G_(e2, "custom-selector") ? [$_(e2, "css-atrule").customSelector, w_] : "", S_([",", G_(e2, ["extend", "custom-selector", "nest"]) ? w_ : T_], e2.map(n2, "nodes"))]);
        case "selector-selector":
          return N_(P_(e2.map(n2, "nodes")));
        case "selector-tag": {
          const t4 = e2.getParentNode(), n3 = t4 && t4.nodes.indexOf(r2), o2 = n3 && t4.nodes[n3 - 1];
          return [r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", o2.type === "selector-nesting" ? r2.value : WM(J_(e2, r2.value) ? r2.value.toLowerCase() : r2.value)];
        }
        case "selector-id":
          return ["#", r2.value];
        case "selector-class":
          return [".", WM(VM(r2.value, t3))];
        case "selector-attribute":
          return ["[", r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", r2.attribute.trim(), r2.operator ? r2.operator : "", r2.value ? $M(VM(r2.value.trim(), t3), t3) : "", r2.insensitive ? " i" : "", "]"];
        case "selector-combinator":
          if (r2.value === "+" || r2.value === ">" || r2.value === "~" || r2.value === ">>>") {
            const t4 = e2.getParentNode();
            return [t4.type === "selector-selector" && t4.nodes[0] === r2 ? "" : w_, r2.value, K_(e2, r2) ? "" : " "];
          }
          return [r2.value.trim().startsWith("(") ? w_ : "", WM(VM(r2.value.trim(), t3)) || w_];
        case "selector-universal":
          return [r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", r2.value];
        case "selector-pseudo":
          return [q_(r2.value), x_(r2.nodes) ? ["(", S_(", ", e2.map(n2, "nodes")), ")"] : ""];
        case "selector-unknown": {
          const n3 = $_(e2, "css-rule");
          if (n3 && n3.isSCSSNesterProperty)
            return WM(VM(q_(r2.value), t3));
          const o2 = e2.getParentNode();
          if (o2.raws && o2.raws.selector) {
            const e3 = IM(o2), n4 = e3 + o2.raws.selector.length;
            return t3.originalText.slice(e3, n4).trim();
          }
          const i2 = e2.getParentNode(1);
          if (o2.type === "value-paren_group" && i2 && i2.type === "value-func" && i2.value === "selector") {
            const e3 = IM(o2.open) + 1, n4 = LM(o2.close) - 1, r3 = t3.originalText.slice(e3, n4).trim();
            return NM(r3) ? [L_, r3] : r3;
          }
          return r2.value;
        }
        case "value-value":
        case "value-root":
          return n2("group");
        case "value-comment":
          return t3.originalText.slice(IM(r2), LM(r2));
        case "value-comma_group": {
          const t4 = e2.getParentNode(), o2 = e2.getParentNode(1), i2 = W_(e2), u2 = i2 && t4.type === "value-value" && (i2 === "grid" || i2.startsWith("grid-template")), s2 = $_(e2, "css-atrule"), a2 = s2 && Z_(s2), c2 = r2.groups.some((e3) => vM(e3)), l2 = e2.map(n2, "groups"), p2 = [], f2 = U_(e2, "url");
          let d2 = false, h2 = false;
          for (let n3 = 0; n3 < r2.groups.length; ++n3) {
            p2.push(l2[n3]);
            const i3 = r2.groups[n3 - 1], c3 = r2.groups[n3], g2 = r2.groups[n3 + 1], m2 = r2.groups[n3 + 2];
            if (f2) {
              (g2 && iM(g2) || iM(c3)) && p2.push(" ");
              continue;
            }
            if (G_(e2, "forward") && c3.type === "value-word" && c3.value && i3 !== void 0 && i3.type === "value-word" && i3.value === "as" && g2.type === "value-operator" && g2.value === "*")
              continue;
            if (!g2)
              continue;
            if (c3.type === "value-word" && c3.value.endsWith("-") && kM(g2))
              continue;
            const y2 = c3.type === "value-string" && c3.value.startsWith("#{"), D2 = d2 && g2.type === "value-string" && g2.value.endsWith("}");
            if (y2 || D2) {
              d2 = !d2;
              continue;
            }
            if (d2)
              continue;
            if (wM(c3) || wM(g2))
              continue;
            if (c3.type === "value-atword" && c3.value === "")
              continue;
            if (c3.value === "~")
              continue;
            if (c3.value && c3.value.includes("\\") && g2 && g2.type !== "value-comment")
              continue;
            if (i3 && i3.value && i3.value.indexOf("\\") === i3.value.length - 1 && c3.type === "value-operator" && c3.value === "/")
              continue;
            if (c3.value === "\\")
              continue;
            if (CM(c3, g2))
              continue;
            if (AM(c3) || FM(c3) || xM(g2) || FM(g2) && hM(g2) || xM(c3) && hM(g2))
              continue;
            if (c3.value === "--" && AM(g2))
              continue;
            const E2 = sM(c3), C3 = sM(g2);
            if ((E2 && AM(g2) || C3 && xM(c3)) && hM(g2))
              continue;
            if (!i3 && oM(c3))
              continue;
            if (U_(e2, "calc") && (iM(c3) || iM(g2) || uM(c3) || uM(g2)) && hM(g2))
              continue;
            const b2 = (iM(c3) || uM(c3)) && n3 === 0 && (g2.type === "value-number" || g2.isHex) && o2 && BM(o2) && !hM(g2), v2 = m2 && m2.type === "value-func" || m2 && SM(m2) || c3.type === "value-func" || SM(c3), A2 = g2.type === "value-func" || SM(g2) || i3 && i3.type === "value-func" || i3 && SM(i3);
            if (rM(g2) || rM(c3) || U_(e2, "calc") || b2 || !(oM(g2) && !v2 || oM(c3) && !A2 || iM(g2) && !v2 || iM(c3) && !A2 || uM(g2) || uM(c3)) || !(hM(g2) || E2 && (!i3 || i3 && sM(i3))))
              if (vM(c3)) {
                if (t4.type === "value-paren_group") {
                  p2.push(O_(T_));
                  continue;
                }
                p2.push(T_);
              } else
                a2 && (nM(g2) || tM(g2) || pM(g2) || aM(c3) || cM(c3)) || s2 && s2.name.toLowerCase() === "namespace" ? p2.push(" ") : u2 ? c3.source && g2.source && c3.source.start.line !== g2.source.start.line ? (p2.push(T_), h2 = true) : p2.push(" ") : C3 ? p2.push(" ") : g2 && g2.value === "..." || kM(c3) && kM(g2) && LM(c3) === IM(g2) || (kM(c3) && OM(g2) && LM(c3) === IM(g2.open) ? p2.push(B_) : c3.value === "with" && OM(g2) ? p2.push(" ") : p2.push(w_));
          }
          return c2 && p2.push(L_), h2 && p2.unshift(T_), a2 ? N_(P_(p2)) : H_(e2) ? N_(k_(p2)) : N_(P_(k_(p2)));
        }
        case "value-paren_group": {
          const o2 = e2.getParentNode();
          if (o2 && lM(o2) && (r2.groups.length === 1 || r2.groups.length > 0 && r2.groups[0].type === "value-comma_group" && r2.groups[0].groups.length > 0 && r2.groups[0].groups[0].type === "value-word" && r2.groups[0].groups[0].value.startsWith("data:")))
            return [r2.open ? n2("open") : "", S_(",", e2.map(n2, "groups")), r2.close ? n2("close") : ""];
          if (!r2.open) {
            const t4 = e2.map(n2, "groups"), r3 = [];
            for (let e3 = 0; e3 < t4.length; e3++)
              e3 !== 0 && r3.push([",", w_]), r3.push(t4[e3]);
            return N_(P_(k_(r3)));
          }
          const i2 = bM(e2), u2 = E_(r2.groups), s2 = u2 && u2.type === "value-comment", a2 = mM(r2, o2), c2 = PM(r2, o2), l2 = c2 || i2 && !a2, p2 = c2 || a2, f2 = N_([r2.open ? n2("open") : "", P_([B_, S_([",", w_], e2.map((e3) => {
            const t4 = e3.getValue(), r3 = n2();
            if (gM(t4) && t4.type === "value-comma_group" && t4.groups && t4.groups[0].type !== "value-paren_group" && t4.groups[2] && t4.groups[2].type === "value-paren_group") {
              const e4 = __(r3.contents.contents);
              return e4[1] = N_(e4[1]), N_(O_(r3));
            }
            return r3;
          }, "groups"))]), I_(!s2 && Y_(t3.parser, t3.originalText) && i2 && jM(t3) ? "," : ""), B_, r2.close ? n2("close") : ""], { shouldBreak: l2 });
          return p2 ? O_(f2) : f2;
        }
        case "value-func":
          return [r2.value, G_(e2, "supports") && TM(r2) ? " " : "", n2("group")];
        case "value-number":
          return [qM(r2.value), q_(r2.unit)];
        case "value-word":
          return r2.isColor && r2.isHex || X_(r2.value) ? r2.value.toLowerCase() : r2.value;
        case "value-colon": {
          const t4 = e2.getParentNode(), n3 = t4 && t4.groups.indexOf(r2), o2 = n3 && t4.groups[n3 - 1];
          return [r2.value, o2 && typeof o2.value == "string" && E_(o2.value) === "\\" || U_(e2, "url") ? "" : w_];
        }
        case "value-string":
          return b_(r2.raws.quote + r2.value + r2.raws.quote, t3);
        case "value-atword":
          return ["@", r2.value];
        default:
          throw new Error("Unknown postcss type ".concat(JSON.stringify(r2.type)));
      }
    }, embed: R_, insertPragma: V_, massageAstNode: M_ };
    var zM = { name: "PostCSS", type: "markup", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 }, GM = { name: "Less", type: "markup", color: "#1d365d", extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 }, HM = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
    const JM = bE, XM = UM, YM = { singleQuote: bj.singleQuote }, KM = [JM({ name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 }, (e2) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...e2.extensions, ".wxss"] })), JM(zM, () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), JM(GM, () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), JM(HM, () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))];
    var QM = { languages: KM, options: YM, printers: { postcss: XM }, parsers: void 0 };
    var ZM = { locStart: function(e2) {
      return e2.loc.start.offset;
    }, locEnd: function(e2) {
      return e2.loc.end.offset;
    } };
    function eR(e2, t3) {
      if (e2.type === "TextNode") {
        const n2 = e2.chars.trim();
        if (!n2)
          return null;
        t3.chars = n2.replace(/[\t\n\f\r ]+/g, " ");
      }
      e2.type === "AttrNode" && e2.name.toLowerCase() === "class" && delete t3.value;
    }
    eR.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]);
    var tR = eR;
    const nR = au;
    const rR = /* @__PURE__ */ new Set(["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"]);
    function oR(e2) {
      return iR(e2, ["TextNode"]) && !/\S/.test(e2.chars);
    }
    function iR(e2, t3) {
      return e2 && t3.includes(e2.type);
    }
    function uR(e2, t3) {
      return iR(e2.getParentNode(0), t3);
    }
    function sR(e2, t3) {
      const n2 = e2.getValue(), r2 = e2.getParentNode(0) || {}, o2 = r2.children || r2.body || r2.parts || [], i2 = o2.indexOf(n2);
      return i2 !== -1 && o2[i2 + t3];
    }
    function aR(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      return sR(e2, -t3);
    }
    function cR(e2) {
      return sR(e2, 1);
    }
    function lR(e2) {
      return iR(e2, ["MustacheCommentStatement"]) && typeof e2.value == "string" && e2.value.trim() === "prettier-ignore";
    }
    var pR = { getNextNode: cR, getPreviousNode: aR, hasPrettierIgnore: function(e2) {
      const t3 = e2.getValue(), n2 = aR(e2, 2);
      return lR(t3) || lR(n2);
    }, isLastNodeOfSiblings: function(e2) {
      const t3 = e2.getValue(), n2 = e2.getParentNode(0);
      return !(!uR(e2, ["ElementNode"]) || nR(n2.children) !== t3) || !(!uR(e2, ["Block"]) || nR(n2.body) !== t3);
    }, isNextNodeOfSomeType: function(e2, t3) {
      return iR(cR(e2), t3);
    }, isNodeOfSomeType: iR, isParentOfSomeType: uR, isPreviousNodeOfSomeType: function(e2, t3) {
      return iR(aR(e2), t3);
    }, isVoid: function(e2) {
      return function(e3) {
        return iR(e3, ["ElementNode"]) && typeof e3.tag == "string" && e3.tag[0] !== ":" && (function(e4) {
          return e4.toUpperCase() === e4;
        }(e3.tag[0]) || e3.tag.includes("."));
      }(e2) && e2.children.every((e3) => oR(e3)) || rR.has(e2.tag);
    }, isWhitespaceNode: oR };
    const { builders: { dedent: fR, fill: dR, group: hR, hardline: gR, ifBreak: mR, indent: yR, join: DR, line: ER, softline: CR }, utils: { getDocParts: bR, replaceTextEndOfLine: vR } } = Zc, { getPreferredQuote: AR, isNonEmptyArray: FR } = dc, { locStart: xR, locEnd: SR } = ZM, wR = tR, { getNextNode: TR, getPreviousNode: BR, hasPrettierIgnore: NR, isLastNodeOfSiblings: kR, isNextNodeOfSomeType: PR, isNodeOfSomeType: OR, isParentOfSomeType: IR, isPreviousNodeOfSomeType: LR, isVoid: jR, isWhitespaceNode: _R } = pR;
    function MR(e2, t3) {
      return xR(e2) - xR(t3);
    }
    function RR(e2, t3, n2) {
      const r2 = e2.getValue().children.every((e3) => _R(e3));
      return t3.htmlWhitespaceSensitivity === "ignore" && r2 ? "" : e2.map((e3, r3) => {
        const o2 = n2();
        return r3 === 0 && t3.htmlWhitespaceSensitivity === "ignore" ? [CR, o2] : o2;
      }, "children");
    }
    function VR(e2) {
      return jR(e2) ? mR([CR, "/>"], [" />", CR]) : mR([CR, ">"], ">");
    }
    function $R(e2) {
      return [e2.escaped === false ? "{{{" : "{{", e2.strip && e2.strip.open ? "~" : ""];
    }
    function WR(e2) {
      const t3 = e2.escaped === false ? "}}}" : "}}";
      return [e2.strip && e2.strip.close ? "~" : "", t3];
    }
    function qR(e2) {
      return [$R(e2), e2.closeStrip.open ? "~" : "", "/"];
    }
    function UR(e2) {
      const t3 = WR(e2);
      return [e2.closeStrip.close ? "~" : "", t3];
    }
    function zR(e2) {
      return [$R(e2), e2.inverseStrip.open ? "~" : ""];
    }
    function GR(e2) {
      const t3 = WR(e2);
      return [e2.inverseStrip.close ? "~" : "", t3];
    }
    function HR(e2, t3) {
      const n2 = e2.getValue(), r2 = function(e3) {
        return [$R(e3), e3.openStrip.open ? "~" : "", "#"];
      }(n2), o2 = function(e3) {
        const t4 = WR(e3);
        return [e3.openStrip.close ? "~" : "", t4];
      }(n2), i2 = [sV(e2, t3)], u2 = aV(e2, t3);
      if (u2 && i2.push(ER, u2), FR(n2.program.blockParams)) {
        const e3 = cV(n2.program);
        i2.push(ER, e3);
      }
      return hR([r2, yR(i2), CR, o2]);
    }
    function JR(e2, t3) {
      return [t3.htmlWhitespaceSensitivity === "ignore" ? gR : "", zR(e2), "else", GR(e2)];
    }
    function XR(e2, t3) {
      const n2 = e2.getParentNode(1);
      return [zR(n2), "else if ", aV(e2, t3), GR(n2)];
    }
    function YR(e2, t3, n2) {
      const r2 = e2.getValue();
      if (n2.htmlWhitespaceSensitivity === "ignore") {
        return [KR(r2) ? CR : gR, qR(r2), t3("path"), UR(r2)];
      }
      return [qR(r2), t3("path"), UR(r2)];
    }
    function KR(e2) {
      return OR(e2, ["BlockStatement"]) && e2.program.body.every((e3) => _R(e3));
    }
    function QR(e2) {
      return OR(e2, ["BlockStatement"]) && e2.inverse;
    }
    function ZR(e2, t3, n2) {
      if (KR(e2.getValue()))
        return "";
      const r2 = t3("program");
      return n2.htmlWhitespaceSensitivity === "ignore" ? yR([gR, r2]) : yR(r2);
    }
    function eV(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = t3("inverse"), i2 = n2.htmlWhitespaceSensitivity === "ignore" ? [gR, o2] : o2;
      return function(e3) {
        return QR(e3) && e3.inverse.body.length === 1 && OR(e3.inverse.body[0], ["BlockStatement"]) && e3.inverse.body[0].path.parts[0] === "if";
      }(r2) ? i2 : QR(r2) ? [JR(r2, n2), yR(i2)] : "";
    }
    function tV(e2) {
      return bR(DR(ER, function(e3) {
        return e3.split(/[\t\n\f\r ]+/);
      }(e2)));
    }
    function nV(e2) {
      return (e2 = typeof e2 == "string" ? e2 : "").split("\n").length - 1;
    }
    function rV() {
      let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return Array.from({ length: Math.min(e2, 2) }).fill(gR);
    }
    function oV(e2, t3) {
      const { quote: n2, regex: r2 } = AR(e2, t3);
      return [n2, e2.replace(r2, "\\".concat(n2)), n2];
    }
    function iV(e2, t3) {
      const n2 = sV(e2, t3), r2 = aV(e2, t3);
      return r2 ? yR([n2, ER, hR(r2)]) : n2;
    }
    function uV(e2, t3) {
      const n2 = sV(e2, t3), r2 = aV(e2, t3);
      return r2 ? [yR([n2, ER, r2]), CR] : n2;
    }
    function sV(e2, t3) {
      return t3("path");
    }
    function aV(e2, t3) {
      const n2 = e2.getValue(), r2 = [];
      if (n2.params.length > 0) {
        const n3 = e2.map(t3, "params");
        r2.push(...n3);
      }
      if (n2.hash && n2.hash.pairs.length > 0) {
        const e3 = t3("hash");
        r2.push(e3);
      }
      return r2.length === 0 ? "" : DR(ER, r2);
    }
    function cV(e2) {
      return ["as |", e2.blockParams.join(" "), "|"];
    }
    var lV = { print: function(e2, t3, n2) {
      const r2 = e2.getValue();
      if (!r2)
        return "";
      if (NR(e2))
        return t3.originalText.slice(xR(r2), SR(r2));
      const o2 = t3.singleQuote ? "'" : '"';
      switch (r2.type) {
        case "Block":
        case "Program":
        case "Template":
          return hR(e2.map(n2, "body"));
        case "ElementNode": {
          const o3 = hR(function(e3, t4) {
            const n3 = e3.getValue(), r3 = ["attributes", "modifiers", "comments"].filter((e4) => FR(n3[e4])), o4 = r3.flatMap((e4) => n3[e4]).sort(MR);
            for (const n4 of r3)
              e3.each((e4) => {
                const n5 = o4.indexOf(e4.getValue());
                o4.splice(n5, 1, [ER, t4()]);
              }, n4);
            FR(n3.blockParams) && o4.push(ER, cV(n3));
            return ["<", n3.tag, yR(o4), VR(n3)];
          }(e2, n2)), i2 = t3.htmlWhitespaceSensitivity === "ignore" && PR(e2, ["ElementNode"]) ? CR : "";
          if (jR(r2))
            return [o3, i2];
          const u2 = ["</", r2.tag, ">"];
          return r2.children.length === 0 ? [o3, yR(u2), i2] : t3.htmlWhitespaceSensitivity === "ignore" ? [o3, yR(RR(e2, t3, n2)), gR, yR(u2), i2] : [o3, yR(hR(RR(e2, t3, n2))), yR(u2), i2];
        }
        case "BlockStatement": {
          const o3 = e2.getParentNode(1);
          return o3 && o3.inverse && o3.inverse.body.length === 1 && o3.inverse.body[0] === r2 && o3.inverse.body[0].path.parts[0] === "if" ? [XR(e2, n2), ZR(e2, n2, t3), eV(e2, n2, t3)] : [HR(e2, n2), hR([ZR(e2, n2, t3), eV(e2, n2, t3), YR(e2, n2, t3)])];
        }
        case "ElementModifierStatement":
          return hR(["{{", uV(e2, n2), "}}"]);
        case "MustacheStatement":
          return hR([$R(r2), uV(e2, n2), WR(r2)]);
        case "SubExpression":
          return hR(["(", iV(e2, n2), CR, ")"]);
        case "AttrNode": {
          const e3 = r2.value.type === "TextNode";
          if (e3 && r2.value.chars === "" && xR(r2.value) === SR(r2.value))
            return r2.name;
          const t4 = e3 ? AR(r2.value.chars, o2).quote : r2.value.type === "ConcatStatement" ? AR(r2.value.parts.filter((e4) => e4.type === "TextNode").map((e4) => e4.chars).join(""), o2).quote : "", i2 = n2("value");
          return [r2.name, "=", t4, r2.name === "class" && t4 ? hR(yR(i2)) : i2, t4];
        }
        case "ConcatStatement":
          return e2.map(n2, "parts");
        case "Hash":
          return DR(ER, e2.map(n2, "pairs"));
        case "HashPair":
          return [r2.key, "=", n2("value")];
        case "TextNode": {
          let n3 = r2.chars.replace(/{{/g, "\\{{");
          const o3 = function(e3) {
            for (let t4 = 0; t4 < 2; t4++) {
              const n4 = e3.getParentNode(t4);
              if (n4 && n4.type === "AttrNode")
                return n4.name.toLowerCase();
            }
          }(e2);
          if (o3) {
            if (o3 === "class") {
              const t4 = n3.trim().split(/\s+/).join(" ");
              let r3 = false, o4 = false;
              return IR(e2, ["ConcatStatement"]) && (LR(e2, ["MustacheStatement"]) && /^\s/.test(n3) && (r3 = true), PR(e2, ["MustacheStatement"]) && /\s$/.test(n3) && t4 !== "" && (o4 = true)), [r3 ? ER : "", t4, o4 ? ER : ""];
            }
            return vR(n3);
          }
          const i2 = /^[\t\n\f\r ]*$/.test(n3), u2 = !BR(e2), s2 = !TR(e2);
          if (t3.htmlWhitespaceSensitivity !== "ignore") {
            const t4 = /^[\t\n\f\r ]*/, r3 = /[\t\n\f\r ]*$/, o4 = s2 && IR(e2, ["Template"]), a3 = u2 && IR(e2, ["Template"]);
            if (i2) {
              if (a3 || o4)
                return "";
              let t5 = [ER];
              const r4 = nV(n3);
              return r4 && (t5 = rV(r4)), kR(e2) && (t5 = t5.map((e3) => fR(e3))), t5;
            }
            const [c3] = n3.match(t4), [l3] = n3.match(r3);
            let p3 = [];
            if (c3) {
              p3 = [ER];
              const e3 = nV(c3);
              e3 && (p3 = rV(e3)), n3 = n3.replace(t4, "");
            }
            let f3 = [];
            if (l3) {
              if (!o4) {
                f3 = [ER];
                const t5 = nV(l3);
                t5 && (f3 = rV(t5)), kR(e2) && (f3 = f3.map((e3) => fR(e3)));
              }
              n3 = n3.replace(r3, "");
            }
            return [...p3, dR(tV(n3)), ...f3];
          }
          const a2 = nV(n3);
          let c2 = function(e3) {
            return nV(((e3 = typeof e3 == "string" ? e3 : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "");
          }(n3), l2 = function(e3) {
            return nV(((e3 = typeof e3 == "string" ? e3 : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "");
          }(n3);
          if ((u2 || s2) && i2 && IR(e2, ["Block", "ElementNode", "Template"]))
            return "";
          i2 && a2 ? (c2 = Math.min(a2, 2), l2 = 0) : (PR(e2, ["BlockStatement", "ElementNode"]) && (l2 = Math.max(l2, 1)), LR(e2, ["BlockStatement", "ElementNode"]) && (c2 = Math.max(c2, 1)));
          let p2 = "", f2 = "";
          return l2 === 0 && PR(e2, ["MustacheStatement"]) && (f2 = " "), c2 === 0 && LR(e2, ["MustacheStatement"]) && (p2 = " "), u2 && (c2 = 0, p2 = ""), s2 && (l2 = 0, f2 = ""), n3 = n3.replace(/^[\t\n\f\r ]+/g, p2).replace(/[\t\n\f\r ]+$/, f2), [...rV(c2), dR(tV(n3)), ...rV(l2)];
        }
        case "MustacheCommentStatement": {
          const e3 = xR(r2), n3 = SR(r2), o3 = t3.originalText.charAt(e3 + 2) === "~", i2 = t3.originalText.charAt(n3 - 3) === "~", u2 = r2.value.includes("}}") ? "--" : "";
          return ["{{", o3 ? "~" : "", "!", u2, r2.value, u2, i2 ? "~" : "", "}}"];
        }
        case "PathExpression":
          return r2.original;
        case "BooleanLiteral":
        case "NumberLiteral":
          return String(r2.value);
        case "CommentStatement":
          return ["<!--", r2.value, "-->"];
        case "StringLiteral":
          if (function(e3) {
            let t4 = 0, n3 = e3.getParentNode(t4);
            for (; n3 && OR(n3, ["SubExpression"]); )
              t4++, n3 = e3.getParentNode(t4);
            if (n3 && OR(e3.getParentNode(t4 + 1), ["ConcatStatement"]) && OR(e3.getParentNode(t4 + 2), ["AttrNode"]))
              return true;
            return false;
          }(e2)) {
            const e3 = t3.singleQuote ? '"' : "'";
            return oV(r2.value, e3);
          }
          return oV(r2.value, o2);
        case "UndefinedLiteral":
          return "undefined";
        case "NullLiteral":
          return "null";
        default:
          throw new Error("unknown glimmer type: " + JSON.stringify(r2.type));
      }
    }, massageAstNode: wR };
    const pV = lV;
    var fV = { languages: [bE({ name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 }, () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], printers: { glimmer: pV }, parsers: void 0 };
    var dV = { hasPragma: function(e2) {
      return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(e2);
    }, insertPragma: function(e2) {
      return "# @format\n\n" + e2;
    } };
    var hV = { locStart: function(e2) {
      return typeof e2.start == "number" ? e2.start : e2.loc && e2.loc.start;
    }, locEnd: function(e2) {
      return typeof e2.end == "number" ? e2.end : e2.loc && e2.loc.end;
    } };
    const { builders: { join: gV, hardline: mV, line: yV, softline: DV, group: EV, indent: CV, ifBreak: bV } } = Zc, { isNextLineEmpty: vV, isNonEmptyArray: AV } = dc, { insertPragma: FV } = dV, { locStart: xV, locEnd: SV } = hV;
    function wV(e2, t3, n2) {
      if (n2.directives.length === 0)
        return "";
      const r2 = gV(yV, e2.map(t3, "directives"));
      return n2.kind === "FragmentDefinition" || n2.kind === "OperationDefinition" ? EV([yV, r2]) : [" ", EV(CV([DV, r2]))];
    }
    function TV(e2, t3, n2) {
      const r2 = e2.getValue().length;
      return e2.map((e3, o2) => {
        const i2 = n2();
        return vV(t3.originalText, e3.getValue(), SV) && o2 < r2 - 1 ? [i2, mV] : i2;
      });
    }
    function BV(e2, t3, n2) {
      const r2 = e2.getNode(), o2 = [], { interfaces: i2 } = r2, u2 = e2.map((e3) => n2(e3), "interfaces");
      for (let e3 = 0; e3 < i2.length; e3++) {
        const n3 = i2[e3];
        o2.push(u2[e3]);
        const r3 = i2[e3 + 1];
        if (r3) {
          const e4 = t3.originalText.slice(n3.loc.end, r3.loc.start), i3 = e4.includes("#"), u3 = e4.replace(/#.*/g, "").trim();
          o2.push(u3 === "," ? "," : " &", i3 ? yV : " ");
        }
      }
      return o2;
    }
    function NV() {
    }
    NV.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
    var kV = { print: function(e2, t3, n2) {
      const r2 = e2.getValue();
      if (!r2)
        return "";
      if (typeof r2 == "string")
        return r2;
      switch (r2.kind) {
        case "Document": {
          const r3 = [];
          return e2.each((e3, o2, i2) => {
            r3.push(n2()), o2 !== i2.length - 1 && (r3.push(mV), vV(t3.originalText, e3.getValue(), SV) && r3.push(mV));
          }, "definitions"), [...r3, mV];
        }
        case "OperationDefinition": {
          const o2 = t3.originalText[xV(r2)] !== "{", i2 = Boolean(r2.name);
          return [o2 ? r2.operation : "", o2 && i2 ? [" ", n2("name")] : "", o2 && !i2 && AV(r2.variableDefinitions) ? " " : "", AV(r2.variableDefinitions) ? EV(["(", CV([DV, gV([bV("", ", "), DV], e2.map(n2, "variableDefinitions"))]), DV, ")"]) : "", wV(e2, n2, r2), r2.selectionSet && (o2 || i2) ? " " : "", n2("selectionSet")];
        }
        case "FragmentDefinition":
          return ["fragment ", n2("name"), AV(r2.variableDefinitions) ? EV(["(", CV([DV, gV([bV("", ", "), DV], e2.map(n2, "variableDefinitions"))]), DV, ")"]) : "", " on ", n2("typeCondition"), wV(e2, n2, r2), " ", n2("selectionSet")];
        case "SelectionSet":
          return ["{", CV([mV, gV(mV, e2.call((e3) => TV(e3, t3, n2), "selections"))]), mV, "}"];
        case "Field":
          return EV([r2.alias ? [n2("alias"), ": "] : "", n2("name"), r2.arguments.length > 0 ? EV(["(", CV([DV, gV([bV("", ", "), DV], e2.call((e3) => TV(e3, t3, n2), "arguments"))]), DV, ")"]) : "", wV(e2, n2, r2), r2.selectionSet ? " " : "", n2("selectionSet")]);
        case "Name":
        case "IntValue":
        case "FloatValue":
        case "EnumValue":
          return r2.value;
        case "StringValue":
          return r2.block ? ['"""', mV, gV(mV, r2.value.replace(/"""/g, "\\$&").split("\n")), mV, '"""'] : ['"', r2.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
        case "BooleanValue":
          return r2.value ? "true" : "false";
        case "NullValue":
          return "null";
        case "Variable":
          return ["$", n2("name")];
        case "ListValue":
          return EV(["[", CV([DV, gV([bV("", ", "), DV], e2.map(n2, "values"))]), DV, "]"]);
        case "ObjectValue":
          return EV(["{", t3.bracketSpacing && r2.fields.length > 0 ? " " : "", CV([DV, gV([bV("", ", "), DV], e2.map(n2, "fields"))]), DV, bV("", t3.bracketSpacing && r2.fields.length > 0 ? " " : ""), "}"]);
        case "ObjectField":
        case "Argument":
          return [n2("name"), ": ", n2("value")];
        case "Directive":
          return ["@", n2("name"), r2.arguments.length > 0 ? EV(["(", CV([DV, gV([bV("", ", "), DV], e2.call((e3) => TV(e3, t3, n2), "arguments"))]), DV, ")"]) : ""];
        case "NamedType":
          return n2("name");
        case "VariableDefinition":
          return [n2("variable"), ": ", n2("type"), r2.defaultValue ? [" = ", n2("defaultValue")] : "", wV(e2, n2, r2)];
        case "ObjectTypeExtension":
        case "ObjectTypeDefinition":
          return [n2("description"), r2.description ? mV : "", r2.kind === "ObjectTypeExtension" ? "extend " : "", "type ", n2("name"), r2.interfaces.length > 0 ? [" implements ", ...BV(e2, t3, n2)] : "", wV(e2, n2, r2), r2.fields.length > 0 ? [" {", CV([mV, gV(mV, e2.call((e3) => TV(e3, t3, n2), "fields"))]), mV, "}"] : ""];
        case "FieldDefinition":
          return [n2("description"), r2.description ? mV : "", n2("name"), r2.arguments.length > 0 ? EV(["(", CV([DV, gV([bV("", ", "), DV], e2.call((e3) => TV(e3, t3, n2), "arguments"))]), DV, ")"]) : "", ": ", n2("type"), wV(e2, n2, r2)];
        case "DirectiveDefinition":
          return [n2("description"), r2.description ? mV : "", "directive ", "@", n2("name"), r2.arguments.length > 0 ? EV(["(", CV([DV, gV([bV("", ", "), DV], e2.call((e3) => TV(e3, t3, n2), "arguments"))]), DV, ")"]) : "", r2.repeatable ? " repeatable" : "", " on ", gV(" | ", e2.map(n2, "locations"))];
        case "EnumTypeExtension":
        case "EnumTypeDefinition":
          return [n2("description"), r2.description ? mV : "", r2.kind === "EnumTypeExtension" ? "extend " : "", "enum ", n2("name"), wV(e2, n2, r2), r2.values.length > 0 ? [" {", CV([mV, gV(mV, e2.call((e3) => TV(e3, t3, n2), "values"))]), mV, "}"] : ""];
        case "EnumValueDefinition":
          return [n2("description"), r2.description ? mV : "", n2("name"), wV(e2, n2, r2)];
        case "InputValueDefinition":
          return [n2("description"), r2.description ? r2.description.block ? mV : yV : "", n2("name"), ": ", n2("type"), r2.defaultValue ? [" = ", n2("defaultValue")] : "", wV(e2, n2, r2)];
        case "InputObjectTypeExtension":
        case "InputObjectTypeDefinition":
          return [n2("description"), r2.description ? mV : "", r2.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", n2("name"), wV(e2, n2, r2), r2.fields.length > 0 ? [" {", CV([mV, gV(mV, e2.call((e3) => TV(e3, t3, n2), "fields"))]), mV, "}"] : ""];
        case "SchemaDefinition":
          return ["schema", wV(e2, n2, r2), " {", r2.operationTypes.length > 0 ? CV([mV, gV(mV, e2.call((e3) => TV(e3, t3, n2), "operationTypes"))]) : "", mV, "}"];
        case "OperationTypeDefinition":
          return [n2("operation"), ": ", n2("type")];
        case "InterfaceTypeExtension":
        case "InterfaceTypeDefinition":
          return [n2("description"), r2.description ? mV : "", r2.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", n2("name"), r2.interfaces.length > 0 ? [" implements ", ...BV(e2, t3, n2)] : "", wV(e2, n2, r2), r2.fields.length > 0 ? [" {", CV([mV, gV(mV, e2.call((e3) => TV(e3, t3, n2), "fields"))]), mV, "}"] : ""];
        case "FragmentSpread":
          return ["...", n2("name"), wV(e2, n2, r2)];
        case "InlineFragment":
          return ["...", r2.typeCondition ? [" on ", n2("typeCondition")] : "", wV(e2, n2, r2), " ", n2("selectionSet")];
        case "UnionTypeExtension":
        case "UnionTypeDefinition":
          return EV([n2("description"), r2.description ? mV : "", EV([r2.kind === "UnionTypeExtension" ? "extend " : "", "union ", n2("name"), wV(e2, n2, r2), r2.types.length > 0 ? [" =", bV("", " "), CV([bV([yV, "  "]), gV([yV, "| "], e2.map(n2, "types"))])] : ""])]);
        case "ScalarTypeExtension":
        case "ScalarTypeDefinition":
          return [n2("description"), r2.description ? mV : "", r2.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", n2("name"), wV(e2, n2, r2)];
        case "NonNullType":
          return [n2("type"), "!"];
        case "ListType":
          return ["[", n2("type"), "]"];
        default:
          throw new Error("unknown graphql type: " + JSON.stringify(r2.kind));
      }
    }, massageAstNode: NV, hasPrettierIgnore: function(e2) {
      const t3 = e2.getValue();
      return t3 && Array.isArray(t3.comments) && t3.comments.some((e3) => e3.value.trim() === "prettier-ignore");
    }, insertPragma: FV, printComment: function(e2) {
      const t3 = e2.getValue();
      if (t3.kind === "Comment")
        return "#" + t3.value.trimEnd();
      throw new Error("Not a comment: " + JSON.stringify(t3));
    }, canAttachComment: function(e2) {
      return e2.kind && e2.kind !== "Comment";
    } };
    const PV = kV, OV = { bracketSpacing: bj.bracketSpacing };
    var IV = { languages: [bE({ name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 }, () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], options: OV, printers: { graphql: PV }, parsers: void 0 };
    var LV = { locStart: function(e2) {
      return e2.position.start.offset;
    }, locEnd: function(e2) {
      return e2.position.end.offset;
    } };
    const { getLast: jV } = dc, { locStart: _V, locEnd: MV } = LV, { cjkPattern: RV, kPattern: VV, punctuationPattern: $V } = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" }, WV = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], qV = [...WV, "tableCell", "paragraph", "heading"], UV = new RegExp(VV), zV = new RegExp($V);
    function GV(e2, t3) {
      const [, n2, r2, o2] = t3.slice(e2.position.start.offset, e2.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
      return { numberText: n2, marker: r2, leadingSpaces: o2 };
    }
    var HV = { mapAst: function(e2, t3) {
      return function e3(n2, r2, o2) {
        const i2 = Object.assign({}, t3(n2, r2, o2));
        return i2.children && (i2.children = i2.children.map((t4, n3) => e3(t4, n3, [i2, ...o2]))), i2;
      }(e2, null, []);
    }, splitText: function(e2, t3) {
      const n2 = "non-cjk", r2 = "cj-letter", o2 = "cjk-punctuation", i2 = [], u2 = (t3.proseWrap === "preserve" ? e2 : e2.replace(new RegExp("(".concat(RV, ")\n(").concat(RV, ")"), "g"), "$1$2")).split(/([\t\n ]+)/);
      for (const [e3, t4] of u2.entries()) {
        if (e3 % 2 == 1) {
          i2.push({ type: "whitespace", value: /\n/.test(t4) ? "\n" : " " });
          continue;
        }
        if ((e3 === 0 || e3 === u2.length - 1) && t4 === "")
          continue;
        const a2 = t4.split(new RegExp("(".concat(RV, ")")));
        for (const [e4, t5] of a2.entries())
          (e4 !== 0 && e4 !== a2.length - 1 || t5 !== "") && (e4 % 2 != 0 ? s2(zV.test(t5) ? { type: "word", value: t5, kind: o2, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: t5, kind: UV.test(t5) ? "k-letter" : r2, hasLeadingPunctuation: false, hasTrailingPunctuation: false }) : t5 !== "" && s2({ type: "word", value: t5, kind: n2, hasLeadingPunctuation: zV.test(t5[0]), hasTrailingPunctuation: zV.test(jV(t5)) }));
      }
      return i2;
      function s2(e3) {
        const t4 = jV(i2);
        var u3, s3;
        t4 && t4.type === "word" && (t4.kind === n2 && e3.kind === r2 && !t4.hasTrailingPunctuation || t4.kind === r2 && e3.kind === n2 && !e3.hasLeadingPunctuation ? i2.push({ type: "whitespace", value: " " }) : (u3 = n2, s3 = o2, t4.kind === u3 && e3.kind === s3 || t4.kind === s3 && e3.kind === u3 || [t4.value, e3.value].some((e4) => /\u3000/.test(e4)) || i2.push({ type: "whitespace", value: "" }))), i2.push(e3);
      }
    }, punctuationPattern: $V, getFencedCodeBlockValue: function(e2, t3) {
      const { value: n2 } = e2;
      return e2.position.end.offset === t3.length && n2.endsWith("\n") && t3.endsWith("\n") ? n2.slice(0, -1) : n2;
    }, getOrderedListItemInfo: GV, hasGitDiffFriendlyOrderedList: function(e2, t3) {
      if (!e2.ordered)
        return false;
      if (e2.children.length < 2)
        return false;
      const n2 = Number(GV(e2.children[0], t3.originalText).numberText), r2 = Number(GV(e2.children[1], t3.originalText).numberText);
      if (n2 === 0 && e2.children.length > 2) {
        const n3 = Number(GV(e2.children[2], t3.originalText).numberText);
        return r2 === 1 && n3 === 1;
      }
      return r2 === 1;
    }, INLINE_NODE_TYPES: WV, INLINE_NODE_WRAPPER_TYPES: qV, isAutolink: function(e2) {
      if (!e2 || e2.type !== "link" || e2.children.length !== 1)
        return false;
      const t3 = e2.children[0];
      return t3 && _V(e2) === _V(t3) && MV(e2) === MV(t3);
    } };
    const { inferParserByLanguage: JV, getMaxContinuousCount: XV } = dc, { builders: { hardline: YV, markAsRoot: KV }, utils: { replaceEndOfLine: QV } } = Zc, ZV = Wj, { getFencedCodeBlockValue: e$ } = HV;
    var t$ = function(e2, t3, n2, r2) {
      const o2 = e2.getValue();
      if (o2.type === "code" && o2.lang !== null) {
        const e3 = JV(o2.lang, r2);
        if (e3) {
          const t4 = r2.__inJsTemplate ? "~" : "`", i2 = t4.repeat(Math.max(3, XV(o2.value, t4) + 1)), u2 = { parser: e3 };
          o2.lang === "tsx" && (u2.filepath = "dummy.tsx");
          const s2 = n2(e$(o2, r2.originalText), u2, { stripTrailingHardline: true });
          return KV([i2, o2.lang, o2.meta ? " " + o2.meta : "", YV, QV(s2), YV, i2]);
        }
      }
      switch (o2.type) {
        case "front-matter":
          return ZV(o2, n2);
        case "importExport":
          return [n2(o2.value, { parser: "babel" }, { stripTrailingHardline: true }), YV];
        case "jsx":
          return n2("<$>".concat(o2.value, "</$>"), { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
      }
      return null;
    };
    const n$ = Hj, r$ = ["format", "prettier"];
    function o$(e2) {
      const t3 = "@(".concat(r$.join("|"), ")"), n2 = new RegExp(["<!--\\s*".concat(t3, "\\s*-->"), "{\\s*\\/\\*\\s*".concat(t3, "\\s*\\*\\/\\s*}"), "<!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*".concat(t3, "[^\\S\n]*($|\n)[\\s\\S]*\n.*-->")].join("|"), "m"), r2 = e2.match(n2);
      return r2 && r2.index === 0;
    }
    var i$ = { startWithPragma: o$, hasPragma: (e2) => o$(n$(e2).content.trimStart()), insertPragma: (e2) => {
      const t3 = n$(e2), n2 = "<!-- @".concat(r$[0], " -->");
      return t3.frontMatter ? "".concat(t3.frontMatter.raw, "\n\n").concat(n2, "\n\n").concat(t3.content) : "".concat(n2, "\n\n").concat(t3.content);
    } };
    const u$ = au, { getOrderedListItemInfo: s$, mapAst: a$, splitText: c$ } = HV, l$ = /^.$/us;
    function p$(e2, t3, n2) {
      return a$(e2, (e3) => {
        if (!e3.children)
          return e3;
        const r2 = e3.children.reduce((e4, r3) => {
          const o2 = u$(e4);
          return o2 && t3(o2, r3) ? e4.splice(-1, 1, n2(o2, r3)) : e4.push(r3), e4;
        }, []);
        return Object.assign(Object.assign({}, e3), {}, { children: r2 });
      });
    }
    var f$ = function(e2, t3) {
      return e2 = function(e3, t4) {
        return a$(e3, (e4) => e4.type === "text" && e4.value !== "*" && e4.value !== "_" && l$.test(e4.value) && e4.position.end.offset - e4.position.start.offset !== e4.value.length ? Object.assign(Object.assign({}, e4), {}, { value: t4.originalText.slice(e4.position.start.offset, e4.position.end.offset) }) : e4);
      }(e2, t3), e2 = function(e3, t4) {
        return a$(e3, (e4, n2, r2) => {
          if (e4.type === "code") {
            const n3 = /^\n?(?: {4,}|\t)/.test(t4.originalText.slice(e4.position.start.offset, e4.position.end.offset));
            if (e4.isIndented = n3, n3)
              for (let e5 = 0; e5 < r2.length; e5++) {
                const t5 = r2[e5];
                if (t5.hasIndentedCodeblock)
                  break;
                t5.type === "list" && (t5.hasIndentedCodeblock = true);
              }
          }
          return e4;
        });
      }(e2 = function(e3) {
        return a$(e3, (e4) => e4.type !== "inlineCode" ? e4 : Object.assign(Object.assign({}, e4), {}, { value: e4.value.replace(/\s+/g, " ") }));
      }(e2 = function(e3) {
        return p$(e3, (e4, t4) => e4.type === "text" && t4.type === "text", (e4, t4) => ({ type: "text", value: e4.value + t4.value, position: { start: e4.position.start, end: t4.position.end } }));
      }(e2)), t3), e2 = function(e3, t4) {
        return a$(e3, (e4, t5, n3) => {
          if (e4.type === "list" && e4.children.length > 0) {
            for (let t6 = 0; t6 < n3.length; t6++) {
              const r3 = n3[t6];
              if (r3.type === "list" && !r3.isAligned)
                return e4.isAligned = false, e4;
            }
            e4.isAligned = r2(e4);
          }
          return e4;
        });
        function n2(e4) {
          return e4.children.length === 0 ? -1 : e4.children[0].position.start.column - 1;
        }
        function r2(e4) {
          if (!e4.ordered)
            return true;
          const [r3, o2] = e4.children;
          if (s$(r3, t4.originalText).leadingSpaces.length > 1)
            return true;
          const i2 = n2(r3);
          if (i2 === -1)
            return false;
          if (e4.children.length === 1)
            return i2 % t4.tabWidth == 0;
          if (i2 !== n2(o2))
            return false;
          if (i2 % t4.tabWidth == 0)
            return true;
          return s$(o2, t4.originalText).leadingSpaces.length > 1;
        }
      }(e2, t3), e2 = function(e3, t4) {
        return a$(e3, (e4, n2, r2) => {
          let [o2] = r2;
          if (e4.type !== "text")
            return e4;
          let { value: i2 } = e4;
          return o2.type === "paragraph" && (n2 === 0 && (i2 = i2.trimStart()), n2 === o2.children.length - 1 && (i2 = i2.trimEnd())), { type: "sentence", position: e4.position, children: c$(i2, t4) };
        });
      }(e2, t3), e2 = function(e3) {
        return p$(e3, (e4, t4) => e4.type === "importExport" && t4.type === "importExport", (e4, t4) => ({ type: "importExport", value: e4.value + "\n\n" + t4.value, position: { start: e4.position.start, end: t4.position.end } }));
      }(e2 = function(e3) {
        return a$(e3, (e4) => e4.type !== "import" && e4.type !== "export" ? e4 : Object.assign(Object.assign({}, e4), {}, { type: "importExport" }));
      }(e2));
    };
    const { isFrontMatterNode: d$ } = dc, { startWithPragma: h$ } = i$, g$ = /* @__PURE__ */ new Set(["position", "raw"]);
    function m$(e2, t3, n2) {
      return e2.type !== "front-matter" && e2.type !== "code" && e2.type !== "yaml" && e2.type !== "import" && e2.type !== "export" && e2.type !== "jsx" || delete t3.value, e2.type === "list" && delete t3.isAligned, e2.type !== "list" && e2.type !== "listItem" || (delete t3.spread, delete t3.loose), e2.type === "text" ? null : (e2.type === "inlineCode" && (t3.value = e2.value.replace(/[\t\n ]+/g, " ")), e2.type === "wikiLink" && (t3.value = e2.value.trim().replace(/[\t\n]+/g, " ")), e2.type !== "definition" && e2.type !== "linkReference" || (t3.label = e2.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), e2.type !== "definition" && e2.type !== "link" && e2.type !== "image" || !e2.title || (t3.title = e2.title.replace(/\\(["')])/g, "$1")), n2 && n2.type === "root" && n2.children.length > 0 && (n2.children[0] === e2 || d$(n2.children[0]) && n2.children[1] === e2) && e2.type === "html" && h$(e2.value) ? null : void 0);
    }
    m$.ignoredProperties = g$;
    var y$ = m$;
    const { getLast: D$, getMinNotPresentContinuousCount: E$, getMaxContinuousCount: C$, getStringWidth: b$, isNonEmptyArray: v$ } = dc, { builders: { breakParent: A$, join: F$, line: x$, literalline: S$, markAsRoot: w$, hardline: T$, softline: B$, ifBreak: N$, fill: k$, align: P$, indent: O$, group: I$, hardlineWithoutBreakParent: L$ }, utils: { normalizeDoc: j$, replaceTextEndOfLine: _$ }, printer: { printDocToString: M$ } } = Zc, R$ = t$, { insertPragma: V$ } = i$, { locStart: $$, locEnd: W$ } = LV, q$ = f$, U$ = y$, { getFencedCodeBlockValue: z$, hasGitDiffFriendlyOrderedList: G$, splitText: H$, punctuationPattern: J$, INLINE_NODE_TYPES: X$, INLINE_NODE_WRAPPER_TYPES: Y$, isAutolink: K$ } = HV, Q$ = /* @__PURE__ */ new Set(["importExport"]), Z$ = ["heading", "tableCell", "link", "wikiLink"], eW = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
    function tW(e2, t3, n2, r2) {
      const o2 = e2.getValue(), i2 = o2.checked === null ? "" : o2.checked ? "[x] " : "[ ] ";
      return [i2, sW(e2, t3, n2, { processor: (e3, o3) => {
        if (o3 === 0 && e3.getValue().type !== "list")
          return P$(" ".repeat(i2.length), n2());
        const u2 = " ".repeat(function(e4, t4, n3) {
          return e4 < t4 ? t4 : e4 > n3 ? n3 : e4;
        }(t3.tabWidth - r2.length, 0, 3));
        return [u2, P$(u2, n2())];
      } })];
    }
    function nW(e2, t3) {
      return function(e3, t4, n2) {
        let r2 = -1;
        for (const o2 of t4.children)
          if (o2.type === e3.type && n2(o2) ? r2++ : r2 = -1, o2 === e3)
            return r2;
      }(e2, t3, (t4) => t4.ordered === e2.ordered);
    }
    function rW(e2, t3) {
      const n2 = Array.isArray(t3) ? t3 : [t3];
      let r2, o2 = -1;
      for (; r2 = e2.getParentNode(++o2); )
        if (n2.includes(r2.type))
          return o2;
      return -1;
    }
    function oW(e2, t3) {
      const n2 = rW(e2, t3);
      return n2 === -1 ? null : e2.getParentNode(n2);
    }
    function iW(e2, t3, n2) {
      if (n2.proseWrap === "preserve" && t3 === "\n")
        return T$;
      const r2 = n2.proseWrap === "always" && !oW(e2, Z$);
      return t3 !== "" ? r2 ? x$ : " " : r2 ? B$ : "";
    }
    function uW(e2, t3, n2) {
      const r2 = [];
      let o2 = null;
      const { children: i2 } = e2.getValue();
      for (const [e3, t4] of i2.entries())
        switch (cW(t4)) {
          case "start":
            o2 === null && (o2 = { index: e3, offset: t4.position.end.offset });
            break;
          case "end":
            o2 !== null && (r2.push({ start: o2, end: { index: e3, offset: t4.position.start.offset } }), o2 = null);
        }
      return sW(e2, t3, n2, { processor: (e3, o3) => {
        if (r2.length > 0) {
          const e4 = r2[0];
          if (o3 === e4.start.index)
            return [i2[e4.start.index].value, t3.originalText.slice(e4.start.offset, e4.end.offset), i2[e4.end.index].value];
          if (e4.start.index < o3 && o3 < e4.end.index)
            return false;
          if (o3 === e4.end.index)
            return r2.shift(), false;
        }
        return n2();
      } });
    }
    function sW(e2, t3, n2) {
      let r2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const { postprocessor: o2 } = r2, i2 = r2.processor || (() => n2()), u2 = e2.getValue(), s2 = [];
      let a2;
      return e2.each((e3, n3) => {
        const r3 = e3.getValue(), o3 = i2(e3, n3);
        if (o3 !== false) {
          const e4 = { parts: s2, prevNode: a2, parentNode: u2, options: t3 };
          lW(r3, e4) && (s2.push(T$), a2 && Q$.has(a2.type) || (pW(r3, e4) || fW(r3, e4)) && s2.push(T$), fW(r3, e4) && s2.push(T$)), s2.push(o3), a2 = r3;
        }
      }, "children"), o2 ? o2(s2) : s2;
    }
    function aW(e2) {
      let t3 = e2;
      for (; v$(t3.children); )
        t3 = D$(t3.children);
      return t3;
    }
    function cW(e2) {
      let t3;
      if (e2.type === "html")
        t3 = e2.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
      else {
        let n2;
        e2.type === "esComment" ? n2 = e2 : e2.type === "paragraph" && e2.children.length === 1 && e2.children[0].type === "esComment" && (n2 = e2.children[0]), n2 && (t3 = n2.value.match(/^prettier-ignore(?:-(start|end))?$/));
      }
      return !!t3 && (t3[1] ? t3[1] : "next");
    }
    function lW(e2, t3) {
      const n2 = t3.parts.length === 0, r2 = X$.includes(e2.type), o2 = e2.type === "html" && Y$.includes(t3.parentNode.type);
      return !n2 && !r2 && !o2;
    }
    function pW(e2, t3) {
      const n2 = (t3.prevNode && t3.prevNode.type) === e2.type && eW.has(e2.type), r2 = t3.parentNode.type === "listItem" && !t3.parentNode.loose, o2 = t3.prevNode && t3.prevNode.type === "listItem" && t3.prevNode.loose, i2 = cW(t3.prevNode) === "next", u2 = e2.type === "html" && t3.prevNode && t3.prevNode.type === "html" && t3.prevNode.position.end.line + 1 === e2.position.start.line, s2 = e2.type === "html" && t3.parentNode.type === "listItem" && t3.prevNode && t3.prevNode.type === "paragraph" && t3.prevNode.position.end.line + 1 === e2.position.start.line;
      return o2 || !(n2 || r2 || i2 || u2 || s2);
    }
    function fW(e2, t3) {
      const n2 = t3.prevNode && t3.prevNode.type === "list", r2 = e2.type === "code" && e2.isIndented;
      return n2 && r2;
    }
    function dW(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      const n2 = [" ", ...Array.isArray(t3) ? t3 : [t3]];
      return new RegExp(n2.map((e3) => "\\".concat(e3)).join("|")).test(e2) ? "<".concat(e2, ">") : e2;
    }
    function hW(e2, t3) {
      let n2 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
      if (!e2)
        return "";
      if (n2)
        return " " + hW(e2, t3, false);
      if ((e2 = e2.replace(/\\(["')])/g, "$1")).includes('"') && e2.includes("'") && !e2.includes(")"))
        return "(".concat(e2, ")");
      const r2 = e2.split("'").length - 1, o2 = e2.split('"').length - 1, i2 = r2 > o2 ? '"' : o2 > r2 || t3.singleQuote ? "'" : '"';
      return e2 = (e2 = e2.replace(/\\/, "\\\\")).replace(new RegExp("(".concat(i2, ")"), "g"), "\\$1"), "".concat(i2).concat(e2).concat(i2);
    }
    var gW = { preprocess: q$, print: function(e2, t3, n2) {
      const r2 = e2.getValue();
      if (function(e3) {
        const t4 = oW(e3, ["linkReference", "imageReference"]);
        return t4 && (t4.type !== "linkReference" || t4.referenceType !== "full");
      }(e2))
        return H$(t3.originalText.slice(r2.position.start.offset, r2.position.end.offset), t3).map((n3) => n3.type === "word" ? n3.value : n3.value === "" ? "" : iW(e2, n3.value, t3));
      switch (r2.type) {
        case "front-matter":
          return t3.originalText.slice(r2.position.start.offset, r2.position.end.offset);
        case "root":
          return r2.children.length === 0 ? "" : [j$(uW(e2, t3, n2)), Q$.has(aW(r2).type) ? "" : T$];
        case "paragraph":
          return sW(e2, t3, n2, { postprocessor: k$ });
        case "sentence":
          return sW(e2, t3, n2);
        case "word": {
          let t4 = r2.value.replace(/\*/g, "\\$&").replace(new RegExp(["(^|".concat(J$, ")(_+)"), "(_+)(".concat(J$, "|$)")].join("|"), "g"), (e3, t5, n4, r3, o3) => (n4 ? "".concat(t5).concat(n4) : "".concat(r3).concat(o3)).replace(/_/g, "\\_"));
          const n3 = (e3, t5, n4) => e3.type === "sentence" && n4 === 0, o2 = (e3, t5, n4) => K$(e3.children[n4 - 1]);
          return t4 !== r2.value && (e2.match(void 0, n3, o2) || e2.match(void 0, n3, (e3, t5, n4) => e3.type === "emphasis" && n4 === 0, o2)) && (t4 = t4.replace(/^(\\?[*_])+/, (e3) => e3.replace(/\\/g, ""))), t4;
        }
        case "whitespace": {
          const n3 = e2.getParentNode(), o2 = n3.children.indexOf(r2), i2 = n3.children[o2 + 1], u2 = i2 && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(i2.value) ? "never" : t3.proseWrap;
          return iW(e2, r2.value, { proseWrap: u2 });
        }
        case "emphasis": {
          let o2;
          if (K$(r2.children[0]))
            o2 = t3.originalText[r2.position.start.offset];
          else {
            const t4 = e2.getParentNode(), n3 = t4.children.indexOf(r2), i2 = t4.children[n3 - 1], u2 = t4.children[n3 + 1];
            o2 = i2 && i2.type === "sentence" && i2.children.length > 0 && D$(i2.children).type === "word" && !D$(i2.children).hasTrailingPunctuation || u2 && u2.type === "sentence" && u2.children.length > 0 && u2.children[0].type === "word" && !u2.children[0].hasLeadingPunctuation || oW(e2, "emphasis") ? "*" : "_";
          }
          return [o2, sW(e2, t3, n2), o2];
        }
        case "strong":
          return ["**", sW(e2, t3, n2), "**"];
        case "delete":
          return ["~~", sW(e2, t3, n2), "~~"];
        case "inlineCode": {
          const e3 = E$(r2.value, "`"), t4 = "`".repeat(e3 || 1), n3 = e3 && !/^\s/.test(r2.value) ? " " : "";
          return [t4, n3, r2.value, n3, t4];
        }
        case "wikiLink": {
          let e3 = "";
          return e3 = t3.proseWrap === "preserve" ? r2.value : r2.value.replace(/[\t\n]+/g, " "), ["[[", e3, "]]"];
        }
        case "link":
          switch (t3.originalText[r2.position.start.offset]) {
            case "<": {
              const e3 = "mailto:";
              return ["<", r2.url.startsWith(e3) && t3.originalText.slice(r2.position.start.offset + 1, r2.position.start.offset + 1 + e3.length) !== e3 ? r2.url.slice(e3.length) : r2.url, ">"];
            }
            case "[":
              return ["[", sW(e2, t3, n2), "](", dW(r2.url, ")"), hW(r2.title, t3), ")"];
            default:
              return t3.originalText.slice(r2.position.start.offset, r2.position.end.offset);
          }
        case "image":
          return ["![", r2.alt || "", "](", dW(r2.url, ")"), hW(r2.title, t3), ")"];
        case "blockquote":
          return ["> ", P$("> ", sW(e2, t3, n2))];
        case "heading":
          return ["#".repeat(r2.depth) + " ", sW(e2, t3, n2)];
        case "code": {
          if (r2.isIndented) {
            const e4 = " ".repeat(4);
            return P$(e4, [e4, ..._$(r2.value, T$)]);
          }
          const e3 = t3.__inJsTemplate ? "~" : "`", n3 = e3.repeat(Math.max(3, C$(r2.value, e3) + 1));
          return [n3, r2.lang || "", r2.meta ? " " + r2.meta : "", T$, ..._$(z$(r2, t3.originalText), T$), T$, n3];
        }
        case "html": {
          const t4 = e2.getParentNode(), n3 = t4.type === "root" && D$(t4.children) === r2 ? r2.value.trimEnd() : r2.value, o2 = /^<!--.*-->$/s.test(n3);
          return _$(n3, o2 ? T$ : w$(S$));
        }
        case "list": {
          const o2 = nW(r2, e2.getParentNode()), i2 = G$(r2, t3);
          return sW(e2, t3, n2, { processor: (e3, u2) => {
            const s2 = function() {
              const e4 = r2.ordered ? (u2 === 0 ? r2.start : i2 ? 1 : r2.start + u2) + (o2 % 2 == 0 ? ". " : ") ") : o2 % 2 == 0 ? "- " : "* ";
              return r2.isAligned || r2.hasIndentedCodeblock ? function(e5, t4) {
                const n3 = r3();
                return e5 + " ".repeat(n3 >= 4 ? 0 : n3);
                function r3() {
                  const n4 = e5.length % t4.tabWidth;
                  return n4 === 0 ? 0 : t4.tabWidth - n4;
                }
              }(e4, t3) : e4;
            }(), a2 = e3.getValue();
            return a2.children.length === 2 && a2.children[1].type === "html" && a2.children[0].position.start.column !== a2.children[1].position.start.column ? [s2, tW(e3, t3, n2, s2)] : [s2, P$(" ".repeat(s2.length), tW(e3, t3, n2, s2))];
          } });
        }
        case "thematicBreak": {
          const t4 = rW(e2, "list");
          if (t4 === -1)
            return "---";
          return nW(e2.getParentNode(t4), e2.getParentNode(t4 + 1)) % 2 == 0 ? "***" : "---";
        }
        case "linkReference":
          return ["[", sW(e2, t3, n2), "]", r2.referenceType === "full" ? ["[", r2.identifier, "]"] : r2.referenceType === "collapsed" ? "[]" : ""];
        case "imageReference":
          return r2.referenceType === "full" ? ["![", r2.alt || "", "][", r2.identifier, "]"] : ["![", r2.alt, "]", r2.referenceType === "collapsed" ? "[]" : ""];
        case "definition": {
          const e3 = t3.proseWrap === "always" ? x$ : " ";
          return I$(["[", r2.identifier, "]:", O$([e3, dW(r2.url), r2.title === null ? "" : [e3, hW(r2.title, t3, false)]])]);
        }
        case "footnote":
          return ["[^", sW(e2, t3, n2), "]"];
        case "footnoteReference":
          return ["[^", r2.identifier, "]"];
        case "footnoteDefinition": {
          const o2 = e2.getParentNode().children[e2.getName() + 1], i2 = r2.children.length === 1 && r2.children[0].type === "paragraph" && (t3.proseWrap === "never" || t3.proseWrap === "preserve" && r2.children[0].position.start.line === r2.children[0].position.end.line);
          return ["[^", r2.identifier, "]: ", i2 ? sW(e2, t3, n2) : I$([P$(" ".repeat(4), sW(e2, t3, n2, { processor: (e3, t4) => t4 === 0 ? I$([B$, n2()]) : n2() })), o2 && o2.type === "footnoteDefinition" ? B$ : ""])];
        }
        case "table":
          return function(e3, t4, n3) {
            const r3 = e3.getValue(), o2 = [], i2 = e3.map((e4) => e4.map((e5, r4) => {
              const i3 = M$(n3(), t4).formatted, u3 = b$(i3);
              return o2[r4] = Math.max(o2[r4] || 3, u3), { text: i3, width: u3 };
            }, "children"), "children"), u2 = a2(false);
            if (t4.proseWrap !== "never")
              return [A$, u2];
            const s2 = a2(true);
            return [A$, I$(N$(s2, u2))];
            function a2(e4) {
              const t5 = [l2(i2[0], e4), c2(e4)];
              return i2.length > 1 && t5.push(F$(L$, i2.slice(1).map((t6) => l2(t6, e4)))), F$(L$, t5);
            }
            function c2(e4) {
              const t5 = o2.map((t6, n4) => {
                const o3 = r3.align[n4], i3 = o3 === "center" || o3 === "left" ? ":" : "-", u3 = o3 === "center" || o3 === "right" ? ":" : "-", s3 = e4 ? "-" : "-".repeat(t6 - 2);
                return "".concat(i3).concat(s3).concat(u3);
              });
              return "| ".concat(t5.join(" | "), " |");
            }
            function l2(e4, t5) {
              const n4 = e4.map((e5, n5) => {
                let { text: i3, width: u3 } = e5;
                if (t5)
                  return i3;
                const s3 = o2[n5] - u3, a3 = r3.align[n5];
                let c3 = 0;
                a3 === "right" ? c3 = s3 : a3 === "center" && (c3 = Math.floor(s3 / 2));
                const l3 = s3 - c3;
                return "".concat(" ".repeat(c3)).concat(i3).concat(" ".repeat(l3));
              });
              return "| ".concat(n4.join(" | "), " |");
            }
          }(e2, t3, n2);
        case "tableCell":
          return sW(e2, t3, n2);
        case "break":
          return /\s/.test(t3.originalText[r2.position.start.offset]) ? ["  ", w$(S$)] : ["\\", T$];
        case "liquidNode":
          return _$(r2.value, T$);
        case "importExport":
          return [r2.value, T$];
        case "esComment":
          return ["{/* ", r2.value, " */}"];
        case "jsx":
          return r2.value;
        case "math":
          return ["$$", T$, r2.value ? [..._$(r2.value, T$), T$] : "", "$$"];
        case "inlineMath":
          return t3.originalText.slice($$(r2), W$(r2));
        default:
          throw new Error("Unknown markdown type ".concat(JSON.stringify(r2.type)));
      }
    }, embed: R$, massageAstNode: U$, hasPrettierIgnore: function(e2) {
      const t3 = Number(e2.getName());
      return t3 !== 0 && cW(e2.getParentNode().children[t3 - 1]) === "next";
    }, insertPragma: V$ };
    var mW = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
    const yW = bE, DW = gW, EW = { proseWrap: bj.proseWrap, singleQuote: bj.singleQuote }, CW = [yW(mW, (e2) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...e2.filenames, "README"], extensions: e2.extensions.filter((e3) => e3 !== ".mdx") })), yW(mW, () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))];
    var bW = { languages: CW, options: EW, printers: { mdast: DW }, parsers: void 0 };
    const { isFrontMatterNode: vW } = dc, AW = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
    function FW(e2, t3) {
      return e2.type === "text" || e2.type === "comment" || vW(e2) || e2.type === "yaml" || e2.type === "toml" ? null : (e2.type === "attribute" && delete t3.value, void (e2.type === "docType" && delete t3.value));
    }
    FW.ignoredProperties = AW;
    var xW = FW;
    const SW = ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"], wW = { "*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], abbr: ["title"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], bdo: ["dir"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dfn: ["title"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["accesskey", "for", "form"], legend: ["accesskey", "align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], select: ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], slot: ["name"], source: ["media", "sizes", "src", "srcset", "type"], style: ["media", "nonce", "title", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"] }, { inferParserByLanguage: TW, isFrontMatterNode: BW } = dc, { builders: { line: NW, hardline: kW, join: PW }, utils: { getDocParts: OW, replaceTextEndOfLine: IW } } = Zc, { CSS_DISPLAY_TAGS: LW, CSS_DISPLAY_DEFAULT: jW, CSS_WHITE_SPACE_TAGS: _W, CSS_WHITE_SPACE_DEFAULT: MW } = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" }, RW = GW(SW), VW = function(e2, t3) {
      const n2 = /* @__PURE__ */ Object.create(null);
      for (const [r2, o2] of Object.entries(e2))
        n2[r2] = t3(o2, r2);
      return n2;
    }(wW, GW), $W = /* @__PURE__ */ new Set(["	", "\n", "\f", "\r", " "]), WW = (e2) => e2.replace(/[\t\n\f\r ]+$/, ""), qW = (e2) => ((e3) => e3.replace(/^[\t\f\r ]*?\n/g, ""))(WW(e2)), UW = (e2) => e2.split(/[\t\n\f\r ]+/), zW = (e2) => e2.match(/^[\t\n\f\r ]*/)[0];
    function GW(e2) {
      const t3 = /* @__PURE__ */ Object.create(null);
      for (const n2 of e2)
        t3[n2] = true;
      return t3;
    }
    function HW(e2) {
      return e2.type === "element" && (e2.fullName === "script" || e2.fullName === "style" || e2.fullName === "svg:style" || oq(e2) && (e2.name === "script" || e2.name === "style"));
    }
    function JW(e2) {
      return iq(e2).startsWith("pre");
    }
    function XW(e2) {
      return e2.type === "element" && e2.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e2.name) || e2.cssDisplay.startsWith("table") && e2.cssDisplay !== "table-cell");
    }
    function YW(e2) {
      return eq(e2) || e2.type === "element" && e2.fullName === "br" || KW(e2);
    }
    function KW(e2) {
      return QW(e2) && ZW(e2);
    }
    function QW(e2) {
      return e2.hasLeadingSpaces && (e2.prev ? e2.prev.sourceSpan.end.line < e2.sourceSpan.start.line : e2.parent.type === "root" || e2.parent.startSourceSpan.end.line < e2.sourceSpan.start.line);
    }
    function ZW(e2) {
      return e2.hasTrailingSpaces && (e2.next ? e2.next.sourceSpan.start.line > e2.sourceSpan.end.line : e2.parent.type === "root" || e2.parent.endSourceSpan && e2.parent.endSourceSpan.start.line > e2.sourceSpan.end.line);
    }
    function eq(e2) {
      switch (e2.type) {
        case "ieConditionalComment":
        case "comment":
        case "directive":
          return true;
        case "element":
          return ["script", "select"].includes(e2.name);
      }
      return false;
    }
    function tq(e2) {
      const { type: t3, lang: n2 } = e2.attrMap;
      return t3 === "module" || t3 === "text/javascript" || t3 === "text/babel" || t3 === "application/javascript" || n2 === "jsx" ? "babel" : t3 === "application/x-typescript" || n2 === "ts" || n2 === "tsx" ? "typescript" : t3 === "text/markdown" ? "markdown" : t3 === "text/html" ? "html" : t3 && (t3.endsWith("json") || t3.endsWith("importmap")) ? "json" : t3 === "text/x-handlebars-template" ? "glimmer" : void 0;
    }
    function nq(e2) {
      return e2 === "block" || e2 === "list-item" || e2.startsWith("table");
    }
    function rq(e2) {
      return iq(e2).startsWith("pre");
    }
    function oq(e2) {
      return e2.type === "element" && !e2.hasExplicitNamespace && !["html", "svg"].includes(e2.namespace);
    }
    function iq(e2) {
      return e2.type === "element" && (!e2.namespace || oq(e2)) && _W[e2.name] || MW;
    }
    function uq(e2) {
      let t3 = Number.POSITIVE_INFINITY;
      for (const n2 of e2.split("\n")) {
        if (n2.length === 0)
          continue;
        if (!$W.has(n2[0]))
          return 0;
        const e3 = zW(n2).length;
        n2.length !== e3 && (e3 < t3 && (t3 = e3));
      }
      return t3 === Number.POSITIVE_INFINITY ? 0 : t3;
    }
    function sq(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : uq(e2);
      return t3 === 0 ? e2 : e2.split("\n").map((e3) => e3.slice(t3)).join("\n");
    }
    const aq = /* @__PURE__ */ new Set(["template", "style", "script"]);
    function cq(e2, t3) {
      return lq(e2, t3) && !aq.has(e2.fullName);
    }
    function lq(e2, t3) {
      return t3.parser === "vue" && e2.type === "element" && e2.parent.type === "root" && e2.fullName.toLowerCase() !== "html";
    }
    function pq(e2, t3) {
      return lq(e2, t3) && (cq(e2, t3) || e2.attrMap.lang && e2.attrMap.lang !== "html");
    }
    var fq = { HTML_ELEMENT_ATTRIBUTES: VW, HTML_TAGS: RW, htmlTrim: (e2) => ((e3) => e3.replace(/^[\t\n\f\r ]+/, ""))(WW(e2)), htmlTrimPreserveIndentation: qW, hasHtmlWhitespace: (e2) => /[\t\n\f\r ]/.test(e2), getLeadingAndTrailingHtmlWhitespace: (e2) => {
      const [, t3, n2, r2] = e2.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
      return { leadingWhitespace: t3, trailingWhitespace: r2, text: n2 };
    }, canHaveInterpolation: function(e2) {
      return e2.children && !HW(e2);
    }, countChars: function(e2, t3) {
      let n2 = 0;
      for (let r2 = 0; r2 < e2.length; r2++)
        e2[r2] === t3 && n2++;
      return n2;
    }, countParents: function(e2, t3) {
      let n2 = 0;
      for (let r2 = e2.stack.length - 1; r2 >= 0; r2--) {
        const o2 = e2.stack[r2];
        o2 && typeof o2 == "object" && !Array.isArray(o2) && t3(o2) && n2++;
      }
      return n2;
    }, dedentString: sq, forceBreakChildren: XW, forceBreakContent: function(e2) {
      return XW(e2) || e2.type === "element" && e2.children.length > 0 && (["body", "script", "style"].includes(e2.name) || e2.children.some((e3) => function(e4) {
        return e4.children && e4.children.some((e5) => e5.type !== "text");
      }(e3))) || e2.firstChild && e2.firstChild === e2.lastChild && e2.firstChild.type !== "text" && QW(e2.firstChild) && (!e2.lastChild.isTrailingSpaceSensitive || ZW(e2.lastChild));
    }, forceNextEmptyLine: function(e2) {
      return BW(e2) || e2.next && e2.sourceSpan.end && e2.sourceSpan.end.line + 1 < e2.next.sourceSpan.start.line;
    }, getLastDescendant: function e2(t3) {
      return t3.lastChild ? e2(t3.lastChild) : t3;
    }, getNodeCssStyleDisplay: function(e2, t3) {
      if (e2.prev && e2.prev.type === "comment") {
        const t4 = e2.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
        if (t4)
          return t4[1];
      }
      let n2 = false;
      if (e2.type === "element" && e2.namespace === "svg") {
        if (!function(e3, t4) {
          let n3 = e3;
          for (; n3; ) {
            if (t4(n3))
              return true;
            n3 = n3.parent;
          }
          return false;
        }(e2, (e3) => e3.fullName === "svg:foreignObject"))
          return e2.name === "svg" ? "inline-block" : "block";
        n2 = true;
      }
      switch (t3.htmlWhitespaceSensitivity) {
        case "strict":
          return "inline";
        case "ignore":
          return "block";
        default:
          return t3.parser === "vue" && e2.parent && e2.parent.type === "root" ? "block" : e2.type === "element" && (!e2.namespace || n2 || oq(e2)) && LW[e2.name] || jW;
      }
    }, getNodeCssStyleWhiteSpace: iq, hasPrettierIgnore: function(e2) {
      return e2.type !== "attribute" && (!!e2.parent && (typeof e2.index == "number" && e2.index !== 0 && function(e3) {
        return e3.type === "comment" && e3.value.trim() === "prettier-ignore";
      }(e2.parent.children[e2.index - 1])));
    }, inferScriptParser: function(e2, t3) {
      return e2.name !== "script" || e2.attrMap.src ? e2.name === "style" ? function(e3) {
        const { lang: t4 } = e3.attrMap;
        return t4 && t4 !== "postcss" && t4 !== "css" ? t4 === "scss" ? "scss" : t4 === "less" ? "less" : void 0 : "css";
      }(e2) : t3 && pq(e2, t3) ? tq(e2) || !("src" in e2.attrMap) && TW(e2.attrMap.lang, t3) : void 0 : e2.attrMap.lang || e2.attrMap.type ? tq(e2) : "babel";
    }, isVueCustomBlock: cq, isVueNonHtmlBlock: pq, isVueSlotAttribute: function(e2) {
      const t3 = e2.fullName;
      return t3.charAt(0) === "#" || t3 === "slot-scope" || t3 === "v-slot" || t3.startsWith("v-slot:");
    }, isVueSfcBindingsAttribute: function(e2, t3) {
      const n2 = e2.parent;
      if (!lq(n2, t3))
        return false;
      const r2 = n2.fullName, o2 = e2.fullName;
      return r2 === "script" && o2 === "setup" || r2 === "style" && o2 === "vars";
    }, isDanglingSpaceSensitiveNode: function(e2) {
      return !(t3 = e2.cssDisplay, nq(t3) || t3 === "inline-block" || HW(e2));
      var t3;
    }, isIndentationSensitiveNode: JW, isLeadingSpaceSensitiveNode: function(e2, t3) {
      const n2 = function() {
        if (BW(e2))
          return false;
        if ((e2.type === "text" || e2.type === "interpolation") && e2.prev && (e2.prev.type === "text" || e2.prev.type === "interpolation"))
          return true;
        if (!e2.parent || e2.parent.cssDisplay === "none")
          return false;
        if (rq(e2.parent))
          return true;
        if (!e2.prev && (e2.parent.type === "root" || rq(e2) && e2.parent || HW(e2.parent) || cq(e2.parent, t3) || (n3 = e2.parent.cssDisplay, nq(n3) || n3 === "inline-block")))
          return false;
        var n3;
        if (e2.prev && !function(e3) {
          return !nq(e3);
        }(e2.prev.cssDisplay))
          return false;
        return true;
      }();
      return n2 && !e2.prev && e2.parent && e2.parent.tagDefinition && e2.parent.tagDefinition.ignoreFirstLf ? e2.type === "interpolation" : n2;
    }, isPreLikeNode: rq, isScriptLikeTag: HW, isTextLikeNode: function(e2) {
      return e2.type === "text" || e2.type === "comment";
    }, isTrailingSpaceSensitiveNode: function(e2, t3) {
      return !BW(e2) && (!(e2.type !== "text" && e2.type !== "interpolation" || !e2.next || e2.next.type !== "text" && e2.next.type !== "interpolation") || !(!e2.parent || e2.parent.cssDisplay === "none") && (!!rq(e2.parent) || !(!e2.next && (e2.parent.type === "root" || rq(e2) && e2.parent || HW(e2.parent) || cq(e2.parent, t3) || (n2 = e2.parent.cssDisplay, nq(n2) || n2 === "inline-block"))) && !(e2.next && !function(e3) {
        return !nq(e3);
      }(e2.next.cssDisplay))));
      var n2;
    }, isWhitespaceSensitiveNode: function(e2) {
      return HW(e2) || e2.type === "interpolation" || JW(e2);
    }, isUnknownNamespace: oq, preferHardlineAsLeadingSpaces: function(e2) {
      return eq(e2) || e2.prev && YW(e2.prev) || KW(e2);
    }, preferHardlineAsTrailingSpaces: YW, shouldPreserveContent: function(e2, t3) {
      return !(e2.type !== "ieConditionalComment" || !e2.lastChild || e2.lastChild.isSelfClosing || e2.lastChild.endSourceSpan) || (e2.type === "ieConditionalComment" && !e2.complete || (!(!rq(e2) || !e2.children.some((e3) => e3.type !== "text" && e3.type !== "interpolation")) || !(!pq(e2, t3) || HW(e2) || e2.type === "interpolation")));
    }, unescapeQuoteEntities: function(e2) {
      return e2.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
    }, getTextValueParts: function(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e2.value;
      return e2.parent.isWhitespaceSensitive ? e2.parent.isIndentationSensitive ? IW(t3) : IW(sq(qW(t3)), kW) : OW(PW(NW, UW(t3)));
    } }, dq = {}, hq = {};
    !function(e2) {
      function t3(t4) {
        return e2.$0 <= t4 && t4 <= e2.$9;
      }
      /**
      	   * @license
      	   * Copyright Google Inc. All Rights Reserved.
      	   *
      	   * Use of this source code is governed by an MIT-style license that can be
      	   * found in the LICENSE file at https://angular.io/license
      	   */
      Object.defineProperty(e2, "__esModule", { value: true }), e2.$EOF = 0, e2.$BSPACE = 8, e2.$TAB = 9, e2.$LF = 10, e2.$VTAB = 11, e2.$FF = 12, e2.$CR = 13, e2.$SPACE = 32, e2.$BANG = 33, e2.$DQ = 34, e2.$HASH = 35, e2.$$ = 36, e2.$PERCENT = 37, e2.$AMPERSAND = 38, e2.$SQ = 39, e2.$LPAREN = 40, e2.$RPAREN = 41, e2.$STAR = 42, e2.$PLUS = 43, e2.$COMMA = 44, e2.$MINUS = 45, e2.$PERIOD = 46, e2.$SLASH = 47, e2.$COLON = 58, e2.$SEMICOLON = 59, e2.$LT = 60, e2.$EQ = 61, e2.$GT = 62, e2.$QUESTION = 63, e2.$0 = 48, e2.$7 = 55, e2.$9 = 57, e2.$A = 65, e2.$E = 69, e2.$F = 70, e2.$X = 88, e2.$Z = 90, e2.$LBRACKET = 91, e2.$BACKSLASH = 92, e2.$RBRACKET = 93, e2.$CARET = 94, e2.$_ = 95, e2.$a = 97, e2.$b = 98, e2.$e = 101, e2.$f = 102, e2.$n = 110, e2.$r = 114, e2.$t = 116, e2.$u = 117, e2.$v = 118, e2.$x = 120, e2.$z = 122, e2.$LBRACE = 123, e2.$BAR = 124, e2.$RBRACE = 125, e2.$NBSP = 160, e2.$PIPE = 124, e2.$TILDA = 126, e2.$AT = 64, e2.$BT = 96, e2.isWhitespace = function(t4) {
        return t4 >= e2.$TAB && t4 <= e2.$SPACE || t4 == e2.$NBSP;
      }, e2.isDigit = t3, e2.isAsciiLetter = function(t4) {
        return t4 >= e2.$a && t4 <= e2.$z || t4 >= e2.$A && t4 <= e2.$Z;
      }, e2.isAsciiHexDigit = function(n2) {
        return n2 >= e2.$a && n2 <= e2.$f || n2 >= e2.$A && n2 <= e2.$F || t3(n2);
      }, e2.isNewLine = function(t4) {
        return t4 === e2.$LF || t4 === e2.$CR;
      }, e2.isOctalDigit = function(t4) {
        return e2.$0 <= t4 && t4 <= e2.$7;
      };
    }(hq);
    var gq = {}, mq = {};
    /**
    	 * @license
    	 * Copyright Google Inc. All Rights Reserved.
    	 *
    	 * Use of this source code is governed by an MIT-style license that can be
    	 * found in the LICENSE file at https://angular.io/license
    	 */
    Object.defineProperty(mq, "__esModule", { value: true });
    class yq {
      constructor(e2, t3, n2) {
        this.filePath = e2, this.name = t3, this.members = n2;
      }
      assertNoMembers() {
        if (this.members.length)
          throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
      }
    }
    mq.StaticSymbol = yq;
    mq.StaticSymbolCache = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
      }
      get(e2, t3, n2) {
        const r2 = (n2 = n2 || []).length ? ".".concat(n2.join(".")) : "", o2 = '"'.concat(e2, '".').concat(t3).concat(r2);
        let i2 = this.cache.get(o2);
        return i2 || (i2 = new yq(e2, t3, n2), this.cache.set(o2, i2)), i2;
      }
    };
    var Dq = {};
    /**
    	 * @license
    	 * Copyright Google Inc. All Rights Reserved.
    	 *
    	 * Use of this source code is governed by an MIT-style license that can be
    	 * found in the LICENSE file at https://angular.io/license
    	 */
    Object.defineProperty(Dq, "__esModule", { value: true });
    const Eq = /-+([a-z0-9])/g;
    function Cq(e2, t3, n2) {
      const r2 = e2.indexOf(t3);
      return r2 == -1 ? n2 : [e2.slice(0, r2).trim(), e2.slice(r2 + 1).trim()];
    }
    function bq(e2, t3, n2) {
      return Array.isArray(e2) ? t3.visitArray(e2, n2) : function(e3) {
        return typeof e3 == "object" && e3 !== null && Object.getPrototypeOf(e3) === Fq;
      }(e2) ? t3.visitStringMap(e2, n2) : e2 == null || typeof e2 == "string" || typeof e2 == "number" || typeof e2 == "boolean" ? t3.visitPrimitive(e2, n2) : t3.visitOther(e2, n2);
    }
    Dq.dashCaseToCamelCase = function(e2) {
      return e2.replace(Eq, function() {
        for (var e3 = arguments.length, t3 = new Array(e3), n2 = 0; n2 < e3; n2++)
          t3[n2] = arguments[n2];
        return t3[1].toUpperCase();
      });
    }, Dq.splitAtColon = function(e2, t3) {
      return Cq(e2, ":", t3);
    }, Dq.splitAtPeriod = function(e2, t3) {
      return Cq(e2, ".", t3);
    }, Dq.visitValue = bq, Dq.isDefined = function(e2) {
      return e2 != null;
    }, Dq.noUndefined = function(e2) {
      return e2 === void 0 ? null : e2;
    };
    Dq.ValueTransformer = class {
      visitArray(e2, t3) {
        return e2.map((e3) => bq(e3, this, t3));
      }
      visitStringMap(e2, t3) {
        const n2 = {};
        return Object.keys(e2).forEach((r2) => {
          n2[r2] = bq(e2[r2], this, t3);
        }), n2;
      }
      visitPrimitive(e2, t3) {
        return e2;
      }
      visitOther(e2, t3) {
        return e2;
      }
    }, Dq.SyncAsync = { assertSync: (e2) => {
      if (xq(e2))
        throw new Error("Illegal state: value cannot be a promise");
      return e2;
    }, then: (e2, t3) => xq(e2) ? e2.then(t3) : t3(e2), all: (e2) => e2.some(xq) ? Promise.all(e2) : e2 }, Dq.error = function(e2) {
      throw new Error("Internal Error: ".concat(e2));
    }, Dq.syntaxError = function(e2, t3) {
      const n2 = Error(e2);
      return n2[vq] = true, t3 && (n2[Aq] = t3), n2;
    };
    const vq = "ngSyntaxError", Aq = "ngParseErrors";
    Dq.isSyntaxError = function(e2) {
      return e2[vq];
    }, Dq.getParseErrors = function(e2) {
      return e2[Aq] || [];
    }, Dq.escapeRegExp = function(e2) {
      return e2.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
    };
    const Fq = Object.getPrototypeOf({});
    function xq(e2) {
      return !!e2 && typeof e2.then == "function";
    }
    Dq.utf8Encode = function(e2) {
      let t3 = "";
      for (let n2 = 0; n2 < e2.length; n2++) {
        let r2 = e2.charCodeAt(n2);
        if (r2 >= 55296 && r2 <= 56319 && e2.length > n2 + 1) {
          const t4 = e2.charCodeAt(n2 + 1);
          t4 >= 56320 && t4 <= 57343 && (n2++, r2 = (r2 - 55296 << 10) + t4 - 56320 + 65536);
        }
        r2 <= 127 ? t3 += String.fromCharCode(r2) : r2 <= 2047 ? t3 += String.fromCharCode(r2 >> 6 & 31 | 192, 63 & r2 | 128) : r2 <= 65535 ? t3 += String.fromCharCode(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128) : r2 <= 2097151 && (t3 += String.fromCharCode(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128));
      }
      return t3;
    }, Dq.stringify = function e2(t3) {
      if (typeof t3 == "string")
        return t3;
      if (t3 instanceof Array)
        return "[" + t3.map(e2).join(", ") + "]";
      if (t3 == null)
        return "" + t3;
      if (t3.overriddenName)
        return "".concat(t3.overriddenName);
      if (t3.name)
        return "".concat(t3.name);
      if (!t3.toString)
        return "object";
      const n2 = t3.toString();
      if (n2 == null)
        return "" + n2;
      const r2 = n2.indexOf("\n");
      return r2 === -1 ? n2 : n2.substring(0, r2);
    }, Dq.resolveForwardRef = function(e2) {
      return typeof e2 == "function" && e2.hasOwnProperty("__forward_ref__") ? e2() : e2;
    }, Dq.isPromise = xq;
    Dq.Version = class {
      constructor(e2) {
        this.full = e2;
        const t3 = e2.split(".");
        this.major = t3[0], this.minor = t3[1], this.patch = t3.slice(2).join(".");
      }
    };
    const Sq = typeof window != "undefined" && window, wq = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self, Tq = e !== void 0 && e || Sq || wq;
    Dq.global = Tq, function(e2) {
      /**
      	   * @license
      	   * Copyright Google Inc. All Rights Reserved.
      	   *
      	   * Use of this source code is governed by an MIT-style license that can be
      	   * found in the LICENSE file at https://angular.io/license
      	   */
      Object.defineProperty(e2, "__esModule", { value: true });
      const t3 = mq, n2 = Dq, r2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
      function o2(e3) {
        return e3.replace(/\W/g, "_");
      }
      e2.sanitizeIdentifier = o2;
      let i2 = 0;
      function u2(e3) {
        if (!e3 || !e3.reference)
          return null;
        const r3 = e3.reference;
        if (r3 instanceof t3.StaticSymbol)
          return r3.name;
        if (r3.__anonymousType)
          return r3.__anonymousType;
        let u3 = n2.stringify(r3);
        return u3.indexOf("(") >= 0 ? (u3 = "anonymous_".concat(i2++), r3.__anonymousType = u3) : u3 = o2(u3), u3;
      }
      var s2;
      e2.identifierName = u2, e2.identifierModuleUrl = function(e3) {
        const r3 = e3.reference;
        return r3 instanceof t3.StaticSymbol ? r3.filePath : "./".concat(n2.stringify(r3));
      }, e2.viewClassName = function(e3, t4) {
        return "View_".concat(u2({ reference: e3 }), "_").concat(t4);
      }, e2.rendererTypeName = function(e3) {
        return "RenderType_".concat(u2({ reference: e3 }));
      }, e2.hostViewClassName = function(e3) {
        return "HostView_".concat(u2({ reference: e3 }));
      }, e2.componentFactoryName = function(e3) {
        return "".concat(u2({ reference: e3 }), "NgFactory");
      }, function(e3) {
        e3[e3.Pipe = 0] = "Pipe", e3[e3.Directive = 1] = "Directive", e3[e3.NgModule = 2] = "NgModule", e3[e3.Injectable = 3] = "Injectable";
      }(s2 = e2.CompileSummaryKind || (e2.CompileSummaryKind = {})), e2.tokenName = function(e3) {
        return e3.value != null ? o2(e3.value) : u2(e3.identifier);
      }, e2.tokenReference = function(e3) {
        return e3.identifier != null ? e3.identifier.reference : e3.value;
      };
      e2.CompileStylesheetMetadata = class {
        constructor() {
          let { moduleUrl: e3, styles: t4, styleUrls: n3 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this.moduleUrl = e3 || null, this.styles = c2(t4), this.styleUrls = c2(n3);
        }
      };
      e2.CompileTemplateMetadata = class {
        constructor(e3) {
          let { encapsulation: t4, template: n3, templateUrl: r3, htmlAst: o3, styles: i3, styleUrls: u3, externalStylesheets: s3, animations: a3, ngContentSelectors: p3, interpolation: f2, isInline: d2, preserveWhitespaces: h2 } = e3;
          if (this.encapsulation = t4, this.template = n3, this.templateUrl = r3, this.htmlAst = o3, this.styles = c2(i3), this.styleUrls = c2(u3), this.externalStylesheets = c2(s3), this.animations = a3 ? l2(a3) : [], this.ngContentSelectors = p3 || [], f2 && f2.length != 2)
            throw new Error("'interpolation' should have a start and an end symbol.");
          this.interpolation = f2, this.isInline = d2, this.preserveWhitespaces = h2;
        }
        toSummary() {
          return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
        }
      };
      class a2 {
        static create(e3) {
          let { isHost: t4, type: o3, isComponent: i3, selector: u3, exportAs: s3, changeDetection: c3, inputs: l3, outputs: p3, host: f2, providers: d2, viewProviders: h2, queries: g2, guards: m2, viewQueries: y2, entryComponents: D2, template: E2, componentViewType: C3, rendererType: b2, componentFactory: v2 } = e3;
          const A2 = {}, F2 = {}, x2 = {};
          f2 != null && Object.keys(f2).forEach((e4) => {
            const t5 = f2[e4], n3 = e4.match(r2);
            n3 === null ? x2[e4] = t5 : n3[1] != null ? F2[n3[1]] = t5 : n3[2] != null && (A2[n3[2]] = t5);
          });
          const S3 = {};
          l3 != null && l3.forEach((e4) => {
            const t5 = n2.splitAtColon(e4, [e4, e4]);
            S3[t5[0]] = t5[1];
          });
          const w2 = {};
          return p3 != null && p3.forEach((e4) => {
            const t5 = n2.splitAtColon(e4, [e4, e4]);
            w2[t5[0]] = t5[1];
          }), new a2({ isHost: t4, type: o3, isComponent: !!i3, selector: u3, exportAs: s3, changeDetection: c3, inputs: S3, outputs: w2, hostListeners: A2, hostProperties: F2, hostAttributes: x2, providers: d2, viewProviders: h2, queries: g2, guards: m2, viewQueries: y2, entryComponents: D2, template: E2, componentViewType: C3, rendererType: b2, componentFactory: v2 });
        }
        constructor(e3) {
          let { isHost: t4, type: n3, isComponent: r3, selector: o3, exportAs: i3, changeDetection: u3, inputs: s3, outputs: a3, hostListeners: l3, hostProperties: p3, hostAttributes: f2, providers: d2, viewProviders: h2, queries: g2, guards: m2, viewQueries: y2, entryComponents: D2, template: E2, componentViewType: C3, rendererType: b2, componentFactory: v2 } = e3;
          this.isHost = !!t4, this.type = n3, this.isComponent = r3, this.selector = o3, this.exportAs = i3, this.changeDetection = u3, this.inputs = s3, this.outputs = a3, this.hostListeners = l3, this.hostProperties = p3, this.hostAttributes = f2, this.providers = c2(d2), this.viewProviders = c2(h2), this.queries = c2(g2), this.guards = m2, this.viewQueries = c2(y2), this.entryComponents = c2(D2), this.template = E2, this.componentViewType = C3, this.rendererType = b2, this.componentFactory = v2;
        }
        toSummary() {
          return { summaryKind: s2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
        }
      }
      e2.CompileDirectiveMetadata = a2;
      e2.CompilePipeMetadata = class {
        constructor(e3) {
          let { type: t4, name: n3, pure: r3 } = e3;
          this.type = t4, this.name = n3, this.pure = !!r3;
        }
        toSummary() {
          return { summaryKind: s2.Pipe, type: this.type, name: this.name, pure: this.pure };
        }
      };
      e2.CompileShallowModuleMetadata = class {
      };
      e2.CompileNgModuleMetadata = class {
        constructor(e3) {
          let { type: t4, providers: n3, declaredDirectives: r3, exportedDirectives: o3, declaredPipes: i3, exportedPipes: u3, entryComponents: s3, bootstrapComponents: a3, importedModules: l3, exportedModules: p3, schemas: f2, transitiveModule: d2, id: h2 } = e3;
          this.type = t4 || null, this.declaredDirectives = c2(r3), this.exportedDirectives = c2(o3), this.declaredPipes = c2(i3), this.exportedPipes = c2(u3), this.providers = c2(n3), this.entryComponents = c2(s3), this.bootstrapComponents = c2(a3), this.importedModules = c2(l3), this.exportedModules = c2(p3), this.schemas = c2(f2), this.id = h2 || null, this.transitiveModule = d2 || null;
        }
        toSummary() {
          const e3 = this.transitiveModule;
          return { summaryKind: s2.NgModule, type: this.type, entryComponents: e3.entryComponents, providers: e3.providers, modules: e3.modules, exportedDirectives: e3.exportedDirectives, exportedPipes: e3.exportedPipes };
        }
      };
      function c2(e3) {
        return e3 || [];
      }
      e2.TransitiveCompileNgModuleMetadata = class {
        constructor() {
          this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
        }
        addProvider(e3, t4) {
          this.providers.push({ provider: e3, module: t4 });
        }
        addDirective(e3) {
          this.directivesSet.has(e3.reference) || (this.directivesSet.add(e3.reference), this.directives.push(e3));
        }
        addExportedDirective(e3) {
          this.exportedDirectivesSet.has(e3.reference) || (this.exportedDirectivesSet.add(e3.reference), this.exportedDirectives.push(e3));
        }
        addPipe(e3) {
          this.pipesSet.has(e3.reference) || (this.pipesSet.add(e3.reference), this.pipes.push(e3));
        }
        addExportedPipe(e3) {
          this.exportedPipesSet.has(e3.reference) || (this.exportedPipesSet.add(e3.reference), this.exportedPipes.push(e3));
        }
        addModule(e3) {
          this.modulesSet.has(e3.reference) || (this.modulesSet.add(e3.reference), this.modules.push(e3));
        }
        addEntryComponent(e3) {
          this.entryComponentsSet.has(e3.componentType) || (this.entryComponentsSet.add(e3.componentType), this.entryComponents.push(e3));
        }
      };
      function l2(e3) {
        return e3.reduce((e4, t4) => {
          const n3 = Array.isArray(t4) ? l2(t4) : t4;
          return e4.concat(n3);
        }, []);
      }
      function p2(e3) {
        return e3.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
      }
      e2.ProviderMeta = class {
        constructor(e3, t4) {
          let { useClass: n3, useValue: r3, useExisting: o3, useFactory: i3, deps: u3, multi: s3 } = t4;
          this.token = e3, this.useClass = n3 || null, this.useValue = r3, this.useExisting = o3, this.useFactory = i3 || null, this.dependencies = u3 || null, this.multi = !!s3;
        }
      }, e2.flatten = l2, e2.templateSourceUrl = function(e3, n3, r3) {
        let o3;
        return o3 = r3.isInline ? n3.type.reference instanceof t3.StaticSymbol ? "".concat(n3.type.reference.filePath, ".").concat(n3.type.reference.name, ".html") : "".concat(u2(e3), "/").concat(u2(n3.type), ".html") : r3.templateUrl, n3.type.reference instanceof t3.StaticSymbol ? o3 : p2(o3);
      }, e2.sharedStylesheetJitUrl = function(e3, t4) {
        const n3 = e3.moduleUrl.split(/\/\\/g), r3 = n3[n3.length - 1];
        return p2("css/".concat(t4).concat(r3, ".ngstyle.js"));
      }, e2.ngModuleJitUrl = function(e3) {
        return p2("".concat(u2(e3.type), "/module.ngfactory.js"));
      }, e2.templateJitUrl = function(e3, t4) {
        return p2("".concat(u2(e3), "/").concat(u2(t4.type), ".ngfactory.js"));
      };
    }(gq), function(e2) {
      Object.defineProperty(e2, "__esModule", { value: true });
      /**
      	   * @license
      	   * Copyright Google Inc. All Rights Reserved.
      	   *
      	   * Use of this source code is governed by an MIT-style license that can be
      	   * found in the LICENSE file at https://angular.io/license
      	   */
      const t3 = hq, n2 = gq;
      class r2 {
        constructor(e3, t4, n3, r3) {
          this.file = e3, this.offset = t4, this.line = n3, this.col = r3;
        }
        toString() {
          return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
        }
        moveBy(e3) {
          const n3 = this.file.content, o3 = n3.length;
          let i3 = this.offset, u3 = this.line, s2 = this.col;
          for (; i3 > 0 && e3 < 0; ) {
            i3--, e3++;
            if (n3.charCodeAt(i3) == t3.$LF) {
              u3--;
              const e4 = n3.substr(0, i3 - 1).lastIndexOf(String.fromCharCode(t3.$LF));
              s2 = e4 > 0 ? i3 - e4 : i3;
            } else
              s2--;
          }
          for (; i3 < o3 && e3 > 0; ) {
            const r3 = n3.charCodeAt(i3);
            i3++, e3--, r3 == t3.$LF ? (u3++, s2 = 0) : s2++;
          }
          return new r2(this.file, i3, u3, s2);
        }
        getContext(e3, t4) {
          const n3 = this.file.content;
          let r3 = this.offset;
          if (r3 != null) {
            r3 > n3.length - 1 && (r3 = n3.length - 1);
            let o3 = r3, i3 = 0, u3 = 0;
            for (; i3 < e3 && r3 > 0 && (r3--, i3++, n3[r3] != "\n" || ++u3 != t4); )
              ;
            for (i3 = 0, u3 = 0; i3 < e3 && o3 < n3.length - 1 && (o3++, i3++, n3[o3] != "\n" || ++u3 != t4); )
              ;
            return { before: n3.substring(r3, this.offset), after: n3.substring(this.offset, o3 + 1) };
          }
          return null;
        }
      }
      e2.ParseLocation = r2;
      class o2 {
        constructor(e3, t4) {
          this.content = e3, this.url = t4;
        }
      }
      e2.ParseSourceFile = o2;
      class i2 {
        constructor(e3, t4) {
          let n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          this.start = e3, this.end = t4, this.details = n3;
        }
        toString() {
          return this.start.file.content.substring(this.start.offset, this.end.offset);
        }
      }
      var u2;
      e2.ParseSourceSpan = i2, e2.EMPTY_PARSE_LOCATION = new r2(new o2("", ""), 0, 0, 0), e2.EMPTY_SOURCE_SPAN = new i2(e2.EMPTY_PARSE_LOCATION, e2.EMPTY_PARSE_LOCATION), function(e3) {
        e3[e3.WARNING = 0] = "WARNING", e3[e3.ERROR = 1] = "ERROR";
      }(u2 = e2.ParseErrorLevel || (e2.ParseErrorLevel = {}));
      e2.ParseError = class {
        constructor(e3, t4) {
          let n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u2.ERROR;
          this.span = e3, this.msg = t4, this.level = n3;
        }
        contextualMessage() {
          const e3 = this.span.start.getContext(100, 3);
          return e3 ? "".concat(this.msg, ' ("').concat(e3.before, "[").concat(u2[this.level], " ->]").concat(e3.after, '")') : this.msg;
        }
        toString() {
          const e3 = this.span.details ? ", ".concat(this.span.details) : "";
          return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(e3);
        }
      }, e2.typeSourceSpan = function(e3, t4) {
        const u3 = n2.identifierModuleUrl(t4), s2 = u3 != null ? "in ".concat(e3, " ").concat(n2.identifierName(t4), " in ").concat(u3) : "in ".concat(e3, " ").concat(n2.identifierName(t4)), a2 = new o2("", s2);
        return new i2(new r2(a2, -1, -1, -1), new r2(a2, -1, -1, -1));
      }, e2.r3JitTypeSourceSpan = function(e3, t4, n3) {
        const u3 = "in ".concat(e3, " ").concat(t4, " in ").concat(n3), s2 = new o2("", u3);
        return new i2(new r2(s2, -1, -1, -1), new r2(s2, -1, -1, -1));
      };
    }(dq);
    const { ParseSourceSpan: Bq } = dq, Nq = au, { htmlTrim: kq, getLeadingAndTrailingHtmlWhitespace: Pq, hasHtmlWhitespace: Oq, canHaveInterpolation: Iq, getNodeCssStyleDisplay: Lq, isDanglingSpaceSensitiveNode: jq, isIndentationSensitiveNode: _q, isLeadingSpaceSensitiveNode: Mq, isTrailingSpaceSensitiveNode: Rq, isWhitespaceSensitiveNode: Vq } = fq, $q = [function(e2) {
      e2.walk((e3) => {
        if (e3.type === "element" && e3.tagDefinition.ignoreFirstLf && e3.children.length > 0 && e3.children[0].type === "text" && e3.children[0].value[0] === "\n") {
          const [t3, ...n2] = e3.children;
          e3.setChildren(t3.value.length === 1 ? n2 : [t3.clone({ value: t3.value.slice(1) }), ...n2]);
        }
      });
    }, function(e2) {
      const t3 = (e3) => e3.type === "element" && e3.prev && e3.prev.type === "ieConditionalStartComment" && e3.prev.sourceSpan.end.offset === e3.startSourceSpan.start.offset && e3.firstChild && e3.firstChild.type === "ieConditionalEndComment" && e3.firstChild.sourceSpan.start.offset === e3.startSourceSpan.end.offset;
      e2.walk((e3) => {
        if (e3.children) {
          const n2 = e3.children.map(t3);
          if (n2.some(Boolean)) {
            const t4 = [];
            for (let r2 = 0; r2 < e3.children.length; r2++) {
              const o2 = e3.children[r2];
              if (!n2[r2 + 1])
                if (n2[r2]) {
                  const e4 = o2.prev, n3 = o2.firstChild, r3 = new Bq(e4.sourceSpan.start, n3.sourceSpan.end), i2 = new Bq(r3.start, o2.sourceSpan.end);
                  t4.push(o2.clone({ condition: e4.condition, sourceSpan: i2, startSourceSpan: r3, children: o2.children.slice(1) }));
                } else
                  t4.push(o2);
            }
            e3.setChildren(t4);
          }
        }
      });
    }, function(e2) {
      return function(e3, t3, n2) {
        e3.walk((e4) => {
          if (e4.children) {
            const r2 = e4.children.map(t3);
            if (r2.some(Boolean)) {
              const t4 = [];
              for (let o2 = 0; o2 < e4.children.length; o2++) {
                const i2 = e4.children[o2];
                if (i2.type !== "text" && !r2[o2]) {
                  t4.push(i2);
                  continue;
                }
                const u2 = i2.type === "text" ? i2 : i2.clone({ type: "text", value: n2(i2) });
                if (t4.length === 0 || Nq(t4).type !== "text") {
                  t4.push(u2);
                  continue;
                }
                const s2 = t4.pop();
                t4.push(s2.clone({ value: s2.value + u2.value, sourceSpan: new Bq(s2.sourceSpan.start, u2.sourceSpan.end) }));
              }
              e4.setChildren(t4);
            }
          }
        });
      }(e2, (e3) => e3.type === "cdata", (e3) => "<![CDATA[".concat(e3.value, "]]>"));
    }, function(e2, t3) {
      if (t3.parser === "html")
        return;
      const n2 = /{{(.+?)}}/s;
      e2.walk((e3) => {
        if (!Iq(e3))
          return;
        const t4 = [];
        for (const r2 of e3.children) {
          if (r2.type !== "text") {
            t4.push(r2);
            continue;
          }
          let e4 = r2.sourceSpan.start, o2 = null;
          const i2 = r2.value.split(n2);
          for (let n3 = 0; n3 < i2.length; n3++, e4 = o2) {
            const r3 = i2[n3];
            n3 % 2 != 0 ? (o2 = e4.moveBy(r3.length + 4), t4.push({ type: "interpolation", sourceSpan: new Bq(e4, o2), children: r3.length === 0 ? [] : [{ type: "text", value: r3, sourceSpan: new Bq(e4.moveBy(2), o2.moveBy(-2)) }] })) : (o2 = e4.moveBy(r3.length), r3.length > 0 && t4.push({ type: "text", value: r3, sourceSpan: new Bq(e4, o2) }));
          }
        }
        e3.setChildren(t4);
      });
    }, function(e2) {
      e2.walk((e3) => {
        if (!e3.children)
          return;
        if (e3.children.length === 0 || e3.children.length === 1 && e3.children[0].type === "text" && kq(e3.children[0].value).length === 0)
          return e3.hasDanglingSpaces = e3.children.length > 0, void (e3.children = []);
        const t3 = Vq(e3), n2 = _q(e3);
        e3.setChildren(e3.children.flatMap((e4) => {
          if (e4.type !== "text" || t3)
            return e4;
          const n3 = [], { leadingWhitespace: r2, text: o2, trailingWhitespace: i2 } = Pq(e4.value);
          return r2 && n3.push(Wq), o2 && n3.push({ type: "text", value: o2, sourceSpan: new Bq(e4.sourceSpan.start.moveBy(r2.length), e4.sourceSpan.end.moveBy(-i2.length)) }), i2 && n3.push(Wq), n3;
        }).map((e4, t4, n3) => {
          if (e4 !== Wq)
            return Object.assign(Object.assign({}, e4), {}, { hasLeadingSpaces: n3[t4 - 1] === Wq, hasTrailingSpaces: n3[t4 + 1] === Wq });
        }).filter(Boolean)), e3.isWhitespaceSensitive = t3, e3.isIndentationSensitive = n2;
      });
    }, function(e2, t3) {
      e2.walk((e3) => Object.assign(e3, { cssDisplay: Lq(e3, t3) }));
    }, function(e2) {
      e2.walk((e3) => Object.assign(e3, { isSelfClosing: !e3.children || e3.type === "element" && (e3.tagDefinition.isVoid || e3.startSourceSpan === e3.endSourceSpan) }));
    }, function(e2, t3) {
      e2.walk((e3) => e3.type !== "element" ? e3 : Object.assign(e3, { hasHtmComponentClosingTag: e3.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t3.originalText.slice(e3.endSourceSpan.start.offset, e3.endSourceSpan.end.offset)) }));
    }, function(e2, t3) {
      e2.walk((e3) => {
        e3.children && (e3.children.length !== 0 ? e3.setChildren(e3.children.map((e4) => Object.assign(Object.assign({}, e4), {}, { isLeadingSpaceSensitive: Mq(e4, t3), isTrailingSpaceSensitive: Rq(e4, t3) })).map((e4, t4, n2) => Object.assign(Object.assign({}, e4), {}, { isLeadingSpaceSensitive: (t4 === 0 || n2[t4 - 1].isTrailingSpaceSensitive) && e4.isLeadingSpaceSensitive, isTrailingSpaceSensitive: (t4 === n2.length - 1 || n2[t4 + 1].isLeadingSpaceSensitive) && e4.isTrailingSpaceSensitive }))) : e3.isDanglingSpaceSensitive = jq(e3));
      });
    }, function(e2) {
      const t3 = (e3) => e3.type === "element" && e3.attrs.length === 0 && e3.children.length === 1 && e3.firstChild.type === "text" && !Oq(e3.children[0].value) && !e3.firstChild.hasLeadingSpaces && !e3.firstChild.hasTrailingSpaces && e3.isLeadingSpaceSensitive && !e3.hasLeadingSpaces && e3.isTrailingSpaceSensitive && !e3.hasTrailingSpaces && e3.prev && e3.prev.type === "text" && e3.next && e3.next.type === "text";
      e2.walk((e3) => {
        if (e3.children) {
          const n2 = e3.children.map(t3);
          if (n2.some(Boolean)) {
            const t4 = [];
            for (let r2 = 0; r2 < e3.children.length; r2++) {
              const o2 = e3.children[r2];
              if (n2[r2]) {
                const n3 = t4.pop(), i2 = e3.children[++r2], { isTrailingSpaceSensitive: u2, hasTrailingSpaces: s2 } = i2;
                t4.push(n3.clone({ value: n3.value + "<".concat(o2.rawName, ">") + o2.firstChild.value + "</".concat(o2.rawName, ">") + i2.value, sourceSpan: new Bq(n3.sourceSpan.start, i2.sourceSpan.end), isTrailingSpaceSensitive: u2, hasTrailingSpaces: s2 }));
              } else
                t4.push(o2);
            }
            e3.setChildren(t4);
          }
        }
      });
    }];
    const Wq = { type: "whitespace" };
    var qq = function(e2, t3) {
      const n2 = e2.map((e3) => e3);
      for (const e3 of $q)
        e3(n2, t3);
      return n2;
    };
    var Uq = { hasPragma: function(e2) {
      return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e2);
    }, insertPragma: function(e2) {
      return "<!-- @format -->\n\n" + e2.replace(/^\s*\n/, "");
    } };
    var zq = { locStart: function(e2) {
      return e2.sourceSpan.start.offset;
    }, locEnd: function(e2) {
      return e2.sourceSpan.end.offset;
    } };
    const Gq = Ty, { isNonEmptyArray: Hq } = dc, { builders: { indent: Jq, join: Xq, line: Yq, softline: Kq }, utils: { replaceTextEndOfLine: Qq } } = Zc, { locStart: Zq, locEnd: eU } = zq, { isTextLikeNode: tU, getLastDescendant: nU, isPreLikeNode: rU, hasPrettierIgnore: oU, shouldPreserveContent: iU } = fq;
    function uU(e2, t3) {
      return e2.lastChild && gU(e2.lastChild) ? "" : [aU(e2, t3), lU(e2, t3)];
    }
    function sU(e2, t3) {
      return (e2.next ? dU(e2.next) : hU(e2.parent)) ? "" : [pU(e2, t3), cU(e2, t3)];
    }
    function aU(e2, t3) {
      return hU(e2) ? pU(e2.lastChild, t3) : "";
    }
    function cU(e2, t3) {
      return gU(e2) ? lU(e2.parent, t3) : mU(e2) ? vU(e2.next) : "";
    }
    function lU(e2, t3) {
      if (Gq(!e2.isSelfClosing), fU(e2, t3))
        return "";
      switch (e2.type) {
        case "ieConditionalComment":
          return "<!";
        case "element":
          if (e2.hasHtmComponentClosingTag)
            return "<//";
        default:
          return "</".concat(e2.rawName);
      }
    }
    function pU(e2, t3) {
      if (fU(e2, t3))
        return "";
      switch (e2.type) {
        case "ieConditionalComment":
        case "ieConditionalEndComment":
          return "[endif]-->";
        case "ieConditionalStartComment":
          return "]><!-->";
        case "interpolation":
          return "}}";
        case "element":
          if (e2.isSelfClosing)
            return "/>";
        default:
          return ">";
      }
    }
    function fU(e2, t3) {
      return !e2.isSelfClosing && !e2.endSourceSpan && (oU(e2) || iU(e2.parent, t3));
    }
    function dU(e2) {
      return e2.prev && e2.prev.type !== "docType" && !tU(e2.prev) && e2.isLeadingSpaceSensitive && !e2.hasLeadingSpaces;
    }
    function hU(e2) {
      return e2.lastChild && e2.lastChild.isTrailingSpaceSensitive && !e2.lastChild.hasTrailingSpaces && !tU(nU(e2.lastChild)) && !rU(e2);
    }
    function gU(e2) {
      return !e2.next && !e2.hasTrailingSpaces && e2.isTrailingSpaceSensitive && tU(nU(e2));
    }
    function mU(e2) {
      return e2.next && !tU(e2.next) && tU(e2) && e2.isTrailingSpaceSensitive && !e2.hasTrailingSpaces;
    }
    function yU(e2) {
      return !e2.prev && e2.isLeadingSpaceSensitive && !e2.hasLeadingSpaces;
    }
    function DU(e2, t3, n2) {
      const r2 = e2.getValue();
      if (!Hq(r2.attrs))
        return r2.isSelfClosing ? " " : "";
      const o2 = r2.prev && r2.prev.type === "comment" && function(e3) {
        const t4 = e3.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
        return !!t4 && (!t4[1] || t4[1].split(/\s+/));
      }(r2.prev.value), i2 = typeof o2 == "boolean" ? () => o2 : Array.isArray(o2) ? (e3) => o2.includes(e3.rawName) : () => false, u2 = e2.map((e3) => {
        const r3 = e3.getValue();
        return i2(r3) ? Qq(t3.originalText.slice(Zq(r3), eU(r3))) : n2();
      }, "attrs"), s2 = r2.type === "element" && r2.fullName === "script" && r2.attrs.length === 1 && r2.attrs[0].fullName === "src" && r2.children.length === 0, a2 = [Jq([s2 ? " " : Yq, Xq(Yq, u2)])];
      return r2.firstChild && yU(r2.firstChild) || r2.isSelfClosing && hU(r2.parent) || s2 ? a2.push(r2.isSelfClosing ? " " : "") : a2.push(t3.bracketSameLine ? r2.isSelfClosing ? " " : "" : r2.isSelfClosing ? Yq : Kq), a2;
    }
    function EU(e2) {
      return e2.firstChild && yU(e2.firstChild) ? "" : AU(e2);
    }
    function CU(e2, t3) {
      return e2.prev && mU(e2.prev) ? "" : [bU(e2, t3), vU(e2)];
    }
    function bU(e2, t3) {
      return yU(e2) ? AU(e2.parent) : dU(e2) ? pU(e2.prev, t3) : "";
    }
    function vU(e2) {
      switch (e2.type) {
        case "ieConditionalComment":
        case "ieConditionalStartComment":
          return "<!--[if ".concat(e2.condition);
        case "ieConditionalEndComment":
          return "<!--<!";
        case "interpolation":
          return "{{";
        case "docType":
          return "<!DOCTYPE";
        case "element":
          if (e2.condition)
            return "<!--[if ".concat(e2.condition, "]><!--><").concat(e2.rawName);
        default:
          return "<".concat(e2.rawName);
      }
    }
    function AU(e2) {
      switch (Gq(!e2.isSelfClosing), e2.type) {
        case "ieConditionalComment":
          return "]>";
        case "element":
          if (e2.condition)
            return "><!--<![endif]-->";
        default:
          return ">";
      }
    }
    var FU = { printClosingTag: function(e2, t3) {
      return [e2.isSelfClosing ? "" : uU(e2, t3), sU(e2, t3)];
    }, printClosingTagStart: uU, printClosingTagStartMarker: lU, printClosingTagEndMarker: pU, printClosingTagSuffix: cU, printClosingTagEnd: sU, needsToBorrowLastChildClosingTagEndMarker: hU, needsToBorrowParentClosingTagStartMarker: gU, needsToBorrowPrevClosingTagEndMarker: dU, printOpeningTag: function(e2, t3, n2) {
      const r2 = e2.getValue();
      return [CU(r2, t3), DU(e2, t3, n2), r2.isSelfClosing ? "" : EU(r2)];
    }, printOpeningTagStart: CU, printOpeningTagPrefix: bU, printOpeningTagStartMarker: vU, printOpeningTagEndMarker: AU, needsToBorrowNextOpeningTagStartMarker: mU, needsToBorrowParentOpeningTagEndMarker: yU }, xU = { exports: {} };
    !function(t3) {
      var n2, r2;
      n2 = e, r2 = function() {
        return function(e2, t4) {
          var n3 = t4 && t4.logger || console;
          function r3(e3) {
            return e3 === " " || e3 === "	" || e3 === "\n" || e3 === "\f" || e3 === "\r";
          }
          function o2(t5) {
            var n4, r4 = t5.exec(e2.substring(y2));
            if (r4)
              return n4 = r4[0], y2 += n4.length, n4;
          }
          for (var i2, u2, s2, a2, c2, l2 = e2.length, p2 = /^[ \t\n\r\u000c]+/, f2 = /^[, \t\n\r\u000c]+/, d2 = /^[^ \t\n\r\u000c]+/, h2 = /[,]+$/, g2 = /^\d+$/, m2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, y2 = 0, D2 = []; ; ) {
            if (o2(f2), y2 >= l2)
              return D2;
            i2 = o2(d2), u2 = [], i2.slice(-1) === "," ? (i2 = i2.replace(h2, ""), C3()) : E2();
          }
          function E2() {
            for (o2(p2), s2 = "", a2 = "in descriptor"; ; ) {
              if (c2 = e2.charAt(y2), a2 === "in descriptor")
                if (r3(c2))
                  s2 && (u2.push(s2), s2 = "", a2 = "after descriptor");
                else {
                  if (c2 === ",")
                    return y2 += 1, s2 && u2.push(s2), void C3();
                  if (c2 === "(")
                    s2 += c2, a2 = "in parens";
                  else {
                    if (c2 === "")
                      return s2 && u2.push(s2), void C3();
                    s2 += c2;
                  }
                }
              else if (a2 === "in parens")
                if (c2 === ")")
                  s2 += c2, a2 = "in descriptor";
                else {
                  if (c2 === "")
                    return u2.push(s2), void C3();
                  s2 += c2;
                }
              else if (a2 === "after descriptor")
                if (r3(c2))
                  ;
                else {
                  if (c2 === "")
                    return void C3();
                  a2 = "in descriptor", y2 -= 1;
                }
              y2 += 1;
            }
          }
          function C3() {
            var t5, r4, o3, s3, a3, c3, l3, p3, f3, d3 = false, h3 = {};
            for (s3 = 0; s3 < u2.length; s3++)
              c3 = (a3 = u2[s3])[a3.length - 1], l3 = a3.substring(0, a3.length - 1), p3 = parseInt(l3, 10), f3 = parseFloat(l3), g2.test(l3) && c3 === "w" ? ((t5 || r4) && (d3 = true), p3 === 0 ? d3 = true : t5 = p3) : m2.test(l3) && c3 === "x" ? ((t5 || r4 || o3) && (d3 = true), f3 < 0 ? d3 = true : r4 = f3) : g2.test(l3) && c3 === "h" ? ((o3 || r4) && (d3 = true), p3 === 0 ? d3 = true : o3 = p3) : d3 = true;
            d3 ? n3 && n3.error && n3.error("Invalid srcset descriptor found in '" + e2 + "' at '" + a3 + "'.") : (h3.url = i2, t5 && (h3.w = t5), r4 && (h3.d = r4), o3 && (h3.h = o3), D2.push(h3));
          }
        };
      }, t3.exports ? t3.exports = r2() : n2.parseSrcset = r2();
    }(xU);
    const SU = xU.exports, { builders: { ifBreak: wU, join: TU, line: BU } } = Zc;
    var NU = { printImgSrcset: function(e2) {
      const t3 = SU(e2, { logger: { error(e3) {
        throw new Error(e3);
      } } }), n2 = t3.some((e3) => {
        let { w: t4 } = e3;
        return t4;
      }), r2 = t3.some((e3) => {
        let { h: t4 } = e3;
        return t4;
      });
      if (n2 + r2 + t3.some((e3) => {
        let { d: t4 } = e3;
        return t4;
      }) > 1)
        throw new Error("Mixed descriptor in srcset is not supported");
      const o2 = n2 ? "w" : r2 ? "h" : "d", i2 = n2 ? "w" : r2 ? "h" : "x", u2 = (e3) => Math.max(...e3), s2 = t3.map((e3) => e3.url), a2 = u2(s2.map((e3) => e3.length)), c2 = t3.map((e3) => e3[o2]).map((e3) => e3 ? e3.toString() : ""), l2 = c2.map((e3) => {
        const t4 = e3.indexOf(".");
        return t4 === -1 ? e3.length : t4;
      }), p2 = u2(l2);
      return TU([",", BU], s2.map((e3, t4) => {
        const n3 = [e3], r3 = c2[t4];
        if (r3) {
          const o3 = a2 - e3.length + 1, u3 = p2 - l2[t4], s3 = " ".repeat(o3 + u3);
          n3.push(wU(s3, " "), r3 + i2);
        }
        return n3;
      }));
    }, printClassNames: function(e2) {
      return e2.trim().split(/\s+/).join(" ");
    } };
    const { builders: { group: kU } } = Zc;
    var PU = { isVueEventBindingExpression: function(e2) {
      const t3 = e2.trim();
      return /^(?:[\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t3) || /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t3);
    }, printVueFor: function(e2, t3) {
      const { left: n2, operator: r2, right: o2 } = function(e3) {
        const t4 = /(.*?)\s+(in|of)\s+(.*)/s, n3 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, r3 = /^\(|\)$/g, o3 = e3.match(t4);
        if (!o3)
          return;
        const i2 = {};
        i2.for = o3[3].trim();
        const u2 = o3[1].trim().replace(r3, ""), s2 = u2.match(n3);
        s2 ? (i2.alias = u2.replace(n3, ""), i2.iterator1 = s2[1].trim(), s2[2] && (i2.iterator2 = s2[2].trim())) : i2.alias = u2;
        return { left: "".concat([i2.alias, i2.iterator1, i2.iterator2].filter(Boolean).join(",")), operator: o3[2], right: i2.for };
      }(e2);
      return [kU(t3("function _(".concat(n2, ") {}"), { parser: "babel", __isVueForBindingLeft: true })), " ", r2, " ", t3(o2, { parser: "__js_expression" }, { stripTrailingHardline: true })];
    }, printVueBindings: function(e2, t3) {
      return t3("function _(".concat(e2, ") {}"), { parser: "babel", __isVueBindings: true });
    } };
    const { needsToBorrowParentClosingTagStartMarker: OU, printClosingTagStartMarker: IU, needsToBorrowLastChildClosingTagEndMarker: LU, printClosingTagEndMarker: jU, needsToBorrowParentOpeningTagEndMarker: _U, printOpeningTagEndMarker: MU } = FU;
    var RU = function(e2, t3) {
      let n2 = e2.startSourceSpan.end.offset;
      e2.firstChild && _U(e2.firstChild) && (n2 -= MU(e2).length);
      let r2 = e2.endSourceSpan.start.offset;
      return e2.lastChild && OU(e2.lastChild) ? r2 += IU(e2, t3).length : LU(e2) && (r2 -= jU(e2.lastChild, t3).length), t3.originalText.slice(n2, r2);
    };
    const { builders: { breakParent: VU, group: $U, hardline: WU, indent: qU, line: UU, fill: zU, softline: GU }, utils: { mapDoc: HU, replaceTextEndOfLine: JU } } = Zc, XU = Wj, { printClosingTag: YU, printClosingTagSuffix: KU, needsToBorrowPrevClosingTagEndMarker: QU, printOpeningTagPrefix: ZU, printOpeningTag: ez } = FU, { printImgSrcset: tz, printClassNames: nz } = NU, { printVueFor: rz, printVueBindings: oz, isVueEventBindingExpression: iz } = PU, { isScriptLikeTag: uz, isVueNonHtmlBlock: sz, inferScriptParser: az, htmlTrimPreserveIndentation: cz, dedentString: lz, unescapeQuoteEntities: pz, isVueSlotAttribute: fz, isVueSfcBindingsAttribute: dz, getTextValueParts: hz } = fq, gz = RU;
    function mz(e2, t3, n2) {
      const r2 = (t4) => new RegExp(t4.join("|")).test(e2.fullName), o2 = () => pz(e2.value);
      let i2 = false;
      const u2 = (e3, t4) => {
        const n3 = e3.type === "NGRoot" ? e3.node.type === "NGMicrosyntax" && e3.node.body.length === 1 && e3.node.body[0].type === "NGMicrosyntaxExpression" ? e3.node.body[0].expression : e3.node : e3.type === "JsExpressionRoot" ? e3.node : e3;
        !n3 || n3.type !== "ObjectExpression" && n3.type !== "ArrayExpression" && (t4.parser !== "__vue_expression" || n3.type !== "TemplateLiteral" && n3.type !== "StringLiteral") || (i2 = true);
      }, s2 = function(e3) {
        let t4 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
        return $U([qU([GU, e3]), t4 ? GU : ""]);
      }, a2 = (e3) => i2 ? ((e4) => $U(e4))(e3) : s2(e3), c2 = (e3, n3) => t3(e3, Object.assign({ __onHtmlBindingRoot: u2, __embeddedInHtml: true }, n3), { stripTrailingHardline: true });
      if (e2.fullName === "srcset" && (e2.parent.fullName === "img" || e2.parent.fullName === "source"))
        return s2(tz(o2()));
      if (e2.fullName === "class" && !n2.parentParser) {
        const e3 = o2();
        if (!e3.includes("{{"))
          return nz(e3);
      }
      if (e2.fullName === "style" && !n2.parentParser) {
        const e3 = o2();
        if (!e3.includes("{{"))
          return s2(c2(e3, { parser: "css", __isHTMLStyleAttribute: true }));
      }
      if (n2.parser === "vue") {
        if (e2.fullName === "v-for")
          return rz(o2(), c2);
        if (fz(e2) || dz(e2, n2))
          return oz(o2(), c2);
        const t4 = ["^:", "^v-bind:"], i3 = ["^v-"];
        if (r2(["^@", "^v-on:"])) {
          const e3 = o2();
          return a2(c2(e3, { parser: iz(e3) ? "__js_expression" : "__vue_event_binding" }));
        }
        if (r2(t4))
          return a2(c2(o2(), { parser: "__vue_expression" }));
        if (r2(i3))
          return a2(c2(o2(), { parser: "__js_expression" }));
      }
      if (n2.parser === "angular") {
        const t4 = (e3, t5) => c2(e3, Object.assign(Object.assign({}, t5), {}, { trailingComma: "none" })), n3 = ["^\\*"], i3 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], u3 = ["^i18n(-.+)?$"];
        if (r2(["^\\(.+\\)$", "^on-"]))
          return a2(t4(o2(), { parser: "__ng_action" }));
        if (r2(i3))
          return a2(t4(o2(), { parser: "__ng_binding" }));
        if (r2(u3)) {
          const t5 = o2().trim();
          return s2(zU(hz(e2, t5)), !t5.includes("@@"));
        }
        if (r2(n3))
          return a2(t4(o2(), { parser: "__ng_directive" }));
        const l2 = /{{(.+?)}}/s, p2 = o2();
        if (l2.test(p2)) {
          const e3 = [];
          for (const [n4, r3] of p2.split(l2).entries())
            if (n4 % 2 == 0)
              e3.push(JU(r3));
            else
              try {
                e3.push($U(["{{", qU([UU, t4(r3, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), UU, "}}"]));
              } catch {
                e3.push("{{", JU(r3), "}}");
              }
          return $U(e3);
        }
      }
      return null;
    }
    var yz = function(e2, t3, n2, r2) {
      const o2 = e2.getValue();
      switch (o2.type) {
        case "element":
          if (uz(o2) || o2.type === "interpolation")
            return;
          if (!o2.isSelfClosing && sz(o2, r2)) {
            const i2 = az(o2, r2);
            if (!i2)
              return;
            const u2 = gz(o2, r2);
            let s2 = /^\s*$/.test(u2), a2 = "";
            return s2 || (a2 = n2(cz(u2), { parser: i2, __embeddedInHtml: true }, { stripTrailingHardline: true }), s2 = a2 === ""), [ZU(o2, r2), $U(ez(e2, r2, t3)), s2 ? "" : WU, a2, s2 ? "" : WU, YU(o2, r2), KU(o2, r2)];
          }
          break;
        case "text":
          if (uz(o2.parent)) {
            const e3 = az(o2.parent);
            if (e3) {
              const t4 = e3 === "markdown" ? lz(o2.value.replace(/^[^\S\n]*?\n/, "")) : o2.value, i2 = { parser: e3, __embeddedInHtml: true };
              if (r2.parser === "html" && e3 === "babel") {
                let e4 = "script";
                const { attrMap: t5 } = o2.parent;
                t5 && (t5.type === "module" || t5.type === "text/babel" && t5["data-type"] === "module") && (e4 = "module"), i2.__babelSourceType = e4;
              }
              return [VU, ZU(o2, r2), n2(t4, i2, { stripTrailingHardline: true }), KU(o2, r2)];
            }
          } else if (o2.parent.type === "interpolation") {
            const e3 = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
            return r2.parser === "angular" ? (e3.parser = "__ng_interpolation", e3.trailingComma = "none") : r2.parser === "vue" ? e3.parser = "__vue_expression" : e3.parser = "__js_expression", [qU([UU, n2(o2.value, e3, { stripTrailingHardline: true })]), o2.parent.next && QU(o2.parent.next) ? " " : UU];
          }
          break;
        case "attribute": {
          if (!o2.value)
            break;
          if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r2.originalText.slice(o2.valueSpan.start.offset, o2.valueSpan.end.offset)))
            return [o2.rawName, "=", o2.value];
          if (r2.parser === "lwc") {
            if (/^{.*}$/s.test(r2.originalText.slice(o2.valueSpan.start.offset, o2.valueSpan.end.offset)))
              return [o2.rawName, "=", o2.value];
          }
          const e3 = mz(o2, (e4, t4) => n2(e4, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, t4), { stripTrailingHardline: true }), r2);
          if (e3)
            return [o2.rawName, '="', $U(HU(e3, (e4) => typeof e4 == "string" ? e4.replace(/"/g, "&quot;") : e4)), '"'];
          break;
        }
        case "front-matter":
          return XU(o2, n2);
      }
    };
    const { builders: { breakParent: Dz, group: Ez, ifBreak: Cz, line: bz, softline: vz, hardline: Az }, utils: { replaceTextEndOfLine: Fz } } = Zc, { locStart: xz, locEnd: Sz } = zq, { forceBreakChildren: wz, forceNextEmptyLine: Tz, isTextLikeNode: Bz, hasPrettierIgnore: Nz, preferHardlineAsLeadingSpaces: kz } = fq, { printOpeningTagPrefix: Pz, needsToBorrowNextOpeningTagStartMarker: Oz, printOpeningTagStartMarker: Iz, needsToBorrowPrevClosingTagEndMarker: Lz, printClosingTagEndMarker: jz, printClosingTagSuffix: _z, needsToBorrowParentClosingTagStartMarker: Mz } = FU;
    function Rz(e2, t3, n2) {
      const r2 = e2.getValue();
      return Nz(r2) ? [Pz(r2, t3), ...Fz(t3.originalText.slice(xz(r2) + (r2.prev && Oz(r2.prev) ? Iz(r2).length : 0), Sz(r2) - (r2.next && Lz(r2.next) ? jz(r2, t3).length : 0))), _z(r2, t3)] : n2();
    }
    function Vz(e2, t3) {
      return Bz(e2) && Bz(t3) ? e2.isTrailingSpaceSensitive ? e2.hasTrailingSpaces ? kz(t3) ? Az : bz : "" : kz(t3) ? Az : vz : Oz(e2) && (Nz(t3) || t3.firstChild || t3.isSelfClosing || t3.type === "element" && t3.attrs.length > 0) || e2.type === "element" && e2.isSelfClosing && Lz(t3) ? "" : !t3.isLeadingSpaceSensitive || kz(t3) || Lz(t3) && e2.lastChild && Mz(e2.lastChild) && e2.lastChild.lastChild && Mz(e2.lastChild.lastChild) ? Az : t3.hasLeadingSpaces ? bz : vz;
    }
    var $z = { printChildren: function(e2, t3, n2) {
      const r2 = e2.getValue();
      if (wz(r2))
        return [Dz, ...e2.map((e3) => {
          const r3 = e3.getValue(), o3 = r3.prev ? Vz(r3.prev, r3) : "";
          return [o3 ? [o3, Tz(r3.prev) ? Az : ""] : "", Rz(e3, t3, n2)];
        }, "children")];
      const o2 = r2.children.map(() => Symbol(""));
      return e2.map((e3, r3) => {
        const i2 = e3.getValue();
        if (Bz(i2)) {
          if (i2.prev && Bz(i2.prev)) {
            const r4 = Vz(i2.prev, i2);
            if (r4)
              return Tz(i2.prev) ? [Az, Az, Rz(e3, t3, n2)] : [r4, Rz(e3, t3, n2)];
          }
          return Rz(e3, t3, n2);
        }
        const u2 = [], s2 = [], a2 = [], c2 = [], l2 = i2.prev ? Vz(i2.prev, i2) : "", p2 = i2.next ? Vz(i2, i2.next) : "";
        return l2 && (Tz(i2.prev) ? u2.push(Az, Az) : l2 === Az ? u2.push(Az) : Bz(i2.prev) ? s2.push(l2) : s2.push(Cz("", vz, { groupId: o2[r3 - 1] }))), p2 && (Tz(i2) ? Bz(i2.next) && c2.push(Az, Az) : p2 === Az ? Bz(i2.next) && c2.push(Az) : a2.push(p2)), [...u2, Ez([...s2, Ez([Rz(e3, t3, n2), ...a2], { id: o2[r3] })]), ...c2];
      }, "children");
    } };
    const { builders: { breakParent: Wz, dedentToRoot: qz, group: Uz, ifBreak: zz, indentIfBreak: Gz, indent: Hz, line: Jz, softline: Xz }, utils: { replaceTextEndOfLine: Yz } } = Zc, Kz = RU, { shouldPreserveContent: Qz, isScriptLikeTag: Zz, isVueCustomBlock: eG, countParents: tG, forceBreakContent: nG } = fq, { printOpeningTagPrefix: rG, printOpeningTag: oG, printClosingTagSuffix: iG, printClosingTag: uG, needsToBorrowPrevClosingTagEndMarker: sG, needsToBorrowLastChildClosingTagEndMarker: aG } = FU, { printChildren: cG } = $z;
    var lG = { printElement: function(e2, t3, n2) {
      const r2 = e2.getValue();
      if (Qz(r2, t3))
        return [rG(r2, t3), Uz(oG(e2, t3, n2)), ...Yz(Kz(r2, t3)), ...uG(r2, t3), iG(r2, t3)];
      const o2 = r2.children.length === 1 && r2.firstChild.type === "interpolation" && r2.firstChild.isLeadingSpaceSensitive && !r2.firstChild.hasLeadingSpaces && r2.lastChild.isTrailingSpaceSensitive && !r2.lastChild.hasTrailingSpaces, i2 = Symbol("element-attr-group-id"), u2 = (o3) => Uz([Uz(oG(e2, t3, n2), { id: i2 }), o3, uG(r2, t3)]);
      return r2.children.length === 0 ? u2(r2.hasDanglingSpaces && r2.isDanglingSpaceSensitive ? Jz : "") : u2([nG(r2) ? Wz : "", (s2 = [o2 ? zz(Xz, "", { groupId: i2 }) : r2.firstChild.hasLeadingSpaces && r2.firstChild.isLeadingSpaceSensitive ? Jz : r2.firstChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive ? qz(Xz) : Xz, cG(e2, t3, n2)], o2 ? Gz(s2, { groupId: i2 }) : !Zz(r2) && !eG(r2, t3) || r2.parent.type !== "root" || t3.parser !== "vue" || t3.vueIndentScriptAndStyle ? Hz(s2) : s2), (r2.next ? sG(r2.next) : aG(r2.parent)) ? r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? " " : "" : o2 ? zz(Xz, "", { groupId: i2 }) : r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? Jz : (r2.lastChild.type === "comment" || r2.lastChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(t3.tabWidth * tG(e2, (e3) => e3.parent && e3.parent.type !== "root"), "}$")).test(r2.lastChild.value) ? "" : Xz]);
      var s2;
    } };
    const { builders: { fill: pG, group: fG, hardline: dG, literalline: hG }, utils: { cleanDoc: gG, getDocParts: mG, isConcat: yG, replaceTextEndOfLine: DG } } = Zc, EG = xW, { countChars: CG, unescapeQuoteEntities: bG, getTextValueParts: vG } = fq, AG = qq, { insertPragma: FG } = Uq, { locStart: xG, locEnd: SG } = zq, wG = yz, { printClosingTagSuffix: TG, printClosingTagEnd: BG, printOpeningTagPrefix: NG, printOpeningTagStart: kG } = FU, { printElement: PG } = lG, { printChildren: OG } = $z;
    var IG = { preprocess: AG, print: function(e2, t3, n2) {
      const r2 = e2.getValue();
      switch (r2.type) {
        case "front-matter":
          return DG(r2.raw);
        case "root":
          return t3.__onHtmlRoot && t3.__onHtmlRoot(r2), [fG(OG(e2, t3, n2)), dG];
        case "element":
        case "ieConditionalComment":
          return PG(e2, t3, n2);
        case "ieConditionalStartComment":
        case "ieConditionalEndComment":
          return [kG(r2), BG(r2)];
        case "interpolation":
          return [kG(r2, t3), ...e2.map(n2, "children"), BG(r2, t3)];
        case "text": {
          if (r2.parent.type === "interpolation") {
            const e4 = /\n[^\S\n]*?$/, t4 = e4.test(r2.value), n3 = t4 ? r2.value.replace(e4, "") : r2.value;
            return [...DG(n3), t4 ? dG : ""];
          }
          const e3 = gG([NG(r2, t3), ...vG(r2), TG(r2, t3)]);
          return yG(e3) || e3.type === "fill" ? pG(mG(e3)) : e3;
        }
        case "docType":
          return [fG([kG(r2, t3), " ", r2.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), BG(r2, t3)];
        case "comment":
          return [NG(r2, t3), ...DG(t3.originalText.slice(xG(r2), SG(r2)), hG), TG(r2, t3)];
        case "attribute": {
          if (r2.value === null)
            return r2.rawName;
          const e3 = bG(r2.value), t4 = CG(e3, "'") < CG(e3, '"') ? "'" : '"';
          return [r2.rawName, "=", t4, ...DG(t4 === '"' ? e3.replace(/"/g, "&quot;") : e3.replace(/'/g, "&apos;")), t4];
        }
        default:
          throw new Error("Unexpected node type ".concat(r2.type));
      }
    }, insertPragma: FG, massageAstNode: EG, embed: wG };
    const LG = "HTML";
    var jG = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 }, _G = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
    const MG = bE, RG = IG, VG = { bracketSameLine: bj.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: LG, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, vueIndentScriptAndStyle: { since: "1.19.0", category: LG, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } }, $G = [MG(jG, () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), MG(jG, (e2) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...e2.extensions, ".mjml"] })), MG(jG, () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), MG(_G, () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))];
    var WG = { languages: $G, printers: { html: RG }, options: VG, parsers: void 0 };
    var qG = { isPragma: function(e2) {
      return /^\s*@(?:prettier|format)\s*$/.test(e2);
    }, hasPragma: function(e2) {
      return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(e2);
    }, insertPragma: function(e2) {
      return "# @format\n\n".concat(e2);
    } };
    var UG = { locStart: function(e2) {
      return e2.position.start.offset;
    }, locEnd: function(e2) {
      return e2.position.end.offset;
    } };
    var zG = function(e2, t3, n2, r2) {
      if (e2.getValue().type === "root" && r2.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(r2.filepath))
        return n2(r2.originalText, Object.assign(Object.assign({}, r2), {}, { parser: "json" }));
    };
    const { getLast: GG, isNonEmptyArray: HG } = dc;
    function JG(e2, t3) {
      return e2 && typeof e2.type == "string" && (!t3 || t3.includes(e2.type));
    }
    function XG(e2) {
      return e2.value.trim() === "prettier-ignore";
    }
    function YG(e2) {
      return e2 && HG(e2.leadingComments);
    }
    function KG(e2) {
      return e2 && HG(e2.middleComments);
    }
    function QG(e2) {
      return e2 && e2.indicatorComment;
    }
    function ZG(e2) {
      return e2 && e2.trailingComment;
    }
    function eH(e2) {
      return e2 && HG(e2.endComments);
    }
    function tH(e2) {
      const t3 = [];
      let n2;
      for (const r2 of e2.split(/( +)/))
        r2 !== " " ? n2 === " " ? t3.push(r2) : t3.push((t3.pop() || "") + r2) : n2 === void 0 && t3.unshift(""), n2 = r2;
      return n2 === " " && t3.push((t3.pop() || "") + " "), t3[0] === "" && (t3.shift(), t3.unshift(" " + (t3.shift() || ""))), t3;
    }
    var nH = { getLast: GG, getAncestorCount: function(e2, t3) {
      let n2 = 0;
      const r2 = e2.stack.length - 1;
      for (let o2 = 0; o2 < r2; o2++) {
        const r3 = e2.stack[o2];
        JG(r3) && t3(r3) && n2++;
      }
      return n2;
    }, isNode: JG, isEmptyNode: function(e2) {
      return !HG(e2.children) && !function(e3) {
        return YG(e3) || KG(e3) || QG(e3) || ZG(e3) || eH(e3);
      }(e2);
    }, isInlineNode: function(e2) {
      if (!e2)
        return true;
      switch (e2.type) {
        case "plain":
        case "quoteDouble":
        case "quoteSingle":
        case "alias":
        case "flowMapping":
        case "flowSequence":
          return true;
        default:
          return false;
      }
    }, mapNode: function e2(t3, n2, r2) {
      return n2("children" in t3 ? Object.assign(Object.assign({}, t3), {}, { children: t3.children.map((r3) => e2(r3, n2, t3)) }) : t3, r2);
    }, defineShortcut: function(e2, t3, n2) {
      Object.defineProperty(e2, t3, { get: n2, enumerable: false });
    }, isNextLineEmpty: function(e2, t3) {
      let n2 = 0;
      const r2 = t3.length;
      for (let o2 = e2.position.end.offset - 1; o2 < r2; o2++) {
        const e3 = t3[o2];
        if (e3 === "\n" && n2++, n2 === 1 && /\S/.test(e3))
          return false;
        if (n2 === 2)
          return true;
      }
      return false;
    }, isLastDescendantNode: function(e2) {
      switch (e2.getValue().type) {
        case "tag":
        case "anchor":
        case "comment":
          return false;
      }
      const t3 = e2.stack.length;
      for (let n2 = 1; n2 < t3; n2++) {
        const t4 = e2.stack[n2], r2 = e2.stack[n2 - 1];
        if (Array.isArray(r2) && typeof t4 == "number" && t4 !== r2.length - 1)
          return false;
      }
      return true;
    }, getBlockValueLineContents: function(e2, t3) {
      let { parentIndent: n2, isLastDescendant: r2, options: o2 } = t3;
      const i2 = e2.position.start.line === e2.position.end.line ? "" : o2.originalText.slice(e2.position.start.offset, e2.position.end.offset).match(/^[^\n]*?\n(.*)$/s)[1], u2 = e2.indent === null ? ((e3) => e3 ? e3[1].length : Number.POSITIVE_INFINITY)(i2.match(/^( *)\S/m)) : e2.indent - 1 + n2, s2 = i2.split("\n").map((e3) => e3.slice(u2));
      return o2.proseWrap === "preserve" || e2.type === "blockLiteral" ? a2(s2.map((e3) => e3.length === 0 ? [] : [e3])) : a2(s2.map((e3) => e3.length === 0 ? [] : tH(e3)).reduce((e3, t4, n3) => n3 !== 0 && s2[n3 - 1].length > 0 && t4.length > 0 && !/^\s/.test(t4[0]) && !/^\s|\s$/.test(GG(e3)) ? [...e3.slice(0, -1), [...GG(e3), ...t4]] : [...e3, t4], []).map((e3) => e3.reduce((e4, t4) => e4.length > 0 && /\s$/.test(GG(e4)) ? [...e4.slice(0, -1), GG(e4) + " " + t4] : [...e4, t4], [])).map((e3) => o2.proseWrap === "never" ? [e3.join(" ")] : e3));
      function a2(t4) {
        if (e2.chomping === "keep")
          return GG(t4).length === 0 ? t4.slice(0, -1) : t4;
        let n3 = 0;
        for (let e3 = t4.length - 1; e3 >= 0 && t4[e3].length === 0; e3--)
          n3++;
        return n3 === 0 ? t4 : n3 >= 2 && !r2 ? t4.slice(0, -(n3 - 1)) : t4.slice(0, -n3);
      }
    }, getFlowScalarLineContents: function(e2, t3, n2) {
      const r2 = t3.split("\n").map((e3, t4, n3) => t4 === 0 && t4 === n3.length - 1 ? e3 : t4 !== 0 && t4 !== n3.length - 1 ? e3.trim() : t4 === 0 ? e3.trimEnd() : e3.trimStart());
      return n2.proseWrap === "preserve" ? r2.map((e3) => e3.length === 0 ? [] : [e3]) : r2.map((e3) => e3.length === 0 ? [] : tH(e3)).reduce((t4, n3, o2) => o2 !== 0 && r2[o2 - 1].length > 0 && n3.length > 0 && (e2 !== "quoteDouble" || !GG(GG(t4)).endsWith("\\")) ? [...t4.slice(0, -1), [...GG(t4), ...n3]] : [...t4, n3], []).map((e3) => n2.proseWrap === "never" ? [e3.join(" ")] : e3);
    }, getLastDescendantNode: function e2(t3) {
      return HG(t3.children) ? e2(GG(t3.children)) : t3;
    }, hasPrettierIgnore: function(e2) {
      const t3 = e2.getValue();
      if (t3.type === "documentBody") {
        const t4 = e2.getParentNode();
        return eH(t4.head) && XG(GG(t4.head.endComments));
      }
      return YG(t3) && XG(GG(t3.leadingComments));
    }, hasLeadingComments: YG, hasMiddleComments: KG, hasIndicatorComment: QG, hasTrailingComment: ZG, hasEndComments: eH };
    const { defineShortcut: rH, mapNode: oH } = nH;
    function iH(e2) {
      switch (e2.type) {
        case "document":
          rH(e2, "head", () => e2.children[0]), rH(e2, "body", () => e2.children[1]);
          break;
        case "documentBody":
        case "sequenceItem":
        case "flowSequenceItem":
        case "mappingKey":
        case "mappingValue":
          rH(e2, "content", () => e2.children[0]);
          break;
        case "mappingItem":
        case "flowMappingItem":
          rH(e2, "key", () => e2.children[0]), rH(e2, "value", () => e2.children[1]);
      }
      return e2;
    }
    var uH = function(e2) {
      return oH(e2, iH);
    };
    const { builders: { softline: sH, align: aH } } = Zc, { hasEndComments: cH, isNextLineEmpty: lH, isNode: pH } = nH, fH = /* @__PURE__ */ new WeakMap();
    function dH(e2) {
      return cH(e2) && !pH(e2, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
    }
    var hH = { alignWithSpaces: function(e2, t3) {
      return aH(" ".repeat(e2), t3);
    }, shouldPrintEndComments: dH, printNextEmptyLine: function(e2, t3) {
      const n2 = e2.getValue(), r2 = e2.stack[0];
      let o2;
      return fH.has(r2) ? o2 = fH.get(r2) : (o2 = /* @__PURE__ */ new Set(), fH.set(r2, o2)), o2.has(n2.position.end.line) || (o2.add(n2.position.end.line), !lH(n2, t3) || dH(e2.getParentNode())) ? "" : sH;
    } };
    const { builders: { ifBreak: gH, line: mH, softline: yH, hardline: DH, join: EH } } = Zc, { isEmptyNode: CH, getLast: bH, hasEndComments: vH } = nH, { printNextEmptyLine: AH, alignWithSpaces: FH } = hH;
    function xH(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = r2.type === "flowMapping", i2 = o2 ? "{" : "[", u2 = o2 ? "}" : "]";
      let s2 = yH;
      o2 && r2.children.length > 0 && n2.bracketSpacing && (s2 = mH);
      const a2 = bH(r2.children), c2 = a2 && a2.type === "flowMappingItem" && CH(a2.key) && CH(a2.value);
      return [i2, FH(n2.tabWidth, [s2, SH(e2, t3, n2), n2.trailingComma === "none" ? "" : gH(","), vH(r2) ? [DH, EH(DH, e2.map(t3, "endComments"))] : ""]), c2 ? "" : s2, u2];
    }
    function SH(e2, t3, n2) {
      const r2 = e2.getValue();
      return e2.map((e3, o2) => [t3(), o2 === r2.children.length - 1 ? "" : [",", mH, r2.children[o2].position.start.line !== r2.children[o2 + 1].position.start.line ? AH(e3, n2.originalText) : ""]], "children");
    }
    var wH = { printFlowMapping: xH, printFlowSequence: xH };
    const { builders: { conditionalGroup: TH, group: BH, hardline: NH, ifBreak: kH, join: PH, line: OH } } = Zc, { hasLeadingComments: IH, hasMiddleComments: LH, hasTrailingComment: jH, hasEndComments: _H, isNode: MH, isEmptyNode: RH, isInlineNode: VH } = nH, { alignWithSpaces: $H } = hH;
    function WH(e2, t3) {
      if (!e2)
        return true;
      switch (e2.type) {
        case "plain":
        case "quoteSingle":
        case "quoteDouble":
          break;
        case "alias":
          return true;
        default:
          return false;
      }
      if (t3.proseWrap === "preserve")
        return e2.position.start.line === e2.position.end.line;
      if (/\\$/m.test(t3.originalText.slice(e2.position.start.offset, e2.position.end.offset)))
        return false;
      switch (t3.proseWrap) {
        case "never":
          return !e2.value.includes("\n");
        case "always":
          return !/[\n ]/.test(e2.value);
        default:
          return false;
      }
    }
    var qH = function(e2, t3, n2, r2, o2) {
      const { key: i2, value: u2 } = e2, s2 = RH(i2), a2 = RH(u2);
      if (s2 && a2)
        return ": ";
      const c2 = r2("key"), l2 = function(e3) {
        return e3.key.content && e3.key.content.type === "alias";
      }(e2) ? " " : "";
      if (a2)
        return e2.type === "flowMappingItem" && t3.type === "flowMapping" ? c2 : e2.type !== "mappingItem" || !WH(i2.content, o2) || jH(i2.content) || t3.tag && t3.tag.value === "tag:yaml.org,2002:set" ? ["? ", $H(2, c2)] : [c2, l2, ":"];
      const p2 = r2("value");
      if (s2)
        return [": ", $H(2, p2)];
      if (IH(u2) || !VH(i2.content))
        return ["? ", $H(2, c2), NH, PH("", n2.map(r2, "value", "leadingComments").map((e3) => [e3, NH])), ": ", $H(2, p2)];
      if (function(e3) {
        if (!e3)
          return true;
        switch (e3.type) {
          case "plain":
          case "quoteDouble":
          case "quoteSingle":
            return e3.position.start.line === e3.position.end.line;
          case "alias":
            return true;
          default:
            return false;
        }
      }(i2.content) && !IH(i2.content) && !LH(i2.content) && !jH(i2.content) && !_H(i2) && !IH(u2.content) && !LH(u2.content) && !_H(u2) && WH(u2.content, o2))
        return [c2, l2, ": ", p2];
      const f2 = Symbol("mappingKey"), d2 = BH([kH("? "), BH($H(2, c2), { id: f2 })]), h2 = [NH, ": ", $H(2, p2)], g2 = [l2, ":"];
      IH(u2.content) || _H(u2) && u2.content && !MH(u2.content, ["mapping", "sequence"]) || t3.type === "mapping" && jH(i2.content) && VH(u2.content) || MH(u2.content, ["mapping", "sequence"]) && u2.content.tag === null && u2.content.anchor === null ? g2.push(NH) : u2.content && g2.push(OH), g2.push(p2);
      const m2 = $H(o2.tabWidth, g2);
      return !WH(i2.content, o2) || IH(i2.content) || LH(i2.content) || _H(i2) ? TH([[d2, kH(h2, m2, { groupId: f2 })]]) : TH([[c2, m2]]);
    };
    const { builders: { dedent: UH, dedentToRoot: zH, fill: GH, hardline: HH, join: JH, line: XH, literalline: YH, markAsRoot: KH }, utils: { getDocParts: QH } } = Zc, { getAncestorCount: ZH, getBlockValueLineContents: eJ, hasIndicatorComment: tJ, isLastDescendantNode: nJ, isNode: rJ } = nH, { alignWithSpaces: oJ } = hH;
    var iJ = function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = ZH(e2, (e3) => rJ(e3, ["sequence", "mapping"])), i2 = nJ(e2), u2 = [r2.type === "blockFolded" ? ">" : "|"];
      r2.indent !== null && u2.push(r2.indent.toString()), r2.chomping !== "clip" && u2.push(r2.chomping === "keep" ? "+" : "-"), tJ(r2) && u2.push(" ", t3("indicatorComment"));
      const s2 = eJ(r2, { parentIndent: o2, isLastDescendant: i2, options: n2 }), a2 = [];
      for (const [e3, t4] of s2.entries())
        e3 === 0 && a2.push(HH), a2.push(GH(QH(JH(XH, t4)))), e3 !== s2.length - 1 ? a2.push(t4.length === 0 ? HH : KH(YH)) : r2.chomping === "keep" && i2 && a2.push(zH(t4.length === 0 ? HH : YH));
      return r2.indent === null ? u2.push(UH(oJ(n2.tabWidth, a2))) : u2.push(zH(oJ(r2.indent - 1 + o2, a2))), u2;
    };
    const { builders: { breakParent: uJ, fill: sJ, group: aJ, hardline: cJ, join: lJ, line: pJ, lineSuffix: fJ, literalline: dJ }, utils: { getDocParts: hJ, replaceTextEndOfLine: gJ } } = Zc, { isPreviousLineEmpty: mJ } = dc, { insertPragma: yJ, isPragma: DJ } = qG, { locStart: EJ } = UG, CJ = zG, { getFlowScalarLineContents: bJ, getLastDescendantNode: vJ, hasLeadingComments: AJ, hasMiddleComments: FJ, hasTrailingComment: xJ, hasEndComments: SJ, hasPrettierIgnore: wJ, isLastDescendantNode: TJ, isNode: BJ, isInlineNode: NJ } = nH, kJ = uH, { alignWithSpaces: PJ, printNextEmptyLine: OJ, shouldPrintEndComments: IJ } = hH, { printFlowMapping: LJ, printFlowSequence: jJ } = wH, _J = qH, MJ = iJ;
    function RJ(e2, t3) {
      return xJ(e2) || t3 && (t3.head.children.length > 0 || SJ(t3.head));
    }
    function VJ(e2, t3, n2) {
      const r2 = bJ(e2, t3, n2);
      return lJ(cJ, r2.map((e3) => sJ(hJ(lJ(pJ, e3)))));
    }
    var $J = { preprocess: kJ, embed: CJ, print: function(e2, t3, n2) {
      const r2 = e2.getValue(), o2 = [];
      r2.type !== "mappingValue" && AJ(r2) && o2.push([lJ(cJ, e2.map(n2, "leadingComments")), cJ]);
      const { tag: i2, anchor: u2 } = r2;
      i2 && o2.push(n2("tag")), i2 && u2 && o2.push(" "), u2 && o2.push(n2("anchor"));
      let s2 = "";
      BJ(r2, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !TJ(e2) && (s2 = OJ(e2, t3.originalText)), (i2 || u2) && (BJ(r2, ["sequence", "mapping"]) && !FJ(r2) ? o2.push(cJ) : o2.push(" ")), FJ(r2) && o2.push([r2.middleComments.length === 1 ? "" : cJ, lJ(cJ, e2.map(n2, "middleComments")), cJ]);
      const a2 = e2.getParentNode();
      return wJ(e2) ? o2.push(gJ(t3.originalText.slice(r2.position.start.offset, r2.position.end.offset).trimEnd(), dJ)) : o2.push(aJ(function(e3, t4, n3, r3, o3) {
        switch (e3.type) {
          case "root": {
            const { children: t5 } = e3, r4 = [];
            n3.each((e4, n4) => {
              const i4 = t5[n4], u3 = t5[n4 + 1];
              n4 !== 0 && r4.push(cJ), r4.push(o3()), RJ(i4, u3) ? (r4.push(cJ, "..."), xJ(i4) && r4.push(" ", o3("trailingComment"))) : u3 && !xJ(u3.head) && r4.push(cJ, "---");
            }, "children");
            const i3 = vJ(e3);
            return BJ(i3, ["blockLiteral", "blockFolded"]) && i3.chomping === "keep" || r4.push(cJ), r4;
          }
          case "document": {
            const i3 = [];
            return function(e4, t5, n4, r4) {
              if (n4.children[0] === e4 && /---(?:\s|$)/.test(r4.originalText.slice(EJ(e4), EJ(e4) + 4)) || e4.head.children.length > 0 || SJ(e4.head) || xJ(e4.head))
                return "head";
              if (RJ(e4, t5))
                return false;
              return !!t5 && "root";
            }(e3, t4.children[n3.getName() + 1], t4, r3) === "head" && ((e3.head.children.length > 0 || e3.head.endComments.length > 0) && i3.push(o3("head")), xJ(e3.head) ? i3.push(["---", " ", o3(["head", "trailingComment"])]) : i3.push("---")), function(e4) {
              return e4.body.children.length > 0 || SJ(e4.body);
            }(e3) && i3.push(o3("body")), lJ(cJ, i3);
          }
          case "documentHead":
            return lJ(cJ, [...n3.map(o3, "children"), ...n3.map(o3, "endComments")]);
          case "documentBody": {
            const { children: t5, endComments: r4 } = e3;
            let i3 = "";
            if (t5.length > 0 && r4.length > 0) {
              const t6 = vJ(e3);
              BJ(t6, ["blockFolded", "blockLiteral"]) ? t6.chomping !== "keep" && (i3 = [cJ, cJ]) : i3 = cJ;
            }
            return [lJ(cJ, n3.map(o3, "children")), i3, lJ(cJ, n3.map(o3, "endComments"))];
          }
          case "directive":
            return ["%", lJ(" ", [e3.name, ...e3.parameters])];
          case "comment":
            return ["#", e3.value];
          case "alias":
            return ["*", e3.value];
          case "tag":
            return r3.originalText.slice(e3.position.start.offset, e3.position.end.offset);
          case "anchor":
            return ["&", e3.value];
          case "plain":
            return VJ(e3.type, r3.originalText.slice(e3.position.start.offset, e3.position.end.offset), r3);
          case "quoteDouble":
          case "quoteSingle": {
            const t5 = "'", n4 = '"', o4 = r3.originalText.slice(e3.position.start.offset + 1, e3.position.end.offset - 1);
            if (e3.type === "quoteSingle" && o4.includes("\\") || e3.type === "quoteDouble" && /\\[^"]/.test(o4)) {
              const i4 = e3.type === "quoteDouble" ? n4 : t5;
              return [i4, VJ(e3.type, o4, r3), i4];
            }
            if (o4.includes(n4))
              return [t5, VJ(e3.type, e3.type === "quoteDouble" ? o4.replace(/\\"/g, n4).replace(/'/g, t5.repeat(2)) : o4, r3), t5];
            if (o4.includes(t5))
              return [n4, VJ(e3.type, e3.type === "quoteSingle" ? o4.replace(/''/g, t5) : o4, r3), n4];
            const i3 = r3.singleQuote ? t5 : n4;
            return [i3, VJ(e3.type, o4, r3), i3];
          }
          case "blockFolded":
          case "blockLiteral":
            return MJ(n3, o3, r3);
          case "mapping":
          case "sequence":
            return lJ(cJ, n3.map(o3, "children"));
          case "sequenceItem":
            return ["- ", PJ(2, e3.content ? o3("content") : "")];
          case "mappingKey":
          case "mappingValue":
            return e3.content ? o3("content") : "";
          case "mappingItem":
          case "flowMappingItem":
            return _J(e3, t4, n3, o3, r3);
          case "flowMapping":
            return LJ(n3, o3, r3);
          case "flowSequence":
            return jJ(n3, o3, r3);
          case "flowSequenceItem":
            return o3("content");
          default:
            throw new Error("Unexpected node type ".concat(e3.type));
        }
      }(r2, a2, e2, t3, n2))), xJ(r2) && !BJ(r2, ["document", "documentHead"]) && o2.push(fJ([r2.type !== "mappingValue" || r2.content ? " " : "", a2.type === "mappingKey" && e2.getParentNode(2).type === "mapping" && NJ(r2) ? "" : uJ, n2("trailingComment")])), IJ(r2) && o2.push(PJ(r2.type === "sequenceItem" ? 2 : 0, [cJ, lJ(cJ, e2.map((e3) => [mJ(t3.originalText, e3.getValue(), EJ) ? cJ : "", n2()], "endComments"))])), o2.push(s2), o2;
    }, massageAstNode: function(e2, t3) {
      if (BJ(t3))
        switch (delete t3.position, t3.type) {
          case "comment":
            if (DJ(t3.value))
              return null;
            break;
          case "quoteDouble":
          case "quoteSingle":
            t3.type = "quote";
        }
    }, insertPragma: yJ };
    const WJ = $J, qJ = { bracketSpacing: bj.bracketSpacing, singleQuote: bj.singleQuote, proseWrap: bj.proseWrap }, UJ = [bE({ name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 }, (e2) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...e2.filenames.filter((e3) => e3 !== "yarn.lock"), ".prettierrc", ".stylelintrc"] }))];
    var zJ = [Ij, QM, fV, IV, bW, WG, { languages: UJ, printers: { yaml: WJ }, options: qJ, parsers: void 0 }];
    const { version: GJ } = n, HJ = XD, { getSupportInfo: JJ } = za, XJ = EE, YJ = zJ, KJ = Zc;
    function QJ(e2) {
      let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      return function() {
        for (var n2 = arguments.length, r2 = new Array(n2), o2 = 0; o2 < n2; o2++)
          r2[o2] = arguments[o2];
        const i2 = r2[t3] || {}, u2 = i2.plugins || [];
        return r2[t3] = Object.assign(Object.assign({}, i2), {}, { plugins: [...YJ, ...Array.isArray(u2) ? u2 : Object.values(u2)] }), e2(...r2);
      };
    }
    const ZJ = QJ(HJ.formatWithCursor);
    var eX = { formatWithCursor: ZJ, format: (e2, t3) => ZJ(e2, t3).formatted, check(e2, t3) {
      const { formatted: n2 } = ZJ(e2, t3);
      return n2 === e2;
    }, doc: KJ, getSupportInfo: QJ(JJ, 0), version: GJ, util: XJ, __debug: { parse: QJ(HJ.parse), formatAST: QJ(HJ.formatAST), formatDoc: QJ(HJ.formatDoc), printToDoc: QJ(HJ.printToDoc), printDocToString: QJ(HJ.printDocToString) } };
    return eX;
  });
})(standalone);
var prettier = /* @__PURE__ */ getDefaultExportFromCjs(standalone.exports);
let nextTagID = 0;
class Tag {
  constructor(set2, base2, modified) {
    this.set = set2;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  static define(parent) {
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new Tag([], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  static defineModifier() {
    let mod = new Modifier();
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
}
let nextModifierID = 0;
class Modifier {
  constructor() {
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray(mods, t2.modified));
    if (exists)
      return exists;
    let set2 = [], tag = new Tag(set2, base2, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = permute(mods);
    for (let parent of base2.set)
      for (let config2 of configs)
        set2.push(Modifier.get(parent, config2));
    return tag;
  }
}
function sameArray(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function permute(array) {
  let result = [array];
  for (let i = 0; i < array.length; i++) {
    for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))
      result.push(a);
  }
  return result;
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop2 in spec) {
    let tags2 = spec[prop2];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part2 of prop2.split(" "))
      if (part2) {
        let pieces = [], mode = 2, rest = part2;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part2.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part2);
          pieces.push(m[0] == "*" ? null : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part2.length)
            break;
          let next = part2[pos++];
          if (pos == part2.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part2);
          rest = part2.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part2);
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
const ruleNodeProp = /* @__PURE__ */ new NodeProp();
const highlightStyle = /* @__PURE__ */ Facet.define({
  combine(stylings) {
    return stylings.length ? HighlightStyle.combinedMatch(stylings) : null;
  }
});
const fallbackHighlightStyle = /* @__PURE__ */ Facet.define({
  combine(values2) {
    return values2.length ? values2[0].match : null;
  }
});
function getHighlightStyle(state) {
  return state.facet(highlightStyle) || state.facet(fallbackHighlightStyle);
}
class Rule {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
class HighlightStyle {
  constructor(spec, options) {
    this.map = /* @__PURE__ */ Object.create(null);
    let modSpec;
    function def(spec2) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec2;
      return cls;
    }
    this.all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : null;
    for (let style of spec) {
      let cls = (style.class || def(Object.assign({}, style, { tag: null }))) + (this.all ? " " + this.all : "");
      let tags2 = style.tag;
      if (!Array.isArray(tags2))
        this.map[tags2.id] = cls;
      else
        for (let tag of tags2)
          this.map[tag.id] = cls;
    }
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.scope = options.scope || null;
    this.match = this.match.bind(this);
    let ext = [treeHighlighter];
    if (this.module)
      ext.push(EditorView.styleModule.of(this.module));
    this.extension = ext.concat(highlightStyle.of(this));
    this.fallback = ext.concat(fallbackHighlightStyle.of(this));
  }
  match(tag, scope) {
    if (this.scope && scope != this.scope)
      return null;
    for (let t2 of tag.set) {
      let match2 = this.map[t2.id];
      if (match2 !== void 0) {
        if (t2 != tag)
          this.map[tag.id] = match2;
        return match2;
      }
    }
    return this.map[tag.id] = this.all;
  }
  static combinedMatch(styles) {
    if (styles.length == 1)
      return styles[0].match;
    let cache = styles.some((s) => s.scope) ? void 0 : /* @__PURE__ */ Object.create(null);
    return (tag, scope) => {
      let cached = cache && cache[tag.id];
      if (cached !== void 0)
        return cached;
      let result = null;
      for (let style of styles) {
        let value = style.match(tag, scope);
        if (value)
          result = result ? result + " " + value : value;
      }
      if (cache)
        cache[tag.id] = result;
      return result;
    };
  }
  static define(specs, options) {
    return new HighlightStyle(specs, options || {});
  }
  static get(state, tag, scope) {
    let style = getHighlightStyle(state);
    return style && style(tag, scope || NodeType.none);
  }
}
class TreeHighlighter {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlightStyle(view.state));
  }
  update(update) {
    let tree = syntaxTree(update.state), style = getHighlightStyle(update.state);
    let styleChange = style != update.startState.facet(highlightStyle);
    if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
      this.decorations = this.decorations.map(update.changes);
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, style);
    }
  }
  buildDeco(view, match2) {
    if (!match2 || !this.tree.length)
      return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let { from, to } of view.visibleRanges) {
      highlightTreeRange(this.tree, from, to, match2, (from2, to2, style) => {
        builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
      });
    }
    return builder.finish();
  }
}
const treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v) => v.decorations
}));
const nodeStack = [""];
class HighlightBuilder {
  constructor(at, style, span2) {
    this.at = at;
    this.style = style;
    this.span = span2;
    this.class = "";
  }
  startSpan(at, cls) {
    if (cls != this.class) {
      this.flush(at);
      if (at > this.at)
        this.at = at;
      this.class = cls;
    }
  }
  flush(to) {
    if (to > this.at && this.class)
      this.span(this.at, to, this.class);
  }
  highlightRange(cursor2, from, to, inheritedClass, depth, scope) {
    let { type, from: start, to: end } = cursor2;
    if (start >= to || end <= from)
      return;
    nodeStack[depth] = type.name;
    if (type.isTop)
      scope = type;
    let cls = inheritedClass;
    let rule = type.prop(ruleNodeProp), opaque = false;
    while (rule) {
      if (!rule.context || matchContext(rule.context, nodeStack, depth)) {
        for (let tag of rule.tags) {
          let st = this.style(tag, scope);
          if (st) {
            if (cls)
              cls += " ";
            cls += st;
            if (rule.mode == 1)
              inheritedClass += (inheritedClass ? " " : "") + st;
            else if (rule.mode == 0)
              opaque = true;
          }
        }
        break;
      }
      rule = rule.next;
    }
    this.startSpan(cursor2.from, cls);
    if (opaque)
      return;
    let mounted = cursor2.tree && cursor2.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor2.node.enter(mounted.overlay[0].from + start, 1);
      let hasChild2 = cursor2.firstChild();
      for (let i = 0, pos = start; ; i++) {
        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
        if (rangeFrom < rangeTo && hasChild2) {
          while (cursor2.from < rangeTo) {
            this.highlightRange(cursor2, rangeFrom, rangeTo, inheritedClass, depth + 1, scope);
            this.startSpan(Math.min(to, cursor2.to), cls);
            if (cursor2.to >= nextPos || !cursor2.nextSibling())
              break;
          }
        }
        if (!next || nextPos > to)
          break;
        pos = next.to + start;
        if (pos > from) {
          this.highlightRange(inner.cursor, Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, depth, mounted.tree.type);
          this.startSpan(pos, cls);
        }
      }
      if (hasChild2)
        cursor2.parent();
    } else if (cursor2.firstChild()) {
      do {
        if (cursor2.to <= from)
          continue;
        if (cursor2.from >= to)
          break;
        this.highlightRange(cursor2, from, to, inheritedClass, depth + 1, scope);
        this.startSpan(Math.min(to, cursor2.to), cls);
      } while (cursor2.nextSibling());
      cursor2.parent();
    }
  }
}
function highlightTreeRange(tree, from, to, style, span2) {
  let builder = new HighlightBuilder(from, style, span2);
  builder.highlightRange(tree.cursor(), from, to, "", 0, tree.type);
  builder.flush(to);
}
function matchContext(context, stack, depth) {
  if (context.length > depth - 1)
    return false;
  for (let d = depth - 1, i = context.length - 1; i >= 0; i--, d--) {
    let check2 = context[i];
    if (check2 && check2 != stack[d])
      return false;
  }
  return true;
}
const t = Tag.define;
const comment = /* @__PURE__ */ t(), name = /* @__PURE__ */ t(), typeName = /* @__PURE__ */ t(name), propertyName = /* @__PURE__ */ t(name), literal = /* @__PURE__ */ t(), string = /* @__PURE__ */ t(literal), number = /* @__PURE__ */ t(literal), content = /* @__PURE__ */ t(), heading2 = /* @__PURE__ */ t(content), keyword = /* @__PURE__ */ t(), operator = /* @__PURE__ */ t(), punctuation = /* @__PURE__ */ t(), bracket = /* @__PURE__ */ t(punctuation), meta = /* @__PURE__ */ t();
const tags$1 = {
  comment,
  lineComment: /* @__PURE__ */ t(comment),
  blockComment: /* @__PURE__ */ t(comment),
  docComment: /* @__PURE__ */ t(comment),
  name,
  variableName: /* @__PURE__ */ t(name),
  typeName,
  tagName: /* @__PURE__ */ t(typeName),
  propertyName,
  attributeName: /* @__PURE__ */ t(propertyName),
  className: /* @__PURE__ */ t(name),
  labelName: /* @__PURE__ */ t(name),
  namespace: /* @__PURE__ */ t(name),
  macroName: /* @__PURE__ */ t(name),
  literal,
  string,
  docString: /* @__PURE__ */ t(string),
  character: /* @__PURE__ */ t(string),
  attributeValue: /* @__PURE__ */ t(string),
  number,
  integer: /* @__PURE__ */ t(number),
  float: /* @__PURE__ */ t(number),
  bool: /* @__PURE__ */ t(literal),
  regexp: /* @__PURE__ */ t(literal),
  escape: /* @__PURE__ */ t(literal),
  color: /* @__PURE__ */ t(literal),
  url: /* @__PURE__ */ t(literal),
  keyword,
  self: /* @__PURE__ */ t(keyword),
  null: /* @__PURE__ */ t(keyword),
  atom: /* @__PURE__ */ t(keyword),
  unit: /* @__PURE__ */ t(keyword),
  modifier: /* @__PURE__ */ t(keyword),
  operatorKeyword: /* @__PURE__ */ t(keyword),
  controlKeyword: /* @__PURE__ */ t(keyword),
  definitionKeyword: /* @__PURE__ */ t(keyword),
  moduleKeyword: /* @__PURE__ */ t(keyword),
  operator,
  derefOperator: /* @__PURE__ */ t(operator),
  arithmeticOperator: /* @__PURE__ */ t(operator),
  logicOperator: /* @__PURE__ */ t(operator),
  bitwiseOperator: /* @__PURE__ */ t(operator),
  compareOperator: /* @__PURE__ */ t(operator),
  updateOperator: /* @__PURE__ */ t(operator),
  definitionOperator: /* @__PURE__ */ t(operator),
  typeOperator: /* @__PURE__ */ t(operator),
  controlOperator: /* @__PURE__ */ t(operator),
  punctuation,
  separator: /* @__PURE__ */ t(punctuation),
  bracket,
  angleBracket: /* @__PURE__ */ t(bracket),
  squareBracket: /* @__PURE__ */ t(bracket),
  paren: /* @__PURE__ */ t(bracket),
  brace: /* @__PURE__ */ t(bracket),
  content,
  heading: heading2,
  heading1: /* @__PURE__ */ t(heading2),
  heading2: /* @__PURE__ */ t(heading2),
  heading3: /* @__PURE__ */ t(heading2),
  heading4: /* @__PURE__ */ t(heading2),
  heading5: /* @__PURE__ */ t(heading2),
  heading6: /* @__PURE__ */ t(heading2),
  contentSeparator: /* @__PURE__ */ t(content),
  list: /* @__PURE__ */ t(content),
  quote: /* @__PURE__ */ t(content),
  emphasis: /* @__PURE__ */ t(content),
  strong: /* @__PURE__ */ t(content),
  link: /* @__PURE__ */ t(content),
  monospace: /* @__PURE__ */ t(content),
  strikethrough: /* @__PURE__ */ t(content),
  inserted: /* @__PURE__ */ t(),
  deleted: /* @__PURE__ */ t(),
  changed: /* @__PURE__ */ t(),
  invalid: /* @__PURE__ */ t(),
  meta,
  documentMeta: /* @__PURE__ */ t(meta),
  annotation: /* @__PURE__ */ t(meta),
  processingInstruction: /* @__PURE__ */ t(meta),
  definition: /* @__PURE__ */ Tag.defineModifier(),
  constant: /* @__PURE__ */ Tag.defineModifier(),
  function: /* @__PURE__ */ Tag.defineModifier(),
  standard: /* @__PURE__ */ Tag.defineModifier(),
  local: /* @__PURE__ */ Tag.defineModifier(),
  special: /* @__PURE__ */ Tag.defineModifier()
};
const defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  {
    tag: tags$1.link,
    textDecoration: "underline"
  },
  {
    tag: tags$1.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: tags$1.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags$1.strong,
    fontWeight: "bold"
  },
  {
    tag: tags$1.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags$1.keyword,
    color: "#708"
  },
  {
    tag: [tags$1.atom, tags$1.bool, tags$1.url, tags$1.contentSeparator, tags$1.labelName],
    color: "#219"
  },
  {
    tag: [tags$1.literal, tags$1.inserted],
    color: "#164"
  },
  {
    tag: [tags$1.string, tags$1.deleted],
    color: "#a11"
  },
  {
    tag: [tags$1.regexp, tags$1.escape, /* @__PURE__ */ tags$1.special(tags$1.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ tags$1.definition(tags$1.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ tags$1.local(tags$1.variableName),
    color: "#30a"
  },
  {
    tag: [tags$1.typeName, tags$1.namespace],
    color: "#085"
  },
  {
    tag: tags$1.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ tags$1.special(tags$1.variableName), tags$1.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ tags$1.definition(tags$1.propertyName),
    color: "#00c"
  },
  {
    tag: tags$1.comment,
    color: "#940"
  },
  {
    tag: tags$1.meta,
    color: "#7a757a"
  },
  {
    tag: tags$1.invalid,
    color: "#f00"
  }
]);
/* @__PURE__ */ HighlightStyle.define([
  { tag: tags$1.link, class: "cmt-link" },
  { tag: tags$1.heading, class: "cmt-heading" },
  { tag: tags$1.emphasis, class: "cmt-emphasis" },
  { tag: tags$1.strong, class: "cmt-strong" },
  { tag: tags$1.keyword, class: "cmt-keyword" },
  { tag: tags$1.atom, class: "cmt-atom" },
  { tag: tags$1.bool, class: "cmt-bool" },
  { tag: tags$1.url, class: "cmt-url" },
  { tag: tags$1.labelName, class: "cmt-labelName" },
  { tag: tags$1.inserted, class: "cmt-inserted" },
  { tag: tags$1.deleted, class: "cmt-deleted" },
  { tag: tags$1.literal, class: "cmt-literal" },
  { tag: tags$1.string, class: "cmt-string" },
  { tag: tags$1.number, class: "cmt-number" },
  { tag: [tags$1.regexp, tags$1.escape, /* @__PURE__ */ tags$1.special(tags$1.string)], class: "cmt-string2" },
  { tag: tags$1.variableName, class: "cmt-variableName" },
  { tag: /* @__PURE__ */ tags$1.local(tags$1.variableName), class: "cmt-variableName cmt-local" },
  { tag: /* @__PURE__ */ tags$1.definition(tags$1.variableName), class: "cmt-variableName cmt-definition" },
  { tag: /* @__PURE__ */ tags$1.special(tags$1.variableName), class: "cmt-variableName2" },
  { tag: /* @__PURE__ */ tags$1.definition(tags$1.propertyName), class: "cmt-propertyName cmt-definition" },
  { tag: tags$1.typeName, class: "cmt-typeName" },
  { tag: tags$1.namespace, class: "cmt-namespace" },
  { tag: tags$1.className, class: "cmt-className" },
  { tag: tags$1.macroName, class: "cmt-macroName" },
  { tag: tags$1.propertyName, class: "cmt-propertyName" },
  { tag: tags$1.operator, class: "cmt-operator" },
  { tag: tags$1.comment, class: "cmt-comment" },
  { tag: tags$1.meta, class: "cmt-meta" },
  { tag: tags$1.invalid, class: "cmt-invalid" },
  { tag: tags$1.punctuation, class: "cmt-punctuation" }
]);
const chalky$1 = "#e5c07b", coral$1 = "#e06c75", cyan$1 = "#56b6c2", invalid$1 = "#ffffff", ivory$1 = "#d4d4d4", stone$1 = "#999999", malibu$1 = "#61afef", sage$1 = "#98c379", whiskey$1 = "#d19a66", violet$1 = "#c678dd", darkBackground$1 = "#21252b", highlightBackground$1 = "#090909", background$1 = "#17171a", tooltipBackground$1 = "#17171a", selection$1 = "#0b4b73", cursor$1 = "#888", fontFamily$1 = 'Menlo, "Ubuntu Mono", Consolas, "Courier New", "Microsoft Yahei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif', fontSize$1 = "14px", iconColor$1 = "%23999";
const arrowDown$1 = `"data:image/svg+xml,%3Csvg class='icon' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg' width='16' height='16'%3E%3Cpath d='M512 714.667c-8.533 0-17.067-2.134-23.467-8.534L147.2 364.8c-12.8-12.8-12.8-32 0-44.8 12.8-12.8 32-12.8 44.8 0l320 317.867 317.867-320c12.8-12.8 32-12.8 44.8 0 12.8 12.8 12.8 32 0 44.8L533.333 704c-4.266 8.533-12.8 10.667-21.333 10.667z' fill='${iconColor$1}'/%3E%3C/svg%3E"`;
const arrowRight$1 = `"data:image/svg+xml,%3Csvg class='icon' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg' width='16' height='16'%3E%3Cpath d='M320 885.333c-8.533 0-17.067-4.266-23.467-10.666-12.8-12.8-10.666-34.134 2.134-44.8L654.933 512 298.667 194.133c-12.8-10.666-14.934-32-2.134-44.8 10.667-12.8 32-14.933 44.8-2.133l384 341.333c6.4 6.4 10.667 14.934 10.667 23.467s-4.267 17.067-10.667 23.467l-384 341.333c-6.4 6.4-12.8 8.533-21.333 8.533z' fill='${iconColor$1}'/%3E%3C/svg%3E"`;
const totonooDarkTheme = EditorView.theme({
  "&": {
    color: ivory$1,
    backgroundColor: background$1,
    height: "100%"
  },
  ".cm-content": {
    caretColor: cursor$1,
    fontFamily: fontFamily$1,
    fontSize: fontSize$1
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: cursor$1, borderWidth: "2px" },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection$1 },
  ".cm-panels": { backgroundColor: darkBackground$1, color: ivory$1 },
  ".cm-panels.cm-panels-top": { borderBottom: "1px solid #eeeeee" },
  ".cm-panels.cm-panels-bottom": { borderTop: "1px solid #eeeeee" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: highlightBackground$1 },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847",
    outline: "1px solid #515a6b"
  },
  ".cm-gutters": {
    backgroundColor: background$1,
    color: stone$1,
    border: "none",
    fontFamily: fontFamily$1,
    fontSize: fontSize$1
  },
  ".cm-activeLineGutter": {
    backgroundColor: highlightBackground$1
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: tooltipBackground$1
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: tooltipBackground$1,
    borderBottomColor: tooltipBackground$1
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: highlightBackground$1,
      color: ivory$1
    }
  },
  ".cm-gutters .editor-unfold, .cm-gutters .editor-fold": {
    width: "10px",
    height: "10px",
    display: "inline-block",
    backgroundImage: "url(" + arrowDown$1 + ")",
    backgroundSize: "100% 100%",
    backgroundPosition: "center center",
    backgroundRepeat: "no-repeat",
    margin: "4px 0 0"
  },
  ".cm-gutters .editor-fold": {
    backgroundImage: "url(" + arrowRight$1 + ")"
  }
}, { dark: true });
const totonooDarkHighlightStyle = HighlightStyle.define([
  {
    tag: tags$1.keyword,
    color: violet$1
  },
  {
    tag: [tags$1.name, tags$1.deleted, tags$1.character, tags$1.propertyName, tags$1.macroName],
    color: coral$1
  },
  {
    tag: [tags$1.function(tags$1.variableName), tags$1.labelName],
    color: malibu$1
  },
  {
    tag: [tags$1.color, tags$1.constant(tags$1.name), tags$1.standard(tags$1.name)],
    color: whiskey$1
  },
  {
    tag: [tags$1.definition(tags$1.name), tags$1.separator],
    color: ivory$1
  },
  {
    tag: [tags$1.typeName, tags$1.className, tags$1.number, tags$1.changed, tags$1.annotation, tags$1.modifier, tags$1.self, tags$1.namespace],
    color: chalky$1
  },
  {
    tag: [tags$1.operator, tags$1.operatorKeyword, tags$1.url, tags$1.escape, tags$1.regexp, tags$1.link, tags$1.special(tags$1.string)],
    color: cyan$1
  },
  {
    tag: [tags$1.meta, tags$1.comment],
    color: stone$1
  },
  {
    tag: tags$1.strong,
    fontWeight: "bold"
  },
  {
    tag: tags$1.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags$1.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags$1.link,
    color: stone$1,
    textDecoration: "underline"
  },
  {
    tag: tags$1.heading,
    fontWeight: "bold",
    color: coral$1
  },
  {
    tag: [tags$1.atom, tags$1.bool, tags$1.special(tags$1.variableName)],
    color: whiskey$1
  },
  {
    tag: [tags$1.processingInstruction, tags$1.string, tags$1.inserted],
    color: sage$1
  },
  {
    tag: tags$1.invalid,
    color: invalid$1
  }
]);
const Dark = [totonooDarkTheme, totonooDarkHighlightStyle];
const chalky = "#e5c07b", coral = "#e06c75", cyan = "#56b6c2", invalid = "#ffffff", ivory = "#444444", stone = "#7d8799", malibu = "#61afef", sage = "#98c379", whiskey = "#d19a66", violet = "#c678dd", darkBackground = "#ffffff", highlightBackground = "rgba(0, 122, 204, 0.1)", background = "#ffffff", tooltipBackground = "#353a42", selection = "rgba(0, 122, 204, 0.3)", cursor = "#bbb", fontFamily = 'Menlo, "Ubuntu Mono", Consolas, "Courier New", "Microsoft Yahei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif', fontSize = "14px", iconColor = "%23999";
const arrowDown = `"data:image/svg+xml,%3Csvg class='icon' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg' width='16' height='16'%3E%3Cpath d='M512 714.667c-8.533 0-17.067-2.134-23.467-8.534L147.2 364.8c-12.8-12.8-12.8-32 0-44.8 12.8-12.8 32-12.8 44.8 0l320 317.867 317.867-320c12.8-12.8 32-12.8 44.8 0 12.8 12.8 12.8 32 0 44.8L533.333 704c-4.266 8.533-12.8 10.667-21.333 10.667z' fill='${iconColor}'/%3E%3C/svg%3E"`;
const arrowRight = `"data:image/svg+xml,%3Csvg class='icon' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg' width='16' height='16'%3E%3Cpath d='M320 885.333c-8.533 0-17.067-4.266-23.467-10.666-12.8-12.8-10.666-34.134 2.134-44.8L654.933 512 298.667 194.133c-12.8-10.666-14.934-32-2.134-44.8 10.667-12.8 32-14.933 44.8-2.133l384 341.333c6.4 6.4 10.667 14.934 10.667 23.467s-4.267 17.067-10.667 23.467l-384 341.333c-6.4 6.4-12.8 8.533-21.333 8.533z' fill='${iconColor}'/%3E%3C/svg%3E"`;
const totonooTheme = EditorView.theme({
  "&": {
    color: ivory,
    backgroundColor: background,
    height: "100%"
  },
  ".cm-content": {
    caretColor: cursor,
    fontFamily,
    fontSize
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: cursor, borderWidth: "2px" },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
  ".cm-panels": { backgroundColor: darkBackground, color: ivory },
  ".cm-panels.cm-panels-top": { borderBottom: "1px solid #eeeeee" },
  ".cm-panels.cm-panels-bottom": { borderTop: "1px solid #eeeeee" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: highlightBackground },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847",
    outline: "1px solid #515a6b"
  },
  ".cm-gutters": {
    backgroundColor: background,
    color: stone,
    border: "none",
    fontFamily,
    fontSize
  },
  ".cm-activeLineGutter": {
    backgroundColor: highlightBackground
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: tooltipBackground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: tooltipBackground,
    borderBottomColor: tooltipBackground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: highlightBackground,
      color: ivory
    }
  },
  ".cm-gutters .editor-unfold, .cm-gutters .editor-fold": {
    width: "10px",
    height: "10px",
    display: "inline-block",
    backgroundImage: "url(" + arrowDown + ")",
    backgroundSize: "100% 100%",
    backgroundPosition: "center center",
    backgroundRepeat: "no-repeat",
    margin: "4px 0 0"
  },
  ".cm-gutters .editor-fold": {
    backgroundImage: "url(" + arrowRight + ")"
  }
}, { dark: false });
const totonooHighlightStyle = HighlightStyle.define([
  {
    tag: tags$1.keyword,
    color: violet
  },
  {
    tag: [tags$1.name, tags$1.deleted, tags$1.character, tags$1.propertyName, tags$1.macroName],
    color: coral
  },
  {
    tag: [tags$1.function(tags$1.variableName), tags$1.labelName],
    color: malibu
  },
  {
    tag: [tags$1.color, tags$1.constant(tags$1.name), tags$1.standard(tags$1.name)],
    color: whiskey
  },
  {
    tag: [tags$1.definition(tags$1.name), tags$1.separator],
    color: ivory
  },
  {
    tag: [tags$1.typeName, tags$1.className, tags$1.number, tags$1.changed, tags$1.annotation, tags$1.modifier, tags$1.self, tags$1.namespace],
    color: chalky
  },
  {
    tag: [tags$1.operator, tags$1.operatorKeyword, tags$1.url, tags$1.escape, tags$1.regexp, tags$1.link, tags$1.special(tags$1.string)],
    color: cyan
  },
  {
    tag: [tags$1.meta, tags$1.comment],
    color: stone
  },
  {
    tag: tags$1.strong,
    fontWeight: "bold"
  },
  {
    tag: tags$1.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags$1.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags$1.link,
    color: stone,
    textDecoration: "underline"
  },
  {
    tag: tags$1.heading,
    fontWeight: "bold",
    color: coral
  },
  {
    tag: [tags$1.atom, tags$1.bool, tags$1.special(tags$1.variableName)],
    color: whiskey
  },
  {
    tag: [tags$1.processingInstruction, tags$1.string, tags$1.inserted],
    color: sage
  },
  {
    tag: tags$1.invalid,
    color: invalid
  }
]);
const Light = [totonooTheme, totonooHighlightStyle];
const MaxOff = 2e3;
function rectangleFor(state, a, b) {
  let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
  let ranges = [];
  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
    let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      if (line.length <= endOff)
        ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
    }
  } else {
    let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      let start = findColumn(line.text, startCol, state.tabSize, true);
      if (start > -1) {
        let end = findColumn(line.text, endCol, state.tabSize);
        ranges.push(EditorSelection.range(line.from + start, line.from + end));
      }
    }
  }
  return ranges;
}
function absoluteColumn(view, x) {
  let ref2 = view.coordsAtPos(view.viewport.from);
  return ref2 ? Math.round(Math.abs((ref2.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
  let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let line = view.state.doc.lineAt(offset), off = offset - line.from;
  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
  return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
  let start = getPos(view, event), startSel = view.state.selection;
  if (!start)
    return null;
  return {
    update(update) {
      if (update.docChanged) {
        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
        let newLine = update.state.doc.lineAt(newStart);
        start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, _extend, multiple) {
      let cur2 = getPos(view, event2);
      if (!cur2)
        return startSel;
      let ranges = rectangleFor(view.state, start, cur2);
      if (!ranges.length)
        return startSel;
      if (multiple)
        return EditorSelection.create(ranges.concat(startSel.ranges));
      else
        return EditorSelection.create(ranges);
    }
  };
}
function rectangularSelection(options) {
  let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e) => e.altKey && e.button == 0);
  return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
const lineWrappingComp = new Compartment();
const _lineNumbers = lineNumbers();
function extensions(options) {
  const extensions2 = [];
  if (options.lineWrapping) {
    extensions2.push(lineWrappingComp.of(EditorView.lineWrapping));
  }
  if (options.lineNumbers) {
    extensions2.push(_lineNumbers);
  }
  extensions2.push(drawSelection());
  if (options.allowMultipleSelections) {
    extensions2.push(EditorState.allowMultipleSelections.of(true));
  }
  extensions2.push(indentOnInput());
  extensions2.push(highlightActiveLineGutter());
  extensions2.push(highlightSpecialChars());
  extensions2.push(history());
  extensions2.push(defaultHighlightStyle.fallback);
  extensions2.push(bracketMatching());
  extensions2.push(closeBrackets());
  extensions2.push(autocompletion());
  extensions2.push(rectangularSelection());
  extensions2.push(highlightActiveLine());
  extensions2.push(highlightSelectionMatches());
  extensions2.push(foldGutter({
    markerDOM(open) {
      const className = open ? "editor-unfold" : "editor-fold";
      const span2 = document.createElement("span");
      span2.classList.add(className);
      return span2;
    }
  }));
  return extensions2;
}
class BaseEditor {
  constructor(options) {
    __publicField(this, "box");
    __publicField(this, "state");
    __publicField(this, "view");
    __publicField(this, "theme", new Compartment());
    __publicField(this, "isDark", true);
    __publicField(this, "themeDark", Dark);
    __publicField(this, "themeLight", Light);
    __publicField(this, "extensions", []);
    __publicField(this, "events", {
      focus: (update, value) => {
      },
      blur: (update, value) => {
      },
      change: (update, value) => {
      },
      selectionChange: (update, line) => {
      }
    });
    __publicField(this, "hotKeyMaps", []);
    __publicField(this, "prettier", prettier);
    const defaultOptions2 = {
      lineWrapping: true,
      lineNumbers: true,
      allowMultipleSelections: true,
      theme: "light"
    };
    const opts = Object.assign({}, defaultOptions2, options);
    this.extensions = extensions(opts);
    if (opts.theme === "dark") {
      this.extensions.push(this.theme.of(this.themeDark));
      this.isDark = true;
    } else {
      this.extensions.push(this.theme.of(this.themeLight));
      this.isDark = false;
    }
    this.hotKeyMaps = [
      indentWithTab,
      ...closeBracketsKeymap,
      ...defaultKeymap,
      ...searchKeymap,
      ...historyKeymap,
      ...foldKeymap,
      ...commentKeymap,
      ...completionKeymap,
      ...lintKeymap
    ];
    const updateListener2 = EditorView.updateListener.of((update) => {
      const value = update.state.doc.toString();
      if (update.docChanged) {
        this.events.change(update, value);
      }
      if (update.selectionSet) {
        this.selectionSet(update);
      }
      if (update.focusChanged) {
        this.focusChanged(update, value);
      }
    });
    this.extensions.push(updateListener2);
  }
  $$(exp) {
    return document.querySelector(exp);
  }
  focusChanged(update, value) {
    if (!update.view.hasFocus) {
      this.events.blur(update, value);
    } else {
      this.events.focus(update, value);
    }
  }
  selectionSet(update) {
    const range2 = update.state.selection.ranges[0];
    const line = update.state.doc.lineAt(range2.from);
    this.events.selectionChange(update, line);
  }
  getValue() {
    const value = this.view.state.doc.toString();
    return value || "";
  }
  setValue(val = "") {
    const { view } = this;
    const state = view.state;
    const transaction = state.update({
      changes: {
        from: 0,
        to: state.doc.length,
        insert: val
      }
    });
    view.dispatch(transaction);
  }
  setCursor(offsetFrom, offsetTo) {
    const { view } = this;
    if (view) {
      const state = view.state;
      const tr = state.update(state.changeByRange((range2) => {
        return {
          range: EditorSelection.range(range2.from + offsetFrom, range2.to + offsetTo)
        };
      }));
      view.dispatch(tr);
      view.focus();
    }
  }
  regExpcharacterEscape(str) {
    str = str.replace(/\{/gmi, "\\{");
    str = str.replace(/\}/gmi, "\\}");
    str = str.replace(/\(/gmi, "\\(");
    str = str.replace(/\)/gmi, "\\)");
    str = str.replace(/\//gmi, "\\/");
    str = str.replace(/\$/gmi, "\\$");
    str = str.replace(/\#/gmi, "\\#");
    str = str.replace(/\&/gmi, "\\&");
    str = str.replace(/\*/gmi, "\\*");
    str = str.replace(/\./gmi, "\\.");
    return str;
  }
}
class CompositeBlock {
  constructor(type, value, from, hash2, end, children, positions) {
    this.type = type;
    this.value = value;
    this.from = from;
    this.hash = hash2;
    this.end = end;
    this.children = children;
    this.positions = positions;
    this.hashProp = [[NodeProp.contextHash, hash2]];
  }
  static create(type, value, from, parentHash, end) {
    let hash2 = parentHash + (parentHash << 8) + type + (value << 4) | 0;
    return new CompositeBlock(type, value, from, hash2, end, [], []);
  }
  addChild(child, pos) {
    if (child.prop(NodeProp.contextHash) != this.hash)
      child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);
    this.children.push(child);
    this.positions.push(pos);
  }
  toTree(nodeSet, end = this.end) {
    let last = this.children.length - 1;
    if (last >= 0)
      end = Math.max(end, this.positions[last] + this.children[last].length + this.from);
    let tree = new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({
      makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)
    });
    return tree;
  }
}
var Type;
(function(Type2) {
  Type2[Type2["Document"] = 1] = "Document";
  Type2[Type2["CodeBlock"] = 2] = "CodeBlock";
  Type2[Type2["FencedCode"] = 3] = "FencedCode";
  Type2[Type2["Blockquote"] = 4] = "Blockquote";
  Type2[Type2["HorizontalRule"] = 5] = "HorizontalRule";
  Type2[Type2["BulletList"] = 6] = "BulletList";
  Type2[Type2["OrderedList"] = 7] = "OrderedList";
  Type2[Type2["ListItem"] = 8] = "ListItem";
  Type2[Type2["ATXHeading1"] = 9] = "ATXHeading1";
  Type2[Type2["ATXHeading2"] = 10] = "ATXHeading2";
  Type2[Type2["ATXHeading3"] = 11] = "ATXHeading3";
  Type2[Type2["ATXHeading4"] = 12] = "ATXHeading4";
  Type2[Type2["ATXHeading5"] = 13] = "ATXHeading5";
  Type2[Type2["ATXHeading6"] = 14] = "ATXHeading6";
  Type2[Type2["SetextHeading1"] = 15] = "SetextHeading1";
  Type2[Type2["SetextHeading2"] = 16] = "SetextHeading2";
  Type2[Type2["HTMLBlock"] = 17] = "HTMLBlock";
  Type2[Type2["LinkReference"] = 18] = "LinkReference";
  Type2[Type2["Paragraph"] = 19] = "Paragraph";
  Type2[Type2["CommentBlock"] = 20] = "CommentBlock";
  Type2[Type2["ProcessingInstructionBlock"] = 21] = "ProcessingInstructionBlock";
  Type2[Type2["Escape"] = 22] = "Escape";
  Type2[Type2["Entity"] = 23] = "Entity";
  Type2[Type2["HardBreak"] = 24] = "HardBreak";
  Type2[Type2["Emphasis"] = 25] = "Emphasis";
  Type2[Type2["StrongEmphasis"] = 26] = "StrongEmphasis";
  Type2[Type2["Link"] = 27] = "Link";
  Type2[Type2["Image"] = 28] = "Image";
  Type2[Type2["InlineCode"] = 29] = "InlineCode";
  Type2[Type2["HTMLTag"] = 30] = "HTMLTag";
  Type2[Type2["Comment"] = 31] = "Comment";
  Type2[Type2["ProcessingInstruction"] = 32] = "ProcessingInstruction";
  Type2[Type2["URL"] = 33] = "URL";
  Type2[Type2["HeaderMark"] = 34] = "HeaderMark";
  Type2[Type2["QuoteMark"] = 35] = "QuoteMark";
  Type2[Type2["ListMark"] = 36] = "ListMark";
  Type2[Type2["LinkMark"] = 37] = "LinkMark";
  Type2[Type2["EmphasisMark"] = 38] = "EmphasisMark";
  Type2[Type2["CodeMark"] = 39] = "CodeMark";
  Type2[Type2["CodeText"] = 40] = "CodeText";
  Type2[Type2["CodeInfo"] = 41] = "CodeInfo";
  Type2[Type2["LinkTitle"] = 42] = "LinkTitle";
  Type2[Type2["LinkLabel"] = 43] = "LinkLabel";
})(Type || (Type = {}));
class LeafBlock {
  constructor(start, content2) {
    this.start = start;
    this.content = content2;
    this.marks = [];
    this.parsers = [];
  }
}
class Line {
  constructor() {
    this.text = "";
    this.baseIndent = 0;
    this.basePos = 0;
    this.depth = 0;
    this.markers = [];
    this.pos = 0;
    this.indent = 0;
    this.next = -1;
  }
  forward() {
    if (this.basePos > this.pos)
      this.forwardInner();
  }
  forwardInner() {
    let newPos = this.skipSpace(this.basePos);
    this.indent = this.countIndent(newPos, this.pos, this.indent);
    this.pos = newPos;
    this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);
  }
  skipSpace(from) {
    return skipSpace(this.text, from);
  }
  reset(text3) {
    this.text = text3;
    this.baseIndent = this.basePos = this.pos = this.indent = 0;
    this.forwardInner();
    this.depth = 1;
    while (this.markers.length)
      this.markers.pop();
  }
  moveBase(to) {
    this.basePos = to;
    this.baseIndent = this.countIndent(to, this.pos, this.indent);
  }
  moveBaseColumn(indent) {
    this.baseIndent = indent;
    this.basePos = this.findColumn(indent);
  }
  addMarker(elt2) {
    this.markers.push(elt2);
  }
  countIndent(to, from = 0, indent = 0) {
    for (let i = from; i < to; i++)
      indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;
    return indent;
  }
  findColumn(goal) {
    let i = 0;
    for (let indent = 0; i < this.text.length && indent < goal; i++)
      indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;
    return i;
  }
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let result = "";
    for (let i = 0; i < this.basePos; i++)
      result += " ";
    return result + this.text.slice(this.basePos);
  }
}
function skipForList(bl, cx, line) {
  if (line.pos == line.text.length || bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent)
    return true;
  if (line.indent >= line.baseIndent + 4)
    return false;
  let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);
  return size > 0 && (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) && line.text.charCodeAt(line.pos + size - 1) == bl.value;
}
const DefaultSkipMarkup = {
  [Type.Blockquote](bl, cx, line) {
    if (line.next != 62)
      return false;
    line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));
    line.moveBase(line.pos + (space$2(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));
    bl.end = cx.lineStart + line.text.length;
    return true;
  },
  [Type.ListItem](bl, _cx, line) {
    if (line.indent < line.baseIndent + bl.value && line.next > -1)
      return false;
    line.moveBaseColumn(line.baseIndent + bl.value);
    return true;
  },
  [Type.OrderedList]: skipForList,
  [Type.BulletList]: skipForList,
  [Type.Document]() {
    return true;
  }
};
function space$2(ch) {
  return ch == 32 || ch == 9 || ch == 10 || ch == 13;
}
function skipSpace(line, i = 0) {
  while (i < line.length && space$2(line.charCodeAt(i)))
    i++;
  return i;
}
function skipSpaceBack(line, i, to) {
  while (i > to && space$2(line.charCodeAt(i - 1)))
    i--;
  return i;
}
function isFencedCode(line) {
  if (line.next != 96 && line.next != 126)
    return -1;
  let pos = line.pos + 1;
  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
    pos++;
  if (pos < line.pos + 3)
    return -1;
  if (line.next == 96) {
    for (let i = pos; i < line.text.length; i++)
      if (line.text.charCodeAt(i) == 96)
        return -1;
  }
  return pos;
}
function isBlockquote(line) {
  return line.next != 62 ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;
}
function isHorizontalRule(line, cx, breaking) {
  if (line.next != 42 && line.next != 45 && line.next != 95)
    return -1;
  let count = 1;
  for (let pos = line.pos + 1; pos < line.text.length; pos++) {
    let ch = line.text.charCodeAt(pos);
    if (ch == line.next)
      count++;
    else if (!space$2(ch))
      return -1;
  }
  if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)
    return -1;
  return count < 3 ? -1 : 1;
}
function inList(cx, type) {
  for (let i = cx.stack.length - 1; i >= 0; i--)
    if (cx.stack[i].type == type)
      return true;
  return false;
}
function isBulletList(line, cx, breaking) {
  return (line.next == 45 || line.next == 43 || line.next == 42) && (line.pos == line.text.length - 1 || space$2(line.text.charCodeAt(line.pos + 1))) && (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;
}
function isOrderedList(line, cx, breaking) {
  let pos = line.pos, next = line.next;
  for (; ; ) {
    if (next >= 48 && next <= 57)
      pos++;
    else
      break;
    if (pos == line.text.length)
      return -1;
    next = line.text.charCodeAt(pos);
  }
  if (pos == line.pos || pos > line.pos + 9 || next != 46 && next != 41 || pos < line.text.length - 1 && !space$2(line.text.charCodeAt(pos + 1)) || breaking && !inList(cx, Type.OrderedList) && (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49))
    return -1;
  return pos + 1 - line.pos;
}
function isAtxHeading(line) {
  if (line.next != 35)
    return -1;
  let pos = line.pos + 1;
  while (pos < line.text.length && line.text.charCodeAt(pos) == 35)
    pos++;
  if (pos < line.text.length && line.text.charCodeAt(pos) != 32)
    return -1;
  let size = pos - line.pos;
  return size > 6 ? -1 : size;
}
function isSetextUnderline(line) {
  if (line.next != 45 && line.next != 61 || line.indent >= line.baseIndent + 4)
    return -1;
  let pos = line.pos + 1;
  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
    pos++;
  let end = pos;
  while (pos < line.text.length && space$2(line.text.charCodeAt(pos)))
    pos++;
  return pos == line.text.length ? end : -1;
}
const EmptyLine = /^[ \t]*$/, CommentEnd = /-->/, ProcessingEnd = /\?>/;
const HTMLBlockStyle = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, CommentEnd],
  [/^\s*<\?/, ProcessingEnd],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, EmptyLine],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, EmptyLine]
];
function isHTMLBlock(line, _cx, breaking) {
  if (line.next != 60)
    return -1;
  let rest = line.text.slice(line.pos);
  for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)
    if (HTMLBlockStyle[i][0].test(rest))
      return i;
  return -1;
}
function getListIndent(line, pos) {
  let indentAfter = line.countIndent(pos, line.pos, line.indent);
  let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);
  return indented >= indentAfter + 5 ? indentAfter + 1 : indented;
}
function addCodeText(marks, from, to) {
  let last = marks.length - 1;
  if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)
    marks[last].to = to;
  else
    marks.push(elt(Type.CodeText, from, to));
}
const DefaultBlockParsers = {
  LinkReference: void 0,
  IndentedCode(cx, line) {
    let base2 = line.baseIndent + 4;
    if (line.indent < base2)
      return false;
    let start = line.findColumn(base2);
    let from = cx.lineStart + start, to = cx.lineStart + line.text.length;
    let marks = [], pendingMarks = [];
    addCodeText(marks, from, to);
    while (cx.nextLine() && line.depth >= cx.stack.length) {
      if (line.pos == line.text.length) {
        addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);
        for (let m of line.markers)
          pendingMarks.push(m);
      } else if (line.indent < base2) {
        break;
      } else {
        if (pendingMarks.length) {
          for (let m of pendingMarks) {
            if (m.type == Type.CodeText)
              addCodeText(marks, m.from, m.to);
            else
              marks.push(m);
          }
          pendingMarks = [];
        }
        addCodeText(marks, cx.lineStart - 1, cx.lineStart);
        for (let m of line.markers)
          marks.push(m);
        to = cx.lineStart + line.text.length;
        let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);
        if (codeStart < to)
          addCodeText(marks, codeStart, to);
      }
    }
    if (pendingMarks.length) {
      pendingMarks = pendingMarks.filter((m) => m.type != Type.CodeText);
      if (pendingMarks.length)
        line.markers = pendingMarks.concat(line.markers);
    }
    cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);
    return true;
  },
  FencedCode(cx, line) {
    let fenceEnd = isFencedCode(line);
    if (fenceEnd < 0)
      return false;
    let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;
    let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);
    let marks = [elt(Type.CodeMark, from, from + len)];
    if (infoFrom < infoTo)
      marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));
    for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {
      let i = line.pos;
      if (line.indent - line.baseIndent < 4)
        while (i < line.text.length && line.text.charCodeAt(i) == ch)
          i++;
      if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {
        for (let m of line.markers)
          marks.push(m);
        marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));
        cx.nextLine();
        break;
      } else {
        if (!first)
          addCodeText(marks, cx.lineStart - 1, cx.lineStart);
        for (let m of line.markers)
          marks.push(m);
        let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;
        if (textStart < textEnd)
          addCodeText(marks, textStart, textEnd);
      }
    }
    cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.FencedCode, cx.prevLineEnd() - from), from);
    return true;
  },
  Blockquote(cx, line) {
    let size = isBlockquote(line);
    if (size < 0)
      return false;
    cx.startContext(Type.Blockquote, line.pos);
    cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);
    line.moveBase(line.pos + size);
    return null;
  },
  HorizontalRule(cx, line) {
    if (isHorizontalRule(line, cx, false) < 0)
      return false;
    let from = cx.lineStart + line.pos;
    cx.nextLine();
    cx.addNode(Type.HorizontalRule, from);
    return true;
  },
  BulletList(cx, line) {
    let size = isBulletList(line, cx, false);
    if (size < 0)
      return false;
    if (cx.block.type != Type.BulletList)
      cx.startContext(Type.BulletList, line.basePos, line.next);
    let newBase = getListIndent(line, line.pos + 1);
    cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
    cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
    line.moveBaseColumn(newBase);
    return null;
  },
  OrderedList(cx, line) {
    let size = isOrderedList(line, cx, false);
    if (size < 0)
      return false;
    if (cx.block.type != Type.OrderedList)
      cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));
    let newBase = getListIndent(line, line.pos + size);
    cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
    cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
    line.moveBaseColumn(newBase);
    return null;
  },
  ATXHeading(cx, line) {
    let size = isAtxHeading(line);
    if (size < 0)
      return false;
    let off = line.pos, from = cx.lineStart + off;
    let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;
    while (after > off && line.text.charCodeAt(after - 1) == line.next)
      after--;
    if (after == endOfSpace || after == off || !space$2(line.text.charCodeAt(after - 1)))
      after = line.text.length;
    let buf = cx.buffer.write(Type.HeaderMark, 0, size).writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);
    if (after < line.text.length)
      buf.write(Type.HeaderMark, after - off, endOfSpace - off);
    let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);
    cx.nextLine();
    cx.addNode(node, from);
    return true;
  },
  HTMLBlock(cx, line) {
    let type = isHTMLBlock(line, cx, false);
    if (type < 0)
      return false;
    let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];
    let marks = [], trailing = end != EmptyLine;
    while (!end.test(line.text) && cx.nextLine()) {
      if (line.depth < cx.stack.length) {
        trailing = false;
        break;
      }
      for (let m of line.markers)
        marks.push(m);
    }
    if (trailing)
      cx.nextLine();
    let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;
    let to = cx.prevLineEnd();
    cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);
    return true;
  },
  SetextHeading: void 0
};
class LinkReferenceParser {
  constructor(leaf) {
    this.stage = 0;
    this.elts = [];
    this.pos = 0;
    this.start = leaf.start;
    this.advance(leaf.content);
  }
  nextLine(cx, line, leaf) {
    if (this.stage == -1)
      return false;
    let content2 = leaf.content + "\n" + line.scrub();
    let finish = this.advance(content2);
    if (finish > -1 && finish < content2.length)
      return this.complete(cx, leaf, finish);
    return false;
  }
  finish(cx, leaf) {
    if ((this.stage == 2 || this.stage == 3) && skipSpace(leaf.content, this.pos) == leaf.content.length)
      return this.complete(cx, leaf, leaf.content.length);
    return false;
  }
  complete(cx, leaf, len) {
    cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));
    return true;
  }
  nextStage(elt2) {
    if (elt2) {
      this.pos = elt2.to - this.start;
      this.elts.push(elt2);
      this.stage++;
      return true;
    }
    if (elt2 === false)
      this.stage = -1;
    return false;
  }
  advance(content2) {
    for (; ; ) {
      if (this.stage == -1) {
        return -1;
      } else if (this.stage == 0) {
        if (!this.nextStage(parseLinkLabel2(content2, this.pos, this.start, true)))
          return -1;
        if (content2.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));
        this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(parseURL(content2, skipSpace(content2, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let skip = skipSpace(content2, this.pos), end = 0;
        if (skip > this.pos) {
          let title = parseLinkTitle2(content2, skip, this.start);
          if (title) {
            let titleEnd = lineEnd(content2, title.to - this.start);
            if (titleEnd > 0) {
              this.nextStage(title);
              end = titleEnd;
            }
          }
        }
        if (!end)
          end = lineEnd(content2, this.pos);
        return end > 0 && end < content2.length ? end : -1;
      } else {
        return lineEnd(content2, this.pos);
      }
    }
  }
}
function lineEnd(text3, pos) {
  for (; pos < text3.length; pos++) {
    let next = text3.charCodeAt(pos);
    if (next == 10)
      break;
    if (!space$2(next))
      return -1;
  }
  return pos;
}
class SetextHeadingParser {
  nextLine(cx, line, leaf) {
    let underline2 = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);
    let next = line.next;
    if (underline2 < 0)
      return false;
    let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline2);
    cx.nextLine();
    cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [
      ...cx.parser.parseInline(leaf.content, leaf.start),
      underlineMark
    ]));
    return true;
  }
  finish() {
    return false;
  }
}
const DefaultLeafBlocks = {
  LinkReference(_, leaf) {
    return leaf.content.charCodeAt(0) == 91 ? new LinkReferenceParser(leaf) : null;
  },
  SetextHeading() {
    return new SetextHeadingParser();
  }
};
const DefaultEndLeaf = [
  (_, line) => isAtxHeading(line) >= 0,
  (_, line) => isFencedCode(line) >= 0,
  (_, line) => isBlockquote(line) >= 0,
  (p, line) => isBulletList(line, p, true) >= 0,
  (p, line) => isOrderedList(line, p, true) >= 0,
  (p, line) => isHorizontalRule(line, p, true) >= 0,
  (p, line) => isHTMLBlock(line, p, true) >= 0
];
class BlockContext {
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges;
    this.line = new Line();
    this.atEnd = false;
    this.dontInject = /* @__PURE__ */ new Set();
    this.stoppedAt = null;
    this.rangeI = 0;
    this.to = ranges[ranges.length - 1].to;
    this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;
    this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);
    this.stack = [this.block];
    this.fragments = fragments.length ? new FragmentCursor$1(fragments, input) : null;
    this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line } = this;
    for (; ; ) {
      while (line.depth < this.stack.length)
        this.finishContext();
      for (let mark of line.markers)
        this.addNode(mark.type, mark.from, mark.to);
      if (line.pos < line.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(line.basePos))
      return null;
    start:
      for (; ; ) {
        for (let type of this.parser.blockParsers)
          if (type) {
            let result = type(this, line);
            if (result != false) {
              if (result == true)
                return null;
              line.forward();
              continue start;
            }
          }
        break;
      }
    let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));
    for (let parse2 of this.parser.leafBlockParsers)
      if (parse2) {
        let parser2 = parse2(this, leaf);
        if (parser2)
          leaf.parsers.push(parser2);
      }
    lines:
      while (this.nextLine()) {
        if (line.pos == line.text.length)
          break;
        if (line.indent < line.baseIndent + 4) {
          for (let stop of this.parser.endLeafBlock)
            if (stop(this, line))
              break lines;
        }
        for (let parser2 of leaf.parsers)
          if (parser2.nextLine(this, line, leaf))
            return null;
        leaf.content += "\n" + line.scrub();
        for (let m of line.markers)
          leaf.marks.push(m);
      }
    this.finishLeaf(leaf);
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  reuseFragment(start) {
    if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return false;
    let taken = this.fragments.takeNodes(this);
    if (!taken)
      return false;
    let withoutGaps = taken, end = this.absoluteLineStart + taken;
    for (let i = 1; i < this.ranges.length; i++) {
      let gapFrom = this.ranges[i - 1].to, gapTo = this.ranges[i].from;
      if (gapFrom >= this.lineStart && gapTo < end)
        withoutGaps -= gapTo - gapFrom;
    }
    this.lineStart += withoutGaps;
    this.absoluteLineStart += taken;
    this.moveRangeI();
    if (this.absoluteLineStart < this.to) {
      this.lineStart++;
      this.absoluteLineStart++;
      this.readLine();
    } else {
      this.atEnd = true;
      this.readLine();
    }
    return true;
  }
  get depth() {
    return this.stack.length;
  }
  parentType(depth = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[depth].type];
  }
  nextLine() {
    this.lineStart += this.line.text.length;
    if (this.absoluteLineEnd >= this.to) {
      this.absoluteLineStart = this.absoluteLineEnd;
      this.atEnd = true;
      this.readLine();
      return false;
    } else {
      this.lineStart++;
      this.absoluteLineStart = this.absoluteLineEnd + 1;
      this.moveRangeI();
      this.readLine();
      return true;
    }
  }
  moveRangeI() {
    while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to)
      this.rangeI++;
  }
  readLine() {
    let { line } = this, text3, end = this.absoluteLineStart;
    if (this.atEnd) {
      text3 = "";
    } else {
      text3 = this.lineChunkAt(end);
      end += text3.length;
      if (this.ranges.length > 1) {
        let textOffset = this.absoluteLineStart, rangeI = this.rangeI;
        while (this.ranges[rangeI].to < end) {
          rangeI++;
          let nextFrom = this.ranges[rangeI].from;
          let after = this.lineChunkAt(nextFrom);
          end = nextFrom + after.length;
          text3 = text3.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;
          textOffset = end - text3.length;
        }
      }
    }
    this.absoluteLineEnd = end;
    line.reset(text3);
    for (; line.depth < this.stack.length; line.depth++) {
      let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];
      if (!handler)
        throw new Error("Unhandled block context " + Type[cx.type]);
      if (!handler(cx, this, line))
        break;
      line.forward();
    }
  }
  lineChunkAt(pos) {
    let next = this.input.chunk(pos), text3;
    if (!this.input.lineChunks) {
      let eol = next.indexOf("\n");
      text3 = eol < 0 ? next : next.slice(0, eol);
    } else {
      text3 = next == "\n" ? "" : next;
    }
    return pos + text3.length > this.to ? text3.slice(0, this.to - pos) : text3;
  }
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  startContext(type, start, value = 0) {
    this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);
    this.stack.push(this.block);
  }
  startComposite(type, start, value = 0) {
    this.startContext(this.parser.getNodeType(type), start, value);
  }
  addNode(block3, from, to) {
    if (typeof block3 == "number")
      block3 = new Tree(this.parser.nodeSet.types[block3], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);
    this.block.addChild(block3, from - this.block.from);
  }
  addElement(elt2) {
    this.block.addChild(elt2.toTree(this.parser.nodeSet), elt2.from - this.block.from);
  }
  addLeafElement(leaf, elt2) {
    this.addNode(this.buffer.writeElements(injectMarks(elt2.children, leaf.marks), -elt2.from).finish(elt2.type, elt2.to - elt2.from), elt2.from);
  }
  finishContext() {
    let cx = this.stack.pop();
    let top2 = this.stack[this.stack.length - 1];
    top2.addChild(cx.toTree(this.parser.nodeSet), cx.from - top2.from);
    this.block = top2;
  }
  finish() {
    while (this.stack.length > 1)
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(tree) {
    return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;
  }
  finishLeaf(leaf) {
    for (let parser2 of leaf.parsers)
      if (parser2.finish(this, leaf))
        return;
    let inline3 = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);
    this.addNode(this.buffer.writeElements(inline3, -leaf.start).finish(Type.Paragraph, leaf.content.length), leaf.start);
  }
  elt(type, from, to, children) {
    if (typeof type == "string")
      return elt(this.parser.getNodeType(type), from, to, children);
    return new TreeElement(type, from);
  }
  get buffer() {
    return new Buffer2(this.parser.nodeSet);
  }
}
function injectGaps(ranges, rangeI, tree, offset, dont) {
  if (dont.has(tree.tree))
    return tree.tree;
  let rangeEnd2 = ranges[rangeI].to;
  let children = [], positions = [], start = tree.from + offset;
  function movePastNext(upto, inclusive) {
    while (inclusive ? upto >= rangeEnd2 : upto > rangeEnd2) {
      let size = ranges[rangeI + 1].from - rangeEnd2;
      offset += size;
      upto += size;
      rangeI++;
      rangeEnd2 = ranges[rangeI].to;
    }
  }
  for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {
    movePastNext(ch.from + offset, true);
    let from = ch.from + offset, node;
    if (ch.to + offset > rangeEnd2) {
      node = injectGaps(ranges, rangeI, ch, offset, dont);
      movePastNext(ch.to + offset, false);
    } else {
      node = ch.toTree();
    }
    children.push(node);
    positions.push(from - start);
  }
  movePastNext(tree.to + offset, false);
  return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : void 0);
}
class MarkdownParser extends Parser {
  constructor(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers) {
    super();
    this.nodeSet = nodeSet;
    this.blockParsers = blockParsers;
    this.leafBlockParsers = leafBlockParsers;
    this.blockNames = blockNames;
    this.endLeafBlock = endLeafBlock;
    this.skipContextMarkup = skipContextMarkup;
    this.inlineParsers = inlineParsers;
    this.inlineNames = inlineNames;
    this.wrappers = wrappers;
    this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let t2 of nodeSet.types)
      this.nodeTypes[t2.name] = t2.id;
  }
  createParse(input, fragments, ranges) {
    let parse2 = new BlockContext(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse2 = w(parse2, input, fragments, ranges);
    return parse2;
  }
  configure(spec) {
    let config2 = resolveConfig(spec);
    if (!config2)
      return this;
    let { nodeSet, skipContextMarkup } = this;
    let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;
    if (nonEmpty(config2.defineNodes)) {
      skipContextMarkup = Object.assign({}, skipContextMarkup);
      let nodeTypes2 = nodeSet.types.slice();
      for (let s of config2.defineNodes) {
        let { name: name2, block: block3, composite } = typeof s == "string" ? { name: s } : s;
        if (nodeTypes2.some((t2) => t2.name == name2))
          continue;
        if (composite)
          skipContextMarkup[nodeTypes2.length] = (bl, cx, line) => composite(cx, line, bl.value);
        let id2 = nodeTypes2.length;
        let group = composite ? ["Block", "BlockContext"] : !block3 ? void 0 : id2 >= Type.ATXHeading1 && id2 <= Type.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"];
        nodeTypes2.push(NodeType.define({
          id: id2,
          name: name2,
          props: group && [[NodeProp.group, group]]
        }));
      }
      nodeSet = new NodeSet(nodeTypes2);
    }
    if (nonEmpty(config2.props))
      nodeSet = nodeSet.extend(...config2.props);
    if (nonEmpty(config2.remove)) {
      for (let rm2 of config2.remove) {
        let block3 = this.blockNames.indexOf(rm2), inline3 = this.inlineNames.indexOf(rm2);
        if (block3 > -1)
          blockParsers[block3] = leafBlockParsers[block3] = void 0;
        if (inline3 > -1)
          inlineParsers[inline3] = void 0;
      }
    }
    if (nonEmpty(config2.parseBlock)) {
      for (let spec2 of config2.parseBlock) {
        let found = blockNames.indexOf(spec2.name);
        if (found > -1) {
          blockParsers[found] = spec2.parse;
          leafBlockParsers[found] = spec2.leaf;
        } else {
          let pos = spec2.before ? findName(blockNames, spec2.before) : spec2.after ? findName(blockNames, spec2.after) + 1 : blockNames.length - 1;
          blockParsers.splice(pos, 0, spec2.parse);
          leafBlockParsers.splice(pos, 0, spec2.leaf);
          blockNames.splice(pos, 0, spec2.name);
        }
        if (spec2.endLeaf)
          endLeafBlock.push(spec2.endLeaf);
      }
    }
    if (nonEmpty(config2.parseInline)) {
      for (let spec2 of config2.parseInline) {
        let found = inlineNames.indexOf(spec2.name);
        if (found > -1) {
          inlineParsers[found] = spec2.parse;
        } else {
          let pos = spec2.before ? findName(inlineNames, spec2.before) : spec2.after ? findName(inlineNames, spec2.after) + 1 : inlineNames.length - 1;
          inlineParsers.splice(pos, 0, spec2.parse);
          inlineNames.splice(pos, 0, spec2.name);
        }
      }
    }
    if (config2.wrap)
      wrappers = wrappers.concat(config2.wrap);
    return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);
  }
  getNodeType(name2) {
    let found = this.nodeTypes[name2];
    if (found == null)
      throw new RangeError(`Unknown node type '${name2}'`);
    return found;
  }
  parseInline(text3, offset) {
    let cx = new InlineContext(this, text3, offset);
    outer:
      for (let pos = offset; pos < cx.end; ) {
        let next = cx.char(pos);
        for (let token2 of this.inlineParsers)
          if (token2) {
            let result = token2(cx, next, pos);
            if (result >= 0) {
              pos = result;
              continue outer;
            }
          }
        pos++;
      }
    return cx.resolveMarkers(0);
  }
}
function nonEmpty(a) {
  return a != null && a.length > 0;
}
function resolveConfig(spec) {
  if (!Array.isArray(spec))
    return spec;
  if (spec.length == 0)
    return null;
  let conf = resolveConfig(spec[0]);
  if (spec.length == 1)
    return conf;
  let rest = resolveConfig(spec.slice(1));
  if (!rest || !conf)
    return conf || rest;
  let conc2 = (a, b) => (a || none).concat(b || none);
  let wrapA = conf.wrap, wrapB = rest.wrap;
  return {
    props: conc2(conf.props, rest.props),
    defineNodes: conc2(conf.defineNodes, rest.defineNodes),
    parseBlock: conc2(conf.parseBlock, rest.parseBlock),
    parseInline: conc2(conf.parseInline, rest.parseInline),
    remove: conc2(conf.remove, rest.remove),
    wrap: !wrapA ? wrapB : !wrapB ? wrapA : (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)
  };
}
function findName(names, name2) {
  let found = names.indexOf(name2);
  if (found < 0)
    throw new RangeError(`Position specified relative to unknown parser ${name2}`);
  return found;
}
let nodeTypes = [NodeType.none];
for (let i = 1, name2; name2 = Type[i]; i++) {
  nodeTypes[i] = NodeType.define({
    id: i,
    name: name2,
    props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]]
  });
}
const none = [];
class Buffer2 {
  constructor(nodeSet) {
    this.nodeSet = nodeSet;
    this.content = [];
    this.nodes = [];
  }
  write(type, from, to, children = 0) {
    this.content.push(type, from, to, 4 + children * 4);
    return this;
  }
  writeElements(elts, offset = 0) {
    for (let e of elts)
      e.writeTo(this, offset);
    return this;
  }
  finish(type, length) {
    return Tree.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: type,
      length
    });
  }
}
class Element$2 {
  constructor(type, from, to, children = none) {
    this.type = type;
    this.from = from;
    this.to = to;
    this.children = children;
  }
  writeTo(buf, offset) {
    let startOff = buf.content.length;
    buf.writeElements(this.children, offset);
    buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);
  }
  toTree(nodeSet) {
    return new Buffer2(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
}
class TreeElement {
  constructor(tree, from) {
    this.tree = tree;
    this.from = from;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return none;
  }
  writeTo(buf, offset) {
    buf.nodes.push(this.tree);
    buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);
  }
  toTree() {
    return this.tree;
  }
}
function elt(type, from, to, children) {
  return new Element$2(type, from, to, children);
}
const EmphasisUnderscore = { resolve: "Emphasis", mark: "EmphasisMark" };
const EmphasisAsterisk = { resolve: "Emphasis", mark: "EmphasisMark" };
const LinkStart = {}, ImageStart = {};
class InlineDelimiter {
  constructor(type, from, to, side) {
    this.type = type;
    this.from = from;
    this.to = to;
    this.side = side;
  }
}
const Escapable = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Punctuation = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
} catch (_) {
}
const DefaultInline = {
  Escape(cx, next, start) {
    if (next != 92 || start == cx.end - 1)
      return -1;
    let escaped = cx.char(start + 1);
    for (let i = 0; i < Escapable.length; i++)
      if (Escapable.charCodeAt(i) == escaped)
        return cx.append(elt(Type.Escape, start, start + 2));
    return -1;
  },
  Entity(cx, next, start) {
    if (next != 38)
      return -1;
    let m = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start + 1, start + 31));
    return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;
  },
  InlineCode(cx, next, start) {
    if (next != 96 || start && cx.char(start - 1) == 96)
      return -1;
    let pos = start + 1;
    while (pos < cx.end && cx.char(pos) == 96)
      pos++;
    let size = pos - start, curSize = 0;
    for (; pos < cx.end; pos++) {
      if (cx.char(pos) == 96) {
        curSize++;
        if (curSize == size && cx.char(pos + 1) != 96)
          return cx.append(elt(Type.InlineCode, start, pos + 1, [
            elt(Type.CodeMark, start, start + size),
            elt(Type.CodeMark, pos + 1 - size, pos + 1)
          ]));
      } else {
        curSize = 0;
      }
    }
    return -1;
  },
  HTMLTag(cx, next, start) {
    if (next != 60 || start == cx.end - 1)
      return -1;
    let after = cx.slice(start + 1, cx.end);
    let url = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);
    if (url)
      return cx.append(elt(Type.URL, start, start + 1 + url[0].length));
    let comment2 = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);
    if (comment2)
      return cx.append(elt(Type.Comment, start, start + 1 + comment2[0].length));
    let procInst = /^\?[^]*?\?>/.exec(after);
    if (procInst)
      return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));
    let m = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);
    if (!m)
      return -1;
    return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));
  },
  Emphasis(cx, next, start) {
    if (next != 95 && next != 42)
      return -1;
    let pos = start + 1;
    while (cx.char(pos) == next)
      pos++;
    let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);
    let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
    let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
    let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);
    let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);
    let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);
    let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);
    return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 : 0) | (canClose ? 2 : 0)));
  },
  HardBreak(cx, next, start) {
    if (next == 92 && cx.char(start + 1) == 10)
      return cx.append(elt(Type.HardBreak, start, start + 2));
    if (next == 32) {
      let pos = start + 1;
      while (cx.char(pos) == 32)
        pos++;
      if (cx.char(pos) == 10 && pos >= start + 2)
        return cx.append(elt(Type.HardBreak, start, pos + 1));
    }
    return -1;
  },
  Link(cx, next, start) {
    return next == 91 ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1)) : -1;
  },
  Image(cx, next, start) {
    return next == 33 && cx.char(start + 1) == 91 ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1)) : -1;
  },
  LinkEnd(cx, next, start) {
    if (next != 93)
      return -1;
    for (let i = cx.parts.length - 1; i >= 0; i--) {
      let part2 = cx.parts[i];
      if (part2 instanceof InlineDelimiter && (part2.type == LinkStart || part2.type == ImageStart)) {
        if (!part2.side || cx.skipSpace(part2.to) == start && !/[(\[]/.test(cx.slice(start + 1, start + 2))) {
          cx.parts[i] = null;
          return -1;
        }
        let content2 = cx.takeContent(i);
        let link3 = cx.parts[i] = finishLink(cx, content2, part2.type == LinkStart ? Type.Link : Type.Image, part2.from, start + 1);
        if (part2.type == LinkStart)
          for (let j = 0; j < i; j++) {
            let p = cx.parts[j];
            if (p instanceof InlineDelimiter && p.type == LinkStart)
              p.side = 0;
          }
        return link3.to;
      }
    }
    return -1;
  }
};
function finishLink(cx, content2, type, start, startPos) {
  let { text: text3 } = cx, next = cx.char(startPos), endPos = startPos;
  content2.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));
  content2.push(elt(Type.LinkMark, startPos - 1, startPos));
  if (next == 40) {
    let pos = cx.skipSpace(startPos + 1);
    let dest = parseURL(text3, pos - cx.offset, cx.offset), title;
    if (dest) {
      pos = cx.skipSpace(dest.to);
      title = parseLinkTitle2(text3, pos - cx.offset, cx.offset);
      if (title)
        pos = cx.skipSpace(title.to);
    }
    if (cx.char(pos) == 41) {
      content2.push(elt(Type.LinkMark, startPos, startPos + 1));
      endPos = pos + 1;
      if (dest)
        content2.push(dest);
      if (title)
        content2.push(title);
      content2.push(elt(Type.LinkMark, pos, endPos));
    }
  } else if (next == 91) {
    let label = parseLinkLabel2(text3, startPos - cx.offset, cx.offset, false);
    if (label) {
      content2.push(label);
      endPos = label.to;
    }
  }
  return elt(type, start, endPos, content2);
}
function parseURL(text3, start, offset) {
  let next = text3.charCodeAt(start);
  if (next == 60) {
    for (let pos = start + 1; pos < text3.length; pos++) {
      let ch = text3.charCodeAt(pos);
      if (ch == 62)
        return elt(Type.URL, start + offset, pos + 1 + offset);
      if (ch == 60 || ch == 10)
        return false;
    }
    return null;
  } else {
    let depth = 0, pos = start;
    for (let escaped = false; pos < text3.length; pos++) {
      let ch = text3.charCodeAt(pos);
      if (space$2(ch)) {
        break;
      } else if (escaped) {
        escaped = false;
      } else if (ch == 40) {
        depth++;
      } else if (ch == 41) {
        if (!depth)
          break;
        depth--;
      } else if (ch == 92) {
        escaped = true;
      }
    }
    return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text3.length ? null : false;
  }
}
function parseLinkTitle2(text3, start, offset) {
  let next = text3.charCodeAt(start);
  if (next != 39 && next != 34 && next != 40)
    return false;
  let end = next == 40 ? 41 : next;
  for (let pos = start + 1, escaped = false; pos < text3.length; pos++) {
    let ch = text3.charCodeAt(pos);
    if (escaped)
      escaped = false;
    else if (ch == end)
      return elt(Type.LinkTitle, start + offset, pos + 1 + offset);
    else if (ch == 92)
      escaped = true;
  }
  return null;
}
function parseLinkLabel2(text3, start, offset, requireNonWS) {
  for (let escaped = false, pos = start + 1, end = Math.min(text3.length, pos + 999); pos < end; pos++) {
    let ch = text3.charCodeAt(pos);
    if (escaped)
      escaped = false;
    else if (ch == 93)
      return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);
    else {
      if (requireNonWS && !space$2(ch))
        requireNonWS = false;
      if (ch == 91)
        return false;
      else if (ch == 92)
        escaped = true;
    }
  }
  return null;
}
class InlineContext {
  constructor(parser2, text3, offset) {
    this.parser = parser2;
    this.text = text3;
    this.offset = offset;
    this.parts = [];
  }
  char(pos) {
    return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset);
  }
  get end() {
    return this.offset + this.text.length;
  }
  slice(from, to) {
    return this.text.slice(from - this.offset, to - this.offset);
  }
  append(elt2) {
    this.parts.push(elt2);
    return elt2.to;
  }
  addDelimiter(type, from, to, open, close) {
    return this.append(new InlineDelimiter(type, from, to, (open ? 1 : 0) | (close ? 2 : 0)));
  }
  addElement(elt2) {
    return this.append(elt2);
  }
  resolveMarkers(from) {
    for (let i = from; i < this.parts.length; i++) {
      let close = this.parts[i];
      if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & 2))
        continue;
      let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;
      let closeSize = close.to - close.from;
      let open, j = i - 1;
      for (; j >= from; j--) {
        let part2 = this.parts[j];
        if (!(part2 instanceof InlineDelimiter && part2.side & 1 && part2.type == close.type) || emp && (close.side & 1 || part2.side & 2) && (part2.to - part2.from + closeSize) % 3 == 0 && ((part2.to - part2.from) % 3 || closeSize % 3))
          continue;
        open = part2;
        break;
      }
      if (!open)
        continue;
      let type = close.type.resolve, content2 = [];
      let start = open.from, end = close.to;
      if (emp) {
        let size = Math.min(2, open.to - open.from, closeSize);
        start = open.to - size;
        end = close.from + size;
        type = size == 1 ? "Emphasis" : "StrongEmphasis";
      }
      if (open.type.mark)
        content2.push(this.elt(open.type.mark, start, open.to));
      for (let k = j + 1; k < i; k++) {
        if (this.parts[k] instanceof Element$2)
          content2.push(this.parts[k]);
        this.parts[k] = null;
      }
      if (close.type.mark)
        content2.push(this.elt(close.type.mark, close.from, end));
      let element = this.elt(type, start, end, content2);
      this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;
      let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;
      if (keep)
        this.parts.splice(i, 0, element);
      else
        this.parts[i] = element;
    }
    let result = [];
    for (let i = from; i < this.parts.length; i++) {
      let part2 = this.parts[i];
      if (part2 instanceof Element$2)
        result.push(part2);
    }
    return result;
  }
  findOpeningDelimiter(type) {
    for (let i = this.parts.length - 1; i >= 0; i--) {
      let part2 = this.parts[i];
      if (part2 instanceof InlineDelimiter && part2.type == type)
        return i;
    }
    return null;
  }
  takeContent(startIndex) {
    let content2 = this.resolveMarkers(startIndex);
    this.parts.length = startIndex;
    return content2;
  }
  skipSpace(from) {
    return skipSpace(this.text, from - this.offset) + this.offset;
  }
  elt(type, from, to, children) {
    if (typeof type == "string")
      return elt(this.parser.getNodeType(type), from, to, children);
    return new TreeElement(type, from);
  }
}
function injectMarks(elements, marks) {
  if (!marks.length)
    return elements;
  if (!elements.length)
    return marks;
  let elts = elements.slice(), eI = 0;
  for (let mark of marks) {
    while (eI < elts.length && elts[eI].to < mark.to)
      eI++;
    if (eI < elts.length && elts[eI].from < mark.from) {
      let e = elts[eI];
      if (e instanceof Element$2)
        elts[eI] = new Element$2(e.type, e.from, e.to, injectMarks(e.children, [mark]));
    } else {
      elts.splice(eI++, 0, mark);
    }
  }
  return elts;
}
const NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];
class FragmentCursor$1 {
  constructor(fragments, input) {
    this.fragments = fragments;
    this.input = input;
    this.i = 0;
    this.fragment = null;
    this.fragmentEnd = -1;
    this.cursor = null;
    if (fragments.length)
      this.fragment = fragments[this.i++];
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;
    this.cursor = null;
    this.fragmentEnd = -1;
  }
  moveTo(pos, lineStart) {
    while (this.fragment && this.fragment.to <= pos)
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))
      return false;
    if (this.fragmentEnd < 0) {
      let end = this.fragment.to;
      while (end > 0 && this.input.read(end - 1, end) != "\n")
        end--;
      this.fragmentEnd = end ? end - 1 : 0;
    }
    let c = this.cursor;
    if (!c) {
      c = this.cursor = this.fragment.tree.cursor();
      c.firstChild();
    }
    let rPos = pos + this.fragment.offset;
    while (c.to <= rPos)
      if (!c.parent())
        return false;
    for (; ; ) {
      if (c.from >= rPos)
        return this.fragment.from <= lineStart;
      if (!c.childAfter(rPos))
        return false;
    }
  }
  matches(hash2) {
    let tree = this.cursor.tree;
    return tree && tree.prop(NodeProp.contextHash) == hash2;
  }
  takeNodes(cx) {
    let cur2 = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);
    let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;
    let prevEnd = end, prevI = blockI;
    for (; ; ) {
      if (cur2.to - off > fragEnd) {
        if (cur2.type.isAnonymous && cur2.firstChild())
          continue;
        break;
      }
      cx.dontInject.add(cur2.tree);
      cx.addNode(cur2.tree, cur2.from - off);
      if (cur2.type.is("Block")) {
        if (NotLast.indexOf(cur2.type.id) < 0) {
          end = cur2.to - off;
          blockI = cx.block.children.length;
        } else {
          end = prevEnd;
          blockI = prevI;
          prevEnd = cur2.to - off;
          prevI = cx.block.children.length;
        }
      }
      if (!cur2.nextSibling())
        break;
    }
    while (cx.block.children.length > blockI) {
      cx.block.children.pop();
      cx.block.positions.pop();
    }
    return end - start;
  }
}
const parser$4 = new MarkdownParser(new NodeSet(nodeTypes), Object.keys(DefaultBlockParsers).map((n) => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map((n) => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map((n) => DefaultInline[n]), Object.keys(DefaultInline), []);
function leftOverSpace(node, from, to) {
  let ranges = [];
  for (let n = node.firstChild, pos = from; ; n = n.nextSibling) {
    let nextPos = n ? n.from : to;
    if (nextPos > pos)
      ranges.push({ from: pos, to: nextPos });
    if (!n)
      break;
    pos = n.to;
  }
  return ranges;
}
function parseCode(config2) {
  let { codeParser, htmlParser } = config2;
  let wrap = parseMixed((node, input) => {
    let id2 = node.type.id;
    if (codeParser && (id2 == Type.CodeBlock || id2 == Type.FencedCode)) {
      let info = "";
      if (id2 == Type.FencedCode) {
        let infoNode = node.node.getChild(Type.CodeInfo);
        if (infoNode)
          info = input.read(infoNode.from, infoNode.to);
      }
      let parser2 = codeParser(info);
      if (parser2)
        return { parser: parser2, overlay: (node2) => node2.type.id == Type.CodeText };
    } else if (htmlParser && (id2 == Type.HTMLBlock || id2 == Type.HTMLTag)) {
      return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };
    }
    return null;
  });
  return { wrap };
}
const StrikethroughDelim = { resolve: "Strikethrough", mark: "StrikethroughMark" };
const Strikethrough = {
  defineNodes: ["Strikethrough", "StrikethroughMark"],
  parseInline: [{
    name: "Strikethrough",
    parse(cx, next, pos) {
      if (next != 126 || cx.char(pos + 1) != 126)
        return -1;
      return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, true, true);
    },
    after: "Emphasis"
  }]
};
function parseRow(cx, line, startI = 0, elts, offset = 0) {
  let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;
  let parseCell = () => {
    elts.push(cx.elt("TableCell", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));
  };
  for (let i = startI; i < line.length; i++) {
    let next = line.charCodeAt(i);
    if (next == 124 && !esc) {
      if (!first || cellStart > -1)
        count++;
      first = false;
      if (elts) {
        if (cellStart > -1)
          parseCell();
        elts.push(cx.elt("TableDelimiter", i + offset, i + offset + 1));
      }
      cellStart = cellEnd = -1;
    } else if (esc || next != 32 && next != 9) {
      if (cellStart < 0)
        cellStart = i;
      cellEnd = i + 1;
    }
    esc = !esc && next == 92;
  }
  if (cellStart > -1) {
    count++;
    if (elts)
      parseCell();
  }
  return count;
}
function hasPipe(str, start) {
  for (let i = start; i < str.length; i++) {
    let next = str.charCodeAt(i);
    if (next == 124)
      return true;
    if (next == 92)
      i++;
  }
  return false;
}
class TableParser {
  constructor() {
    this.rows = null;
  }
  nextLine(cx, line, leaf) {
    if (this.rows == null) {
      this.rows = false;
      let lineText;
      if ((line.next == 45 || line.next == 58 || line.next == 124) && /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/.test(lineText = line.text.slice(line.pos))) {
        let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);
        if (firstCount == parseRow(cx, lineText, line.pos))
          this.rows = [
            cx.elt("TableHeader", leaf.start, leaf.start + leaf.content.length, firstRow),
            cx.elt("TableDelimiter", cx.lineStart + line.pos, cx.lineStart + line.text.length)
          ];
      }
    } else if (this.rows) {
      let content2 = [];
      parseRow(cx, line.text, line.pos, content2, cx.lineStart);
      this.rows.push(cx.elt("TableRow", cx.lineStart + line.pos, cx.lineStart + line.text.length, content2));
    }
    return false;
  }
  finish(cx, leaf) {
    if (this.rows) {
      this.emit(cx, leaf);
      return true;
    }
    return false;
  }
  emit(cx, leaf) {
    cx.addLeafElement(leaf, cx.elt("Table", leaf.start, leaf.start + leaf.content.length, this.rows));
  }
}
const Table = {
  defineNodes: [
    { name: "Table", block: true },
    "TableHeader",
    "TableRow",
    "TableCell",
    "TableDelimiter"
  ],
  parseBlock: [{
    name: "Table",
    leaf(_, leaf) {
      return hasPipe(leaf.content, 0) ? new TableParser() : null;
    },
    before: "SetextHeading"
  }]
};
class TaskParser {
  nextLine() {
    return false;
  }
  finish(cx, leaf) {
    cx.addLeafElement(leaf, cx.elt("Task", leaf.start, leaf.start + leaf.content.length, [
      cx.elt("TaskMarker", leaf.start, leaf.start + 3),
      ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)
    ]));
    return true;
  }
}
const TaskList = {
  defineNodes: [
    { name: "Task", block: true },
    "TaskMarker"
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(cx, leaf) {
      return /^\[[ xX]\]/.test(leaf.content) && cx.parentType().name == "ListItem" ? new TaskParser() : null;
    },
    after: "SetextHeading"
  }]
};
const GFM = [Table, TaskList, Strikethrough];
function parseSubSuper(ch, node, mark) {
  return (cx, next, pos) => {
    if (next != ch || cx.char(pos + 1) == ch)
      return -1;
    let elts = [cx.elt(mark, pos, pos + 1)];
    for (let i = pos + 1; i < cx.end; i++) {
      let next2 = cx.char(i);
      if (next2 == ch)
        return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));
      if (next2 == 92)
        elts.push(cx.elt("Escape", i, i++ + 2));
      if (space$2(next2))
        break;
    }
    return -1;
  };
}
const Superscript = {
  defineNodes: ["Superscript", "SuperscriptMark"],
  parseInline: [{
    name: "Superscript",
    parse: parseSubSuper(94, "Superscript", "SuperscriptMark")
  }]
};
const Subscript = {
  defineNodes: ["Subscript", "SubscriptMark"],
  parseInline: [{
    name: "Subscript",
    parse: parseSubSuper(126, "Subscript", "SubscriptMark")
  }]
};
const Emoji = {
  defineNodes: ["Emoji"],
  parseInline: [{
    name: "Emoji",
    parse(cx, next, pos) {
      let match2;
      if (next != 58 || !(match2 = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))
        return -1;
      return cx.addElement(cx.elt("Emoji", pos, pos + 1 + match2[0].length));
    }
  }]
};
class Stack {
  constructor(p, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score2;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  toString() {
    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  reduce(action) {
    let depth = action >> 19, type = action & 65535;
    let { parser: parser2 } = this.p;
    let dPrec = parser2.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth == 0) {
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
      if (type < parser2.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = this.stack[base2 - 2];
    let bufferBase = this.stack[base2 - 1], count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base2];
    } else {
      let baseStateID = this.stack[base2 - 3];
      this.state = parser2.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base2)
      this.stack.pop();
    this.reduceContext(type, start);
  }
  storeNode(term, start, end, size = 4, isReduce = false) {
    if (term == 0) {
      let cur2 = this, top2 = this.buffer.length;
      if (top2 == 0 && cur2.parent) {
        top2 = cur2.bufferBase - cur2.parent.bufferBase;
        cur2 = cur2.parent;
      }
      if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
        if (start == end)
          return;
        if (cur2.buffer[top2 - 2] >= start) {
          cur2.buffer[top2 - 2] = end;
          return;
        }
      }
    }
    if (!isReduce || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index2 = this.buffer.length;
      if (index2 > 0 && this.buffer[index2 - 4] != 0)
        while (index2 > 0 && this.buffer[index2 - 2] > end) {
          this.buffer[index2] = this.buffer[index2 - 4];
          this.buffer[index2 + 1] = this.buffer[index2 - 3];
          this.buffer[index2 + 2] = this.buffer[index2 - 2];
          this.buffer[index2 + 3] = this.buffer[index2 - 1];
          index2 -= 4;
          if (size > 4)
            size -= 4;
        }
      this.buffer[index2] = term;
      this.buffer[index2 + 1] = start;
      this.buffer[index2 + 2] = end;
      this.buffer[index2 + 3] = size;
    }
  }
  shift(action, next, nextEnd) {
    let start = this.pos;
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser2 } = this.p;
      if (nextEnd > this.pos || next <= parser2.maxNode) {
        this.pos = nextEnd;
        if (!parser2.stateFlag(nextState, 1))
          this.reducePos = nextEnd;
      }
      this.pushState(nextState, start);
      this.shiftContext(next, start);
      if (next <= parser2.maxNode)
        this.buffer.push(next, start, nextEnd, 4);
    } else {
      this.pos = nextEnd;
      this.shiftContext(next, start);
      if (next <= this.p.parser.maxNode)
        this.buffer.push(next, start, nextEnd, 4);
    }
  }
  apply(action, next, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextEnd);
  }
  useNode(value, next) {
    let index2 = this.p.reused.length - 1;
    if (index2 < 0 || this.p.reused[index2] != value) {
      this.p.reused.push(value);
      index2++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(index2, start, this.reducePos, -1);
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
    while (parent && base2 == parent.bufferBase)
      parent = parent.parent;
    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
  }
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  canShift(term) {
    for (let sim2 = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(sim2.state, 4) || this.p.parser.hasAction(sim2.state, term);
      if ((action & 65536) == 0)
        return true;
      if (action == 0)
        return false;
      sim2.reduce(action);
    }
  }
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s; i < nextStates.length; i += 2) {
        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
          best.push(nextStates[i], s);
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s = nextStates[i + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s))
            best.push(nextStates[i], s);
        }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s = nextStates[i + 1];
      if (s == this.state)
        continue;
      let stack = this.split();
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.pushState(s, this.pos);
      stack.shiftContext(nextStates[i], this.pos);
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  forceReduce() {
    let reduce = this.p.parser.stateSlot(this.state, 5);
    if ((reduce & 65536) == 0)
      return false;
    let { parser: parser2 } = this.p;
    if (!parser2.validAction(this.state, reduce)) {
      let depth = reduce >> 19, term = reduce & 65535;
      let target2 = this.stack.length - depth * 3;
      if (target2 < 0 || parser2.getGoto(this.stack[target2], term, false) < 0)
        return false;
      this.storeNode(0, this.reducePos, this.reducePos, 4, true);
      this.score -= 100;
    }
    this.reduce(reduce);
    return true;
  }
  forceAll() {
    while (!this.p.parser.stateFlag(this.state, 2)) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser2 } = this.p;
    return parser2.data[parser2.stateSlot(this.state, 1)] == 65535 && !parser2.stateSlot(this.state, 4);
  }
  restart() {
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != other.stack[i])
        return false;
    return true;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
  }
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  }
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
}
class StackContext {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
}
var Recover;
(function(Recover2) {
  Recover2[Recover2["Insert"] = 200] = "Insert";
  Recover2[Recover2["Delete"] = 190] = "Delete";
  Recover2[Recover2["Reduce"] = 100] = "Reduce";
  Recover2[Recover2["MaxNext"] = 4] = "MaxNext";
  Recover2[Recover2["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
  Recover2[Recover2["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
class SimulatedStack {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth = action >> 19;
    if (depth == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
}
class StackBufferCursor {
  constructor(stack, pos, index2) {
    this.stack = stack;
    this.pos = pos;
    this.index = index2;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }
}
class CachedToken {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
}
const nullToken = new CachedToken();
class InputStream {
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  resolveOffset(offset, assoc) {
    let range2 = this.range, index2 = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range2.from) {
      if (!index2)
        return null;
      let next = this.ranges[--index2];
      pos -= range2.from - next.to;
      range2 = next;
    }
    while (assoc < 0 ? pos > range2.to : pos >= range2.to) {
      if (index2 == this.ranges.length - 1)
        return null;
      let next = this.ranges[++index2];
      pos += next.from - range2.to;
      range2 = next;
    }
    return pos;
  }
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i = this.rangeIndex, range2 = this.range;
        while (range2.to <= pos)
          range2 = this.ranges[++i];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range2.to)
          this.chunk2 = this.chunk2.slice(0, range2.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  acceptToken(token2, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token2;
    this.token.end = end;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  advance(n = 1) {
    this.chunkOff += n;
    while (this.pos + n >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  reset(pos, token2) {
    if (token2) {
      this.token = token2;
      token2.start = pos;
      token2.lookAhead = pos + 1;
      token2.value = token2.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
    if (from >= this.range.from && to <= this.range.to)
      return this.input.read(from, to);
    let result = "";
    for (let r of this.ranges) {
      if (r.from >= to)
        break;
      if (r.to > from)
        result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
    }
    return result;
  }
}
class TokenGroup {
  constructor(data2, id2) {
    this.data = data2;
    this.id = id2;
  }
  token(input, stack) {
    readToken(this.data, input, stack, this.id);
  }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
class ExternalTokenizer {
  constructor(token2, options = {}) {
    this.token = token2;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }
}
function readToken(data2, input, stack, group) {
  let state = 0, groupMask = 1 << group, { parser: parser2 } = stack.p, { dialect } = parser2;
  scan:
    for (; ; ) {
      if ((groupMask & data2[state]) == 0)
        break;
      let accEnd = data2[state + 1];
      for (let i = state + 3; i < accEnd; i += 2)
        if ((data2[i + 1] & groupMask) > 0) {
          let term = data2[i];
          if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser2.overrides(term, input.token.value))) {
            input.acceptToken(term);
            break;
          }
        }
      for (let next = input.next, low = 0, high = data2[state + 2]; low < high; ) {
        let mid2 = low + high >> 1;
        let index2 = accEnd + mid2 + (mid2 << 1);
        let from = data2[index2], to = data2[index2 + 1];
        if (next < from)
          high = mid2;
        else if (next >= to)
          low = mid2 + 1;
        else {
          state = data2[index2 + 2];
          input.advance();
          continue scan;
        }
      }
      break;
    }
}
function decodeArray(input, Type2 = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type2(value);
  }
  return array;
}
const verbose = typeof process != "undefined" && /\bparse\b/.test({}.LOG);
let stackIDs = null;
var Safety;
(function(Safety2) {
  Safety2[Safety2["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));
function cutAt(tree, pos, side) {
  let cursor2 = tree.fullCursor();
  cursor2.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor2.childBefore(pos) : cursor2.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor2.to < pos : cursor2.from > pos) && !cursor2.type.isError)
          return side < 0 ? Math.max(0, Math.min(cursor2.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor2.from + 1, pos + 25));
        if (side < 0 ? cursor2.prevSibling() : cursor2.nextSibling())
          break;
        if (!cursor2.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
class FragmentCursor {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top2 = this.trees[last], index2 = this.index[last];
      if (index2 == top2.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top2.children[index2];
      let start = this.start[last] + top2.positions[index2];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to)
              return next;
          }
        }
        this.index[last]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next.length;
      }
    }
  }
}
class TokenCache {
  constructor(parser2, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser2 } = stack.p, { tokenizers } = parser2;
    let mask = parser2.stateSlot(stack.state, 3);
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0)
        continue;
      let tokenizer = tokenizers[i], token2 = this.tokens[i];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token2.start != stack.pos || token2.mask != mask || token2.context != context) {
        this.updateCachedToken(token2, tokenizer, stack);
        token2.mask = mask;
        token2.context = context;
      }
      if (token2.lookAhead > token2.end + 25)
        lookAhead = Math.max(token2.lookAhead, lookAhead);
      if (token2.value != 0) {
        let startIndex = actionIndex;
        if (token2.extended > -1)
          actionIndex = this.addActions(stack, token2.extended, token2.end, actionIndex);
        actionIndex = this.addActions(stack, token2.value, token2.end, actionIndex);
        if (!tokenizer.extend) {
          main = token2;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p.stream.end);
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token2, tokenizer, stack) {
    tokenizer.token(this.stream.reset(stack.pos, token2), stack);
    if (token2.value > -1) {
      let { parser: parser2 } = stack.p;
      for (let i = 0; i < parser2.specialized.length; i++)
        if (parser2.specialized[i] == token2.value) {
          let result = parser2.specializers[i](this.stream.read(token2.start, token2.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token2.value = result >> 1;
            else
              token2.extended = result >> 1;
            break;
          }
        }
    } else {
      token2.value = 0;
      token2.end = Math.min(stack.p.stream.end, stack.pos + 1);
    }
  }
  putAction(action, token2, end, index2) {
    for (let i = 0; i < index2; i += 3)
      if (this.actions[i] == action)
        return index2;
    this.actions[index2++] = action;
    this.actions[index2++] = token2;
    this.actions[index2++] = end;
    return index2;
  }
  addActions(stack, token2, end, index2) {
    let { state } = stack, { parser: parser2 } = stack.p, { data: data2 } = parser2;
    for (let set2 = 0; set2 < 2; set2++) {
      for (let i = parser2.stateSlot(state, set2 ? 2 : 1); ; i += 3) {
        if (data2[i] == 65535) {
          if (data2[i + 1] == 1) {
            i = pair(data2, i + 2);
          } else {
            if (index2 == 0 && data2[i + 1] == 2)
              index2 = this.putAction(pair(data2, i + 2), token2, end, index2);
            break;
          }
        }
        if (data2[i] == token2)
          index2 = this.putAction(pair(data2, i + 1), token2, end, index2);
      }
    }
    return index2;
  }
}
var Rec;
(function(Rec2) {
  Rec2[Rec2["Distance"] = 5] = "Distance";
  Rec2[Rec2["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
  Rec2[Rec2["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
  Rec2[Rec2["ForceReduceLimit"] = 10] = "ForceReduceLimit";
  Rec2[Rec2["CutDepth"] = 15e3] = "CutDepth";
  Rec2[Rec2["CutTo"] = 9e3] = "CutTo";
})(Rec || (Rec = {}));
class Parse {
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser2, this.stream);
    this.topTerm = parser2.top[1];
    let { from } = ranges[0];
    this.stacks = [Stack.start(this, parser2.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished)
        return this.stackToTree(finished);
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished)
        return this.stackToTree(finished.forceAll());
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s) => s.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer:
        for (let i = 0; i < newStacks.length - 1; i++) {
          let stack = newStacks[i];
          for (let j = i + 1; j < newStacks.length; j++) {
            let other = newStacks[j];
            if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
              if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j--, 1);
              } else {
                newStacks.splice(i--, 1);
                continue outer;
              }
            }
          }
        }
    }
    this.minStackPos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.minStackPos)
        this.minStackPos = newStacks[i].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser2 } = this;
    let base2 = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match2 = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
        if (match2 > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match2);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(stack.state, 4);
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser2.getName(defaultReduce & 65535)})`);
      return true;
    }
    if (stack.stack.length >= 15e3) {
      while (stack.stack.length > 9e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i = 0; i < actions.length; ) {
      let action = actions[i++], term = actions[i++], end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      localStack.apply(action, term, end);
      if (verbose)
        console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(action & 65535)}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], token2 = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base2 + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done)
          continue;
      }
      let force = stack.split(), forceBase = base2;
      for (let j = 0; force.forceReduce() && j < 10; j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert2 of stack.recoverByInsert(token2)) {
        if (verbose)
          console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
        this.advanceFully(insert2, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token2 = 0;
        }
        stack.recoverByDelete(token2, tokenEnd);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token2)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2)
      stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
}
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score)
        newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
class Dialect {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
}
const id = (x) => x;
class ContextTracker {
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id;
    this.reduce = spec.reduce || id;
    this.reuse = spec.reuse || id;
    this.hash = spec.hash || (() => 0);
    this.strict = spec.strict !== false;
  }
}
class LRParser extends Parser {
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 13)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i = 0; i < spec.repeatNodeCount; i++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++)
      nodeProps.push([]);
    function setProp(nodeID, prop2, value) {
      nodeProps[nodeID].push([prop2, prop2.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop2 = propSpec[0];
        for (let i = 1; i < propSpec.length; ) {
          let next = propSpec[i++];
          if (next >= 0) {
            setProp(next, prop2, propSpec[i++]);
          } else {
            let value = propSpec[i + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i++], prop2, value);
            i++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
      name: i >= this.minRepeatTerm ? void 0 : name2,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
    this.specializers = [];
    if (spec.specialized)
      for (let i = 0; i < spec.specialized.length; i++) {
        this.specialized[i] = spec.specialized[i].term;
        this.specializers[i] = spec.specialized[i].get;
      }
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse2 = new Parse(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse2 = w(parse2, input, fragments, ranges);
    return parse2;
  }
  getGoto(state, term, loose = false) {
    let table3 = this.goto;
    if (term >= table3[0])
      return -1;
    for (let pos = table3[term + 1]; ; ) {
      let groupTag = table3[pos++], last = groupTag & 1;
      let target2 = table3[pos++];
      if (last && loose)
        return target2;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table3[pos] == state)
          return target2;
      if (last)
        return -1;
    }
  }
  hasAction(state, terminal) {
    let data2 = this.data;
    for (let set2 = 0; set2 < 2; set2++) {
      for (let i = this.stateSlot(state, set2 ? 2 : 1), next; ; i += 3) {
        if ((next = data2[i]) == 65535) {
          if (data2[i + 1] == 1)
            next = data2[i = pair(data2, i + 2)];
          else if (data2[i + 1] == 2)
            return pair(data2, i + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data2, i + 1);
      }
    }
    return 0;
  }
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  stateFlag(state, flag) {
    return (this.stateSlot(state, 0) & flag) > 0;
  }
  validAction(state, action) {
    if (action == this.stateSlot(state, 4))
      return true;
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          return false;
      }
      if (action == pair(this.data, i + 1))
        return true;
    }
  }
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i2) => i2 & 1 && v == value))
          result.push(this.data[i], value);
      }
    }
    return result;
  }
  overrides(token2, prev) {
    let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token2) < iPrev;
  }
  configure(config2) {
    let copy2 = Object.assign(Object.create(LRParser.prototype), this);
    if (config2.props)
      copy2.nodeSet = this.nodeSet.extend(...config2.props);
    if (config2.top) {
      let info = this.topRules[config2.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config2.top}`);
      copy2.top = info;
    }
    if (config2.tokenizers)
      copy2.tokenizers = this.tokenizers.map((t2) => {
        let found = config2.tokenizers.find((r) => r.from == t2);
        return found ? found.to : t2;
      });
    if (config2.contextTracker)
      copy2.context = config2.contextTracker;
    if (config2.dialect)
      copy2.dialect = this.parseDialect(config2.dialect);
    if (config2.strict != null)
      copy2.strict = config2.strict;
    if (config2.wrap)
      copy2.wrappers = copy2.wrappers.concat(config2.wrap);
    if (config2.bufferLength != null)
      copy2.bufferLength = config2.bufferLength;
    return copy2;
  }
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(term) {
    let prec2 = this.dynamicPrecedences;
    return prec2 == null ? 0 : prec2[term] || 0;
  }
  parseDialect(dialect) {
    let values2 = Object.keys(this.dialects), flags = values2.map(() => false);
    if (dialect)
      for (let part2 of dialect.split(" ")) {
        let id2 = values2.indexOf(part2);
        if (id2 >= 0)
          flags[id2] = true;
      }
    let disabled = null;
    for (let i = 0; i < values2.length; i++)
      if (!flags[i]) {
        for (let j = this.dialects[values2[i]], id2; (id2 = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect, flags, disabled);
  }
  static deserialize(spec) {
    return new LRParser(spec);
  }
}
function pair(data2, off) {
  return data2[off] | data2[off + 1] << 16;
}
function findOffset(data2, start, term) {
  for (let i = start, next; (next = data2[i]) != 65535; i++)
    if (next == term)
      return i - start;
  return -1;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
const scriptText = 53, StartCloseScriptTag = 1, styleText = 54, StartCloseStyleTag = 2, textareaText = 55, StartCloseTextareaTag = 3, StartTag = 4, StartScriptTag = 5, StartStyleTag = 6, StartTextareaTag = 7, StartSelfClosingTag = 8, StartCloseTag = 9, NoMatchStartCloseTag = 10, MismatchedStartCloseTag = 11, missingCloseTag = 56, IncompleteCloseTag = 12, commentContent$1 = 57, Element$1 = 18, ScriptText = 27, StyleText = 30, TextareaText = 33, OpenTag = 35, Dialect_noMatch = 0;
const selfClosers = {
  area: true,
  base: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
  menuitem: true
};
const implicitlyClosed = {
  dd: true,
  li: true,
  optgroup: true,
  option: true,
  p: true,
  rp: true,
  rt: true,
  tbody: true,
  td: true,
  tfoot: true,
  th: true,
  tr: true
};
const closeOnOpen = {
  dd: { dd: true, dt: true },
  dt: { dd: true, dt: true },
  li: { li: true },
  option: { option: true, optgroup: true },
  optgroup: { optgroup: true },
  p: {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    dir: true,
    div: true,
    dl: true,
    fieldset: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    menu: true,
    nav: true,
    ol: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    ul: true
  },
  rp: { rp: true, rt: true },
  rt: { rp: true, rt: true },
  tbody: { tbody: true, tfoot: true },
  td: { td: true, th: true },
  tfoot: { tbody: true },
  th: { td: true, th: true },
  thead: { tbody: true, tfoot: true },
  tr: { tr: true }
};
function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;
}
function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32;
}
let cachedName = null, cachedInput = null, cachedPos = 0;
function tagNameAfter(input, offset) {
  let pos = input.pos + offset;
  if (cachedPos == pos && cachedInput == input)
    return cachedName;
  let next = input.peek(offset);
  while (isSpace(next))
    next = input.peek(++offset);
  let name2 = "";
  for (; ; ) {
    if (!nameChar(next))
      break;
    name2 += String.fromCharCode(next);
    next = input.peek(++offset);
  }
  cachedInput = input;
  cachedPos = pos;
  return cachedName = name2 ? name2.toLowerCase() : next == question || next == bang ? void 0 : null;
}
const lessThan = 60, greaterThan = 62, slash$1 = 47, question = 63, bang = 33;
function ElementContext(name2, parent) {
  this.name = name2;
  this.parent = parent;
  this.hash = parent ? parent.hash : 0;
  for (let i = 0; i < name2.length; i++)
    this.hash += (this.hash << 4) + name2.charCodeAt(i) + (name2.charCodeAt(i) << 8);
}
const startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];
const elementContext = new ContextTracker({
  start: null,
  shift(context, term, stack, input) {
    return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
  },
  reduce(context, term) {
    return term == Element$1 && context ? context.parent : context;
  },
  reuse(context, node, stack, input) {
    let type = node.type.id;
    return type == StartTag || type == OpenTag ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
  },
  hash(context) {
    return context ? context.hash : 0;
  },
  strict: false
});
const tagStart = new ExternalTokenizer((input, stack) => {
  if (input.next != lessThan) {
    if (input.next < 0 && stack.context)
      input.acceptToken(missingCloseTag);
    return;
  }
  input.advance();
  let close = input.next == slash$1;
  if (close)
    input.advance();
  let name2 = tagNameAfter(input, 0);
  if (name2 === void 0)
    return;
  if (!name2)
    return input.acceptToken(close ? IncompleteCloseTag : StartTag);
  let parent = stack.context ? stack.context.name : null;
  if (close) {
    if (name2 == parent)
      return input.acceptToken(StartCloseTag);
    if (parent && implicitlyClosed[parent])
      return input.acceptToken(missingCloseTag, -2);
    if (stack.dialectEnabled(Dialect_noMatch))
      return input.acceptToken(NoMatchStartCloseTag);
    for (let cx = stack.context; cx; cx = cx.parent)
      if (cx.name == name2)
        return;
    input.acceptToken(MismatchedStartCloseTag);
  } else {
    if (name2 == "script")
      return input.acceptToken(StartScriptTag);
    if (name2 == "style")
      return input.acceptToken(StartStyleTag);
    if (name2 == "textarea")
      return input.acceptToken(StartTextareaTag);
    if (selfClosers.hasOwnProperty(name2))
      return input.acceptToken(StartSelfClosingTag);
    if (parent && closeOnOpen[parent] && closeOnOpen[parent][name2])
      input.acceptToken(missingCloseTag, -1);
    else
      input.acceptToken(StartTag);
  }
}, { contextual: true });
const commentContent = new ExternalTokenizer((input) => {
  for (let endPos = 0, i = 0; ; i++) {
    if (input.next < 0) {
      if (i)
        input.acceptToken(commentContent$1);
      break;
    }
    if (input.next == "-->".charCodeAt(endPos)) {
      endPos++;
      if (endPos == 3) {
        if (i > 3)
          input.acceptToken(commentContent$1, -2);
        break;
      }
    } else {
      endPos = 0;
    }
    input.advance();
  }
});
function contentTokenizer(tag, textToken, endToken) {
  let lastState = 2 + tag.length;
  return new ExternalTokenizer((input) => {
    for (let state = 0, matchedLen = 0, i = 0; ; i++) {
      if (input.next < 0) {
        if (i)
          input.acceptToken(textToken);
        break;
      }
      if (state == 0 && input.next == lessThan || state == 1 && input.next == slash$1 || state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {
        state++;
        matchedLen++;
      } else if ((state == 2 || state == lastState) && isSpace(input.next)) {
        matchedLen++;
      } else if (state == lastState && input.next == greaterThan) {
        if (i > matchedLen)
          input.acceptToken(textToken, -matchedLen);
        else
          input.acceptToken(endToken, -(matchedLen - 2));
        break;
      } else if ((input.next == 10 || input.next == 13) && i) {
        input.acceptToken(textToken, 1);
        break;
      } else {
        state = matchedLen = 0;
      }
      input.advance();
    }
  });
}
const scriptTokens = contentTokenizer("script", scriptText, StartCloseScriptTag);
const styleTokens = contentTokenizer("style", styleText, StartCloseStyleTag);
const textareaTokens = contentTokenizer("textarea", textareaText, StartCloseTextareaTag);
const parser$3 = LRParser.deserialize({
  version: 13,
  states: ",xOVOxOOO!WQ!bO'#CoO!]Q!bO'#CyO!bQ!bO'#C|O!gQ!bO'#DPO!lQ!bO'#DRO!qOXO'#CnO!|OYO'#CnO#XO[O'#CnO$eOxO'#CnOOOW'#Cn'#CnO$lO!rO'#DSO$tQ!bO'#DUO$yQ!bO'#DVOOOW'#Dj'#DjOOOW'#DX'#DXQVOxOOO%OQ#tO,59ZO%WQ#tO,59eO%`Q#tO,59hO%hQ#tO,59kO%pQ#tO,59mOOOX'#D]'#D]O%xOXO'#CwO&TOXO,59YOOOY'#D^'#D^O&]OYO'#CzO&hOYO,59YOOO['#D_'#D_O&pO[O'#C}O&{O[O,59YOOOW'#D`'#D`O'TOxO,59YO'[Q!bO'#DQOOOW,59Y,59YOOO`'#Da'#DaO'aO!rO,59nOOOW,59n,59nO'iQ!bO,59pO'nQ!bO,59qOOOW-E7V-E7VO'sQ#tO'#CqOOQO'#DY'#DYO(OQ#tO1G.uOOOX1G.u1G.uO(WQ#tO1G/POOOY1G/P1G/PO(`Q#tO1G/SOOO[1G/S1G/SO(hQ#tO1G/VOOOW1G/V1G/VO(pQ#tO1G/XOOOW1G/X1G/XOOOX-E7Z-E7ZO(xQ!bO'#CxOOOW1G.t1G.tOOOY-E7[-E7[O(}Q!bO'#C{OOO[-E7]-E7]O)SQ!bO'#DOOOOW-E7^-E7^O)XQ!bO,59lOOO`-E7_-E7_OOOW1G/Y1G/YOOOW1G/[1G/[OOOW1G/]1G/]O)^Q&jO,59]OOQO-E7W-E7WOOOX7+$a7+$aOOOY7+$k7+$kOOO[7+$n7+$nOOOW7+$q7+$qOOOW7+$s7+$sO)iQ!bO,59dO)nQ!bO,59gO)sQ!bO,59jOOOW1G/W1G/WO)xO,UO'#CtO*WO7[O'#CtOOQO1G.w1G.wOOOW1G/O1G/OOOOW1G/R1G/ROOOW1G/U1G/UOOOO'#DZ'#DZO*fO,UO,59`OOQO,59`,59`OOOO'#D['#D[O*tO7[O,59`OOOO-E7X-E7XOOQO1G.z1G.zOOOO-E7Y-E7Y",
  stateData: "+[~O!]OS~OSSOTPOUQOVROWTOY]OZ[O[^O^^O_^O`^Oa^Ow^Oz_O!cZO~OdaO~OdbO~OdcO~OddO~OdeO~O!VfOPkP!YkP~O!WiOQnP!YnP~O!XlORqP!YqP~OSSOTPOUQOVROWTOXqOY]OZ[O[^O^^O_^O`^Oa^Ow^O!cZO~O!YrO~P#dO!ZsO!duO~OdvO~OdwO~OfyOj|O~OfyOj!OO~OfyOj!QO~OfyOj!SO~OfyOj!UO~O!VfOPkX!YkX~OP!WO!Y!XO~O!WiOQnX!YnX~OQ!ZO!Y!XO~O!XlORqX!YqX~OR!]O!Y!XO~O!Y!XO~P#dOd!_O~O!ZsO!d!aO~Oj!bO~Oj!cO~Og!dOfeXjeX~OfyOj!fO~OfyOj!gO~OfyOj!hO~OfyOj!iO~OfyOj!jO~Od!kO~Od!lO~Od!mO~Oj!nO~Oi!qO!_!oO!a!pO~Oj!rO~Oj!sO~Oj!tO~O_!uO`!uO!_!wO!`!uO~O_!xO`!xO!a!wO!b!xO~O_!uO`!uO!_!{O!`!uO~O_!xO`!xO!a!{O!b!xO~O`_a!cwz!c~",
  goto: "%o!_PPPPPPPPPPPPPPPPPP!`!fP!lPP!xPP!{#O#R#X#[#_#e#h#k#q#w!`P!`!`P#}$T$k$q$w$}%T%Z%aPPPPPPPP%gX^OX`pXUOX`pezabcde{}!P!R!TR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!TeZ!e{}!P!R!TQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "\u26A0 StartCloseTag StartCloseTag StartCloseTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 66,
  context: elementContext,
  nodeProps: [
    [NodeProp.closedBy, -11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, "EndTag", -4, 19, 29, 32, 35, "CloseTag"],
    [NodeProp.group, -9, 12, 15, 16, 17, 18, 38, 39, 40, 41, "Entity", 14, "Entity TextContent", -3, 27, 30, 33, "TextContent Entity"],
    [NodeProp.openedBy, 26, "StartTag StartCloseTag", -4, 28, 31, 34, 36, "OpenTag"]
  ],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!#b!aR!WOX$kXY)sYZ)sZ]$k]^)s^p$kpq)sqr$krs*zsv$kvw+dwx2yx}$k}!O3f!O!P$k!P!Q7_!Q![$k![!]8u!]!^$k!^!_>b!_!`!!p!`!a8T!a!c$k!c!}8u!}#R$k#R#S8u#S#T$k#T#o8u#o$f$k$f$g&R$g%W$k%W%o8u%o%p$k%p&a8u&a&b$k&b1p8u1p4U$k4U4d8u4d4e$k4e$IS8u$IS$I`$k$I`$Ib8u$Ib$Kh$k$Kh%#t8u%#t&/x$k&/x&Et8u&Et&FV$k&FV;'S8u;'S;:j<t;:j?&r$k?&r?Ah8u?Ah?BY$k?BY?Mn8u?Mn~$k!Z$vc^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!R&[V^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&Rq&xT^P!bpOv&qwx'Xx!^&q!^!_'g!_~&qP'^R^POv'Xw!^'X!_~'Xp'lQ!bpOv'gx~'ga'yU^P!``Or'rrs'Xsv'rw!^'r!^!_(]!_~'r`(bR!``Or(]sv(]w~(]!Q(rT!``!bpOr(krs'gsv(kwx(]x~(kW)WXiWOX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!a*O^^P!``!bp!]^OX&RXY)sYZ)sZ]&R]^)s^p&Rpq)sqr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!Z+TT!_h^P!bpOv&qwx'Xx!^&q!^!_'g!_~&q!Z+kbiWaPOX,sXZ.QZ],s]^.Q^p,sqr,srs.Qst/]tw,swx.Qx!P,s!P!Q.Q!Q!],s!]!^)R!^!a.Q!a$f,s$f$g.Q$g~,s!Z,xbiWOX,sXZ.QZ],s]^.Q^p,sqr,srs.Qst)Rtw,swx.Qx!P,s!P!Q.Q!Q!],s!]!^.i!^!a.Q!a$f,s$f$g.Q$g~,s!R.TTOp.Qqs.Qt!].Q!]!^.d!^~.Q!R.iO_!R!Z.pXiW_!ROX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z/baiWOX0gXZ1qZ]0g]^1q^p0gqr0grs1qsw0gwx1qx!P0g!P!Q1q!Q!]0g!]!^)R!^!a1q!a$f0g$f$g1q$g~0g!Z0laiWOX0gXZ1qZ]0g]^1q^p0gqr0grs1qsw0gwx1qx!P0g!P!Q1q!Q!]0g!]!^2V!^!a1q!a$f0g$f$g1q$g~0g!R1tSOp1qq!]1q!]!^2Q!^~1q!R2VO`!R!Z2^XiW`!ROX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z3SU!ax^P!``Or'rrs'Xsv'rw!^'r!^!_(]!_~'r!]3qe^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O5S!O!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!]5_d^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!`&R!`!a6m!a$f$k$f$g&R$g~$k!T6xV^P!``!bp!dQOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!X7hX^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_!`&R!`!a8T!a~&R!X8`VjU^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!a9U!YfSdQ^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O8u!O!P8u!P!Q&R!Q![8u![!]8u!]!^$k!^!_(k!_!a&R!a!c$k!c!}8u!}#R$k#R#S8u#S#T$k#T#o8u#o$f$k$f$g&R$g$}$k$}%O8u%O%W$k%W%o8u%o%p$k%p&a8u&a&b$k&b1p8u1p4U8u4U4d8u4d4e$k4e$IS8u$IS$I`$k$I`$Ib8u$Ib$Je$k$Je$Jg8u$Jg$Kh$k$Kh%#t8u%#t&/x$k&/x&Et8u&Et&FV$k&FV;'S8u;'S;:j<t;:j?&r$k?&r?Ah8u?Ah?BY$k?BY?Mn8u?Mn~$k!a=Pe^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g;=`$k;=`<%l8u<%l~$k!R>iW!``!bpOq(kqr?Rrs'gsv(kwx(]x!a(k!a!bKj!b~(k!R?YZ!``!bpOr(krs'gsv(kwx(]x}(k}!O?{!O!f(k!f!gAR!g#W(k#W#XGz#X~(k!R@SV!``!bpOr(krs'gsv(kwx(]x}(k}!O@i!O~(k!R@rT!``!bp!cPOr(krs'gsv(kwx(]x~(k!RAYV!``!bpOr(krs'gsv(kwx(]x!q(k!q!rAo!r~(k!RAvV!``!bpOr(krs'gsv(kwx(]x!e(k!e!fB]!f~(k!RBdV!``!bpOr(krs'gsv(kwx(]x!v(k!v!wBy!w~(k!RCQV!``!bpOr(krs'gsv(kwx(]x!{(k!{!|Cg!|~(k!RCnV!``!bpOr(krs'gsv(kwx(]x!r(k!r!sDT!s~(k!RD[V!``!bpOr(krs'gsv(kwx(]x!g(k!g!hDq!h~(k!RDxW!``!bpOrDqrsEbsvDqvwEvwxFfx!`Dq!`!aGb!a~DqqEgT!bpOvEbvxEvx!`Eb!`!aFX!a~EbPEyRO!`Ev!`!aFS!a~EvPFXOzPqF`Q!bpzPOv'gx~'gaFkV!``OrFfrsEvsvFfvwEvw!`Ff!`!aGQ!a~FfaGXR!``zPOr(]sv(]w~(]!RGkT!``!bpzPOr(krs'gsv(kwx(]x~(k!RHRV!``!bpOr(krs'gsv(kwx(]x#c(k#c#dHh#d~(k!RHoV!``!bpOr(krs'gsv(kwx(]x#V(k#V#WIU#W~(k!RI]V!``!bpOr(krs'gsv(kwx(]x#h(k#h#iIr#i~(k!RIyV!``!bpOr(krs'gsv(kwx(]x#m(k#m#nJ`#n~(k!RJgV!``!bpOr(krs'gsv(kwx(]x#d(k#d#eJ|#e~(k!RKTV!``!bpOr(krs'gsv(kwx(]x#X(k#X#YDq#Y~(k!RKqW!``!bpOrKjrsLZsvKjvwLowxNPx!aKj!a!b! g!b~KjqL`T!bpOvLZvxLox!aLZ!a!bM^!b~LZPLrRO!aLo!a!bL{!b~LoPMORO!`Lo!`!aMX!a~LoPM^OwPqMcT!bpOvLZvxLox!`LZ!`!aMr!a~LZqMyQ!bpwPOv'gx~'gaNUV!``OrNPrsLosvNPvwLow!aNP!a!bNk!b~NPaNpV!``OrNPrsLosvNPvwLow!`NP!`!a! V!a~NPa! ^R!``wPOr(]sv(]w~(]!R! nW!``!bpOrKjrsLZsvKjvwLowxNPx!`Kj!`!a!!W!a~Kj!R!!aT!``!bpwPOr(krs'gsv(kwx(]x~(k!V!!{VgS^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R",
  tokenizers: [scriptTokens, styleTokens, textareaTokens, tagStart, commentContent, 0, 1, 2, 3, 4, 5],
  topRules: { "Document": [0, 13] },
  dialects: { noMatch: 0 },
  tokenPrec: 464
});
function getAttrs(element, input) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let att of element.firstChild.getChildren("Attribute")) {
    let name2 = att.getChild("AttributeName"), value = att.getChild("AttributeValue") || att.getChild("UnquotedAttributeValue");
    if (name2)
      attrs[input.read(name2.from, name2.to)] = !value ? "" : value.name == "AttributeValue" ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);
  }
  return attrs;
}
function maybeNest(node, input, tags2) {
  let attrs;
  for (let tag of tags2) {
    if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node.node.parent, input))))
      return { parser: tag.parser };
  }
  return null;
}
function configureNesting(tags2) {
  let script = [], style = [], textarea = [];
  for (let tag of tags2) {
    let array = tag.tag == "script" ? script : tag.tag == "style" ? style : tag.tag == "textarea" ? textarea : null;
    if (!array)
      throw new RangeError("Only script, style, and textarea tags can host nested parsers");
    array.push(tag);
  }
  return parseMixed((node, input) => {
    let id2 = node.type.id;
    if (id2 == ScriptText)
      return maybeNest(node, input, script);
    if (id2 == StyleText)
      return maybeNest(node, input, style);
    if (id2 == TextareaText)
      return maybeNest(node, input, textarea);
    return null;
  });
}
const descendantOp = 93, Unit = 1, callee = 94, identifier$1 = 95, VariableName = 2;
const space$1 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
const colon = 58, parenL = 40, underscore = 95, bracketL = 91, dash = 45, period = 46, hash = 35, percent = 37;
function isAlpha(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
const identifiers = new ExternalTokenizer((input, stack) => {
  for (let inside2 = false, dashes = 0, i = 0; ; i++) {
    let { next } = input;
    if (isAlpha(next) || next == dash || next == underscore || inside2 && isDigit(next)) {
      if (!inside2 && (next != dash || i > 0))
        inside2 = true;
      if (dashes === i && next == dash)
        dashes++;
      input.advance();
    } else {
      if (inside2)
        input.acceptToken(next == parenL ? callee : dashes == 2 && stack.canShift(VariableName) ? VariableName : identifier$1);
      break;
    }
  }
});
const descendant = new ExternalTokenizer((input) => {
  if (space$1.includes(input.peek(-1))) {
    let { next } = input;
    if (isAlpha(next) || next == underscore || next == hash || next == period || next == bracketL || next == colon || next == dash)
      input.acceptToken(descendantOp);
  }
});
const unitToken = new ExternalTokenizer((input) => {
  if (!space$1.includes(input.peek(-1))) {
    let { next } = input;
    if (next == percent) {
      input.advance();
      input.acceptToken(Unit);
    }
    if (isAlpha(next)) {
      do {
        input.advance();
      } while (isAlpha(input.next));
      input.acceptToken(Unit);
    }
  }
});
const spec_callee = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, dir: 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 };
const spec_AtKeyword = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 };
const spec_identifier$1 = { __proto__: null, not: 128, only: 128, from: 158, to: 160 };
const parser$2 = LRParser.deserialize({
  version: 13,
  states: "7WOYQ[OOOOQP'#Cd'#CdOOQP'#Cc'#CcO!ZQ[O'#CfO!}QXO'#CaO#UQ[O'#ChO#aQ[O'#DPO#fQ[O'#DTOOQP'#Ec'#EcO#kQdO'#DeO$VQ[O'#DrO#kQdO'#DtO$hQ[O'#DvO$sQ[O'#DyO$xQ[O'#EPO%WQ[O'#EROOQS'#Eb'#EbOOQS'#ES'#ESQYQ[OOOOQP'#Cg'#CgOOQP,59Q,59QO!ZQ[O,59QO%_Q[O'#EVO%yQWO,58{O&RQ[O,59SO#aQ[O,59kO#fQ[O,59oO%_Q[O,59sO%_Q[O,59uO%_Q[O,59vO'bQ[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO'iQWO,59SO'nQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO'sQ`O,59oOOQS'#Cp'#CpO#kQdO'#CqO'{QvO'#CsO)VQtO,5:POOQO'#Cx'#CxO'iQWO'#CwO)kQWO'#CyOOQS'#Ef'#EfOOQO'#Dh'#DhO)pQ[O'#DoO*OQWO'#EiO$xQ[O'#DmO*^QWO'#DpOOQO'#Ej'#EjO%|QWO,5:^O*cQpO,5:`OOQS'#Dx'#DxO*kQWO,5:bO*pQ[O,5:bOOQO'#D{'#D{O*xQWO,5:eO*}QWO,5:kO+VQWO,5:mOOQS-E8Q-E8QOOQP1G.l1G.lO+yQXO,5:qOOQO-E8T-E8TOOQS1G.g1G.gOOQP1G.n1G.nO'iQWO1G.nO'nQWO1G.nOOQP1G/V1G/VO,WQ`O1G/ZO,qQXO1G/_O-XQXO1G/aO-oQXO1G/bO.VQXO'#CdO.zQWO'#DaOOQS,59z,59zO/PQWO,59zO/XQ[O,59zO/`QdO'#CoO/gQ[O'#DOOOQP1G/Z1G/ZO#kQdO1G/ZO/nQpO,59]OOQS,59_,59_O#kQdO,59aO/vQWO1G/kOOQS,59c,59cO/{Q!bO,59eO0TQWO'#DhO0`QWO,5:TO0eQWO,5:ZO$xQ[O,5:VO$xQ[O'#EYO0mQWO,5;TO0xQWO,5:XO%_Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O1ZQWO1G/|O1`QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XOOQP7+$Y7+$YOOQP7+$u7+$uO#kQdO7+$uO#kQdO,59{O1nQ[O'#EXO1xQWO1G/fOOQS1G/f1G/fO1xQWO1G/fO2QQtO'#ETO2uQdO'#EeO3PQWO,59ZO3UQXO'#EhO3]QWO,59jO3bQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO3jQWO1G/PO#kQdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO3oQWO,5:tOOQO-E8W-E8WO3}QXO1G/vOOQS7+%h7+%hO4UQYO'#CsO%|QWO'#EZO4^QdO,5:hOOQS,5:h,5:hO4lQpO<<HaO4tQtO1G/gOOQO,5:s,5:sO5XQ[O,5:sOOQO-E8V-E8VOOQS7+%Q7+%QO5cQWO7+%QOOQS-E8R-E8RO#kQdO'#EUO5kQWO,5;POOQT1G.u1G.uO5sQWO,5;SOOQP1G/U1G/UOOQP<<Ha<<HaOOQS7+$k7+$kO5{QdO7+%ZOOQO7+%b7+%bOOQS,5:u,5:uOOQS-E8X-E8XOOQS1G0S1G0SOOQPAN={AN={O6SQtO'#EWO#kQdO'#EWO6}QdO7+%ROOQO7+%R7+%ROOQO1G0_1G0_OOQS<<Hl<<HlO7_QdO,5:pOOQO-E8S-E8SOOQO<<Hu<<HuO7iQtO,5:rOOQS-E8U-E8UOOQO<<Hm<<Hm",
  stateData: "8j~O#TOSROS~OUWOXWO]TO^TOtUOxVO!Y_O!ZXO!gYO!iZO!k[O!n]O!t^O#RPO#WRO~O#RcO~O]hO^hOpfOtiOxjO|kO!PmO#PlO#WeO~O!RnO~P!`O`sO#QqO#RpO~O#RuO~O#RwO~OQ!QObzOf!QOh!QOn!PO#Q}O#RyO#Z{O~Ob!SO!b!UO!e!VO#R!RO!R#]P~Oh![On!PO#R!ZO~O#R!^O~Ob!SO!b!UO!e!VO#R!RO~O!W#]P~P$VOUWOXWO]TO^TOtUOxVO#RPO#WRO~OpfO!RnO~O`!hO#QqO#RpO~OQ!pOUWOXWO]TO^TOtUOxVO!Y_O!ZXO!gYO!iZO!k[O!n]O!t^O#R!oO#WRO~O!Q!qO~P&^Ob!tO~Ob!uO~Ov!vOz!wO~OP!yObgXjgX!WgX!bgX!egX#RgXagXQgXfgXhgXngXpgX#QgX#ZgXvgX!QgX!VgX~Ob!SOj!zO!b!UO!e!VO#R!RO!W#]P~Ob!}O~Ob!SO!b!UO!e!VO#R#OO~Op#SO!`#RO!R#]X!W#]X~Ob#VO~Oj!zO!W#XO~O!W#YO~Oh#ZOn!PO~O!R#[O~O!RnO!`#RO~O!RnO!W#_O~O]hO^hOtiOxjO|kO!PmO#PlO#WeO~Op!ya!R!yaa!ya~P+_Ov#aOz#bO~O]hO^hOtiOxjO#WeO~Op{i|{i!P{i!R{i#P{ia{i~P,`Op}i|}i!P}i!R}i#P}ia}i~P,`Op!Oi|!Oi!P!Oi!R!Oi#P!Oia!Oi~P,`O]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#PWX#WWX~O]#cO~O!Q#fO!W#dO~O!Q#fO~P&^Oa#XP~P#kOa#[P~P%_Oa#nOj!zO~O!W#pO~Oh#qOo#qO~O]!^Xa![X!`![X~O]#rO~Oa#sO!`#RO~Op#SO!R#]a!W#]a~O!`#ROp!aa!R!aa!W!aaa!aa~O!W#xO~O!Q#|O!q#zO!r#zO#Z#yO~O!Q!{X!W!{X~P&^O!Q$SO!W#dO~Oj!zOQ!wXa!wXb!wXf!wXh!wXn!wXp!wX#Q!wX#R!wX#Z!wX~Op$VOa#XX~P#kOa$XO~Oa#[X~P!`Oa$ZO~Oj!zOv$[O~Oa$]O~O!`#ROp!|a!R!|a!W!|a~Oa$_O~P+_OP!yO!RgX~O!Q$bO!q#zO!r#zO#Z#yO~Oj!zOv$cO~Oj!zOp$eO!V$gO!Q!Ti!W!Ti~P#kO!Q!{a!W!{a~P&^O!Q$iO!W#dO~Op$VOa#Xa~OpfOa#[a~Oa$lO~P#kOj!zOQ!zXb!zXf!zXh!zXn!zXp!zX!Q!zX!V!zX!W!zX#Q!zX#R!zX#Z!zX~Op$eO!V$oO!Q!Tq!W!Tq~P#kOa!xap!xa~P#kOj!zOQ!zab!zaf!zah!zan!zap!za!Q!za!V!za!W!za#Q!za#R!za#Z!za~Oo#Zj!Pj~",
  goto: ",O#_PPPPP#`P#h#vP#h$U#hPP$[PPP$b$k$kP$}P$kP$k%e%wPPP&a&g#hP&mP#hP&sP#hP#h#hPPP&y']'iPP#`PP'o'o'y'oP'oP'o'oP#`P#`P#`P'|#`P(P(SPP#`P#`(V(e(s(y)T)Z)e)kPPPPPP)q)yP*e*hP+^+a+j]`Obn!s#d$QiWObfklmn!s!u#V#d$QiQObfklmn!s!u#V#d$QQdRR!ceQrTR!ghQ!gsQ!|!OR#`!hq!QXZz!t!w!z#b#c#i#r$O$V$^$e$f$jp!QXZz!t!w!z#b#c#i#r$O$V$^$e$f$jT#z#[#{q!OXZz!t!w!z#b#c#i#r$O$V$^$e$f$jp!QXZz!t!w!z#b#c#i#r$O$V$^$e$f$jQ![[R#Z!]QtTR!ihQ!gtR#`!iQvUR!jiQxVR!kjQoSQ!fgQ#W!XQ#^!`Q#_!aR$`#zQ!rnQ#g!sQ$P#dR$h$QX!pn!s#d$Qa!WY^_|!S!U#R#SR#P!SR!][R!_]R#]!_QbOU!bb!s$QQ!snR$Q#dQ#i!tU$U#i$^$jQ$^#rR$j$VQ$W#iR$k$WQgSS!eg$YR$Y#kQ$f$OR$n$fQ#e!rS$R#e$TR$T#gQ#T!TR#v#TQ#{#[R$a#{]aObn!s#d$Q[SObn!s#d$QQ!dfQ!lkQ!mlQ!nmQ#k!uR#w#VR#j!tQ|XQ!YZQ!xz[#h!t#i#r$V$^$jQ#m!wQ#o!zQ#}#bQ$O#cS$d$O$fR$m$eR#l!uQ!XYQ!a_R!{|U!TY_|Q!`^Q#Q!SQ#U!UQ#t#RR#u#S",
  nodeNames: "\u26A0 Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList from to SupportsStatement supports AtRule",
  maxTerm: 106,
  nodeProps: [
    [NodeProp.openedBy, 17, "(", 48, "{"],
    [NodeProp.closedBy, 18, ")", 49, "}"]
  ],
  skippedNodes: [0, 3],
  repeatNodeCount: 8,
  tokenData: "Ay~R![OX$wX^%]^p$wpq%]qr(crs+}st,otu2Uuv$wvw2rwx2}xy3jyz3uz{3z{|4_|}8U}!O8a!O!P8x!P!Q9Z!Q![;e![!]<Y!]!^<x!^!_$w!_!`=T!`!a=`!a!b$w!b!c>O!c!}$w!}#O?[#O#P$w#P#Q?g#Q#R2U#R#T$w#T#U?r#U#c$w#c#d@q#d#o$w#o#pAQ#p#q2U#q#rA]#r#sAh#s#y$w#y#z%]#z$f$w$f$g%]$g#BY$w#BY#BZ%]#BZ$IS$w$IS$I_%]$I_$I|$w$I|$JO%]$JO$JT$w$JT$JU%]$JU$KV$w$KV$KW%]$KW&FU$w&FU&FV%]&FV~$wW$zQOy%Qz~%QW%VQoWOy%Qz~%Q~%bf#T~OX%QX^&v^p%Qpq&vqy%Qz#y%Q#y#z&v#z$f%Q$f$g&v$g#BY%Q#BY#BZ&v#BZ$IS%Q$IS$I_&v$I_$I|%Q$I|$JO&v$JO$JT%Q$JT$JU&v$JU$KV%Q$KV$KW&v$KW&FU%Q&FU&FV&v&FV~%Q~&}f#T~oWOX%QX^&v^p%Qpq&vqy%Qz#y%Q#y#z&v#z$f%Q$f$g&v$g#BY%Q#BY#BZ&v#BZ$IS%Q$IS$I_&v$I_$I|%Q$I|$JO&v$JO$JT%Q$JT$JU&v$JU$KV%Q$KV$KW&v$KW&FU%Q&FU&FV&v&FV~%Q^(fSOy%Qz#]%Q#]#^(r#^~%Q^(wSoWOy%Qz#a%Q#a#b)T#b~%Q^)YSoWOy%Qz#d%Q#d#e)f#e~%Q^)kSoWOy%Qz#c%Q#c#d)w#d~%Q^)|SoWOy%Qz#f%Q#f#g*Y#g~%Q^*_SoWOy%Qz#h%Q#h#i*k#i~%Q^*pSoWOy%Qz#T%Q#T#U*|#U~%Q^+RSoWOy%Qz#b%Q#b#c+_#c~%Q^+dSoWOy%Qz#h%Q#h#i+p#i~%Q^+wQ!VUoWOy%Qz~%Q~,QUOY+}Zr+}rs,ds#O+}#O#P,i#P~+}~,iOh~~,lPO~+}_,tWtPOy%Qz!Q%Q!Q![-^![!c%Q!c!i-^!i#T%Q#T#Z-^#Z~%Q^-cWoWOy%Qz!Q%Q!Q![-{![!c%Q!c!i-{!i#T%Q#T#Z-{#Z~%Q^.QWoWOy%Qz!Q%Q!Q![.j![!c%Q!c!i.j!i#T%Q#T#Z.j#Z~%Q^.qWfUoWOy%Qz!Q%Q!Q![/Z![!c%Q!c!i/Z!i#T%Q#T#Z/Z#Z~%Q^/bWfUoWOy%Qz!Q%Q!Q![/z![!c%Q!c!i/z!i#T%Q#T#Z/z#Z~%Q^0PWoWOy%Qz!Q%Q!Q![0i![!c%Q!c!i0i!i#T%Q#T#Z0i#Z~%Q^0pWfUoWOy%Qz!Q%Q!Q![1Y![!c%Q!c!i1Y!i#T%Q#T#Z1Y#Z~%Q^1_WoWOy%Qz!Q%Q!Q![1w![!c%Q!c!i1w!i#T%Q#T#Z1w#Z~%Q^2OQfUoWOy%Qz~%QY2XSOy%Qz!_%Q!_!`2e!`~%QY2lQzQoWOy%Qz~%QX2wQXPOy%Qz~%Q~3QUOY2}Zw2}wx,dx#O2}#O#P3d#P~2}~3gPO~2}_3oQbVOy%Qz~%Q~3zOa~_4RSUPjSOy%Qz!_%Q!_!`2e!`~%Q_4fUjS!PPOy%Qz!O%Q!O!P4x!P!Q%Q!Q![7_![~%Q^4}SoWOy%Qz!Q%Q!Q![5Z![~%Q^5bWoW#ZUOy%Qz!Q%Q!Q![5Z![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q^6PWoWOy%Qz{%Q{|6i|}%Q}!O6i!O!Q%Q!Q![6z![~%Q^6nSoWOy%Qz!Q%Q!Q![6z![~%Q^7RSoW#ZUOy%Qz!Q%Q!Q![6z![~%Q^7fYoW#ZUOy%Qz!O%Q!O!P5Z!P!Q%Q!Q![7_![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q_8ZQpVOy%Qz~%Q^8fUjSOy%Qz!O%Q!O!P4x!P!Q%Q!Q![7_![~%Q_8}S#WPOy%Qz!Q%Q!Q![5Z![~%Q~9`RjSOy%Qz{9i{~%Q~9nSoWOy9iyz9zz{:o{~9i~9}ROz9zz{:W{~9z~:ZTOz9zz{:W{!P9z!P!Q:j!Q~9z~:oOR~~:tUoWOy9iyz9zz{:o{!P9i!P!Q;W!Q~9i~;_QR~oWOy%Qz~%Q^;jY#ZUOy%Qz!O%Q!O!P5Z!P!Q%Q!Q![7_![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%QX<_S]POy%Qz![%Q![!]<k!]~%QX<rQ^PoWOy%Qz~%Q_<}Q!WVOy%Qz~%QY=YQzQOy%Qz~%QX=eS|POy%Qz!`%Q!`!a=q!a~%QX=xQ|PoWOy%Qz~%QX>RUOy%Qz!c%Q!c!}>e!}#T%Q#T#o>e#o~%QX>lY!YPoWOy%Qz}%Q}!O>e!O!Q%Q!Q![>e![!c%Q!c!}>e!}#T%Q#T#o>e#o~%QX?aQxPOy%Qz~%Q^?lQvUOy%Qz~%QX?uSOy%Qz#b%Q#b#c@R#c~%QX@WSoWOy%Qz#W%Q#W#X@d#X~%QX@kQ!`PoWOy%Qz~%QX@tSOy%Qz#f%Q#f#g@d#g~%QXAVQ!RPOy%Qz~%Q_AbQ!QVOy%Qz~%QZAmS!PPOy%Qz!_%Q!_!`2e!`~%Q",
  tokenizers: [descendant, unitToken, identifiers, 0, 1, 2, 3],
  topRules: { "StyleSheet": [0, 4] },
  specialized: [{ term: 94, get: (value) => spec_callee[value] || -1 }, { term: 56, get: (value) => spec_AtKeyword[value] || -1 }, { term: 95, get: (value) => spec_identifier$1[value] || -1 }],
  tokenPrec: 1078
});
let _properties = null;
function properties() {
  if (!_properties && typeof document == "object" && document.body) {
    let names = [];
    for (let prop2 in document.body.style) {
      if (!/[A-Z]|^-|^(item|length)$/.test(prop2))
        names.push(prop2);
    }
    _properties = names.sort().map((name2) => ({ type: "property", label: name2 }));
  }
  return _properties || [];
}
const pseudoClasses = /* @__PURE__ */ [
  "active",
  "after",
  "before",
  "checked",
  "default",
  "disabled",
  "empty",
  "enabled",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "lang",
  "last-child",
  "last-of-type",
  "link",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-of-type",
  "only-child",
  "optional",
  "out-of-range",
  "placeholder",
  "read-only",
  "read-write",
  "required",
  "root",
  "selection",
  "target",
  "valid",
  "visited"
].map((name2) => ({ type: "class", label: name2 }));
const values = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((name2) => ({ type: "keyword", label: name2 })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((name2) => ({ type: "constant", label: name2 })));
const tags = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((name2) => ({ type: "type", label: name2 }));
const span = /^[\w-]*/;
const cssCompletionSource = (context) => {
  let { state, pos } = context, node = syntaxTree(state).resolveInner(pos, -1);
  if (node.name == "PropertyName")
    return { from: node.from, options: properties(), span };
  if (node.name == "ValueName")
    return { from: node.from, options: values, span };
  if (node.name == "PseudoClassName")
    return { from: node.from, options: pseudoClasses, span };
  if (node.name == "TagName") {
    for (let { parent } = node; parent; parent = parent.parent)
      if (parent.name == "Block")
        return { from: node.from, options: properties(), span };
    return { from: node.from, options: tags, span };
  }
  if (!context.explicit)
    return null;
  let above = node.resolve(pos), before = above.childBefore(pos);
  if (before && before.name == ":" && above.name == "PseudoClassSelector")
    return { from: pos, options: pseudoClasses, span };
  if (before && before.name == ":" && above.name == "Declaration" || above.name == "ArgList")
    return { from: pos, options: values, span };
  if (above.name == "Block")
    return { from: pos, options: properties(), span };
  return null;
};
const cssLanguage = /* @__PURE__ */ LRLanguage.define({
  parser: /* @__PURE__ */ parser$2.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        Declaration: /* @__PURE__ */ continuedIndent()
      }),
      /* @__PURE__ */ foldNodeProp.add({
        Block: foldInside$1
      }),
      /* @__PURE__ */ styleTags({
        "import charset namespace keyframes": tags$1.definitionKeyword,
        "media supports": tags$1.controlKeyword,
        "from to selector": tags$1.keyword,
        NamespaceName: tags$1.namespace,
        KeyframeName: tags$1.labelName,
        TagName: tags$1.tagName,
        ClassName: tags$1.className,
        PseudoClassName: /* @__PURE__ */ tags$1.constant(tags$1.className),
        IdName: tags$1.labelName,
        "FeatureName PropertyName": tags$1.propertyName,
        AttributeName: tags$1.attributeName,
        NumberLiteral: tags$1.number,
        KeywordQuery: tags$1.keyword,
        UnaryQueryOp: tags$1.operatorKeyword,
        "CallTag ValueName": tags$1.atom,
        VariableName: tags$1.variableName,
        Callee: tags$1.operatorKeyword,
        Unit: tags$1.unit,
        "UniversalSelector NestingSelector": tags$1.definitionOperator,
        AtKeyword: tags$1.keyword,
        MatchOp: tags$1.compareOperator,
        "ChildOp SiblingOp, LogicOp": tags$1.logicOperator,
        BinOp: tags$1.arithmeticOperator,
        Important: tags$1.modifier,
        Comment: tags$1.blockComment,
        ParenthesizedContent: /* @__PURE__ */ tags$1.special(tags$1.name),
        ColorLiteral: tags$1.color,
        StringLiteral: tags$1.string,
        ":": tags$1.punctuation,
        "PseudoOp #": tags$1.derefOperator,
        "; ,": tags$1.separator,
        "( )": tags$1.paren,
        "[ ]": tags$1.squareBracket,
        "{ }": tags$1.brace
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
const cssCompletion = /* @__PURE__ */ cssLanguage.data.of({ autocomplete: cssCompletionSource });
function css() {
  return new LanguageSupport(cssLanguage, cssCompletion);
}
const noSemi = 279, incdec = 1, incdecPrefix = 2, templateContent = 280, InterpolationStart = 3, templateEnd = 281, insertSemi = 282, TSExtends = 4, spaces = 284, newline2 = 285, LineComment = 5, BlockComment = 6, Dialect_ts = 1;
const space = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
const braceR = 125, braceL = 123, semicolon = 59, slash = 47, star = 42, plus = 43, minus = 45, dollar = 36, backtick2 = 96, backslash = 92;
const trackNewline = new ContextTracker({
  start: false,
  shift(context, term) {
    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline2;
  },
  strict: false
});
const insertSemicolon = new ExternalTokenizer((input, stack) => {
  let { next } = input;
  if ((next == braceR || next == -1 || stack.context) && stack.canShift(insertSemi))
    input.acceptToken(insertSemi);
}, { contextual: true, fallback: true });
const noSemicolon = new ExternalTokenizer((input, stack) => {
  let { next } = input, after;
  if (space.indexOf(next) > -1)
    return;
  if (next == slash && ((after = input.peek(1)) == slash || after == star))
    return;
  if (next != braceR && next != semicolon && next != -1 && !stack.context && stack.canShift(noSemi))
    input.acceptToken(noSemi);
}, { contextual: true });
const incdecToken = new ExternalTokenizer((input, stack) => {
  let { next } = input;
  if (next == plus || next == minus) {
    input.advance();
    if (next == input.next) {
      input.advance();
      let mayPostfix = !stack.context && stack.canShift(incdec);
      input.acceptToken(mayPostfix ? incdec : incdecPrefix);
    }
  }
}, { contextual: true });
const template = new ExternalTokenizer((input) => {
  for (let afterDollar = false, i = 0; ; i++) {
    let { next } = input;
    if (next < 0) {
      if (i)
        input.acceptToken(templateContent);
      break;
    } else if (next == backtick2) {
      if (i)
        input.acceptToken(templateContent);
      else
        input.acceptToken(templateEnd, 1);
      break;
    } else if (next == braceL && afterDollar) {
      if (i == 1)
        input.acceptToken(InterpolationStart, 1);
      else
        input.acceptToken(templateContent, -1);
      break;
    } else if (next == 10 && i) {
      input.advance();
      input.acceptToken(templateContent);
      break;
    } else if (next == backslash) {
      input.advance();
    }
    afterDollar = next == dollar;
    input.advance();
  }
});
function tsExtends(value, stack) {
  return value == "extends" && stack.dialectEnabled(Dialect_ts) ? TSExtends : -1;
}
const spec_identifier = { __proto__: null, export: 18, as: 23, from: 29, default: 32, async: 37, function: 38, this: 48, true: 56, false: 56, void: 66, typeof: 70, null: 86, super: 88, new: 122, await: 139, yield: 141, delete: 142, class: 152, extends: 154, public: 197, private: 197, protected: 197, readonly: 199, instanceof: 220, in: 222, const: 224, import: 256, keyof: 307, unique: 311, infer: 317, is: 351, abstract: 371, implements: 373, type: 375, let: 378, var: 380, interface: 387, enum: 391, namespace: 397, module: 399, declare: 403, global: 407, for: 428, of: 437, while: 440, with: 444, do: 448, if: 452, else: 454, switch: 458, case: 464, try: 470, catch: 472, finally: 474, return: 478, throw: 482, break: 486, continue: 490, debugger: 494 };
const spec_word = { __proto__: null, async: 109, get: 111, set: 113, public: 161, private: 161, protected: 161, static: 163, abstract: 165, override: 167, readonly: 173, new: 355 };
const spec_LessThan = { __proto__: null, "<": 129 };
const parser$1 = LRParser.deserialize({
  version: 13,
  states: "$1jO`QYOOO'QQ!LdO'#ChO'XOSO'#DVO)dQYO'#D]O)tQYO'#DhO){QYO'#DrO-xQYO'#DxOOQO'#E]'#E]O.]QWO'#E[O.bQWO'#E[OOQ!LS'#Ef'#EfO0aQ!LdO'#IrO2wQ!LdO'#IsO3eQWO'#EzO3jQpO'#FaOOQ!LS'#FS'#FSO3rO!bO'#FSO4QQWO'#FhO5_QWO'#FgOOQ!LS'#Is'#IsOOQ!LQ'#Ir'#IrOOQQ'#J['#J[O5dQWO'#HnO5iQ!LYO'#HoOOQQ'#If'#IfOOQQ'#Hp'#HpQ`QYOOO){QYO'#DjO5qQWO'#G[O5vQ#tO'#CmO6UQWO'#EZO6aQWO'#EgO6fQ#tO'#FRO7QQWO'#G[O7VQWO'#G`O7bQWO'#G`O7pQWO'#GcO7pQWO'#GdO7pQWO'#GfO5qQWO'#GiO8aQWO'#GlO9oQWO'#CdO:PQWO'#GyO:XQWO'#HPO:XQWO'#HRO`QYO'#HTO:XQWO'#HVO:XQWO'#HYO:^QWO'#H`O:cQ!LZO'#HdO){QYO'#HfO:nQ!LZO'#HhO:yQ!LZO'#HjO5iQ!LYO'#HlO){QYO'#DWOOOS'#Hr'#HrO;UOSO,59qOOQ!LS,59q,59qO=gQbO'#ChO=qQYO'#HsO>UQWO'#ItO@TQbO'#ItO'dQYO'#ItO@[QWO,59wO@rQ&jO'#DbOAkQWO'#E]OAxQWO'#JPOBTQWO'#JOOBTQWO'#JOOB]QWO,5:yOBbQWO'#I}OBiQWO'#DyO5vQ#tO'#EZOBwQWO'#EZOCSQ`O'#FROOQ!LS,5:S,5:SOC[QYO,5:SOEYQ!LdO,5:^OEvQWO,5:dOFaQ!LYO'#I|O7VQWO'#I{OFhQWO'#I{OFpQWO,5:xOFuQWO'#I{OGTQYO,5:vOITQWO'#EWOJ_QWO,5:vOKnQWO'#DlOKuQYO'#DqOLPQ&jO,5;PO){QYO,5;POOQQ'#Er'#ErOOQQ'#Et'#EtO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;ROOQQ'#Ex'#ExOLXQYO,5;cOOQ!LS,5;h,5;hOOQ!LS,5;i,5;iONXQWO,5;iOOQ!LS,5;j,5;jO){QYO'#H}ON^Q!LYO,5<TONxQWO,5;RO){QYO,5;fO! bQpO'#JTO! PQpO'#JTO! iQpO'#JTO! zQpO,5;qOOOO,5;{,5;{O!!YQYO'#FcOOOO'#H|'#H|O3rO!bO,5;nO!!aQpO'#FeOOQ!LS,5;n,5;nO!!}Q,UO'#CrOOQ!LS'#Cu'#CuO!#bQWO'#CuO!#gOSO'#CyO!$TQ#tO,5<QO!$[QWO,5<SO!%hQWO'#FrO!%uQWO'#FsO!%zQWO'#FwO!&|Q&jO'#F{O!'oQ,UO'#IoOOQ!LS'#Io'#IoO!'yQWO'#InO!(XQWO'#ImOOQ!LS'#Cs'#CsOOQ!LS'#C|'#C|O!(aQWO'#DOOJdQWO'#FjOJdQWO'#FlO!(fQWO'#FnO!(kQWO'#FoO!(pQWO'#FuOJdQWO'#FzO!(uQWO'#E^O!)^QWO,5<RO`QYO,5>YOOQQ'#Ii'#IiOOQQ,5>Z,5>ZOOQQ-E;n-E;nO!+YQ!LdO,5:UOOQ!LQ'#Cp'#CpO!+yQ#tO,5<vOOQO'#Cf'#CfO!,[QWO'#CqO!,dQ!LYO'#IjO5_QWO'#IjO:^QWO,59XO!,rQpO,59XO!,zQ#tO,59XO5vQ#tO,59XO!-VQWO,5:vO!-_QWO'#GxO!-mQWO'#J`O){QYO,5;kO!-uQ&jO,5;mO!-zQWO,5=cO!.PQWO,5=cO!.UQWO,5=cO5iQ!LYO,5=cO5qQWO,5<vO!.dQWO'#E_O!.xQ&jO'#E`OOQ!LQ'#I}'#I}O!/ZQ!LYO'#J]O5iQ!LYO,5<zO7pQWO,5=QOOQO'#Cr'#CrO!/fQpO,5<}O!/nQ#tO,5=OO!/yQWO,5=QO!0OQ`O,5=TO:^QWO'#GnO5qQWO'#GpO!0WQWO'#GpO5vQ#tO'#GsO!0]QWO'#GsOOQQ,5=W,5=WO!0bQWO'#GtO!0jQWO'#CmO!0oQWO,59OO!0yQWO,59OO!2{QYO,59OOOQQ,59O,59OO!3YQ!LYO,59OO){QYO,59OO!3eQYO'#G{OOQQ'#G|'#G|OOQQ'#G}'#G}O`QYO,5=eO!3uQWO,5=eO){QYO'#DxO`QYO,5=kO`QYO,5=mO!3zQWO,5=oO`QYO,5=qO!4PQWO,5=tO!4UQYO,5=zOOQQ,5>O,5>OO){QYO,5>OO5iQ!LYO,5>QOOQQ,5>S,5>SO!8VQWO,5>SOOQQ,5>U,5>UO!8VQWO,5>UOOQQ,5>W,5>WO!8[Q`O,59rOOOS-E;p-E;pOOQ!LS1G/]1G/]O!8aQbO,5>_O'dQYO,5>_OOQO,5>d,5>dO!8kQYO'#HsOOQO-E;q-E;qO!8xQWO,5?`O!9QQbO,5?`O!9XQWO,5?jOOQ!LS1G/c1G/cO!9aQpO'#DTOOQO'#Iv'#IvO){QYO'#IvO!:OQpO'#IvO!:mQpO'#DcO!;OQ&jO'#DcO!=ZQYO'#DcO!=bQWO'#IuO!=jQWO,59|O!=oQWO'#EaO!=}QWO'#JQO!>VQWO,5:zO!>mQ&jO'#DcO){QYO,5?kO!>wQWO'#HxOOQO-E;v-E;vO!9XQWO,5?jOOQ!LQ1G0e1G0eO!@TQ&jO'#D|OOQ!LS,5:e,5:eO){QYO,5:eOITQWO,5:eO!@[QWO,5:eO:^QWO,5:uO!,rQpO,5:uO!,zQ#tO,5:uO5vQ#tO,5:uOOQ!LS1G/n1G/nOOQ!LS1G0O1G0OOOQ!LQ'#EV'#EVO){QYO,5?hO!@gQ!LYO,5?hO!@xQ!LYO,5?hO!APQWO,5?gO!AXQWO'#HzO!APQWO,5?gOOQ!LQ1G0d1G0dO7VQWO,5?gOOQ!LS1G0b1G0bO!AsQ!LdO1G0bO!BdQ!LbO,5:rOOQ!LS'#Fq'#FqO!CQQ!LdO'#IoOGTQYO1G0bO!EPQ#tO'#IwO!EZQWO,5:WO!E`QbO'#IxO){QYO'#IxO!EjQWO,5:]OOQ!LS'#DT'#DTOOQ!LS1G0k1G0kO!EoQWO1G0kO!HQQ!LdO1G0mO!HXQ!LdO1G0mO!JlQ!LdO1G0mO!JsQ!LdO1G0mO!LzQ!LdO1G0mO!M_Q!LdO1G0mO#!OQ!LdO1G0mO#!VQ!LdO1G0mO#$jQ!LdO1G0mO#$qQ!LdO1G0mO#&fQ!LdO1G0mO#)`Q7^O'#ChO#+ZQ7^O1G0}O#-UQ7^O'#IsOOQ!LS1G1T1G1TO#-iQ!LdO,5>iOOQ!LQ-E;{-E;{O#.YQ!LdO1G0mOOQ!LS1G0m1G0mO#0[Q!LdO1G1QO#0{QpO,5;sO#1QQpO,5;tO#1VQpO'#F[O#1kQWO'#FZOOQO'#JU'#JUOOQO'#H{'#H{O#1pQpO1G1]OOQ!LS1G1]1G1]OOOO1G1f1G1fO#2OQ7^O'#IrO#2YQWO,5;}OLXQYO,5;}OOOO-E;z-E;zOOQ!LS1G1Y1G1YOOQ!LS,5<P,5<PO#2_QpO,5<POOQ!LS,59a,59aOITQWO'#C{OOOS'#Hq'#HqO#2dOSO,59eOOQ!LS,59e,59eO){QYO1G1lO!(kQWO'#IPO#2oQWO,5<eOOQ!LS,5<b,5<bOOQO'#GV'#GVOJdQWO,5<pOOQO'#GX'#GXOJdQWO,5<rOJdQWO,5<tOOQO1G1n1G1nO#2zQ`O'#CpO#3_Q`O,5<^O#3fQWO'#JXO5qQWO'#JXO#3tQWO,5<`OJdQWO,5<_O#3yQ`O'#FqO#4WQ`O'#JYO#4bQWO'#JYOITQWO'#JYO#4gQWO,5<cOOQ!LQ'#Dg'#DgO#4lQWO'#FtO#4wQpO'#F|O!&wQ&jO'#F|O!&wQ&jO'#GOO#5YQWO'#GPO!(pQWO'#GSOOQO'#IR'#IRO#5_Q&jO,5<gOOQ!LS,5<g,5<gO#5fQ&jO'#F|O#5tQ&jO'#F}O#5|Q&jO'#F}OOQ!LS,5<u,5<uOJdQWO,5?YOJdQWO,5?YO#6RQWO'#ISO#6^QWO,5?XOOQ!LS'#Ch'#ChO#7QQ#tO,59jOOQ!LS,59j,59jO#7sQ#tO,5<UO#8fQ#tO,5<WO#8pQWO,5<YOOQ!LS,5<Z,5<ZO#8uQWO,5<aO#8zQ#tO,5<fOGTQYO1G1mO#9[QWO1G1mOOQQ1G3t1G3tOOQ!LS1G/p1G/pONXQWO1G/pOOQQ1G2b1G2bOITQWO1G2bO){QYO1G2bOITQWO1G2bO#9aQWO1G2bO#9oQWO,59]O#:xQWO'#EWOOQ!LQ,5?U,5?UO#;SQ!LYO,5?UOOQQ1G.s1G.sO:^QWO1G.sO!,rQpO1G.sO!,zQ#tO1G.sO#;bQWO1G0bO#;gQWO'#ChO#;rQWO'#JaO#;zQWO,5=dO#<PQWO'#JaO#<UQWO'#JaO#<^QWO'#I[O#<lQWO,5?zO#<tQbO1G1VOOQ!LS1G1X1G1XO5qQWO1G2}O#<{QWO1G2}O#=QQWO1G2}O#=VQWO1G2}OOQQ1G2}1G2}O#=[Q#tO1G2bO7VQWO'#JOO7VQWO'#EaO7VQWO'#IUO#=mQ!LYO,5?wOOQQ1G2f1G2fO!/yQWO1G2lOITQWO1G2iO#=xQWO1G2iOOQQ1G2j1G2jOITQWO1G2jO#=}QWO1G2jO#>VQ&jO'#GhOOQQ1G2l1G2lO!&wQ&jO'#IWO!0OQ`O1G2oOOQQ1G2o1G2oOOQQ,5=Y,5=YO#>_Q#tO,5=[O5qQWO,5=[O#5YQWO,5=_O5_QWO,5=_O!,rQpO,5=_O!,zQ#tO,5=_O5vQ#tO,5=_O#>pQWO'#J_O#>{QWO,5=`OOQQ1G.j1G.jO#?QQ!LYO1G.jO#?]QWO1G.jO#?bQWO1G.jO5iQ!LYO1G.jO#?jQbO,5?|O#?tQWO,5?|O#@PQYO,5=gO#@WQWO,5=gO7VQWO,5?|OOQQ1G3P1G3PO`QYO1G3POOQQ1G3V1G3VOOQQ1G3X1G3XO:XQWO1G3ZO#@]QYO1G3]O#DWQYO'#H[OOQQ1G3`1G3`O:^QWO1G3fO#DeQWO1G3fO5iQ!LYO1G3jOOQQ1G3l1G3lOOQ!LQ'#Fx'#FxO5iQ!LYO1G3nO5iQ!LYO1G3pOOOS1G/^1G/^O#DmQ`O,5<TO#DuQbO1G3yOOQO1G4O1G4OO){QYO,5>_O#EPQWO1G4zO#EXQWO1G5UO#EaQWO,5?bOLXQYO,5:{O7VQWO,5:{O:^QWO,59}OLXQYO,59}O!,rQpO,59}O#EfQ7^O,59}OOQO,5:{,5:{O#EpQ&jO'#HtO#FWQWO,5?aOOQ!LS1G/h1G/hO#F`Q&jO'#HyO#FtQWO,5?lOOQ!LQ1G0f1G0fO!;OQ&jO,59}O#F|QbO1G5VO7VQWO,5>dOOQ!LQ'#ES'#ESO#GWQ!LrO'#ETO!?{Q&jO'#D}OOQO'#Hw'#HwO#GrQ&jO,5:hOOQ!LS,5:h,5:hO#GyQ&jO'#D}O#H[Q&jO'#D}O#HcQ&jO'#EYO#HfQ&jO'#ETO#HsQ&jO'#ETO!?{Q&jO'#ETO#IWQWO1G0PO#I]Q`O1G0POOQ!LS1G0P1G0PO){QYO1G0POITQWO1G0POOQ!LS1G0a1G0aO:^QWO1G0aO!,rQpO1G0aO!,zQ#tO1G0aO#IdQ!LdO1G5SO){QYO1G5SO#ItQ!LYO1G5SO#JVQWO1G5RO7VQWO,5>fOOQO,5>f,5>fO#J_QWO,5>fOOQO-E;x-E;xO#JVQWO1G5RO#JmQ!LdO,59jO#LlQ!LdO,5<UO#NnQ!LdO,5<WO$!pQ!LdO,5<fOOQ!LS7+%|7+%|O$$xQ!LdO7+%|O$%iQWO'#HuO$%sQWO,5?cOOQ!LS1G/r1G/rO$%{QYO'#HvO$&YQWO,5?dO$&bQbO,5?dOOQ!LS1G/w1G/wOOQ!LS7+&V7+&VO$&lQ7^O,5:^O){QYO7+&iO$&vQ7^O,5:UOOQO1G1_1G1_OOQO1G1`1G1`O$'TQMhO,5;vOLXQYO,5;uOOQO-E;y-E;yOOQ!LS7+&w7+&wOOOO7+'Q7+'QOOOO1G1i1G1iO$'`QWO1G1iOOQ!LS1G1k1G1kO$'eQ`O,59gOOOS-E;o-E;oOOQ!LS1G/P1G/PO$'lQ!LdO7+'WOOQ!LS,5>k,5>kO$(]QWO,5>kOOQ!LS1G2P1G2PP$(bQWO'#IPPOQ!LS-E;}-E;}O$)RQ#tO1G2[O$)tQ#tO1G2^O$*OQ#tO1G2`OOQ!LS1G1x1G1xO$*VQWO'#IOO$*eQWO,5?sO$*eQWO,5?sO$*mQWO,5?sO$*xQWO,5?sOOQO1G1z1G1zO$+WQ#tO1G1yO$+hQWO'#IQO$+xQWO,5?tOITQWO,5?tO$,QQ`O,5?tOOQ!LS1G1}1G1}O5iQ!LYO,5<hO5iQ!LYO,5<iO$,[QWO,5<iO#5TQWO,5<iO!,rQpO,5<hO$,aQWO,5<jO5iQ!LYO,5<kO$,[QWO,5<nOOQO-E<P-E<POOQ!LS1G2R1G2RO!&wQ&jO,5<hO$,iQWO,5<iO!&wQ&jO,5<jO!&wQ&jO,5<iO$,tQ#tO1G4tO$-OQ#tO1G4tOOQO,5>n,5>nOOQO-E<Q-E<QO!-uQ&jO,59lO){QYO,59lO$-]QWO1G1tOJdQWO1G1{O$-bQ!LdO7+'XOOQ!LS7+'X7+'XOGTQYO7+'XOOQ!LS7+%[7+%[O$.RQ`O'#JZO#IWQWO7+'|O$.]QWO7+'|O$.eQ`O7+'|OOQQ7+'|7+'|OITQWO7+'|O){QYO7+'|OITQWO7+'|OOQO1G.w1G.wO$.oQ!LbO'#ChO$/PQ!LbO,5<lO$/nQWO,5<lOOQ!LQ1G4p1G4pOOQQ7+$_7+$_O:^QWO7+$_O!,rQpO7+$_OGTQYO7+%|O$/sQWO'#IZO$0UQWO,5?{OOQO1G3O1G3OO5qQWO,5?{O$0UQWO,5?{O$0^QWO,5?{OOQO,5>v,5>vOOQO-E<Y-E<YOOQ!LS7+&q7+&qO$0cQWO7+(iO5iQ!LYO7+(iO5qQWO7+(iO$0hQWO7+(iO$0mQWO7+'|OOQ!LQ,5>p,5>pOOQ!LQ-E<S-E<SOOQQ7+(W7+(WO$0{Q!LbO7+(TOITQWO7+(TO$1VQ`O7+(UOOQQ7+(U7+(UOITQWO7+(UO$1^QWO'#J^O$1iQWO,5=SOOQO,5>r,5>rOOQO-E<U-E<UOOQQ7+(Z7+(ZO$2cQ&jO'#GqOOQQ1G2v1G2vOITQWO1G2vO){QYO1G2vOITQWO1G2vO$2jQWO1G2vO$2xQ#tO1G2vO5iQ!LYO1G2yO#5YQWO1G2yO5_QWO1G2yO!,rQpO1G2yO!,zQ#tO1G2yO$3ZQWO'#IYO$3fQWO,5?yO$3nQ&jO,5?yOOQ!LQ1G2z1G2zOOQQ7+$U7+$UO$3vQWO7+$UO5iQ!LYO7+$UO$3{QWO7+$UO){QYO1G5hO){QYO1G5iO$4QQYO1G3RO$4XQWO1G3RO$4^QYO1G3RO$4eQ!LYO1G5hOOQQ7+(k7+(kO5iQ!LYO7+(uO`QYO7+(wOOQQ'#Jd'#JdOOQQ'#I]'#I]O$4oQYO,5=vOOQQ,5=v,5=vO){QYO'#H]O$4|QWO'#H_OOQQ7+)Q7+)QO$5RQYO7+)QO7VQWO7+)QOOQQ7+)U7+)UOOQQ7+)Y7+)YOOQQ7+)[7+)[OOQO1G4|1G4|O$9PQ7^O1G0gO$9ZQWO1G0gOOQO1G/i1G/iO$9fQ7^O1G/iO:^QWO1G/iOLXQYO'#DcOOQO,5>`,5>`OOQO-E;r-E;rOOQO,5>e,5>eOOQO-E;w-E;wO!,rQpO1G/iO:^QWO,5:iOOQO,5:o,5:oO){QYO,5:oO$9pQ!LYO,5:oO$9{Q!LYO,5:oO!,rQpO,5:iOOQO-E;u-E;uOOQ!LS1G0S1G0SO!?{Q&jO,5:iO$:ZQ&jO,5:iO$:lQ!LrO,5:oO$;WQ&jO,5:iO!?{Q&jO,5:oOOQO,5:t,5:tO$;_Q&jO,5:oO$;lQ!LYO,5:oOOQ!LS7+%k7+%kO#IWQWO7+%kO#I]Q`O7+%kOOQ!LS7+%{7+%{O:^QWO7+%{O!,rQpO7+%{O$<QQ!LdO7+*nO){QYO7+*nOOQO1G4Q1G4QO7VQWO1G4QO$<bQWO7+*mO$<jQ!LdO1G2[O$>lQ!LdO1G2^O$@nQ!LdO1G1yO$BvQ#tO,5>aOOQO-E;s-E;sO$CQQbO,5>bO){QYO,5>bOOQO-E;t-E;tO$C[QWO1G5OO$CdQ7^O1G0bO$EkQ7^O1G0mO$ErQ7^O1G0mO$GsQ7^O1G0mO$GzQ7^O1G0mO$IoQ7^O1G0mO$JSQ7^O1G0mO$LaQ7^O1G0mO$LhQ7^O1G0mO$NiQ7^O1G0mO$NpQ7^O1G0mO%!eQ7^O1G0mO%!xQ!LdO<<JTO%#iQ7^O1G0mO%%XQ7^O'#IoO%'UQ7^O1G1QOLXQYO'#F^OOQO'#JV'#JVOOQO1G1b1G1bO%'cQWO1G1aO%'hQ7^O,5>iOOOO7+'T7+'TOOOS1G/R1G/ROOQ!LS1G4V1G4VOJdQWO7+'zO%'rQWO,5>jO5qQWO,5>jOOQO-E;|-E;|O%(QQWO1G5_O%(QQWO1G5_O%(YQWO1G5_O%(eQ`O,5>lO%(oQWO,5>lOITQWO,5>lOOQO-E<O-E<OO%(tQ`O1G5`O%)OQWO1G5`OOQO1G2S1G2SOOQO1G2T1G2TO5iQ!LYO1G2TO$,[QWO1G2TO5iQ!LYO1G2SO%)WQWO1G2UOITQWO1G2UOOQO1G2V1G2VO5iQ!LYO1G2YO!,rQpO1G2SO#5TQWO1G2TO%)]QWO1G2UO%)eQWO1G2TOJdQWO7+*`OOQ!LS1G/W1G/WO%)pQWO1G/WOOQ!LS7+'`7+'`O%)uQ#tO7+'gO%*VQ!LdO<<JsOOQ!LS<<Js<<JsOITQWO'#ITO%*vQWO,5?uOOQQ<<Kh<<KhOITQWO<<KhO#IWQWO<<KhO%+OQWO<<KhO%+WQ`O<<KhOITQWO1G2WOOQQ<<Gy<<GyO:^QWO<<GyO%+bQ!LdO<<IhOOQ!LS<<Ih<<IhOOQO,5>u,5>uO%,RQWO,5>uO%,WQWO,5>uOOQO-E<X-E<XO%,`QWO1G5gO%,`QWO1G5gO5qQWO1G5gO%,hQWO<<LTOOQQ<<LT<<LTO%,mQWO<<LTO5iQ!LYO<<LTO){QYO<<KhOITQWO<<KhOOQQ<<Ko<<KoO$0{Q!LbO<<KoOOQQ<<Kp<<KpO$1VQ`O<<KpO%,rQ&jO'#IVO%,}QWO,5?xOLXQYO,5?xOOQQ1G2n1G2nO#GWQ!LrO'#ETO!?{Q&jO'#GrOOQO'#IX'#IXO%-VQ&jO,5=]OOQQ,5=],5=]O%-^Q&jO'#ETO%-iQ&jO'#ETO%.QQ&jO'#ETO%.[Q&jO'#GrO%.mQWO7+(bO%.rQWO7+(bO%.zQ`O7+(bOOQQ7+(b7+(bOITQWO7+(bO){QYO7+(bOITQWO7+(bO%/UQWO7+(bOOQQ7+(e7+(eO5iQ!LYO7+(eO#5YQWO7+(eO5_QWO7+(eO!,rQpO7+(eO%/dQWO,5>tOOQO-E<W-E<WOOQO'#Gu'#GuO%/oQWO1G5eO5iQ!LYO<<GpOOQQ<<Gp<<GpO%/wQWO<<GpO%/|QWO7++SO%0RQWO7++TOOQQ7+(m7+(mO%0WQWO7+(mO%0]QYO7+(mO%0dQWO7+(mO){QYO7++SO){QYO7++TOOQQ<<La<<LaOOQQ<<Lc<<LcOOQQ-E<Z-E<ZOOQQ1G3b1G3bO%0iQWO,5=wOOQQ,5=y,5=yO:^QWO<<LlO%0nQWO<<LlOLXQYO7+&ROOQO7+%T7+%TO%0sQ7^O1G5VO:^QWO7+%TOOQO1G0T1G0TO%0}Q!LdO1G0ZOOQO1G0Z1G0ZO){QYO1G0ZO%1XQ!LYO1G0ZO:^QWO1G0TO!,rQpO1G0TO!?{Q&jO1G0TO%1dQ!LYO1G0ZO%1rQ&jO1G0TO%2TQ!LYO1G0ZO%2iQ!LrO1G0ZO%2sQ&jO1G0TO!?{Q&jO1G0ZOOQ!LS<<IV<<IVOOQ!LS<<Ig<<IgO:^QWO<<IgO%2zQ!LdO<<NYOOQO7+)l7+)lO%3[Q!LdO7+'gO%5dQbO1G3|O%5nQ7^O7+%|O%5{Q7^O,59jO%7xQ7^O,5<UO%9uQ7^O,5<WO%;rQ7^O,5<fO%=bQ7^O7+'WO%=oQ7^O7+'XO%=|QWO,5;xOOQO7+&{7+&{O%>RQ#tO<<KfOOQO1G4U1G4UO%>cQWO1G4UO%>nQWO1G4UO%>|QWO7+*yO%>|QWO7+*yOITQWO1G4WO%?UQ`O1G4WO%?`QWO7+*zOOQO7+'o7+'oO5iQ!LYO7+'oOOQO7+'n7+'nO$,[QWO7+'pO%?hQ`O7+'pOOQO7+'t7+'tO5iQ!LYO7+'nO$,[QWO7+'oO%?oQWO7+'pOITQWO7+'pO#5TQWO7+'oO%?tQ#tO<<MzOOQ!LS7+$r7+$rO%@OQ`O,5>oOOQO-E<R-E<RO#IWQWOANASOOQQANASANASOITQWOANASO%@YQ!LbO7+'rOOQQAN=eAN=eO5qQWO1G4aOOQO1G4a1G4aO%@gQWO1G4aO%@lQWO7++RO%@lQWO7++RO5iQ!LYOANAoO%@tQWOANAoOOQQANAoANAoO%@yQWOANASO%ARQ`OANASOOQQANAZANAZOOQQANA[ANA[O%A]QWO,5>qOOQO-E<T-E<TO%AhQ7^O1G5dO#5YQWO,5=^O5_QWO,5=^O!,rQpO,5=^OOQO-E<V-E<VOOQQ1G2w1G2wO$:lQ!LrO,5:oO!?{Q&jO,5=^O%ArQ&jO,5=^O%BTQ&jO,5:oOOQQ<<K|<<K|OITQWO<<K|O%.mQWO<<K|O%B_QWO<<K|O%BgQ`O<<K|O){QYO<<K|OITQWO<<K|OOQQ<<LP<<LPO5iQ!LYO<<LPO#5YQWO<<LPO5_QWO<<LPO%BqQ&jO1G4`O%ByQWO7++POOQQAN=[AN=[O5iQ!LYOAN=[OOQQ<<Nn<<NnOOQQ<<No<<NoOOQQ<<LX<<LXO%CRQWO<<LXO%CWQYO<<LXO%C_QWO<<NnO%CdQWO<<NoOOQQ1G3c1G3cOOQQANBWANBWO:^QWOANBWO%CiQ7^O<<ImOOQO<<Ho<<HoOOQO7+%u7+%uO%0}Q!LdO7+%uO){QYO7+%uOOQO7+%o7+%oO:^QWO7+%oO!,rQpO7+%oO%CsQ!LYO7+%uO!?{Q&jO7+%oO%DOQ!LYO7+%uO%D^Q&jO7+%oO%DoQ!LYO7+%uOOQ!LSAN?RAN?RO%ETQ!LdO<<KfO%G]Q7^O<<JTO%GjQ7^O1G1yO%IYQ7^O1G2[O%KVQ7^O1G2^O%MSQ7^O<<JsO%MaQ7^O<<IhOOQO1G1d1G1dOOQO7+)p7+)pO%MnQWO7+)pO%MyQWO<<NeO%NRQ`O7+)rOOQO<<KZ<<KZO5iQ!LYO<<K[O$,[QWO<<K[OOQO<<KY<<KYO5iQ!LYO<<KZO%N]Q`O<<K[O$,[QWO<<KZOOQQG26nG26nO#IWQWOG26nOOQO7+){7+){O5qQWO7+){O%NdQWO<<NmOOQQG27ZG27ZO5iQ!LYOG27ZOITQWOG26nOLXQYO1G4]O%NlQWO7++OO5iQ!LYO1G2xO#5YQWO1G2xO5_QWO1G2xO!,rQpO1G2xO!?{Q&jO1G2xO%2iQ!LrO1G0ZO%NtQ&jO1G2xO%.mQWOANAhOOQQANAhANAhOITQWOANAhO& VQWOANAhO& _Q`OANAhOOQQANAkANAkO5iQ!LYOANAkO#5YQWOANAkOOQO'#Gv'#GvOOQO7+)z7+)zOOQQG22vG22vOOQQANAsANAsO& iQWOANAsOOQQANDYANDYOOQQANDZANDZO& nQYOG27rOOQO<<Ia<<IaO%0}Q!LdO<<IaOOQO<<IZ<<IZO:^QWO<<IZO){QYO<<IaO!,rQpO<<IZO&%lQ!LYO<<IaO!?{Q&jO<<IZO&%wQ!LYO<<IaO&&VQ7^O7+'gOOQO<<M[<<M[OOQOAN@vAN@vO5iQ!LYOAN@vOOQOAN@uAN@uO$,[QWOAN@vO5iQ!LYOAN@uOOQQLD,YLD,YOOQO<<Mg<<MgOOQQLD,uLD,uO#IWQWOLD,YO&'uQ7^O7+)wOOQO7+(d7+(dO5iQ!LYO7+(dO#5YQWO7+(dO5_QWO7+(dO!,rQpO7+(dO!?{Q&jO7+(dOOQQG27SG27SO%.mQWOG27SOITQWOG27SOOQQG27VG27VO5iQ!LYOG27VOOQQG27_G27_O:^QWOLD-^OOQOAN>{AN>{OOQOAN>uAN>uO%0}Q!LdOAN>{O:^QWOAN>uO){QYOAN>{O!,rQpOAN>uO&(PQ!LYOAN>{O&([Q7^O<<KfOOQOG26bG26bO5iQ!LYOG26bOOQOG26aG26aOOQQ!$( t!$( tOOQO<<LO<<LOO5iQ!LYO<<LOO#5YQWO<<LOO5_QWO<<LOO!,rQpO<<LOOOQQLD,nLD,nO%.mQWOLD,nOOQQLD,qLD,qOOQQ!$(!x!$(!xOOQOG24gG24gOOQOG24aG24aO%0}Q!LdOG24gO:^QWOG24aO){QYOG24gOOQOLD+|LD+|OOQOANAjANAjO5iQ!LYOANAjO#5YQWOANAjO5_QWOANAjOOQQ!$(!Y!$(!YOOQOLD*RLD*ROOQOLD){LD){O%0}Q!LdOLD*ROOQOG27UG27UO5iQ!LYOG27UO#5YQWOG27UOOQO!$'Mm!$'MmOOQOLD,pLD,pO5iQ!LYOLD,pOOQO!$(![!$(![OLXQYO'#DrO&)zQbO'#IrOLXQYO'#DjO&*RQ!LdO'#ChO&*lQbO'#ChO&*|QYO,5:vOLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO'#H}O&,|QWO,5<TO&.`QWO,5;ROLXQYO,5;fO!(aQWO'#DOO!(aQWO'#DOOITQWO'#FjO&-UQWO'#FjOITQWO'#FlO&-UQWO'#FlOITQWO'#FzO&-UQWO'#FzOLXQYO,5?kO&*|QYO1G0bO&.gQ7^O'#ChOLXQYO1G1lOITQWO,5<pO&-UQWO,5<pOITQWO,5<rO&-UQWO,5<rOITQWO,5<_O&-UQWO,5<_O&*|QYO1G1mOLXQYO7+&iOITQWO1G1{O&-UQWO1G1{O&*|QYO7+'XO&*|QYO7+%|OITQWO7+'zO&-UQWO7+'zO&.qQWO'#E[O&.vQWO'#E[O&/OQWO'#EzO&/TQWO'#EgO&/YQWO'#JPO&/eQWO'#I}O&/pQWO,5:vO&/uQ#tO,5<QO&/|QWO'#FsO&0RQWO'#FsO&0WQWO,5<RO&0`QWO,5:vO&0hQ7^O1G0}O&0oQWO,5<aO&0tQWO,5<aO&0yQWO1G1mO&1OQWO1G0bO&1TQ#tO1G2`O&1[Q#tO1G2`O4QQWO'#FhO5_QWO'#FgOBwQWO'#EZOLXQYO,5;cO!(pQWO'#FuO!(pQWO'#FuOJdQWO,5<tOJdQWO,5<t",
  stateData: "&2X~O'WOS'XOSTOSUOS~OPTOQTOXyO]cO_hObnOcmOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!TSO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!nlO#dsO#tpO#x^O%PqO%RtO%TrO%UrO%XuO%ZvO%^wO%_wO%axO%nzO%t{O%v|O%x}O%z!OO%}!PO&T!QO&X!RO&Z!SO&]!TO&_!UO&a!VO'ZPO'dQO'mYO'zaO~OP[XZ[X_[Xj[Xu[Xv[Xx[X!R[X!a[X!b[X!d[X!j[X!{[X#WdX#[[X#][X#^[X#_[X#`[X#a[X#b[X#c[X#e[X#g[X#i[X#j[X#o[X'U[X'd[X'n[X'u[X'v[X~O!]$lX~P$zOR!WO'S!XO'T!ZO~OPTOQTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!T!bO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'Z![O'dQO'mYO'zaO~O!Q!`O!R!]O!O'hP!O'rP~P'dO!S!mO~P`OPTOQTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!T!bO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'Z9YO'dQO'mYO'zaO~OPTOQTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!T!bO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'dQO'mYO'zaO~O!Q!rO#U!uO#V!rO'Z9ZO!c'oP~P+{O#W!vO~O!]!wO#W!vO~OP#^OZ#dOj#ROu!{Ov!{Ox!|O!R#bO!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO#j#ZO'dQO'n#[O'u!}O'v#OO~O_'fX'U'fX!c'fX!O'fX!T'fX%Q'fX!]'fX~P.jO!{#eO#o#eOP'gXZ'gX_'gXj'gXu'gXv'gXx'gX!R'gX!a'gX!b'gX!d'gX!j'gX#['gX#]'gX#^'gX#_'gX#`'gX#a'gX#b'gX#e'gX#g'gX#i'gX#j'gX'd'gX'n'gX'u'gX'v'gX~O#c'gX'U'gX!O'gX!c'gXn'gX!T'gX%Q'gX!]'gX~P0zO!{#eO~O#z#fO$R#jO~O!T#kO#x^O$U#lO$W#nO~O]#qOh$OOj#rOk#qOl#qOq$POs$QOx#xO!T#yO!_$VO!d#vO#V$WO#t$TO$_$RO$a$SO$d$UO'Z#pO'd#sO'_'aP~O!d$XO~O!]$ZO~O_$[O'U$[O~O'Z$`O~O!d$XO'Z$`O'[$bO'`$cO~Oc$iO!d$XO'Z$`O~O#c#TO~O]$rOu$nO!T$kO!d$mO%R$qO'Z$`O'[$bO^(SP~O!n$sO~Ox$tO!T$uO'Z$`O~Ox$tO!T$uO%Z$yO'Z$`O~O'Z$zO~O#dsO%RtO%TrO%UrO%XuO%ZvO%^wO%_wO~Ob%TOc%SO!n%QO%P%RO%c%PO~P7uOb%WOcmO!T%VO!nlO#dsO%PqO%TrO%UrO%XuO%ZvO%^wO%_wO%axO~O`%ZO!{%^O%R%XO'[$bO~P8tO!d%_O!g%cO~O!d%dO~O!TSO~O_$[O'R%lO'U$[O~O_$[O'R%oO'U$[O~O_$[O'R%qO'U$[O~OR!WO'S!XO'T%uO~OP[XZ[Xj[Xu[Xv[Xx[X!R[X!RdX!a[X!b[X!d[X!j[X!{[X!{dX#WdX#[[X#][X#^[X#_[X#`[X#a[X#b[X#c[X#e[X#g[X#i[X#j[X#o[X'd[X'n[X'u[X'v[X~O!O[X!OdX~P;aO!Q%wO!O&gX!O&lX!R&gX!R&lX~P'dO!R%yO!O'hX~OP#^OZ#dOj#ROu!{Ov!{Ox!|O!R%yO!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO#j#ZO'dQO'n#[O'u!}O'v#OO~O!O'hX~P>^O!O&OO~Ox&RO!W&]O!X&UO!Y&UO'[$bO~O]&SOk&SO!Q&VO'e&PO!S'iP!S'tP~P@aO!O'qX!R'qX!]'qX!c'qX'n'qX~O!{'qX#W#PX!S'qX~PAYO!{&^O!O'sX!R'sX~O!R&_O!O'rX~O!O&bO~O!{#eO~PAYOS&fO!T&cO!o&eO'Z$`O~Oc&kO!d$XO'Z$`O~Ou$nO!d$mO~O!S&lO~P`Ou!{Ov!{Ox!|O!b!yO!d!zO'dQOP!faZ!faj!fa!R!fa!a!fa!j!fa#[!fa#]!fa#^!fa#_!fa#`!fa#a!fa#b!fa#c!fa#e!fa#g!fa#i!fa#j!fa'n!fa'u!fa'v!fa~O_!fa'U!fa!O!fa!c!fan!fa!T!fa%Q!fa!]!fa~PCcO!c&mO~O!]!wO!{&oO'n&nO!R'pX_'pX'U'pX~O!c'pX~PE{O!R&sO!c'oX~O!c&uO~Ox$tO!T$uO#V&vO'Z$`O~OPTOQTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!TSO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'Z9YO'dQO'mYO'zaO~O]#qOh$OOj#rOk#qOl#qOq$POs9lOx#xO!T#yO!_:oO!d#vO#V9rO#t$TO$_9nO$a9pO$d$UO'Z&zO'd#sO~O#W&|O~O]#qOh$OOj#rOk#qOl#qOq$POs$QOx#xO!T#yO!_$VO!d#vO#V$WO#t$TO$_$RO$a$SO$d$UO'Z&zO'd#sO~O'_'kP~PJdO!Q'QO!c'lP~P){O'e'SO'mYO~OP9VOQ9VO]cOb:mOc!jOhcOj9VOkcOlcOq9VOs9VOxRO{cO|cO}cO!T!bO!_9XO!dUO!g9VO!h9VO!i9VO!j9VO!k9VO!n!iO#t!lO#x^O'Z'bO'dQO'mYO'z:kO~O!d!zO~O!R#bO_$]a'U$]a!c$]a!O$]a!T$]a%Q$]a!]$]a~O#d'iO~PITO!]'kO!T'wX#w'wX#z'wX$R'wX~Ou'lO~P! POu'lO!T'wX#w'wX#z'wX$R'wX~O!T'nO#w'rO#z'mO$R'sO~O!Q'vO~PLXO#z#fO$R'yO~Ou$eXx$eX!b$eX'n$eX'u$eX'v$eX~OSfX!RfX!{fX'_fX'_$eX~P!!iOk'{O~OR'|O'S'}O'T(PO~Ou(ROx(SO'n#[O'u(UO'v(WO~O'_(QO~P!#rO'_(ZO~O]#qOh$OOj#rOk#qOl#qOq$POs9lOx#xO!T#yO!_:oO!d#vO#V9rO#t$TO$_9nO$a9pO$d$UO'd#sO~O!Q(_O'Z([O!c'{P~P!$aO#W(aO~O!Q(eO'Z(bO!O'|P~P!$aO_(nOj(sOx(kO!W(qO!X(jO!Y(jO!d(hO!x(rO$w(mO'[$bO'e(gO~O!S(pO~P!&XO!b!yOu'cXx'cX'n'cX'u'cX'v'cX!R'cX!{'cX~O'_'cX#m'cX~P!'TOS(vO!{(uO!R'bX'_'bX~O!R(wO'_'aX~O'Z(yO~O!d)OO~O'Z&zO~O!d(hO~Ox$tO!Q!rO!T$uO#U!uO#V!rO'Z$`O!c'oP~O!]!wO#W)SO~OP#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO#j#ZO'dQO'n#[O'u!}O'v#OO~O_!^a!R!^a'U!^a!O!^a!c!^an!^a!T!^a%Q!^a!]!^a~P!)fOS)[O!T&cO!o)ZO%Q)YO'`$cO~O'Z$zO'_'aP~O!])_O!T'^X_'^X'U'^X~O!d$XO'`$cO~O!d$XO'Z$`O'`$cO~O!]!wO#W&|O~O])jO%R)kO'Z)gO!S(TP~O!R)lO^(SX~O'e'SO~OZ)pO~O^)qO~O!T$kO'Z$`O'[$bO^(SP~Ox$tO!Q)vO!R&_O!T$uO'Z$`O!O'rP~O]&YOk&YO!Q)wO'e'SO!S'tP~O!R)xO_(PX'U(PX~O!{)|O'`$cO~OS*PO!T#yO'`$cO~O!T*RO~Ou*TO!TSO~O!n*YO~Oc*_O~O'Z(yO!S(RP~Oc$iO~O%RtO'Z$zO~P8tOZ*eO^*dO~OPTOQTO]cObnOcmOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!nlO#x^O%PqO'dQO'mYO'zaO~O!T!bO#t!lO'Z9YO~P!1RO^*dO_$[O'U$[O~O_*iO#d*kO%T*kO%U*kO~P){O!d%_O~O%t*pO~O!T*rO~O&U*uO&V*tOP&SaQ&SaX&Sa]&Sa_&Sab&Sac&Sah&Saj&Sak&Sal&Saq&Sas&Sax&Sa{&Sa|&Sa}&Sa!T&Sa!_&Sa!d&Sa!g&Sa!h&Sa!i&Sa!j&Sa!k&Sa!n&Sa#d&Sa#t&Sa#x&Sa%P&Sa%R&Sa%T&Sa%U&Sa%X&Sa%Z&Sa%^&Sa%_&Sa%a&Sa%n&Sa%t&Sa%v&Sa%x&Sa%z&Sa%}&Sa&T&Sa&X&Sa&Z&Sa&]&Sa&_&Sa&a&Sa'Q&Sa'Z&Sa'd&Sa'm&Sa'z&Sa!S&Sa%{&Sa`&Sa&Q&Sa~O'Z*xO~On*{O~O!O&ga!R&ga~P!)fO!Q+PO!O&gX!R&gX~P){O!R%yO!O'ha~O!O'ha~P>^O!R&_O!O'ra~O!RwX!R!ZX!SwX!S!ZX!]wX!]!ZX!d!ZX!{wX'`!ZX~O!]+UO!{+TO!R#TX!R'jX!S#TX!S'jX!]'jX!d'jX'`'jX~O!]+WO!d$XO'`$cO!R!VX!S!VX~O]&QOk&QOx&RO'e(gO~OP9VOQ9VO]cOb:mOc!jOhcOj9VOkcOlcOq9VOs9VOxRO{cO|cO}cO!T!bO!_9XO!dUO!g9VO!h9VO!i9VO!j9VO!k9VO!n!iO#t!lO#x^O'dQO'mYO'z:kO~O'Z9vO~P!;^O!R+[O!S'iX~O!S+^O~O!]+UO!{+TO!R#TX!S#TX~O!R+_O!S'tX~O!S+aO~O]&QOk&QOx&RO'[$bO'e(gO~O!X+bO!Y+bO~P!>[Ox$tO!Q+dO!T$uO'Z$`O!O&lX!R&lX~O_+hO!W+kO!X+gO!Y+gO!r+oO!s+mO!t+nO!u+lO!x+pO'[$bO'e(gO'm+eO~O!S+jO~P!?]OS+uO!T&cO!o+tO~O!{+{O!R'pa!c'pa_'pa'U'pa~O!]!wO~P!@gO!R&sO!c'oa~Ox$tO!Q,OO!T$uO#U,QO#V,OO'Z$`O!R&nX!c&nX~O_#Oi!R#Oi'U#Oi!O#Oi!c#Oin#Oi!T#Oi%Q#Oi!]#Oi~P!)fO#W!za!R!za!c!za!{!za!T!za_!za'U!za!O!za~P!#rO#W'cXP'cXZ'cX_'cXj'cXv'cX!a'cX!d'cX!j'cX#['cX#]'cX#^'cX#_'cX#`'cX#a'cX#b'cX#c'cX#e'cX#g'cX#i'cX#j'cX'U'cX'd'cX!c'cX!O'cX!T'cXn'cX%Q'cX!]'cX~P!'TO!R,ZO'_'kX~P!#rO'_,]O~O!R,^O!c'lX~P!)fO!c,aO~O!O,bO~OP#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O'dQOZ#Zi_#Zij#Zi!R#Zi!a#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi'U#Zi'n#Zi'u#Zi'v#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~O#[#Zi~P!EtO#[#PO~P!EtOP#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO'dQOZ#Zi_#Zi!R#Zi!a#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi'U#Zi'n#Zi'u#Zi'v#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~Oj#Zi~P!H`Oj#RO~P!H`OP#^Oj#ROu!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO'dQO_#Zi!R#Zi#e#Zi#g#Zi#i#Zi#j#Zi'U#Zi'n#Zi'u#Zi'v#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~OZ#Zi!a#Zi#a#Zi#b#Zi#c#Zi~P!JzOZ#dO!a#TO#a#TO#b#TO#c#TO~P!JzOP#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO'dQO_#Zi!R#Zi#g#Zi#i#Zi#j#Zi'U#Zi'n#Zi'v#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~O'u#Zi~P!MrO'u!}O~P!MrOP#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO'dQO'u!}O_#Zi!R#Zi#i#Zi#j#Zi'U#Zi'n#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~O'v#Zi~P#!^O'v#OO~P#!^OP#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO'dQO'u!}O'v#OO~O_#Zi!R#Zi#j#Zi'U#Zi'n#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~P#$xOP[XZ[Xj[Xu[Xv[Xx[X!a[X!b[X!d[X!j[X!{[X#WdX#[[X#][X#^[X#_[X#`[X#a[X#b[X#c[X#e[X#g[X#i[X#j[X#o[X'd[X'n[X'u[X'v[X!R[X!S[X~O#m[X~P#']OP#^OZ9jOj9_Ou!{Ov!{Ox!|O!a9aO!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O#a9aO#b9aO#c9aO#e9bO#g9dO#i9fO#j9gO'dQO'n#[O'u!}O'v#OO~O#m,dO~P#)gOP'gXZ'gXj'gXu'gXv'gXx'gX!a'gX!b'gX!d'gX!j'gX#['gX#]'gX#^'gX#_'gX#`'gX#a'gX#b'gX#e'gX#g'gX#i'gX#j'gX'd'gX'n'gX'u'gX'v'gX!R'gX~O!{9kO#o9kO#c'gX#m'gX!S'gX~P#+bO_&qa!R&qa'U&qa!c&qan&qa!O&qa!T&qa%Q&qa!]&qa~P!)fOP#ZiZ#Zi_#Zij#Ziv#Zi!R#Zi!a#Zi!b#Zi!d#Zi!j#Zi#[#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi'U#Zi'd#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~P!#rO_#ni!R#ni'U#ni!O#ni!c#nin#ni!T#ni%Q#ni!]#ni~P!)fO#z,fO~O#z,gO~O!]'kO!{,hO!T$OX#w$OX#z$OX$R$OX~O!Q,iO~O!T'nO#w,kO#z'mO$R,lO~O!R9hO!S'fX~P#)gO!S,mO~O$R,oO~OR'|O'S'}O'T,rO~O],uOk,uO!O,vO~O!RdX!]dX!cdX!c$eX'ndX~P!!iO!c,|O~P!#rO!R,}O!]!wO'n&nO!c'{X~O!c-SO~O!O$eX!R$eX!]$lX~P!!iO!R-UO!O'|X~P!#rO!]-WO~O!O-YO~O!Q(_O'Z$`O!c'{P~Oj-^O!]!wO!d$XO'`$cO'n&nO~O!])_O~O!S-dO~P!&XO!X-eO!Y-eO'[$bO'e(gO~Ox-gO'e(gO~O!x-hO~O'Z$zO!R&vX'_&vX~O!R(wO'_'aa~Ou-mOv-mOx-nO'nra'ura'vra!Rra!{ra~O'_ra#mra~P#6fOu(ROx(SO'n$^a'u$^a'v$^a!R$^a!{$^a~O'_$^a#m$^a~P#7[Ou(ROx(SO'n$`a'u$`a'v$`a!R$`a!{$`a~O'_$`a#m$`a~P#7}O]-oO~O#W-pO~O'_$na!R$na#m$na!{$na~P!#rO#W-sO~OS-|O!T&cO!o-{O%Q-zO~O'_-}O~O]#qOj#rOk#qOl#qOq$POs9lOx#xO!T#yO!_:oO!d#vO#V9rO#t$TO$_9nO$a9pO$d$UO'd#sO~Oh.PO'Z.OO~P#9tO!])_O!T'^a_'^a'U'^a~O#W.VO~OZ[X!RdX!SdX~O!R.WO!S(TX~O!S.YO~OZ.ZO~O].]O'Z)gO~O!T$kO'Z$`O^'OX!R'OX~O!R)lO^(Sa~O!c.`O~P!)fO].bO~OZ.cO~O^.dO~OS-|O!T&cO!o-{O%Q-zO'`$cO~O!R)xO_(Pa'U(Pa~O!{.jO~OS.mO!T#yO~O'e'SO!S(QP~OS.wO!T.sO!o.vO%Q.uO'`$cO~OZ/RO!R/PO!S(RX~O!S/SO~O^/UO_$[O'U$[O~O]/VO~O]/WO'Z(yO~O#c/XO%r/YO~P0zO!{#eO#c/XO%r/YO~O_/ZO~P){O_/]O~O%{/aOP%yiQ%yiX%yi]%yi_%yib%yic%yih%yij%yik%yil%yiq%yis%yix%yi{%yi|%yi}%yi!T%yi!_%yi!d%yi!g%yi!h%yi!i%yi!j%yi!k%yi!n%yi#d%yi#t%yi#x%yi%P%yi%R%yi%T%yi%U%yi%X%yi%Z%yi%^%yi%_%yi%a%yi%n%yi%t%yi%v%yi%x%yi%z%yi%}%yi&T%yi&X%yi&Z%yi&]%yi&_%yi&a%yi'Q%yi'Z%yi'd%yi'm%yi'z%yi!S%yi`%yi&Q%yi~O`/gO!S/eO&Q/fO~P`O!TSO!d/jO~O!R#bOn$]a~O!O&gi!R&gi~P!)fO!R%yO!O'hi~O!R&_O!O'ri~O!O/nO~O!R!Va!S!Va~P#)gO]&QOk&QO!Q/tO'e(gO!R&hX!S&hX~P@aO!R+[O!S'ia~O]&YOk&YO!Q)wO'e'SO!R&mX!S&mX~O!R+_O!S'ta~O!O'si!R'si~P!)fO_$[O!]!wO!d$XO!j0OO!{/|O'U$[O'`$cO'n&nO~O!S0RO~P!?]O!X0SO!Y0SO'[$bO'e(gO'm+eO~O!W0TO~P#GyO!TSO!W0TO!u0VO!x0WO~P#GyO!W0TO!s0YO!t0YO!u0VO!x0WO~P#GyO!T&cO~O!T&cO~P!#rO!R'pi!c'pi_'pi'U'pi~P!)fO!{0cO!R'pi!c'pi_'pi'U'pi~O!R&sO!c'oi~Ox$tO!T$uO#V0eO'Z$`O~O#WraPraZra_rajra!ara!bra!dra!jra#[ra#]ra#^ra#_ra#`ra#ara#bra#cra#era#gra#ira#jra'Ura'dra!cra!Ora!Tranra%Qra!]ra~P#6fO#W$^aP$^aZ$^a_$^aj$^av$^a!a$^a!b$^a!d$^a!j$^a#[$^a#]$^a#^$^a#_$^a#`$^a#a$^a#b$^a#c$^a#e$^a#g$^a#i$^a#j$^a'U$^a'd$^a!c$^a!O$^a!T$^an$^a%Q$^a!]$^a~P#7[O#W$`aP$`aZ$`a_$`aj$`av$`a!a$`a!b$`a!d$`a!j$`a#[$`a#]$`a#^$`a#_$`a#`$`a#a$`a#b$`a#c$`a#e$`a#g$`a#i$`a#j$`a'U$`a'd$`a!c$`a!O$`a!T$`an$`a%Q$`a!]$`a~P#7}O#W$naP$naZ$na_$naj$nav$na!R$na!a$na!b$na!d$na!j$na#[$na#]$na#^$na#_$na#`$na#a$na#b$na#c$na#e$na#g$na#i$na#j$na'U$na'd$na!c$na!O$na!T$na!{$nan$na%Q$na!]$na~P!#rO_#Oq!R#Oq'U#Oq!O#Oq!c#Oqn#Oq!T#Oq%Q#Oq!]#Oq~P!)fO!R&iX'_&iX~PJdO!R,ZO'_'ka~O!Q0mO!R&jX!c&jX~P){O!R,^O!c'la~O!R,^O!c'la~P!)fO#m!fa!S!fa~PCcO#m!^a!R!^a!S!^a~P#)gO!T1QO#x^O$P1RO~O!S1VO~On1WO~P!#rO_$Yq!R$Yq'U$Yq!O$Yq!c$Yqn$Yq!T$Yq%Q$Yq!]$Yq~P!)fO!O1XO~O],uOk,uO~Ou(ROx(SO'v(WO'n$xi'u$xi!R$xi!{$xi~O'_$xi#m$xi~P$(jOu(ROx(SO'n$zi'u$zi'v$zi!R$zi!{$zi~O'_$zi#m$zi~P$)]O#m1YO~P!#rO!Q1[O'Z$`O!R&rX!c&rX~O!R,}O!c'{a~O!R,}O!]!wO!c'{a~O!R,}O!]!wO'n&nO!c'{a~O'_$gi!R$gi#m$gi!{$gi~P!#rO!Q1cO'Z(bO!O&tX!R&tX~P!$aO!R-UO!O'|a~O!R-UO!O'|a~P!#rO!]!wO~O!]!wO#c1mO~Oj1qO!]!wO'n&nO~O!R'bi'_'bi~P!#rO!{1tO!R'bi'_'bi~P!#rO!c1wO~O_$Zq!R$Zq'U$Zq!O$Zq!c$Zqn$Zq!T$Zq%Q$Zq!]$Zq~P!)fO!R1{O!T'}X~P!#rO!T&cO%Q2OO~O!T&cO%Q2OO~P!#rO!T$eX$u[X_$eX'U$eX~P!!iO$u2SOugXxgX!TgX'ngX'ugX'vgX_gX'UgX~O$u2SO~O]2YO%R2ZO'Z)gO!R&}X!S&}X~O!R.WO!S(Ta~OZ2_O~O^2`O~O]2cO~OS2eO!T&cO!o2dO%Q2OO~O_$[O'U$[O~P!#rO!T#yO~P!#rO!R2jO!{2lO!S(QX~O!S2mO~Ox(kO!W2vO!X2oO!Y2oO!r2uO!s2tO!t2tO!x2sO'[$bO'e(gO'm+eO~O!S2rO~P$1nOS2}O!T.sO!o2|O%Q2{O~OS2}O!T.sO!o2|O%Q2{O'`$cO~O'Z(yO!R&|X!S&|X~O!R/PO!S(Ra~O]3XO'e3WO~O]3YO~O^3[O~O!c3_O~P){O_3aO~O_3aO~P){O#c3cO%r3dO~PE{O`/gO!S3hO&Q/fO~P`O!]3jO~O&V3kOP&SqQ&SqX&Sq]&Sq_&Sqb&Sqc&Sqh&Sqj&Sqk&Sql&Sqq&Sqs&Sqx&Sq{&Sq|&Sq}&Sq!T&Sq!_&Sq!d&Sq!g&Sq!h&Sq!i&Sq!j&Sq!k&Sq!n&Sq#d&Sq#t&Sq#x&Sq%P&Sq%R&Sq%T&Sq%U&Sq%X&Sq%Z&Sq%^&Sq%_&Sq%a&Sq%n&Sq%t&Sq%v&Sq%x&Sq%z&Sq%}&Sq&T&Sq&X&Sq&Z&Sq&]&Sq&_&Sq&a&Sq'Q&Sq'Z&Sq'd&Sq'm&Sq'z&Sq!S&Sq%{&Sq`&Sq&Q&Sq~O!R#Ti!S#Ti~P#)gO!{3mO!R#Ti!S#Ti~O!R!Vi!S!Vi~P#)gO_$[O!{3tO'U$[O~O_$[O!]!wO!{3tO'U$[O~O!X3xO!Y3xO'[$bO'e(gO'm+eO~O_$[O!]!wO!d$XO!j3yO!{3tO'U$[O'`$cO'n&nO~O!W3zO~P$:ZO!W3zO!u3}O!x4OO~P$:ZO_$[O!]!wO!j3yO!{3tO'U$[O'n&nO~O!R'pq!c'pq_'pq'U'pq~P!)fO!R&sO!c'oq~O#W$xiP$xiZ$xi_$xij$xiv$xi!a$xi!b$xi!d$xi!j$xi#[$xi#]$xi#^$xi#_$xi#`$xi#a$xi#b$xi#c$xi#e$xi#g$xi#i$xi#j$xi'U$xi'd$xi!c$xi!O$xi!T$xin$xi%Q$xi!]$xi~P$(jO#W$ziP$ziZ$zi_$zij$ziv$zi!a$zi!b$zi!d$zi!j$zi#[$zi#]$zi#^$zi#_$zi#`$zi#a$zi#b$zi#c$zi#e$zi#g$zi#i$zi#j$zi'U$zi'd$zi!c$zi!O$zi!T$zin$zi%Q$zi!]$zi~P$)]O#W$giP$giZ$gi_$gij$giv$gi!R$gi!a$gi!b$gi!d$gi!j$gi#[$gi#]$gi#^$gi#_$gi#`$gi#a$gi#b$gi#c$gi#e$gi#g$gi#i$gi#j$gi'U$gi'd$gi!c$gi!O$gi!T$gi!{$gin$gi%Q$gi!]$gi~P!#rO!R&ia'_&ia~P!#rO!R&ja!c&ja~P!)fO!R,^O!c'li~O#m#Oi!R#Oi!S#Oi~P#)gOP#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O'dQOZ#Zij#Zi!a#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'n#Zi'u#Zi'v#Zi!R#Zi!S#Zi~O#[#Zi~P$CqO#[9]O~P$CqOP#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O'dQOZ#Zi!a#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'n#Zi'u#Zi'v#Zi!R#Zi!S#Zi~Oj#Zi~P$EyOj9_O~P$EyOP#^Oj9_Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O'dQO#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'n#Zi'u#Zi'v#Zi!R#Zi!S#Zi~OZ#Zi!a#Zi#a#Zi#b#Zi#c#Zi~P$HROZ9jO!a9aO#a9aO#b9aO#c9aO~P$HROP#^OZ9jOj9_Ou!{Ov!{Ox!|O!a9aO!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O#a9aO#b9aO#c9aO#e9bO'dQO#g#Zi#i#Zi#j#Zi#m#Zi'n#Zi'v#Zi!R#Zi!S#Zi~O'u#Zi~P$JgO'u!}O~P$JgOP#^OZ9jOj9_Ou!{Ov!{Ox!|O!a9aO!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O#a9aO#b9aO#c9aO#e9bO#g9dO'dQO'u!}O#i#Zi#j#Zi#m#Zi'n#Zi!R#Zi!S#Zi~O'v#Zi~P$LoO'v#OO~P$LoOP#^OZ9jOj9_Ou!{Ov!{Ox!|O!a9aO!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O#a9aO#b9aO#c9aO#e9bO#g9dO#i9fO'dQO'u!}O'v#OO~O#j#Zi#m#Zi'n#Zi!R#Zi!S#Zi~P$NwO_#ky!R#ky'U#ky!O#ky!c#kyn#ky!T#ky%Q#ky!]#ky~P!)fOP#ZiZ#Zij#Ziv#Zi!a#Zi!b#Zi!d#Zi!j#Zi#[#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'd#Zi!R#Zi!S#Zi~P!#rO!b!yOP'cXZ'cXj'cXu'cXv'cXx'cX!a'cX!d'cX!j'cX#['cX#]'cX#^'cX#_'cX#`'cX#a'cX#b'cX#c'cX#e'cX#g'cX#i'cX#j'cX#m'cX'd'cX'n'cX'u'cX'v'cX!R'cX!S'cX~O#m#ni!R#ni!S#ni~P#)gO!S4`O~O!R&qa!S&qa~P#)gO!]!wO'n&nO!R&ra!c&ra~O!R,}O!c'{i~O!R,}O!]!wO!c'{i~O!O&ta!R&ta~P!#rO!]4gO~O!R-UO!O'|i~P!#rO!R-UO!O'|i~O!O4mO~O!]!wO#c4sO~Oj4tO!]!wO'n&nO~O!O4vO~O'_$iq!R$iq#m$iq!{$iq~P!#rO_$Zy!R$Zy'U$Zy!O$Zy!c$Zyn$Zy!T$Zy%Q$Zy!]$Zy~P!)fO!R1{O!T'}a~O!T&cO%Q4{O~O!T&cO%Q4{O~P!#rO_#Oy!R#Oy'U#Oy!O#Oy!c#Oyn#Oy!T#Oy%Q#Oy!]#Oy~P!)fOZ5OO~O]5QO'Z)gO~O!R.WO!S(Ti~O]5TO~O^5UO~O'e'SO!R&yX!S&yX~O!R2jO!S(Qa~O!S5cO~P$1nOx-gO'e(gO'm+eO~O!W5fO!X5eO!Y5eO!x0WO'[$bO'e(gO'm+eO~O!s5gO!t5gO~P%-iO!X5eO!Y5eO'[$bO'e(gO'm+eO~O!T.sO~O!T.sO%Q5iO~O!T.sO%Q5iO~P!#rOS5nO!T.sO!o5mO%Q5iO~OZ5sO!R&|a!S&|a~O!R/PO!S(Ri~O]5vO~O!c5wO~O!c5xO~O!c5yO~O!c5yO~P){O_5{O~O!]6OO~O!c6QO~O!R'si!S'si~P#)gO_$[O'U$[O~P!)fO_$[O!{6VO'U$[O~O_$[O!]!wO!{6VO'U$[O~O!X6[O!Y6[O'[$bO'e(gO'm+eO~O_$[O!]!wO!j6]O!{6VO'U$[O'n&nO~O!d$XO'`$cO~P%2TO!W6^O~P%1rO!R'py!c'py_'py'U'py~P!)fO#W$iqP$iqZ$iq_$iqj$iqv$iq!R$iq!a$iq!b$iq!d$iq!j$iq#[$iq#]$iq#^$iq#_$iq#`$iq#a$iq#b$iq#c$iq#e$iq#g$iq#i$iq#j$iq'U$iq'd$iq!c$iq!O$iq!T$iq!{$iqn$iq%Q$iq!]$iq~P!#rO!R&ji!c&ji~P!)fO#m#Oq!R#Oq!S#Oq~P#)gOu-mOv-mOx-nOPraZrajra!ara!bra!dra!jra#[ra#]ra#^ra#_ra#`ra#ara#bra#cra#era#gra#ira#jra#mra'dra'nra'ura'vra!Rra!Sra~Ou(ROx(SOP$^aZ$^aj$^av$^a!a$^a!b$^a!d$^a!j$^a#[$^a#]$^a#^$^a#_$^a#`$^a#a$^a#b$^a#c$^a#e$^a#g$^a#i$^a#j$^a#m$^a'd$^a'n$^a'u$^a'v$^a!R$^a!S$^a~Ou(ROx(SOP$`aZ$`aj$`av$`a!a$`a!b$`a!d$`a!j$`a#[$`a#]$`a#^$`a#_$`a#`$`a#a$`a#b$`a#c$`a#e$`a#g$`a#i$`a#j$`a#m$`a'd$`a'n$`a'u$`a'v$`a!R$`a!S$`a~OP$naZ$naj$nav$na!a$na!b$na!d$na!j$na#[$na#]$na#^$na#_$na#`$na#a$na#b$na#c$na#e$na#g$na#i$na#j$na#m$na'd$na!R$na!S$na~P!#rO#m$Yq!R$Yq!S$Yq~P#)gO#m$Zq!R$Zq!S$Zq~P#)gO!S6hO~O'_$|y!R$|y#m$|y!{$|y~P!#rO!]!wO!R&ri!c&ri~O!]!wO'n&nO!R&ri!c&ri~O!R,}O!c'{q~O!O&ti!R&ti~P!#rO!R-UO!O'|q~O!O6oO~P!#rO!O6oO~O!R'by'_'by~P!#rO!R&wa!T&wa~P!#rO!T$tq_$tq'U$tq~P!#rOZ6wO~O!R.WO!S(Tq~O]6zO~O!T&cO%Q6{O~O!T&cO%Q6{O~P!#rO!{6|O!R&ya!S&ya~O!R2jO!S(Qi~P#)gO!X7SO!Y7SO'[$bO'e(gO'm+eO~O!W7UO!x4OO~P%ArO!T.sO%Q7XO~O!T.sO%Q7XO~P!#rO]7`O'e7_O~O!R/PO!S(Rq~O!c7bO~O!c7bO~P){O!c7dO~O!c7eO~O!R#Ty!S#Ty~P#)gO_$[O!{7kO'U$[O~O_$[O!]!wO!{7kO'U$[O~O!X7nO!Y7nO'[$bO'e(gO'm+eO~O_$[O!]!wO!j7oO!{7kO'U$[O'n&nO~O#W$|yP$|yZ$|y_$|yj$|yv$|y!R$|y!a$|y!b$|y!d$|y!j$|y#[$|y#]$|y#^$|y#_$|y#`$|y#a$|y#b$|y#c$|y#e$|y#g$|y#i$|y#j$|y'U$|y'd$|y!c$|y!O$|y!T$|y!{$|yn$|y%Q$|y!]$|y~P!#rO#m#ky!R#ky!S#ky~P#)gOP$giZ$gij$giv$gi!a$gi!b$gi!d$gi!j$gi#[$gi#]$gi#^$gi#_$gi#`$gi#a$gi#b$gi#c$gi#e$gi#g$gi#i$gi#j$gi#m$gi'd$gi!R$gi!S$gi~P!#rOu(ROx(SO'v(WOP$xiZ$xij$xiv$xi!a$xi!b$xi!d$xi!j$xi#[$xi#]$xi#^$xi#_$xi#`$xi#a$xi#b$xi#c$xi#e$xi#g$xi#i$xi#j$xi#m$xi'd$xi'n$xi'u$xi!R$xi!S$xi~Ou(ROx(SOP$ziZ$zij$ziv$zi!a$zi!b$zi!d$zi!j$zi#[$zi#]$zi#^$zi#_$zi#`$zi#a$zi#b$zi#c$zi#e$zi#g$zi#i$zi#j$zi#m$zi'd$zi'n$zi'u$zi'v$zi!R$zi!S$zi~O#m$Zy!R$Zy!S$Zy~P#)gO#m#Oy!R#Oy!S#Oy~P#)gO!]!wO!R&rq!c&rq~O!R,}O!c'{y~O!O&tq!R&tq~P!#rO!O7uO~P!#rO!R.WO!S(Ty~O!R2jO!S(Qq~O!X8RO!Y8RO'[$bO'e(gO'm+eO~O!T.sO%Q8UO~O!T.sO%Q8UO~P!#rO!c8XO~O&V8YOP&S!ZQ&S!ZX&S!Z]&S!Z_&S!Zb&S!Zc&S!Zh&S!Zj&S!Zk&S!Zl&S!Zq&S!Zs&S!Zx&S!Z{&S!Z|&S!Z}&S!Z!T&S!Z!_&S!Z!d&S!Z!g&S!Z!h&S!Z!i&S!Z!j&S!Z!k&S!Z!n&S!Z#d&S!Z#t&S!Z#x&S!Z%P&S!Z%R&S!Z%T&S!Z%U&S!Z%X&S!Z%Z&S!Z%^&S!Z%_&S!Z%a&S!Z%n&S!Z%t&S!Z%v&S!Z%x&S!Z%z&S!Z%}&S!Z&T&S!Z&X&S!Z&Z&S!Z&]&S!Z&_&S!Z&a&S!Z'Q&S!Z'Z&S!Z'd&S!Z'm&S!Z'z&S!Z!S&S!Z%{&S!Z`&S!Z&Q&S!Z~O_$[O!{8_O'U$[O~O_$[O!]!wO!{8_O'U$[O~OP$iqZ$iqj$iqv$iq!a$iq!b$iq!d$iq!j$iq#[$iq#]$iq#^$iq#_$iq#`$iq#a$iq#b$iq#c$iq#e$iq#g$iq#i$iq#j$iq#m$iq'd$iq!R$iq!S$iq~P!#rO!R&yq!S&yq~P#)gO_$[O!{8tO'U$[O~OP$|yZ$|yj$|yv$|y!a$|y!b$|y!d$|y!j$|y#[$|y#]$|y#^$|y#_$|y#`$|y#a$|y#b$|y#c$|y#e$|y#g$|y#i$|y#j$|y#m$|y'd$|y!R$|y!S$|y~P!#rOn'fX~P.jOn[X!O[X!c[X%r[X!T[X%Q[X!][X~P$zO!]dX!c[X!cdX'ndX~P;aOP9VOQ9VO]cOb:mOc!jOhcOj9VOkcOlcOq9VOs9VOxRO{cO|cO}cO!TSO!_9XO!dUO!g9VO!h9VO!i9VO!j9VO!k9VO!n!iO#t!lO#x^O'Z'bO'dQO'mYO'z:kO~O!R9hO!S$]a~O]#qOh$OOj#rOk#qOl#qOq$POs9mOx#xO!T#yO!_:pO!d#vO#V9sO#t$TO$_9oO$a9qO$d$UO'Z&zO'd#sO~O#d'iO~P&-UO!S[X!SdX~P;aO#W9[O~O!]!wO#W9[O~O!{9kO~O#c9aO~O!{9tO!R'sX!S'sX~O!{9kO!R'qX!S'qX~O#W9uO~O'_9wO~P!#rO#W9|O~O#W9}O~O!]!wO#W:OO~O!]!wO#W9uO~O#m:PO~P#)gO#W:QO~O#W:RO~O#W:SO~O#W:TO~O#m:UO~P!#rO#m:VO~P!#rO#x~!b!r!t!u#U#V'z$_$a$d$u%P%Q%R%X%Z%^%_%a%c~UT#x'z#]}'W'X#z'W'Z'e~",
  goto: "#Ed(XPPPPPPPP(YP(jP*^PPPP-uPP.[3n5b5uP5uPPP5uP7c5uP5uP7gPP7lP8Q<cPPPP<gPPPP<g?XPPP?_AjP<gPDTPPPPE{<gPPPPPGt<gPPJuKrPPPPKvM`PMhNiPKr<g<g!#p!&k!+^!+^!.mPPP!.t!1j<gPPPPPPPPPP!4aP!5rPP<g!7PP<gP<g<g<g<gP<g!9dPP!<]P!?Q!?Y!?^!?^P!<YP!?b!?bP!BVP!BZ<g<g!Ba!ET5uP5uP5u5uP!FW5u5u!HO5u!JQ5u!Kr5u5u!L`!NY!NY!N^!NY!NfP!NYP5u# b5u#!l5u5u-uPPP##yPP#$c#$cP#$cP#$x#$cPP#%OP#$uP#$u#%bMd#$u#&P#&V#&Y(Y#&](YP#&d#&d#&dP(YP(YP(YP(YPP(YP#&j#&mP#&m(YPPP(YP(YP(YP(YP(YP(Y(Y#&q#&{#'R#'X#'g#'m#'s#'}#(T#(d#(j#(x#)O#)U#)d#)y#+]#+k#+q#+w#+}#,T#,_#,e#,k#,u#-X#-_PPPPPPPP#-ePP#.X#2VPP#3m#3t#3|PP#8Y#:m#@i#@l#@o#@z#@}PP#AQ#AU#As#Bj#Bn#CSPP#CW#C^#CbP#Ce#Ci#Cl#D[#Dr#Dw#Dz#D}#ET#EW#E[#E`mhOSj}!n$Z%b%e%f%h*m*r/a/dQ$hmQ$opQ%YyS&U!b+[Q&j!jS(j#y(oQ)e$iQ)r$qQ*^%SQ+b&]S+g&c+iQ+y&kQ-e(qQ/O*_Y0S+k+l+m+n+oS2o.s2qU3x0T0V0YU5e2t2u2vS6[3z3}S7S5f5gQ7n6^R8R7U$p[ORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8t!j'd#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nQ(z$QQ)j$kQ*`%VQ*g%_Q,T9lQ.Q)_Q.])kQ/W*eQ2Y.WQ3U/PQ4X9mR5Q2ZpeOSjy}!n$Z%X%b%e%f%h*m*r/a/dR*b%Z&WVOSTjkn}!S!W!k!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%y&R&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:m:n[!cRU!]!`%w&VQ$alQ$gmS$lp$qv$vrs!r!u$X$t&_&s&v)v)w)x*k+U+d,O,Q/j0eQ%OwQ&g!iQ&i!jS(^#v(hS)d$h$iQ)h$kQ)u$sQ*X%QQ*]%SS+x&j&kQ-R(_Q.U)eQ.[)kQ.^)lQ.a)pQ.y*YS.}*^*_Q0a+yQ1Z,}Q2X.WQ2].ZQ2b.cQ3T/OQ4d1[Q5P2ZQ5S2_Q6v5OR7x6w!Y$em!j$g$h$i&T&i&j&k(i)d)e+X+f+x+y-_.U/y0P0U0a1p3w3|6Y7l8`Q)]$aQ)}${Q*Q$|Q*[%SQ.e)uQ.x*XU.|*]*^*_Q3O.yS3S.}/OQ5`2nQ5r3TS7Q5a5dS8P7R7TQ8j8QR8y8kW#|a$c(w:kS${t%XQ$|uQ$}vR){$y$V#{a!w!y#d#v#x$R$S$W&f'|(V(X(Y(a(e(u(v)Y)[)_)|*P+u,Z-U-W-p-z-|.j.m.u.w1Y1c1m1t1{2O2S2e2{2}4g4s4{5i5n6{7X8U9j9n9o9p9q9r9s9x9y9z9{9|9}:Q:R:U:V:k:q:rT'}#s(OV({$Q9l9mU&Y!b$u+_Q'T!{Q)o$nQ.n*RQ1u-mR5[2j&^cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:n$]#aZ!_!o$_%v%|&x'P'V'W'X'Y'Z'[']'^'_'`'a'c'f'j't)n*}+Y+c+z,Y,`,c,e,s-q/o/r0b0l0p0q0r0s0t0u0v0w0x0y0z0{0|1P1U1y2V3o3r4S4V4W4]4^5^6R6U6b6f6g7h7{8]8r8}9W:dT!XQ!Y&_cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nQ&W!bR/u+[Y&Q!b&U&]+[+bS(i#y(oS+f&c+iS-_(j(qQ-`(kQ-f(rQ.p*TU0P+g+k+lU0U+m+n+oS0Z+p2sQ1p-eQ1r-gQ1s-hS2n.s2qU3w0S0T0VQ3{0WQ3|0YS5a2o2vS5d2t2uU6Y3x3z3}Q6_4OS7R5e5fQ7T5gS7l6[6^S8Q7S7UQ8`7nR8k8RlhOSj}!n$Z%b%e%f%h*m*r/a/dQ%j!QS&w!v9[Q)b$fQ*V%OQ*W%PQ+v&hS,X&|9uS-r)S:OQ.S)cQ.r*UQ/h*tQ/i*uQ/q+VQ0X+mQ0_+wS1z-s:SQ2T.TS2W.V:TQ3n/sQ3q/zQ4Q0`Q4}2UQ6P3kQ6S3pQ6W3vQ6`4RQ7f6QQ7i6XQ8[7jQ8o8YQ8q8^R8|8s$W#`Z!_!o%v%|&x'P'V'W'X'Y'Z'[']'^'_'`'a'c'f'j't)n*}+Y+c+z,Y,`,c,s-q/o/r0b0l0p0q0r0s0t0u0v0w0x0y0z0{0|1P1U1y2V3o3r4S4V4W4]4^5^6R6U6b6f6g7h7{8]8r8}9W:dU(t#z&{1OT)W$_,e$W#_Z!_!o%v%|&x'P'V'W'X'Y'Z'[']'^'_'`'a'c'f'j't)n*}+Y+c+z,Y,`,c,s-q/o/r0b0l0p0q0r0s0t0u0v0w0x0y0z0{0|1P1U1y2V3o3r4S4V4W4]4^5^6R6U6b6f6g7h7{8]8r8}9W:dQ'e#`S)V$_,eR-t)W&^cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nQ%e{Q%f|Q%h!OQ%i!PR/`*pQ&d!iQ)X$aQ+s&gS-y)])uS0[+q+rW1}-v-w-x.eS4P0]0^U4z2P2Q2RU6t4y5W5XQ7w6uR8f7zT+h&c+iS+f&c+iU0P+g+k+lU0U+m+n+oS0Z+p2sS2n.s2qU3w0S0T0VQ3{0WQ3|0YS5a2o2vS5d2t2uU6Y3x3z3}Q6_4OS7R5e5fQ7T5gS7l6[6^S8Q7S7UQ8`7nR8k8RS+h&c+iT2p.s2qS&q!q/^Q-Q(^Q-](iS0O+f2nQ1`-RS1j-^-fU3y0U0Z5dQ4c1ZS4q1q1sU6]3{3|7TQ6j4dQ6s4tR7o6_Q!xXS&p!q/^Q)T$YQ)`$dQ)f$jQ+|&qQ-P(^Q-[(iQ-a(lQ.R)aQ.z*ZS/}+f2nS1_-Q-RS1i-]-fQ1l-`Q1o-bQ3Q.{W3u0O0U0Z5dQ4b1ZQ4f1`S4k1j1sQ4r1rQ5p3RW6Z3y3{3|7TS6i4c4dQ6n4mQ6q4qQ7O5_Q7]5qS7m6]6_Q7q6jQ7s6oQ7v6sQ7}7PQ8W7^Q8a7oQ8d7uQ8h8OQ8w8iQ9P8xQ9T9QQ:^:XQ:g:bR:h:c$rWORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8tS!xn!k!j:W#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nR:^:m$rXORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8tQ$Yb!Y$dm!j$g$h$i&T&i&j&k(i)d)e+X+f+x+y-_.U/y0P0U0a1p3w3|6Y7l8`S$jn!kQ)a$eQ*Z%SW.{*[*]*^*_U3R.|.}/OQ5_2nS5q3S3TU7P5`5a5dQ7^5rU8O7Q7R7TS8i8P8QS8x8j8kQ9Q8y!j:X#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nQ:b:lR:c:m$f]OSTjk}!S!W!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%b%d%e%f%h%l%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8tY!hRU!]!`%wv$vrs!r!u$X$t&_&s&v)v)w)x*k+U+d,O,Q/j0eQ*h%_!h:Y#]#k'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nR:]&VS&Z!b$uR/w+_$p[ORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8t!j'd#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nR*g%_$roORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8tQ'T!{!k:Z#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:n!h#VZ!_$_%v%|&x'P'^'_'`'a'f'j)n*}+c+z,Y,`,s-q0b0l0|1y2V3r4S4V6U7h8]8r8}9W!R9c'c't+Y,e/o/r0p0x0y0z0{1P1U3o4W4]4^5^6R6b6f6g7{:d!d#XZ!_$_%v%|&x'P'`'a'f'j)n*}+c+z,Y,`,s-q0b0l0|1y2V3r4S4V6U7h8]8r8}9W}9e'c't+Y,e/o/r0p0z0{1P1U3o4W4]4^5^6R6b6f6g7{:d!`#]Z!_$_%v%|&x'P'f'j)n*}+c+z,Y,`,s-q0b0l0|1y2V3r4S4V6U7h8]8r8}9Wl(Y#t&})R,{-T-i-j0j1x4a4u:_:i:jx:n'c't+Y,e/o/r0p1P1U3o4W4]4^5^6R6b6f6g7{:d!`:q&y'h(](c+r,W,p-X-u-x.i.k0^0i1a1e2R2g2i2y4U4h4n4w4|5X5l6a6l6r7ZZ:r0}4[6c7p8b&^cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nS#l`#mR1R,h&e_ORSTU`jk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k#m$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,h,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nS#g^#nT'm#i'qT#h^#nT'o#i'q&e`ORSTU`jk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k#m$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,h,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nT#l`#mQ#o`R'x#m$rbORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8t!k:l#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:n#RdOSUj}!S!W!n!|#k$Z%Z%^%_%b%d%e%f%h%l&R&e'v)Z*i*m*r+t,i-n-{.v/X/Y/Z/]/a/d/f1Q2d2|3a3c3d5m5{t#za!y$R$S$W(V(X(Y(a(u(v,Z-p1Y1t:k:q:r!|&{!w#d#v#x&f'|(e)Y)[)_)|*P+u-U-W-z-|.j.m.u.w1c1m1{2O2S2e2{2}4g4s4{5i5n6{7X8U9n9p9r9x9z9|:Q:UQ)P$UQ,t(Rc1O9j9o9q9s9y9{9}:R:Vt#wa!y$R$S$W(V(X(Y(a(u(v,Z-p1Y1t:k:q:rS(l#y(oQ)Q$VQ-b(m!|:`!w#d#v#x&f'|(e)Y)[)_)|*P+u-U-W-z-|.j.m.u.w1c1m1{2O2S2e2{2}4g4s4{5i5n6{7X8U9n9p9r9x9z9|:Q:Ub:a9j9o9q9s9y9{9}:R:VQ:e:oR:f:pt#za!y$R$S$W(V(X(Y(a(u(v,Z-p1Y1t:k:q:r!|&{!w#d#v#x&f'|(e)Y)[)_)|*P+u-U-W-z-|.j.m.u.w1c1m1{2O2S2e2{2}4g4s4{5i5n6{7X8U9n9p9r9x9z9|:Q:Uc1O9j9o9q9s9y9{9}:R:VlfOSj}!n$Z%b%e%f%h*m*r/a/dQ(d#xQ*y%oQ*z%qR1b-U$U#{a!w!y#d#v#x$R$S$W&f'|(V(X(Y(a(e(u(v)Y)[)_)|*P+u,Z-U-W-p-z-|.j.m.u.w1Y1c1m1t1{2O2S2e2{2}4g4s4{5i5n6{7X8U9j9n9o9p9q9r9s9x9y9z9{9|9}:Q:R:U:V:k:q:rQ*O$|Q.l*QQ2h.kR5Z2iT(n#y(oS(n#y(oT2p.s2qQ)`$dQ-a(lQ.R)aQ.z*ZQ3Q.{Q5p3RQ7O5_Q7]5qQ7}7PQ8W7^Q8h8OQ8w8iQ9P8xR9T9Ql(V#t&})R,{-T-i-j0j1x4a4u:_:i:j!`9x&y'h(](c+r,W,p-X-u-x.i.k0^0i1a1e2R2g2i2y4U4h4n4w4|5X5l6a6l6r7ZZ9y0}4[6c7p8bn(X#t&})R,y,{-T-i-j0j1x4a4u:_:i:j!b9z&y'h(](c+r,W,p-X-u-x.i.k0^0g0i1a1e2R2g2i2y4U4h4n4w4|5X5l6a6l6r7Z]9{0}4[6c6d7p8bpeOSjy}!n$Z%X%b%e%f%h*m*r/a/dQ%UxR*i%_peOSjy}!n$Z%X%b%e%f%h*m*r/a/dR%UxQ*S$}R.h){qeOSjy}!n$Z%X%b%e%f%h*m*r/a/dQ.t*XS2z.x.yW5h2w2x2y3OU7W5j5k5lU8S7V7Y7ZQ8l8TR8z8mQ%]yR*c%XR3X/RR7`5sS$lp$qR.^)lQ%bzR*m%cR*s%iT/b*r/dQjOQ!nST$^j!nQ(O#sR,q(OQ!YQR%t!YQ!^RU%z!^%{+QQ%{!_R+Q%|Q+]&WR/v+]Q,[&}R0k,[Q,_'PS0n,_0oR0o,`Q+i&cR0Q+iS!eR$tU&`!e&a+RQ&a!fR+R%}Q+`&ZR/x+`Q&t!sQ+}&rU,R&t+}0fR0f,SQ'q#iR,j'qQ#m`R'w#mQ#cZU'g#c*|9iQ*|9WR9i'tQ-O(^W1]-O1^4e6kU1^-P-Q-RS4e1_1`R6k4f#q(T#t&y&}'h(](c(|(})R+r,U,V,W,p,y,z,{-T-X-i-j-u-x.i.k0^0g0h0i0j0}1a1e1x2R2g2i2y4U4Y4Z4[4a4h4n4u4w4|5X5l6a6c6d6e6l6r7Z7p8b:_:i:jQ-V(cU1d-V1f4iQ1f-XR4i1eQ(o#yR-c(oQ(x#}R-l(xQ1|-uR4x1|Q)y$wR.g)yQ2k.nS5]2k6}R6}5^Q*U%OR.q*UQ2q.sR5b2qQ/Q*`S3V/Q5tR5t3XQ.X)hW2[.X2^5R6xQ2^.[Q5R2]R6x5SQ)m$lR._)mQ/d*rR3g/dWiOSj!nQ%g}Q)U$ZQ*l%bQ*n%eQ*o%fQ*q%hQ/_*mS/b*r/dR3f/aQ$]gQ%k!RQ%n!TQ%p!UQ%r!VQ)t$rQ)z$xQ*b%]Q*w%mS/T*c*fQ/k*vQ/l*yQ/m*zS/{+f2nQ1g-ZQ1h-[Q1n-aQ2a.bQ2f.iQ3P.zQ3Z/VQ3e/`Y3s/}0O0U0Z5dQ4j1iQ4l1kQ4o1oQ5V2cQ5Y2gQ5o3QQ5u3Y[6T3r3u3y3{3|7TQ6m4kQ6p4pQ6y5TQ7[5pQ7a5vW7g6U6Z6]6_Q7r6nQ7t6qQ7y6zQ7|7OQ8V7]U8Z7h7m7oQ8c7sQ8e7vQ8g7}Q8n8WS8p8]8aQ8u8dQ8v8hQ8{8rQ9O8wQ9R8}Q9S9PR9U9TQ$fmQ&h!jU)c$g$h$iQ+V&TU+w&i&j&kQ-Z(iS.T)d)eQ/s+XQ/z+fS0`+x+yQ1k-_Q2U.UQ3p/yS3v0P0UQ4R0aQ4p1pS6X3w3|Q7j6YQ8^7lR8s8`S#ua:kR)^$cU#}a$c:kR-k(wQ#taS&y!w)_Q&}!yQ'h#dQ(]#vQ(c#xQ(|$RQ(}$SQ)R$WQ+r&fQ,U9nQ,V9pQ,W9rQ,p'|Q,y(VQ,z(XQ,{(YQ-T(aQ-X(eQ-i(uQ-j(vd-u)Y-z.u2O2{4{5i6{7X8UQ-x)[Q.i)|Q.k*PQ0^+uQ0g9xQ0h9zQ0i9|Q0j,ZQ0}9jQ1a-UQ1e-WQ1x-pQ2R-|Q2g.jQ2i.mQ2y.wQ4U:QQ4Y9oQ4Z9qQ4[9sQ4a1YQ4h1cQ4n1mQ4u1tQ4w1{Q4|2SQ5X2eQ5l2}Q6a:UQ6c9}Q6d9yQ6e9{Q6l4gQ6r4sQ7Z5nQ7p:RQ8b:VQ:_:kQ:i:qR:j:rlgOSj}!n$Z%b%e%f%h*m*r/a/dS!pU%dQ%m!SQ%s!WQ'U!|Q'u#kS*f%Z%^Q*j%_Q*v%lQ+S&RQ+q&eQ,n'vQ-w)ZQ/[*iQ0]+tQ1T,iQ1v-nQ2Q-{Q2x.vQ3]/XQ3^/YQ3`/ZQ3b/]Q3i/fQ4_1QQ5W2dQ5k2|Q5z3aQ5|3cQ5}3dQ7Y5mR7c5{!vZOSUj}!S!n!|$Z%Z%^%_%b%d%e%f%h%l&R&e)Z*i*m*r+t-n-{.v/X/Y/Z/]/a/d/f2d2|3a3c3d5m5{Q!_RQ!oTQ$_kS%v!]%yQ%|!`Q&x!vQ'P!zQ'V#PQ'W#QQ'X#RQ'Y#SQ'Z#TQ'[#UQ']#VQ'^#WQ'_#XQ'`#YQ'a#ZQ'c#]Q'f#bQ'j#eW't#k'v,i1QQ)n$mS*}%w+PS+Y&V/tQ+c&^Q+z&oQ,Y&|Q,`'QQ,c9VQ,e9XQ,s(QQ-q)SQ/o+TQ/r+WQ0b+{Q0l,^Q0p9[Q0q9]Q0r9^Q0s9_Q0t9`Q0u9aQ0v9bQ0w9cQ0x9dQ0y9eQ0z9fQ0{9gQ0|,dQ1P9kQ1U9hQ1y-sQ2V.VQ3o9tQ3r/|Q4S0cQ4V0mQ4W9uQ4]9wQ4^:OQ5^2lQ6R3mQ6U3tQ6b:PQ6f:SQ6g:TQ7h6VQ7{6|Q8]7kQ8r8_Q8}8tQ9W!WR:d:nR!aRR&X!bS&T!b+[S+X&U&]R/y+bR'O!yR'R!zT!tU$XS!sU$XU$wrs*kS&r!r!uQ,P&sQ,S&vQ.f)xS0d,O,QR4T0e`!dR!]!`$t%w&_)v+dh!qUrs!r!u$X&s&v)x,O,Q0eQ/^*kQ/p+UQ3l/jT:[&V)wT!gR$tS!fR$tS%x!]&_S%}!`)vS+O%w+dT+Z&V)wT&[!b$uQ#i^R'z#nT'p#i'qR1S,hT(`#v(hR(f#xQ-v)YQ2P-zQ2w.uQ4y2OQ5j2{Q6u4{Q7V5iQ7z6{Q8T7XR8m8UlhOSj}!n$Z%b%e%f%h*m*r/a/dQ%[yR*b%XV$xrs*kR.o*RR*a%VQ$ppR)s$qR)i$kT%`z%cT%az%cT/c*r/d",
  nodeNames: "\u26A0 ArithOp ArithOp InterpolationStart extends LineComment BlockComment Script ExportDeclaration export Star as VariableName String from ; default FunctionDeclaration async function VariableDefinition TypeParamList TypeDefinition ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Interpolation null super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression await yield delete LogicOp BitOp ParenthesizedExpression ClassExpression class extends ClassBody MethodDeclaration Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression PrivatePropertyName BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try catch finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement",
  maxTerm: 330,
  context: trackNewline,
  nodeProps: [
    [NodeProp.closedBy, 3, "InterpolationEnd", 40, "]", 51, "}", 66, ")", 132, "JSXSelfCloseEndTag JSXEndTag", 146, "JSXEndTag"],
    [NodeProp.group, -26, 8, 15, 17, 58, 184, 188, 191, 192, 194, 197, 200, 211, 213, 219, 221, 223, 225, 228, 234, 238, 240, 242, 244, 246, 248, 249, "Statement", -30, 12, 13, 24, 27, 28, 41, 43, 44, 45, 47, 52, 60, 68, 74, 75, 91, 92, 101, 103, 119, 122, 124, 125, 126, 127, 129, 130, 148, 149, 151, "Expression", -22, 23, 25, 29, 32, 34, 152, 154, 156, 157, 159, 160, 161, 163, 164, 165, 167, 168, 169, 178, 180, 182, 183, "Type", -3, 79, 85, 90, "ClassItem"],
    [NodeProp.openedBy, 30, "InterpolationStart", 46, "[", 50, "{", 65, "(", 131, "JSXStartTag", 141, "JSXStartTag JSXStartCloseTag"]
  ],
  skippedNodes: [0, 5, 6],
  repeatNodeCount: 28,
  tokenData: "!C}~R!`OX%TXY%cYZ'RZ[%c[]%T]^'R^p%Tpq%cqr'crs(kst0htu2`uv4pvw5ewx6cxy<yyz=Zz{=k{|>k|}?O}!O>k!O!P?`!P!QCl!Q!R!0[!R![!1q![!]!7s!]!^!8V!^!_!8g!_!`!9d!`!a!:[!a!b!<R!b!c%T!c!}2`!}#O!=d#O#P%T#P#Q!=t#Q#R!>U#R#S2`#S#T!>i#T#o2`#o#p!>y#p#q!?O#q#r!?f#r#s!?x#s$f%T$f$g%c$g#BY2`#BY#BZ!@Y#BZ$IS2`$IS$I_!@Y$I_$I|2`$I|$I}!Bq$I}$JO!Bq$JO$JT2`$JT$JU!@Y$JU$KV2`$KV$KW!@Y$KW&FU2`&FU&FV!@Y&FV?HT2`?HT?HU!@Y?HU~2`W%YR$UWO!^%T!_#o%T#p~%T,T%jg$UW'W+{OX%TXY%cYZ%TZ[%c[p%Tpq%cq!^%T!_#o%T#p$f%T$f$g%c$g#BY%T#BY#BZ%c#BZ$IS%T$IS$I_%c$I_$JT%T$JT$JU%c$JU$KV%T$KV$KW%c$KW&FU%T&FU&FV%c&FV?HT%T?HT?HU%c?HU~%T,T'YR$UW'X+{O!^%T!_#o%T#p~%T$T'jS$UW!j#{O!^%T!_!`'v!`#o%T#p~%T$O'}S#e#v$UWO!^%T!_!`(Z!`#o%T#p~%T$O(bR#e#v$UWO!^%T!_#o%T#p~%T'u(rZ$UW]!ROY(kYZ)eZr(krs*rs!^(k!^!_+U!_#O(k#O#P-b#P#o(k#o#p+U#p~(k&r)jV$UWOr)ers*Ps!^)e!^!_*a!_#o)e#o#p*a#p~)e&r*WR$P&j$UWO!^%T!_#o%T#p~%T&j*dROr*ars*ms~*a&j*rO$P&j'u*{R$P&j$UW]!RO!^%T!_#o%T#p~%T'm+ZV]!ROY+UYZ*aZr+Urs+ps#O+U#O#P+w#P~+U'm+wO$P&j]!R'm+zROr+Urs,Ts~+U'm,[U$P&j]!ROY,nZr,nrs-Vs#O,n#O#P-[#P~,n!R,sU]!ROY,nZr,nrs-Vs#O,n#O#P-[#P~,n!R-[O]!R!R-_PO~,n'u-gV$UWOr(krs-|s!^(k!^!_+U!_#o(k#o#p+U#p~(k'u.VZ$P&j$UW]!ROY.xYZ%TZr.xrs/rs!^.x!^!_,n!_#O.x#O#P0S#P#o.x#o#p,n#p~.x!Z/PZ$UW]!ROY.xYZ%TZr.xrs/rs!^.x!^!_,n!_#O.x#O#P0S#P#o.x#o#p,n#p~.x!Z/yR$UW]!RO!^%T!_#o%T#p~%T!Z0XT$UWO!^.x!^!_,n!_#o.x#o#p,n#p~.xy0mZ$UWOt%Ttu1`u!^%T!_!c%T!c!}1`!}#R%T#R#S1`#S#T%T#T#o1`#p$g%T$g~1`y1g]$UW'mqOt%Ttu1`u!Q%T!Q![1`![!^%T!_!c%T!c!}1`!}#R%T#R#S1`#S#T%T#T#o1`#p$g%T$g~1`&i2k_$UW#zS'Z%k'epOt%Ttu2`u}%T}!O3j!O!Q%T!Q![2`![!^%T!_!c%T!c!}2`!}#R%T#R#S2`#S#T%T#T#o2`#p$g%T$g~2`[3q_$UW#zSOt%Ttu3ju}%T}!O3j!O!Q%T!Q![3j![!^%T!_!c%T!c!}3j!}#R%T#R#S3j#S#T%T#T#o3j#p$g%T$g~3j$O4wS#^#v$UWO!^%T!_!`5T!`#o%T#p~%T$O5[R$UW#o#vO!^%T!_#o%T#p~%T%r5lU'v%j$UWOv%Tvw6Ow!^%T!_!`5T!`#o%T#p~%T$O6VS$UW#i#vO!^%T!_!`5T!`#o%T#p~%T'u6jZ$UW]!ROY6cYZ7]Zw6cwx*rx!^6c!^!_8T!_#O6c#O#P:T#P#o6c#o#p8T#p~6c&r7bV$UWOw7]wx*Px!^7]!^!_7w!_#o7]#o#p7w#p~7]&j7zROw7wwx*mx~7w'm8YV]!ROY8TYZ7wZw8Twx+px#O8T#O#P8o#P~8T'm8rROw8Twx8{x~8T'm9SU$P&j]!ROY9fZw9fwx-Vx#O9f#O#P9}#P~9f!R9kU]!ROY9fZw9fwx-Vx#O9f#O#P9}#P~9f!R:QPO~9f'u:YV$UWOw6cwx:ox!^6c!^!_8T!_#o6c#o#p8T#p~6c'u:xZ$P&j$UW]!ROY;kYZ%TZw;kwx/rx!^;k!^!_9f!_#O;k#O#P<e#P#o;k#o#p9f#p~;k!Z;rZ$UW]!ROY;kYZ%TZw;kwx/rx!^;k!^!_9f!_#O;k#O#P<e#P#o;k#o#p9f#p~;k!Z<jT$UWO!^;k!^!_9f!_#o;k#o#p9f#p~;k%V=QR!d$}$UWO!^%T!_#o%T#p~%TZ=bR!cR$UWO!^%T!_#o%T#p~%T%R=tU'[!R#_#v$UWOz%Tz{>W{!^%T!_!`5T!`#o%T#p~%T$O>_S#[#v$UWO!^%T!_!`5T!`#o%T#p~%T$u>rSj$m$UWO!^%T!_!`5T!`#o%T#p~%T&i?VR!R&a$UWO!^%T!_#o%T#p~%T&i?gVu%n$UWO!O%T!O!P?|!P!Q%T!Q![@r![!^%T!_#o%T#p~%Ty@RT$UWO!O%T!O!P@b!P!^%T!_#o%T#p~%Ty@iR!Qq$UWO!^%T!_#o%T#p~%Ty@yZ$UWkqO!Q%T!Q![@r![!^%T!_!g%T!g!hAl!h#R%T#R#S@r#S#X%T#X#YAl#Y#o%T#p~%TyAqZ$UWO{%T{|Bd|}%T}!OBd!O!Q%T!Q![CO![!^%T!_#R%T#R#SCO#S#o%T#p~%TyBiV$UWO!Q%T!Q![CO![!^%T!_#R%T#R#SCO#S#o%T#p~%TyCVV$UWkqO!Q%T!Q![CO![!^%T!_#R%T#R#SCO#S#o%T#p~%T,TCs`$UW#]#vOYDuYZ%TZzDuz{Jl{!PDu!P!Q!-e!Q!^Du!^!_Fx!_!`!.^!`!a!/]!a!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~DuXD|[$UW}POYDuYZ%TZ!PDu!P!QEr!Q!^Du!^!_Fx!_!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~DuXEy_$UW}PO!^%T!_#Z%T#Z#[Er#[#]%T#]#^Er#^#a%T#a#bEr#b#g%T#g#hEr#h#i%T#i#jEr#j#m%T#m#nEr#n#o%T#p~%TPF}V}POYFxZ!PFx!P!QGd!Q!}Fx!}#OG{#O#PHh#P~FxPGiU}P#Z#[Gd#]#^Gd#a#bGd#g#hGd#i#jGd#m#nGdPHOTOYG{Z#OG{#O#PH_#P#QFx#Q~G{PHbQOYG{Z~G{PHkQOYFxZ~FxXHvY$UWOYHqYZ%TZ!^Hq!^!_G{!_#OHq#O#PIf#P#QDu#Q#oHq#o#pG{#p~HqXIkV$UWOYHqYZ%TZ!^Hq!^!_G{!_#oHq#o#pG{#p~HqXJVV$UWOYDuYZ%TZ!^Du!^!_Fx!_#oDu#o#pFx#p~Du,TJs^$UW}POYJlYZKoZzJlz{NQ{!PJl!P!Q!,R!Q!^Jl!^!_!!]!_!}Jl!}#O!'|#O#P!+a#P#oJl#o#p!!]#p~Jl,TKtV$UWOzKoz{LZ{!^Ko!^!_M]!_#oKo#o#pM]#p~Ko,TL`X$UWOzKoz{LZ{!PKo!P!QL{!Q!^Ko!^!_M]!_#oKo#o#pM]#p~Ko,TMSR$UWU+{O!^%T!_#o%T#p~%T+{M`ROzM]z{Mi{~M]+{MlTOzM]z{Mi{!PM]!P!QM{!Q~M]+{NQOU+{,TNX^$UW}POYJlYZKoZzJlz{NQ{!PJl!P!Q! T!Q!^Jl!^!_!!]!_!}Jl!}#O!'|#O#P!+a#P#oJl#o#p!!]#p~Jl,T! ^_$UWU+{}PO!^%T!_#Z%T#Z#[Er#[#]%T#]#^Er#^#a%T#a#bEr#b#g%T#g#hEr#h#i%T#i#jEr#j#m%T#m#nEr#n#o%T#p~%T+{!!bY}POY!!]YZM]Zz!!]z{!#Q{!P!!]!P!Q!&x!Q!}!!]!}#O!$`#O#P!&f#P~!!]+{!#VY}POY!!]YZM]Zz!!]z{!#Q{!P!!]!P!Q!#u!Q!}!!]!}#O!$`#O#P!&f#P~!!]+{!#|UU+{}P#Z#[Gd#]#^Gd#a#bGd#g#hGd#i#jGd#m#nGd+{!$cWOY!$`YZM]Zz!$`z{!${{#O!$`#O#P!&S#P#Q!!]#Q~!$`+{!%OYOY!$`YZM]Zz!$`z{!${{!P!$`!P!Q!%n!Q#O!$`#O#P!&S#P#Q!!]#Q~!$`+{!%sTU+{OYG{Z#OG{#O#PH_#P#QFx#Q~G{+{!&VTOY!$`YZM]Zz!$`z{!${{~!$`+{!&iTOY!!]YZM]Zz!!]z{!#Q{~!!]+{!&}_}POzM]z{Mi{#ZM]#Z#[!&x#[#]M]#]#^!&x#^#aM]#a#b!&x#b#gM]#g#h!&x#h#iM]#i#j!&x#j#mM]#m#n!&x#n~M],T!(R[$UWOY!'|YZKoZz!'|z{!(w{!^!'|!^!_!$`!_#O!'|#O#P!*o#P#QJl#Q#o!'|#o#p!$`#p~!'|,T!(|^$UWOY!'|YZKoZz!'|z{!(w{!P!'|!P!Q!)x!Q!^!'|!^!_!$`!_#O!'|#O#P!*o#P#QJl#Q#o!'|#o#p!$`#p~!'|,T!*PY$UWU+{OYHqYZ%TZ!^Hq!^!_G{!_#OHq#O#PIf#P#QDu#Q#oHq#o#pG{#p~Hq,T!*tX$UWOY!'|YZKoZz!'|z{!(w{!^!'|!^!_!$`!_#o!'|#o#p!$`#p~!'|,T!+fX$UWOYJlYZKoZzJlz{NQ{!^Jl!^!_!!]!_#oJl#o#p!!]#p~Jl,T!,Yc$UW}POzKoz{LZ{!^Ko!^!_M]!_#ZKo#Z#[!,R#[#]Ko#]#^!,R#^#aKo#a#b!,R#b#gKo#g#h!,R#h#iKo#i#j!,R#j#mKo#m#n!,R#n#oKo#o#pM]#p~Ko,T!-lV$UWT+{OY!-eYZ%TZ!^!-e!^!_!.R!_#o!-e#o#p!.R#p~!-e+{!.WQT+{OY!.RZ~!.R$P!.g[$UW#o#v}POYDuYZ%TZ!PDu!P!QEr!Q!^Du!^!_Fx!_!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~Du]!/f[#wS$UW}POYDuYZ%TZ!PDu!P!QEr!Q!^Du!^!_Fx!_!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~Duy!0cd$UWkqO!O%T!O!P@r!P!Q%T!Q![!1q![!^%T!_!g%T!g!hAl!h#R%T#R#S!1q#S#U%T#U#V!3X#V#X%T#X#YAl#Y#b%T#b#c!2w#c#d!4m#d#l%T#l#m!5{#m#o%T#p~%Ty!1x_$UWkqO!O%T!O!P@r!P!Q%T!Q![!1q![!^%T!_!g%T!g!hAl!h#R%T#R#S!1q#S#X%T#X#YAl#Y#b%T#b#c!2w#c#o%T#p~%Ty!3OR$UWkqO!^%T!_#o%T#p~%Ty!3^W$UWO!Q%T!Q!R!3v!R!S!3v!S!^%T!_#R%T#R#S!3v#S#o%T#p~%Ty!3}Y$UWkqO!Q%T!Q!R!3v!R!S!3v!S!^%T!_#R%T#R#S!3v#S#b%T#b#c!2w#c#o%T#p~%Ty!4rV$UWO!Q%T!Q!Y!5X!Y!^%T!_#R%T#R#S!5X#S#o%T#p~%Ty!5`X$UWkqO!Q%T!Q!Y!5X!Y!^%T!_#R%T#R#S!5X#S#b%T#b#c!2w#c#o%T#p~%Ty!6QZ$UWO!Q%T!Q![!6s![!^%T!_!c%T!c!i!6s!i#R%T#R#S!6s#S#T%T#T#Z!6s#Z#o%T#p~%Ty!6z]$UWkqO!Q%T!Q![!6s![!^%T!_!c%T!c!i!6s!i#R%T#R#S!6s#S#T%T#T#Z!6s#Z#b%T#b#c!2w#c#o%T#p~%T%w!7|R!]V$UW#m%hO!^%T!_#o%T#p~%T!P!8^R_w$UWO!^%T!_#o%T#p~%T+c!8rR'`d!a%Y#x&s'zP!P!Q!8{!^!_!9Q!_!`!9_W!9QO$WW#v!9VP#`#v!_!`!9Y#v!9_O#o#v#v!9dO#a#v%w!9kT!{%o$UWO!^%T!_!`'v!`!a!9z!a#o%T#p~%T$P!:RR#W#w$UWO!^%T!_#o%T#p~%T%w!:gT'_!s#a#v$RS$UWO!^%T!_!`!:v!`!a!;W!a#o%T#p~%T$O!:}R#a#v$UWO!^%T!_#o%T#p~%T$O!;_T#`#v$UWO!^%T!_!`5T!`!a!;n!a#o%T#p~%T$O!;uS#`#v$UWO!^%T!_!`5T!`#o%T#p~%T%w!<YV'n%o$UWO!O%T!O!P!<o!P!^%T!_!a%T!a!b!=P!b#o%T#p~%T$`!<vRv$W$UWO!^%T!_#o%T#p~%T$O!=WS$UW#j#vO!^%T!_!`5T!`#o%T#p~%T&e!=kRx&]$UWO!^%T!_#o%T#p~%TZ!={R!OR$UWO!^%T!_#o%T#p~%T$O!>]S#g#v$UWO!^%T!_!`5T!`#o%T#p~%T$P!>pR$UW'd#wO!^%T!_#o%T#p~%T~!?OO!T~%r!?VT'u%j$UWO!^%T!_!`5T!`#o%T#p#q!=P#q~%T$u!?oR!S$knQ$UWO!^%T!_#o%T#p~%TX!@PR!kP$UWO!^%T!_#o%T#p~%T,T!@gr$UW'W+{#zS'Z%k'epOX%TXY%cYZ%TZ[%c[p%Tpq%cqt%Ttu2`u}%T}!O3j!O!Q%T!Q![2`![!^%T!_!c%T!c!}2`!}#R%T#R#S2`#S#T%T#T#o2`#p$f%T$f$g%c$g#BY2`#BY#BZ!@Y#BZ$IS2`$IS$I_!@Y$I_$JT2`$JT$JU!@Y$JU$KV2`$KV$KW!@Y$KW&FU2`&FU&FV!@Y&FV?HT2`?HT?HU!@Y?HU~2`,T!CO_$UW'X+{#zS'Z%k'epOt%Ttu2`u}%T}!O3j!O!Q%T!Q![2`![!^%T!_!c%T!c!}2`!}#R%T#R#S2`#S#T%T#T#o2`#p$g%T$g~2`",
  tokenizers: [noSemicolon, incdecToken, template, 0, 1, 2, 3, 4, 5, 6, 7, 8, insertSemicolon],
  topRules: { "Script": [0, 7] },
  dialects: { jsx: 11335, ts: 11337 },
  dynamicPrecedences: { "149": 1, "176": 1 },
  specialized: [{ term: 287, get: (value, stack) => tsExtends(value, stack) << 1 }, { term: 287, get: (value) => spec_identifier[value] || -1 }, { term: 297, get: (value) => spec_word[value] || -1 }, { term: 63, get: (value) => spec_LessThan[value] || -1 }],
  tokenPrec: 11358
});
const snippets = [
  /* @__PURE__ */ snippetCompletion("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("try {\n	${}\n} catch (${error}) {\n	${}\n}", {
    label: "try",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("class ${name} {\n	constructor(${params}) {\n		${}\n	}\n}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
];
const javascriptLanguage = /* @__PURE__ */ LRLanguage.define({
  parser: /* @__PURE__ */ parser$1.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        IfStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: flatIndent,
        SwitchBody: (context) => {
          let after = context.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
          return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
        },
        Block: /* @__PURE__ */ delimitedIndent({ closing: "}" }),
        ArrowFunction: (cx) => cx.baseIndent + cx.unit,
        "TemplateString BlockComment": () => -1,
        "Statement Property": /* @__PURE__ */ continuedIndent({ except: /^{/ }),
        JSXElement(context) {
          let closed = /^\s*<\//.test(context.textAfter);
          return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
        },
        JSXEscape(context) {
          let closed = /\s*\}/.test(context.textAfter);
          return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(context) {
          return context.column(context.node.from) + context.unit;
        }
      }),
      /* @__PURE__ */ foldNodeProp.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": foldInside$1,
        BlockComment(tree) {
          return { from: tree.from + 2, to: tree.to - 2 };
        }
      }),
      /* @__PURE__ */ styleTags({
        "get set async static": tags$1.modifier,
        "for while do if else switch try catch finally return throw break continue default case": tags$1.controlKeyword,
        "in of await yield void typeof delete instanceof": tags$1.operatorKeyword,
        "let var const function class extends": tags$1.definitionKeyword,
        "import export from": tags$1.moduleKeyword,
        "with debugger as new": tags$1.keyword,
        TemplateString: /* @__PURE__ */ tags$1.special(tags$1.string),
        Super: tags$1.atom,
        BooleanLiteral: tags$1.bool,
        this: tags$1.self,
        null: tags$1.null,
        Star: tags$1.modifier,
        VariableName: tags$1.variableName,
        "CallExpression/VariableName TaggedTemplateExpression/VariableName": /* @__PURE__ */ tags$1.function(tags$1.variableName),
        VariableDefinition: /* @__PURE__ */ tags$1.definition(tags$1.variableName),
        Label: tags$1.labelName,
        PropertyName: tags$1.propertyName,
        PrivatePropertyName: /* @__PURE__ */ tags$1.special(tags$1.propertyName),
        "CallExpression/MemberExpression/PropertyName": /* @__PURE__ */ tags$1.function(tags$1.propertyName),
        "FunctionDeclaration/VariableDefinition": /* @__PURE__ */ tags$1.function(/* @__PURE__ */ tags$1.definition(tags$1.variableName)),
        "ClassDeclaration/VariableDefinition": /* @__PURE__ */ tags$1.definition(tags$1.className),
        PropertyDefinition: /* @__PURE__ */ tags$1.definition(tags$1.propertyName),
        PrivatePropertyDefinition: /* @__PURE__ */ tags$1.definition(/* @__PURE__ */ tags$1.special(tags$1.propertyName)),
        UpdateOp: tags$1.updateOperator,
        LineComment: tags$1.lineComment,
        BlockComment: tags$1.blockComment,
        Number: tags$1.number,
        String: tags$1.string,
        ArithOp: tags$1.arithmeticOperator,
        LogicOp: tags$1.logicOperator,
        BitOp: tags$1.bitwiseOperator,
        CompareOp: tags$1.compareOperator,
        RegExp: tags$1.regexp,
        Equals: tags$1.definitionOperator,
        "Arrow : Spread": tags$1.punctuation,
        "( )": tags$1.paren,
        "[ ]": tags$1.squareBracket,
        "{ }": tags$1.brace,
        "InterpolationStart InterpolationEnd": /* @__PURE__ */ tags$1.special(tags$1.brace),
        ".": tags$1.derefOperator,
        ", ;": tags$1.separator,
        TypeName: tags$1.typeName,
        TypeDefinition: /* @__PURE__ */ tags$1.definition(tags$1.typeName),
        "type enum interface implements namespace module declare": tags$1.definitionKeyword,
        "abstract global Privacy readonly override": tags$1.modifier,
        "is keyof unique infer": tags$1.operatorKeyword,
        JSXAttributeValue: tags$1.attributeValue,
        JSXText: tags$1.content,
        "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": tags$1.angleBracket,
        "JSXIdentifier JSXNameSpacedName": tags$1.tagName,
        "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": tags$1.attributeName
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
});
const typescriptLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "ts" });
const jsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "jsx" });
const tsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "jsx ts" });
function javascript(config2 = {}) {
  let lang2 = config2.jsx ? config2.typescript ? tsxLanguage : jsxLanguage : config2.typescript ? typescriptLanguage : javascriptLanguage;
  return new LanguageSupport(lang2, javascriptLanguage.data.of({
    autocomplete: ifNotIn(["LineComment", "BlockComment", "String"], completeFromList(snippets))
  }));
}
const Targets = ["_blank", "_self", "_top", "_parent"];
const Charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
const Methods = ["get", "post", "put", "delete"];
const Encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
const Bool = ["true", "false"];
const S = {};
const Tags = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Targets,
      hreflang: null
    }
  },
  abbr: S,
  acronym: S,
  address: S,
  applet: S,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: S,
  aside: S,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: S,
  base: { attrs: { href: null, target: Targets } },
  basefont: S,
  bdi: S,
  bdo: S,
  big: S,
  blockquote: { attrs: { cite: null } },
  body: S,
  br: S,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: Encs,
      formmethod: Methods,
      formnovalidate: ["novalidate"],
      formtarget: Targets,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: S,
  center: S,
  cite: S,
  code: S,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: S,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: S,
  dir: S,
  div: S,
  dl: S,
  dt: S,
  em: S,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: S,
  figure: S,
  font: S,
  footer: S,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Charsets,
      autocomplete: ["on", "off"],
      enctype: Encs,
      method: Methods,
      novalidate: ["novalidate"],
      target: Targets
    }
  },
  frame: S,
  frameset: S,
  h1: S,
  h2: S,
  h3: S,
  h4: S,
  h5: S,
  h6: S,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: S,
  hgroup: S,
  hr: S,
  html: {
    attrs: { manifest: null }
  },
  i: S,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: Encs,
      formmethod: Methods,
      formnovalidate: ["novalidate"],
      formtarget: Targets,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: S,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: S,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: S,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Charsets,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: S,
  noframes: S,
  noscript: S,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: S,
  param: { attrs: { name: null, value: null } },
  pre: S,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: S,
  rt: S,
  ruby: S,
  s: S,
  samp: S,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Charsets
    }
  },
  section: S,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  small: S,
  source: { attrs: { src: null, type: null, media: null } },
  span: S,
  strike: S,
  strong: S,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: S,
  summary: S,
  sup: S,
  table: S,
  tbody: S,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: S,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: S,
  time: { attrs: { datetime: null } },
  title: S,
  tr: S,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  tt: S,
  u: S,
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: S,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: S
};
const GlobalAttrs = {
  accesskey: null,
  class: null,
  contenteditable: Bool,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Bool,
  autocorrect: Bool,
  autocapitalize: Bool,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  onclick: null,
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Bool,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Bool,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Bool,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Bool,
  "aria-hidden": Bool,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Bool,
  "aria-multiselectable": Bool,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Bool,
  "aria-relevant": null,
  "aria-required": Bool,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
};
const AllTags = /* @__PURE__ */ Object.keys(Tags);
const GlobalAttrNames = /* @__PURE__ */ Object.keys(GlobalAttrs);
function elementName(doc2, tree, max = doc2.length) {
  if (!tree)
    return "";
  let tag = tree.firstChild;
  let name2 = tag && tag.getChild("TagName");
  return name2 ? doc2.sliceString(name2.from, Math.min(name2.to, max)) : "";
}
function findParentElement(tree, skip = false) {
  for (let cur2 = tree.parent; cur2; cur2 = cur2.parent)
    if (cur2.name == "Element") {
      if (skip)
        skip = false;
      else
        return cur2;
    }
  return null;
}
function allowedChildren(doc2, tree) {
  let parentInfo = Tags[elementName(doc2, findParentElement(tree, true))];
  return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || AllTags;
}
function openTags(doc2, tree) {
  let open = [];
  for (let parent = tree; parent = findParentElement(parent); ) {
    let tagName = elementName(doc2, parent);
    if (tagName && parent.lastChild.name == "CloseTag")
      break;
    if (tagName && open.indexOf(tagName) < 0 && (tree.name == "EndTag" || tree.from >= parent.firstChild.to))
      open.push(tagName);
  }
  return open;
}
const identifier = /^[:\-\.\w\u00b7-\uffff]+$/;
function completeTag(state, tree, from, to) {
  let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
  return {
    from,
    to,
    options: allowedChildren(state.doc, tree).map((tagName) => ({ label: tagName, type: "type" })).concat(openTags(state.doc, tree).map((tag, i) => ({ label: "/" + tag, apply: "/" + tag + end, type: "type", boost: 99 - i }))),
    span: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function completeCloseTag(state, tree, from, to) {
  let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
  return {
    from,
    to,
    options: openTags(state.doc, tree).map((tag, i) => ({ label: tag, apply: tag + end, type: "type", boost: 99 - i })),
    span: identifier
  };
}
function completeStartTag(state, tree, pos) {
  let options = [], level = 0;
  for (let tagName of allowedChildren(state.doc, tree))
    options.push({ label: "<" + tagName, type: "type" });
  for (let open of openTags(state.doc, tree))
    options.push({ label: "</" + open + ">", type: "type", boost: 99 - level++ });
  return { from: pos, to: pos, options, span: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeAttrName(state, tree, from, to) {
  let elt2 = findParentElement(tree), info = elt2 ? Tags[elementName(state.doc, elt2)] : null;
  let names = info && info.attrs ? Object.keys(info.attrs).concat(GlobalAttrNames) : GlobalAttrNames;
  return {
    from,
    to,
    options: names.map((attrName) => ({ label: attrName, type: "property" })),
    span: identifier
  };
}
function completeAttrValue(state, tree, from, to) {
  var _a;
  let nameNode = (_a = tree.parent) === null || _a === void 0 ? void 0 : _a.getChild("AttributeName");
  let options = [], span2 = void 0;
  if (nameNode) {
    let attrName = state.sliceDoc(nameNode.from, nameNode.to);
    let attrs = GlobalAttrs[attrName];
    if (!attrs) {
      let elt2 = findParentElement(tree), info = elt2 ? Tags[elementName(state.doc, elt2)] : null;
      attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];
    }
    if (attrs) {
      let base2 = state.sliceDoc(from, to).toLowerCase(), quoteStart = '"', quoteEnd = '"';
      if (/^['"]/.test(base2)) {
        span2 = base2[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
        quoteStart = "";
        quoteEnd = state.sliceDoc(to, to + 1) == base2[0] ? "" : base2[0];
        base2 = base2.slice(1);
        from++;
      } else {
        span2 = /^[^\s<>='"]*$/;
      }
      for (let value of attrs)
        options.push({ label: value, apply: quoteStart + value + quoteEnd, type: "constant" });
    }
  }
  return { from, to, options, span: span2 };
}
function htmlCompletionSource(context) {
  let { state, pos } = context, around = syntaxTree(state).resolveInner(pos), tree = around.resolve(pos, -1);
  for (let scan = pos, before; around == tree && (before = tree.childBefore(scan)); ) {
    let last = before.lastChild;
    if (!last || !last.type.isError || last.from < last.to)
      break;
    around = tree = before;
    scan = last.from;
  }
  if (tree.name == "TagName") {
    return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos) : completeTag(state, tree, tree.from, pos);
  } else if (tree.name == "StartTag") {
    return completeTag(state, tree, pos, pos);
  } else if (tree.name == "StartCloseTag" || tree.name == "IncompleteCloseTag") {
    return completeCloseTag(state, tree, pos, pos);
  } else if (context.explicit && (tree.name == "OpenTag" || tree.name == "SelfClosingTag") || tree.name == "AttributeName") {
    return completeAttrName(state, tree, tree.name == "AttributeName" ? tree.from : pos, pos);
  } else if (tree.name == "Is" || tree.name == "AttributeValue" || tree.name == "UnquotedAttributeValue") {
    return completeAttrValue(state, tree, tree.name == "Is" ? pos : tree.from, pos);
  } else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
    return completeStartTag(state, tree, pos);
  } else {
    return null;
  }
}
const htmlLanguage = /* @__PURE__ */ LRLanguage.define({
  parser: /* @__PURE__ */ parser$3.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        Element(context) {
          let after = /^(\s*)(<\/)?/.exec(context.textAfter);
          if (context.node.to <= context.pos + after[0].length)
            return context.continue();
          return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(context) {
          return context.column(context.node.from) + context.unit;
        },
        Document(context) {
          if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to)
            return context.continue();
          let endElt = null, close;
          for (let cur2 = context.node; ; ) {
            let last = cur2.lastChild;
            if (!last || last.name != "Element" || last.to != cur2.to)
              break;
            endElt = cur2 = last;
          }
          if (endElt && !((close = endElt.lastChild) && (close.name == "CloseTag" || close.name == "SelfClosingTag")))
            return context.lineIndent(endElt.from) + context.unit;
          return null;
        }
      }),
      /* @__PURE__ */ foldNodeProp.add({
        Element(node) {
          let first = node.firstChild, last = node.lastChild;
          if (!first || first.name != "OpenTag")
            return null;
          return { from: first.to, to: last.name == "CloseTag" ? last.from : node.to };
        }
      }),
      /* @__PURE__ */ styleTags({
        "Text RawText": tags$1.content,
        "StartTag StartCloseTag SelfCloserEndTag EndTag SelfCloseEndTag": tags$1.angleBracket,
        TagName: tags$1.tagName,
        "MismatchedCloseTag/TagName": [tags$1.tagName, tags$1.invalid],
        AttributeName: tags$1.attributeName,
        "AttributeValue UnquotedAttributeValue": tags$1.attributeValue,
        Is: tags$1.definitionOperator,
        "EntityReference CharacterReference": tags$1.character,
        Comment: tags$1.blockComment,
        ProcessingInst: tags$1.processingInstruction,
        DoctypeDecl: tags$1.documentMeta
      })
    ],
    wrap: /* @__PURE__ */ configureNesting([
      {
        tag: "script",
        attrs(attrs) {
          return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
        },
        parser: javascriptLanguage.parser
      },
      {
        tag: "style",
        attrs(attrs) {
          return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
        },
        parser: cssLanguage.parser
      }
    ])
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
});
const htmlCompletion = /* @__PURE__ */ htmlLanguage.data.of({ autocomplete: htmlCompletionSource });
function html(config2 = {}) {
  let lang2 = htmlLanguage;
  if (config2.matchClosingTags === false)
    lang2 = lang2.configure({ dialect: "noMatch" });
  return new LanguageSupport(lang2, [
    htmlCompletion,
    config2.autoCloseTags !== false ? autoCloseTags : [],
    javascript().support,
    css().support
  ]);
}
const autoCloseTags = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, text3) => {
  if (view.composing || view.state.readOnly || from != to || text3 != ">" && text3 != "/" || !htmlLanguage.isActiveAt(view.state, from, -1))
    return false;
  let { state } = view;
  let changes = state.changeByRange((range2) => {
    var _a, _b, _c;
    let { head } = range2, around = syntaxTree(state).resolveInner(head, -1), name2;
    if (around.name == "TagName" || around.name == "StartTag")
      around = around.parent;
    if (text3 == ">" && around.name == "OpenTag") {
      if (((_b = (_a = around.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" && (name2 = elementName(state.doc, around.parent, head)))
        return { range: EditorSelection.cursor(head + 1), changes: { from: head, insert: `></${name2}>` } };
    } else if (text3 == "/" && around.name == "OpenTag") {
      let empty2 = around.parent, base2 = empty2 === null || empty2 === void 0 ? void 0 : empty2.parent;
      if (empty2.from == head - 1 && ((_c = base2.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" && (name2 = elementName(state.doc, base2, head))) {
        let insert2 = `/${name2}>`;
        return { range: EditorSelection.cursor(head + insert2.length), changes: { from: head, insert: insert2 } };
      }
    }
    return { range: range2 };
  });
  if (changes.changes.empty)
    return false;
  view.dispatch(changes, { userEvent: "input.type", scrollIntoView: true });
  return true;
});
const data = /* @__PURE__ */ defineLanguageFacet({ block: { open: "<!--", close: "-->" } });
const commonmark = /* @__PURE__ */ parser$4.configure({
  props: [
    /* @__PURE__ */ styleTags({
      "Blockquote/...": tags$1.quote,
      HorizontalRule: tags$1.contentSeparator,
      "ATXHeading1/... SetextHeading1/...": tags$1.heading1,
      "ATXHeading2/... SetextHeading2/...": tags$1.heading2,
      "ATXHeading3/...": tags$1.heading3,
      "ATXHeading4/...": tags$1.heading4,
      "ATXHeading5/...": tags$1.heading5,
      "ATXHeading6/...": tags$1.heading6,
      "Comment CommentBlock": tags$1.comment,
      Escape: tags$1.escape,
      Entity: tags$1.character,
      "Emphasis/...": tags$1.emphasis,
      "StrongEmphasis/...": tags$1.strong,
      "Link/... Image/...": tags$1.link,
      "OrderedList/... BulletList/...": tags$1.list,
      "BlockQuote/...": tags$1.quote,
      "InlineCode CodeText": tags$1.monospace,
      URL: tags$1.url,
      "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": tags$1.processingInstruction,
      "CodeInfo LinkLabel": tags$1.labelName,
      LinkTitle: tags$1.string,
      Paragraph: tags$1.content
    }),
    /* @__PURE__ */ foldNodeProp.add((type) => {
      if (!type.is("Block") || type.is("Document"))
        return void 0;
      return (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });
    }),
    /* @__PURE__ */ indentNodeProp.add({
      Document: () => null
    }),
    /* @__PURE__ */ languageDataProp.add({
      Document: data
    })
  ]
});
function mkLang(parser2) {
  return new Language(data, parser2, parser2.nodeSet.types.find((t2) => t2.name == "Document"));
}
const commonmarkLanguage = /* @__PURE__ */ mkLang(commonmark);
const extended = /* @__PURE__ */ commonmark.configure([GFM, Subscript, Superscript, Emoji, {
  props: [
    /* @__PURE__ */ styleTags({
      "TableDelimiter SubscriptMark SuperscriptMark StrikethroughMark": tags$1.processingInstruction,
      "TableHeader/...": tags$1.heading,
      "Strikethrough/...": tags$1.strikethrough,
      TaskMarker: tags$1.atom,
      Task: tags$1.list,
      Emoji: tags$1.character,
      "Subscript Superscript": /* @__PURE__ */ tags$1.special(tags$1.content),
      TableCell: tags$1.content
    })
  ]
}]);
const markdownLanguage = /* @__PURE__ */ mkLang(extended);
function getCodeParser(languages, defaultLanguage) {
  return (info) => {
    let found = info && LanguageDescription.matchLanguageName(languages, info, true);
    if (!found)
      return defaultLanguage ? defaultLanguage.parser : null;
    if (found.support)
      return found.support.language.parser;
    return ParseContext.getSkippingParser(found.load());
  };
}
function nodeStart(node, doc2) {
  return doc2.sliceString(node.from, node.from + 50);
}
class Context {
  constructor(node, from, to, spaceBefore, spaceAfter, type, item) {
    this.node = node;
    this.from = from;
    this.to = to;
    this.spaceBefore = spaceBefore;
    this.spaceAfter = spaceAfter;
    this.type = type;
    this.item = item;
  }
  blank(trailing = true) {
    let result = this.spaceBefore;
    if (this.node.name == "Blockquote")
      result += ">";
    else
      for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)
        result += " ";
    return result + (trailing ? this.spaceAfter : "");
  }
  marker(doc2, add3) {
    let number2 = this.node.name == "OrderedList" ? String(+itemNumber(this.item, doc2)[2] + add3) : "";
    return this.spaceBefore + number2 + this.type + this.spaceAfter;
  }
}
function getContext(node, line, doc2) {
  let nodes = [];
  for (let cur2 = node; cur2 && cur2.name != "Document"; cur2 = cur2.parent) {
    if (cur2.name == "ListItem" || cur2.name == "Blockquote")
      nodes.push(cur2);
  }
  let context = [], pos = 0;
  for (let i = nodes.length - 1; i >= 0; i--) {
    let node2 = nodes[i], match2, start = pos;
    if (node2.name == "Blockquote" && (match2 = /^[ \t]*>( ?)/.exec(line.slice(pos)))) {
      pos += match2[0].length;
      context.push(new Context(node2, start, pos, "", match2[1], ">", null));
    } else if (node2.name == "ListItem" && node2.parent.name == "OrderedList" && (match2 = /^([ \t]*)\d+([.)])([ \t]*)/.exec(nodeStart(node2, doc2)))) {
      let after = match2[3], len = match2[0].length;
      if (after.length >= 4) {
        after = after.slice(0, after.length - 4);
        len -= 4;
      }
      pos += len;
      context.push(new Context(node2.parent, start, pos, match2[1], after, match2[2], node2));
    } else if (node2.name == "ListItem" && node2.parent.name == "BulletList" && (match2 = /^([ \t]*)([-+*])([ \t]+)/.exec(nodeStart(node2, doc2)))) {
      let after = match2[3], len = match2[0].length;
      if (after.length > 4) {
        after = after.slice(0, after.length - 4);
        len -= 4;
      }
      pos += len;
      context.push(new Context(node2.parent, start, pos, match2[1], after, match2[2], node2));
    }
  }
  return context;
}
function itemNumber(item, doc2) {
  return /^(\s*)(\d+)(?=[.)])/.exec(doc2.sliceString(item.from, item.from + 10));
}
function renumberList(after, doc2, changes, offset = 0) {
  for (let prev = -1, node = after; ; ) {
    if (node.name == "ListItem") {
      let m = itemNumber(node, doc2);
      let number2 = +m[2];
      if (prev >= 0) {
        if (number2 != prev + 1)
          return;
        changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });
      }
      prev = number2;
    }
    let next = node.nextSibling;
    if (!next)
      break;
    node = next;
  }
}
const insertNewlineContinueMarkup = ({ state, dispatch }) => {
  let tree = syntaxTree(state), { doc: doc2 } = state;
  let dont = null, changes = state.changeByRange((range2) => {
    if (!range2.empty || !markdownLanguage.isActiveAt(state, range2.from))
      return dont = { range: range2 };
    let pos = range2.from, line = doc2.lineAt(pos);
    let context = getContext(tree.resolveInner(pos, -1), line.text, doc2);
    while (context.length && context[context.length - 1].from > pos - line.from)
      context.pop();
    if (!context.length)
      return dont = { range: range2 };
    let inner = context[context.length - 1];
    if (inner.to - inner.spaceAfter.length > pos - line.from)
      return dont = { range: range2 };
    let emptyLine = pos >= inner.to - inner.spaceAfter.length && !/\S/.test(line.text.slice(inner.to));
    if (inner.item && emptyLine) {
      if (inner.node.firstChild.to >= pos || line.from > 0 && !/[^\s>]/.test(doc2.lineAt(line.from - 1).text)) {
        let next = context.length > 1 ? context[context.length - 2] : null;
        let delTo, insert3 = "";
        if (next && next.item) {
          delTo = line.from + next.from;
          insert3 = next.marker(doc2, 1);
        } else {
          delTo = line.from + (next ? next.to : 0);
        }
        let changes3 = [{ from: delTo, to: pos, insert: insert3 }];
        if (inner.node.name == "OrderedList")
          renumberList(inner.item, doc2, changes3, -2);
        if (next && next.node.name == "OrderedList")
          renumberList(next.item, doc2, changes3);
        return { range: EditorSelection.cursor(delTo + insert3.length), changes: changes3 };
      } else {
        let insert3 = "";
        for (let i = 0, e = context.length - 2; i <= e; i++)
          insert3 += context[i].blank(i < e);
        insert3 += state.lineBreak;
        return { range: EditorSelection.cursor(pos + insert3.length), changes: { from: line.from, insert: insert3 } };
      }
    }
    if (inner.node.name == "Blockquote" && emptyLine && line.from) {
      let prevLine = doc2.lineAt(line.from - 1), quoted = />\s*$/.exec(prevLine.text);
      if (quoted && quoted.index == inner.from) {
        let changes3 = state.changes([
          { from: prevLine.from + quoted.index, to: prevLine.to },
          { from: line.from + inner.from, to: line.to }
        ]);
        return { range: range2.map(changes3), changes: changes3 };
      }
    }
    let changes2 = [];
    if (inner.node.name == "OrderedList")
      renumberList(inner.item, doc2, changes2);
    let insert2 = state.lineBreak;
    let continued = inner.item && inner.item.from < line.from;
    if (!continued || /^[\s\d.)\-+*>]*/.exec(line.text)[0].length >= inner.to) {
      for (let i = 0, e = context.length - 1; i <= e; i++)
        insert2 += i == e && !continued ? context[i].marker(doc2, 1) : context[i].blank();
    }
    let from = pos;
    while (from > line.from && /\s/.test(line.text.charAt(from - line.from - 1)))
      from--;
    changes2.push({ from, to: pos, insert: insert2 });
    return { range: EditorSelection.cursor(from + insert2.length), changes: changes2 };
  });
  if (dont)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
function isMark(node) {
  return node.name == "QuoteMark" || node.name == "ListMark";
}
function contextNodeForDelete(tree, pos) {
  let node = tree.resolveInner(pos, -1), scan = pos;
  if (isMark(node)) {
    scan = node.from;
    node = node.parent;
  }
  for (let prev; prev = node.childBefore(scan); ) {
    if (isMark(prev)) {
      scan = prev.from;
    } else if (prev.name == "OrderedList" || prev.name == "BulletList") {
      node = prev.lastChild;
      scan = node.to;
    } else {
      break;
    }
  }
  return node;
}
const deleteMarkupBackward = ({ state, dispatch }) => {
  let tree = syntaxTree(state);
  let dont = null, changes = state.changeByRange((range2) => {
    let pos = range2.from, { doc: doc2 } = state;
    if (range2.empty && markdownLanguage.isActiveAt(state, range2.from)) {
      let line = doc2.lineAt(pos);
      let context = getContext(contextNodeForDelete(tree, pos), line.text, doc2);
      if (context.length) {
        let inner = context[context.length - 1];
        let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);
        if (pos - line.from > spaceEnd && !/\S/.test(line.text.slice(spaceEnd, pos - line.from)))
          return {
            range: EditorSelection.cursor(line.from + spaceEnd),
            changes: { from: line.from + spaceEnd, to: pos }
          };
        if (pos - line.from == spaceEnd) {
          let start = line.from + inner.from;
          if (inner.item && inner.node.from < inner.item.from && /\S/.test(line.text.slice(inner.from, inner.to)))
            return { range: range2, changes: { from: start, to: line.from + inner.to, insert: inner.blank() } };
          if (start < pos)
            return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };
        }
      }
    }
    return dont = { range: range2 };
  });
  if (dont)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete" }));
  return true;
};
const markdownKeymap = [
  { key: "Enter", run: insertNewlineContinueMarkup },
  { key: "Backspace", run: deleteMarkupBackward }
];
const htmlNoMatch = /* @__PURE__ */ html({ matchClosingTags: false });
function markdown(config2 = {}) {
  let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser: parser2 } = commonmarkLanguage } = config2;
  if (!(parser2 instanceof MarkdownParser))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let extensions2 = config2.extensions ? [config2.extensions] : [];
  let support = [htmlNoMatch.support], defaultCode;
  if (defaultCodeLanguage instanceof LanguageSupport) {
    support.push(defaultCodeLanguage.support);
    defaultCode = defaultCodeLanguage.language;
  } else if (defaultCodeLanguage) {
    defaultCode = defaultCodeLanguage;
  }
  let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages || [], defaultCode) : void 0;
  extensions2.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));
  if (addKeymap)
    support.push(Prec.high(keymap.of(markdownKeymap)));
  return new LanguageSupport(mkLang(parser2.configure(extensions2)), support);
}
const parser = LRParser.deserialize({
  version: 13,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "\u26A0 JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    [NodeProp.openedBy, 7, "{", 12, "["],
    [NodeProp.closedBy, 8, "}", 13, "]"]
  ],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oc~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOe~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOh~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOg~~&rO]~~&wO[~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOW~~(pOV~",
  tokenizers: [0],
  topRules: { "JsonText": [0, 1] },
  tokenPrec: 0
});
const jsonLanguage = /* @__PURE__ */ LRLanguage.define({
  parser: /* @__PURE__ */ parser.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        Object: /* @__PURE__ */ continuedIndent({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ continuedIndent({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ foldNodeProp.add({
        "Object Array": foldInside$1
      }),
      /* @__PURE__ */ styleTags({
        String: tags$1.string,
        Number: tags$1.number,
        "True False": tags$1.bool,
        PropertyName: tags$1.propertyName,
        Null: tags$1.null,
        ",": tags$1.separator,
        "[ ]": tags$1.squareBracket,
        "{ }": tags$1.brace
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
var parserMarkdown$1 = { exports: {} };
(function(module, exports) {
  !function(e, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    var e = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : {};
    function t2(e2) {
      return e2 && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
    }
    var r = function() {
      for (var e2 = {}, t3 = 0; t3 < arguments.length; t3++) {
        var r2 = arguments[t3];
        for (var u2 in r2)
          n.call(r2, u2) && (e2[u2] = r2[u2]);
      }
      return e2;
    }, n = Object.prototype.hasOwnProperty;
    var u = { exports: {} }, i = i !== void 0 ? i : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, o = [], a = [], c = typeof Uint8Array != "undefined" ? Uint8Array : Array, s = false;
    function l() {
      s = true;
      for (var e2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t3 = 0, r2 = e2.length; t3 < r2; ++t3)
        o[t3] = e2[t3], a[e2.charCodeAt(t3)] = t3;
      a["-".charCodeAt(0)] = 62, a["_".charCodeAt(0)] = 63;
    }
    function f(e2) {
      return o[e2 >> 18 & 63] + o[e2 >> 12 & 63] + o[e2 >> 6 & 63] + o[63 & e2];
    }
    function D(e2, t3, r2) {
      for (var n2, u2 = [], i2 = t3; i2 < r2; i2 += 3)
        n2 = (e2[i2] << 16) + (e2[i2 + 1] << 8) + e2[i2 + 2], u2.push(f(n2));
      return u2.join("");
    }
    function p(e2) {
      var t3;
      s || l();
      for (var r2 = e2.length, n2 = r2 % 3, u2 = "", i2 = [], a2 = 16383, c2 = 0, f2 = r2 - n2; c2 < f2; c2 += a2)
        i2.push(D(e2, c2, c2 + a2 > f2 ? f2 : c2 + a2));
      return n2 === 1 ? (t3 = e2[r2 - 1], u2 += o[t3 >> 2], u2 += o[t3 << 4 & 63], u2 += "==") : n2 === 2 && (t3 = (e2[r2 - 2] << 8) + e2[r2 - 1], u2 += o[t3 >> 10], u2 += o[t3 >> 4 & 63], u2 += o[t3 << 2 & 63], u2 += "="), i2.push(u2), i2.join("");
    }
    function h(e2, t3, r2, n2, u2) {
      var i2, o2, a2 = 8 * u2 - n2 - 1, c2 = (1 << a2) - 1, s2 = c2 >> 1, l2 = -7, f2 = r2 ? u2 - 1 : 0, D2 = r2 ? -1 : 1, p2 = e2[t3 + f2];
      for (f2 += D2, i2 = p2 & (1 << -l2) - 1, p2 >>= -l2, l2 += a2; l2 > 0; i2 = 256 * i2 + e2[t3 + f2], f2 += D2, l2 -= 8)
        ;
      for (o2 = i2 & (1 << -l2) - 1, i2 >>= -l2, l2 += n2; l2 > 0; o2 = 256 * o2 + e2[t3 + f2], f2 += D2, l2 -= 8)
        ;
      if (i2 === 0)
        i2 = 1 - s2;
      else {
        if (i2 === c2)
          return o2 ? NaN : 1 / 0 * (p2 ? -1 : 1);
        o2 += Math.pow(2, n2), i2 -= s2;
      }
      return (p2 ? -1 : 1) * o2 * Math.pow(2, i2 - n2);
    }
    function d(e2, t3, r2, n2, u2, i2) {
      var o2, a2, c2, s2 = 8 * i2 - u2 - 1, l2 = (1 << s2) - 1, f2 = l2 >> 1, D2 = u2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p2 = n2 ? 0 : i2 - 1, h2 = n2 ? 1 : -1, d2 = t3 < 0 || t3 === 0 && 1 / t3 < 0 ? 1 : 0;
      for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a2 = isNaN(t3) ? 1 : 0, o2 = l2) : (o2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (c2 = Math.pow(2, -o2)) < 1 && (o2--, c2 *= 2), (t3 += o2 + f2 >= 1 ? D2 / c2 : D2 * Math.pow(2, 1 - f2)) * c2 >= 2 && (o2++, c2 /= 2), o2 + f2 >= l2 ? (a2 = 0, o2 = l2) : o2 + f2 >= 1 ? (a2 = (t3 * c2 - 1) * Math.pow(2, u2), o2 += f2) : (a2 = t3 * Math.pow(2, f2 - 1) * Math.pow(2, u2), o2 = 0)); u2 >= 8; e2[r2 + p2] = 255 & a2, p2 += h2, a2 /= 256, u2 -= 8)
        ;
      for (o2 = o2 << u2 | a2, s2 += u2; s2 > 0; e2[r2 + p2] = 255 & o2, p2 += h2, o2 /= 256, s2 -= 8)
        ;
      e2[r2 + p2 - h2] |= 128 * d2;
    }
    var g = {}.toString, m = Array.isArray || function(e2) {
      return g.call(e2) == "[object Array]";
    };
    function E() {
      return y.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    }
    function v(e2, t3) {
      if (E() < t3)
        throw new RangeError("Invalid typed array length");
      return y.TYPED_ARRAY_SUPPORT ? (e2 = new Uint8Array(t3)).__proto__ = y.prototype : (e2 === null && (e2 = new y(t3)), e2.length = t3), e2;
    }
    function y(e2, t3, r2) {
      if (!(y.TYPED_ARRAY_SUPPORT || this instanceof y))
        return new y(e2, t3, r2);
      if (typeof e2 == "number") {
        if (typeof t3 == "string")
          throw new Error("If encoding is specified then the first argument must be a string");
        return A(this, e2);
      }
      return b(this, e2, t3, r2);
    }
    function b(e2, t3, r2, n2) {
      if (typeof t3 == "number")
        throw new TypeError('"value" argument must not be a number');
      return typeof ArrayBuffer != "undefined" && t3 instanceof ArrayBuffer ? function(e3, t4, r3, n3) {
        if (t4.byteLength, r3 < 0 || t4.byteLength < r3)
          throw new RangeError("'offset' is out of bounds");
        if (t4.byteLength < r3 + (n3 || 0))
          throw new RangeError("'length' is out of bounds");
        t4 = r3 === void 0 && n3 === void 0 ? new Uint8Array(t4) : n3 === void 0 ? new Uint8Array(t4, r3) : new Uint8Array(t4, r3, n3);
        y.TYPED_ARRAY_SUPPORT ? (e3 = t4).__proto__ = y.prototype : e3 = w(e3, t4);
        return e3;
      }(e2, t3, r2, n2) : typeof t3 == "string" ? function(e3, t4, r3) {
        typeof r3 == "string" && r3 !== "" || (r3 = "utf8");
        if (!y.isEncoding(r3))
          throw new TypeError('"encoding" must be a valid string encoding');
        var n3 = 0 | O(t4, r3), u2 = (e3 = v(e3, n3)).write(t4, r3);
        u2 !== n3 && (e3 = e3.slice(0, u2));
        return e3;
      }(e2, t3, r2) : function(e3, t4) {
        if (k(t4)) {
          var r3 = 0 | F(t4.length);
          return (e3 = v(e3, r3)).length === 0 || t4.copy(e3, 0, 0, r3), e3;
        }
        if (t4) {
          if (typeof ArrayBuffer != "undefined" && t4.buffer instanceof ArrayBuffer || "length" in t4)
            return typeof t4.length != "number" || (n3 = t4.length) != n3 ? v(e3, 0) : w(e3, t4);
          if (t4.type === "Buffer" && m(t4.data))
            return w(e3, t4.data);
        }
        var n3;
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }(e2, t3);
    }
    function C2(e2) {
      if (typeof e2 != "number")
        throw new TypeError('"size" argument must be a number');
      if (e2 < 0)
        throw new RangeError('"size" argument must not be negative');
    }
    function A(e2, t3) {
      if (C2(t3), e2 = v(e2, t3 < 0 ? 0 : 0 | F(t3)), !y.TYPED_ARRAY_SUPPORT)
        for (var r2 = 0; r2 < t3; ++r2)
          e2[r2] = 0;
      return e2;
    }
    function w(e2, t3) {
      var r2 = t3.length < 0 ? 0 : 0 | F(t3.length);
      e2 = v(e2, r2);
      for (var n2 = 0; n2 < r2; n2 += 1)
        e2[n2] = 255 & t3[n2];
      return e2;
    }
    function F(e2) {
      if (e2 >= E())
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + E().toString(16) + " bytes");
      return 0 | e2;
    }
    function k(e2) {
      return !(e2 == null || !e2._isBuffer);
    }
    function O(e2, t3) {
      if (k(e2))
        return e2.length;
      if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e2) || e2 instanceof ArrayBuffer))
        return e2.byteLength;
      typeof e2 != "string" && (e2 = "" + e2);
      var r2 = e2.length;
      if (r2 === 0)
        return 0;
      for (var n2 = false; ; )
        switch (t3) {
          case "ascii":
          case "latin1":
          case "binary":
            return r2;
          case "utf8":
          case "utf-8":
          case void 0:
            return ee2(e2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * r2;
          case "hex":
            return r2 >>> 1;
          case "base64":
            return te(e2).length;
          default:
            if (n2)
              return ee2(e2).length;
            t3 = ("" + t3).toLowerCase(), n2 = true;
        }
    }
    function x(e2, t3, r2) {
      var n2 = false;
      if ((t3 === void 0 || t3 < 0) && (t3 = 0), t3 > this.length)
        return "";
      if ((r2 === void 0 || r2 > this.length) && (r2 = this.length), r2 <= 0)
        return "";
      if ((r2 >>>= 0) <= (t3 >>>= 0))
        return "";
      for (e2 || (e2 = "utf8"); ; )
        switch (e2) {
          case "hex":
            return G(this, t3, r2);
          case "utf8":
          case "utf-8":
            return _(this, t3, r2);
          case "ascii":
            return M(this, t3, r2);
          case "latin1":
          case "binary":
            return z(this, t3, r2);
          case "base64":
            return j(this, t3, r2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return V(this, t3, r2);
          default:
            if (n2)
              throw new TypeError("Unknown encoding: " + e2);
            e2 = (e2 + "").toLowerCase(), n2 = true;
        }
    }
    function T(e2, t3, r2) {
      var n2 = e2[t3];
      e2[t3] = e2[r2], e2[r2] = n2;
    }
    function S2(e2, t3, r2, n2, u2) {
      if (e2.length === 0)
        return -1;
      if (typeof r2 == "string" ? (n2 = r2, r2 = 0) : r2 > 2147483647 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), r2 = +r2, isNaN(r2) && (r2 = u2 ? 0 : e2.length - 1), r2 < 0 && (r2 = e2.length + r2), r2 >= e2.length) {
        if (u2)
          return -1;
        r2 = e2.length - 1;
      } else if (r2 < 0) {
        if (!u2)
          return -1;
        r2 = 0;
      }
      if (typeof t3 == "string" && (t3 = y.from(t3, n2)), k(t3))
        return t3.length === 0 ? -1 : R(e2, t3, r2, n2, u2);
      if (typeof t3 == "number")
        return t3 &= 255, y.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? u2 ? Uint8Array.prototype.indexOf.call(e2, t3, r2) : Uint8Array.prototype.lastIndexOf.call(e2, t3, r2) : R(e2, [t3], r2, n2, u2);
      throw new TypeError("val must be string, number or Buffer");
    }
    function R(e2, t3, r2, n2, u2) {
      var i2, o2 = 1, a2 = e2.length, c2 = t3.length;
      if (n2 !== void 0 && ((n2 = String(n2).toLowerCase()) === "ucs2" || n2 === "ucs-2" || n2 === "utf16le" || n2 === "utf-16le")) {
        if (e2.length < 2 || t3.length < 2)
          return -1;
        o2 = 2, a2 /= 2, c2 /= 2, r2 /= 2;
      }
      function s2(e3, t4) {
        return o2 === 1 ? e3[t4] : e3.readUInt16BE(t4 * o2);
      }
      if (u2) {
        var l2 = -1;
        for (i2 = r2; i2 < a2; i2++)
          if (s2(e2, i2) === s2(t3, l2 === -1 ? 0 : i2 - l2)) {
            if (l2 === -1 && (l2 = i2), i2 - l2 + 1 === c2)
              return l2 * o2;
          } else
            l2 !== -1 && (i2 -= i2 - l2), l2 = -1;
      } else
        for (r2 + c2 > a2 && (r2 = a2 - c2), i2 = r2; i2 >= 0; i2--) {
          for (var f2 = true, D2 = 0; D2 < c2; D2++)
            if (s2(e2, i2 + D2) !== s2(t3, D2)) {
              f2 = false;
              break;
            }
          if (f2)
            return i2;
        }
      return -1;
    }
    function I(e2, t3, r2, n2) {
      r2 = Number(r2) || 0;
      var u2 = e2.length - r2;
      n2 ? (n2 = Number(n2)) > u2 && (n2 = u2) : n2 = u2;
      var i2 = t3.length;
      if (i2 % 2 != 0)
        throw new TypeError("Invalid hex string");
      n2 > i2 / 2 && (n2 = i2 / 2);
      for (var o2 = 0; o2 < n2; ++o2) {
        var a2 = parseInt(t3.substr(2 * o2, 2), 16);
        if (isNaN(a2))
          return o2;
        e2[r2 + o2] = a2;
      }
      return o2;
    }
    function B(e2, t3, r2, n2) {
      return re2(ee2(t3, e2.length - r2), e2, r2, n2);
    }
    function N(e2, t3, r2, n2) {
      return re2(function(e3) {
        for (var t4 = [], r3 = 0; r3 < e3.length; ++r3)
          t4.push(255 & e3.charCodeAt(r3));
        return t4;
      }(t3), e2, r2, n2);
    }
    function L(e2, t3, r2, n2) {
      return N(e2, t3, r2, n2);
    }
    function P(e2, t3, r2, n2) {
      return re2(te(t3), e2, r2, n2);
    }
    function q(e2, t3, r2, n2) {
      return re2(function(e3, t4) {
        for (var r3, n3, u2, i2 = [], o2 = 0; o2 < e3.length && !((t4 -= 2) < 0); ++o2)
          n3 = (r3 = e3.charCodeAt(o2)) >> 8, u2 = r3 % 256, i2.push(u2), i2.push(n3);
        return i2;
      }(t3, e2.length - r2), e2, r2, n2);
    }
    function j(e2, t3, r2) {
      return t3 === 0 && r2 === e2.length ? p(e2) : p(e2.slice(t3, r2));
    }
    function _(e2, t3, r2) {
      r2 = Math.min(e2.length, r2);
      for (var n2 = [], u2 = t3; u2 < r2; ) {
        var i2, o2, a2, c2, s2 = e2[u2], l2 = null, f2 = s2 > 239 ? 4 : s2 > 223 ? 3 : s2 > 191 ? 2 : 1;
        if (u2 + f2 <= r2)
          switch (f2) {
            case 1:
              s2 < 128 && (l2 = s2);
              break;
            case 2:
              (192 & (i2 = e2[u2 + 1])) == 128 && (c2 = (31 & s2) << 6 | 63 & i2) > 127 && (l2 = c2);
              break;
            case 3:
              i2 = e2[u2 + 1], o2 = e2[u2 + 2], (192 & i2) == 128 && (192 & o2) == 128 && (c2 = (15 & s2) << 12 | (63 & i2) << 6 | 63 & o2) > 2047 && (c2 < 55296 || c2 > 57343) && (l2 = c2);
              break;
            case 4:
              i2 = e2[u2 + 1], o2 = e2[u2 + 2], a2 = e2[u2 + 3], (192 & i2) == 128 && (192 & o2) == 128 && (192 & a2) == 128 && (c2 = (15 & s2) << 18 | (63 & i2) << 12 | (63 & o2) << 6 | 63 & a2) > 65535 && c2 < 1114112 && (l2 = c2);
          }
        l2 === null ? (l2 = 65533, f2 = 1) : l2 > 65535 && (l2 -= 65536, n2.push(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), n2.push(l2), u2 += f2;
      }
      return function(e3) {
        var t4 = e3.length;
        if (t4 <= U)
          return String.fromCharCode.apply(String, e3);
        var r3 = "", n3 = 0;
        for (; n3 < t4; )
          r3 += String.fromCharCode.apply(String, e3.slice(n3, n3 += U));
        return r3;
      }(n2);
    }
    y.TYPED_ARRAY_SUPPORT = i.TYPED_ARRAY_SUPPORT === void 0 || i.TYPED_ARRAY_SUPPORT, y.poolSize = 8192, y._augment = function(e2) {
      return e2.__proto__ = y.prototype, e2;
    }, y.from = function(e2, t3, r2) {
      return b(null, e2, t3, r2);
    }, y.TYPED_ARRAY_SUPPORT && (y.prototype.__proto__ = Uint8Array.prototype, y.__proto__ = Uint8Array), y.alloc = function(e2, t3, r2) {
      return function(e3, t4, r3, n2) {
        return C2(t4), t4 <= 0 ? v(e3, t4) : r3 !== void 0 ? typeof n2 == "string" ? v(e3, t4).fill(r3, n2) : v(e3, t4).fill(r3) : v(e3, t4);
      }(null, e2, t3, r2);
    }, y.allocUnsafe = function(e2) {
      return A(null, e2);
    }, y.allocUnsafeSlow = function(e2) {
      return A(null, e2);
    }, y.isBuffer = function(e2) {
      return e2 != null && (!!e2._isBuffer || ne2(e2) || function(e3) {
        return typeof e3.readFloatLE == "function" && typeof e3.slice == "function" && ne2(e3.slice(0, 0));
      }(e2));
    }, y.compare = function(e2, t3) {
      if (!k(e2) || !k(t3))
        throw new TypeError("Arguments must be Buffers");
      if (e2 === t3)
        return 0;
      for (var r2 = e2.length, n2 = t3.length, u2 = 0, i2 = Math.min(r2, n2); u2 < i2; ++u2)
        if (e2[u2] !== t3[u2]) {
          r2 = e2[u2], n2 = t3[u2];
          break;
        }
      return r2 < n2 ? -1 : n2 < r2 ? 1 : 0;
    }, y.isEncoding = function(e2) {
      switch (String(e2).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, y.concat = function(e2, t3) {
      if (!m(e2))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (e2.length === 0)
        return y.alloc(0);
      var r2;
      if (t3 === void 0)
        for (t3 = 0, r2 = 0; r2 < e2.length; ++r2)
          t3 += e2[r2].length;
      var n2 = y.allocUnsafe(t3), u2 = 0;
      for (r2 = 0; r2 < e2.length; ++r2) {
        var i2 = e2[r2];
        if (!k(i2))
          throw new TypeError('"list" argument must be an Array of Buffers');
        i2.copy(n2, u2), u2 += i2.length;
      }
      return n2;
    }, y.byteLength = O, y.prototype._isBuffer = true, y.prototype.swap16 = function() {
      var e2 = this.length;
      if (e2 % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var t3 = 0; t3 < e2; t3 += 2)
        T(this, t3, t3 + 1);
      return this;
    }, y.prototype.swap32 = function() {
      var e2 = this.length;
      if (e2 % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var t3 = 0; t3 < e2; t3 += 4)
        T(this, t3, t3 + 3), T(this, t3 + 1, t3 + 2);
      return this;
    }, y.prototype.swap64 = function() {
      var e2 = this.length;
      if (e2 % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var t3 = 0; t3 < e2; t3 += 8)
        T(this, t3, t3 + 7), T(this, t3 + 1, t3 + 6), T(this, t3 + 2, t3 + 5), T(this, t3 + 3, t3 + 4);
      return this;
    }, y.prototype.toString = function() {
      var e2 = 0 | this.length;
      return e2 === 0 ? "" : arguments.length === 0 ? _(this, 0, e2) : x.apply(this, arguments);
    }, y.prototype.equals = function(e2) {
      if (!k(e2))
        throw new TypeError("Argument must be a Buffer");
      return this === e2 || y.compare(this, e2) === 0;
    }, y.prototype.inspect = function() {
      var e2 = "";
      return this.length > 0 && (e2 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e2 += " ... ")), "<Buffer " + e2 + ">";
    }, y.prototype.compare = function(e2, t3, r2, n2, u2) {
      if (!k(e2))
        throw new TypeError("Argument must be a Buffer");
      if (t3 === void 0 && (t3 = 0), r2 === void 0 && (r2 = e2 ? e2.length : 0), n2 === void 0 && (n2 = 0), u2 === void 0 && (u2 = this.length), t3 < 0 || r2 > e2.length || n2 < 0 || u2 > this.length)
        throw new RangeError("out of range index");
      if (n2 >= u2 && t3 >= r2)
        return 0;
      if (n2 >= u2)
        return -1;
      if (t3 >= r2)
        return 1;
      if (this === e2)
        return 0;
      for (var i2 = (u2 >>>= 0) - (n2 >>>= 0), o2 = (r2 >>>= 0) - (t3 >>>= 0), a2 = Math.min(i2, o2), c2 = this.slice(n2, u2), s2 = e2.slice(t3, r2), l2 = 0; l2 < a2; ++l2)
        if (c2[l2] !== s2[l2]) {
          i2 = c2[l2], o2 = s2[l2];
          break;
        }
      return i2 < o2 ? -1 : o2 < i2 ? 1 : 0;
    }, y.prototype.includes = function(e2, t3, r2) {
      return this.indexOf(e2, t3, r2) !== -1;
    }, y.prototype.indexOf = function(e2, t3, r2) {
      return S2(this, e2, t3, r2, true);
    }, y.prototype.lastIndexOf = function(e2, t3, r2) {
      return S2(this, e2, t3, r2, false);
    }, y.prototype.write = function(e2, t3, r2, n2) {
      if (t3 === void 0)
        n2 = "utf8", r2 = this.length, t3 = 0;
      else if (r2 === void 0 && typeof t3 == "string")
        n2 = t3, r2 = this.length, t3 = 0;
      else {
        if (!isFinite(t3))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        t3 |= 0, isFinite(r2) ? (r2 |= 0, n2 === void 0 && (n2 = "utf8")) : (n2 = r2, r2 = void 0);
      }
      var u2 = this.length - t3;
      if ((r2 === void 0 || r2 > u2) && (r2 = u2), e2.length > 0 && (r2 < 0 || t3 < 0) || t3 > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n2 || (n2 = "utf8");
      for (var i2 = false; ; )
        switch (n2) {
          case "hex":
            return I(this, e2, t3, r2);
          case "utf8":
          case "utf-8":
            return B(this, e2, t3, r2);
          case "ascii":
            return N(this, e2, t3, r2);
          case "latin1":
          case "binary":
            return L(this, e2, t3, r2);
          case "base64":
            return P(this, e2, t3, r2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return q(this, e2, t3, r2);
          default:
            if (i2)
              throw new TypeError("Unknown encoding: " + n2);
            n2 = ("" + n2).toLowerCase(), i2 = true;
        }
    }, y.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    var U = 4096;
    function M(e2, t3, r2) {
      var n2 = "";
      r2 = Math.min(e2.length, r2);
      for (var u2 = t3; u2 < r2; ++u2)
        n2 += String.fromCharCode(127 & e2[u2]);
      return n2;
    }
    function z(e2, t3, r2) {
      var n2 = "";
      r2 = Math.min(e2.length, r2);
      for (var u2 = t3; u2 < r2; ++u2)
        n2 += String.fromCharCode(e2[u2]);
      return n2;
    }
    function G(e2, t3, r2) {
      var n2 = e2.length;
      (!t3 || t3 < 0) && (t3 = 0), (!r2 || r2 < 0 || r2 > n2) && (r2 = n2);
      for (var u2 = "", i2 = t3; i2 < r2; ++i2)
        u2 += Q(e2[i2]);
      return u2;
    }
    function V(e2, t3, r2) {
      for (var n2 = e2.slice(t3, r2), u2 = "", i2 = 0; i2 < n2.length; i2 += 2)
        u2 += String.fromCharCode(n2[i2] + 256 * n2[i2 + 1]);
      return u2;
    }
    function Y(e2, t3, r2) {
      if (e2 % 1 != 0 || e2 < 0)
        throw new RangeError("offset is not uint");
      if (e2 + t3 > r2)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function $(e2, t3, r2, n2, u2, i2) {
      if (!k(e2))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t3 > u2 || t3 < i2)
        throw new RangeError('"value" argument is out of bounds');
      if (r2 + n2 > e2.length)
        throw new RangeError("Index out of range");
    }
    function H(e2, t3, r2, n2) {
      t3 < 0 && (t3 = 65535 + t3 + 1);
      for (var u2 = 0, i2 = Math.min(e2.length - r2, 2); u2 < i2; ++u2)
        e2[r2 + u2] = (t3 & 255 << 8 * (n2 ? u2 : 1 - u2)) >>> 8 * (n2 ? u2 : 1 - u2);
    }
    function X(e2, t3, r2, n2) {
      t3 < 0 && (t3 = 4294967295 + t3 + 1);
      for (var u2 = 0, i2 = Math.min(e2.length - r2, 4); u2 < i2; ++u2)
        e2[r2 + u2] = t3 >>> 8 * (n2 ? u2 : 3 - u2) & 255;
    }
    function Z(e2, t3, r2, n2, u2, i2) {
      if (r2 + n2 > e2.length)
        throw new RangeError("Index out of range");
      if (r2 < 0)
        throw new RangeError("Index out of range");
    }
    function W(e2, t3, r2, n2, u2) {
      return u2 || Z(e2, 0, r2, 4), d(e2, t3, r2, n2, 23, 4), r2 + 4;
    }
    function J(e2, t3, r2, n2, u2) {
      return u2 || Z(e2, 0, r2, 8), d(e2, t3, r2, n2, 52, 8), r2 + 8;
    }
    y.prototype.slice = function(e2, t3) {
      var r2, n2 = this.length;
      if ((e2 = ~~e2) < 0 ? (e2 += n2) < 0 && (e2 = 0) : e2 > n2 && (e2 = n2), (t3 = t3 === void 0 ? n2 : ~~t3) < 0 ? (t3 += n2) < 0 && (t3 = 0) : t3 > n2 && (t3 = n2), t3 < e2 && (t3 = e2), y.TYPED_ARRAY_SUPPORT)
        (r2 = this.subarray(e2, t3)).__proto__ = y.prototype;
      else {
        var u2 = t3 - e2;
        r2 = new y(u2, void 0);
        for (var i2 = 0; i2 < u2; ++i2)
          r2[i2] = this[i2 + e2];
      }
      return r2;
    }, y.prototype.readUIntLE = function(e2, t3, r2) {
      e2 |= 0, t3 |= 0, r2 || Y(e2, t3, this.length);
      for (var n2 = this[e2], u2 = 1, i2 = 0; ++i2 < t3 && (u2 *= 256); )
        n2 += this[e2 + i2] * u2;
      return n2;
    }, y.prototype.readUIntBE = function(e2, t3, r2) {
      e2 |= 0, t3 |= 0, r2 || Y(e2, t3, this.length);
      for (var n2 = this[e2 + --t3], u2 = 1; t3 > 0 && (u2 *= 256); )
        n2 += this[e2 + --t3] * u2;
      return n2;
    }, y.prototype.readUInt8 = function(e2, t3) {
      return t3 || Y(e2, 1, this.length), this[e2];
    }, y.prototype.readUInt16LE = function(e2, t3) {
      return t3 || Y(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
    }, y.prototype.readUInt16BE = function(e2, t3) {
      return t3 || Y(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
    }, y.prototype.readUInt32LE = function(e2, t3) {
      return t3 || Y(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
    }, y.prototype.readUInt32BE = function(e2, t3) {
      return t3 || Y(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
    }, y.prototype.readIntLE = function(e2, t3, r2) {
      e2 |= 0, t3 |= 0, r2 || Y(e2, t3, this.length);
      for (var n2 = this[e2], u2 = 1, i2 = 0; ++i2 < t3 && (u2 *= 256); )
        n2 += this[e2 + i2] * u2;
      return n2 >= (u2 *= 128) && (n2 -= Math.pow(2, 8 * t3)), n2;
    }, y.prototype.readIntBE = function(e2, t3, r2) {
      e2 |= 0, t3 |= 0, r2 || Y(e2, t3, this.length);
      for (var n2 = t3, u2 = 1, i2 = this[e2 + --n2]; n2 > 0 && (u2 *= 256); )
        i2 += this[e2 + --n2] * u2;
      return i2 >= (u2 *= 128) && (i2 -= Math.pow(2, 8 * t3)), i2;
    }, y.prototype.readInt8 = function(e2, t3) {
      return t3 || Y(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
    }, y.prototype.readInt16LE = function(e2, t3) {
      t3 || Y(e2, 2, this.length);
      var r2 = this[e2] | this[e2 + 1] << 8;
      return 32768 & r2 ? 4294901760 | r2 : r2;
    }, y.prototype.readInt16BE = function(e2, t3) {
      t3 || Y(e2, 2, this.length);
      var r2 = this[e2 + 1] | this[e2] << 8;
      return 32768 & r2 ? 4294901760 | r2 : r2;
    }, y.prototype.readInt32LE = function(e2, t3) {
      return t3 || Y(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
    }, y.prototype.readInt32BE = function(e2, t3) {
      return t3 || Y(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
    }, y.prototype.readFloatLE = function(e2, t3) {
      return t3 || Y(e2, 4, this.length), h(this, e2, true, 23, 4);
    }, y.prototype.readFloatBE = function(e2, t3) {
      return t3 || Y(e2, 4, this.length), h(this, e2, false, 23, 4);
    }, y.prototype.readDoubleLE = function(e2, t3) {
      return t3 || Y(e2, 8, this.length), h(this, e2, true, 52, 8);
    }, y.prototype.readDoubleBE = function(e2, t3) {
      return t3 || Y(e2, 8, this.length), h(this, e2, false, 52, 8);
    }, y.prototype.writeUIntLE = function(e2, t3, r2, n2) {
      (e2 = +e2, t3 |= 0, r2 |= 0, n2) || $(this, e2, t3, r2, Math.pow(2, 8 * r2) - 1, 0);
      var u2 = 1, i2 = 0;
      for (this[t3] = 255 & e2; ++i2 < r2 && (u2 *= 256); )
        this[t3 + i2] = e2 / u2 & 255;
      return t3 + r2;
    }, y.prototype.writeUIntBE = function(e2, t3, r2, n2) {
      (e2 = +e2, t3 |= 0, r2 |= 0, n2) || $(this, e2, t3, r2, Math.pow(2, 8 * r2) - 1, 0);
      var u2 = r2 - 1, i2 = 1;
      for (this[t3 + u2] = 255 & e2; --u2 >= 0 && (i2 *= 256); )
        this[t3 + u2] = e2 / i2 & 255;
      return t3 + r2;
    }, y.prototype.writeUInt8 = function(e2, t3, r2) {
      return e2 = +e2, t3 |= 0, r2 || $(this, e2, t3, 1, 255, 0), y.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), this[t3] = 255 & e2, t3 + 1;
    }, y.prototype.writeUInt16LE = function(e2, t3, r2) {
      return e2 = +e2, t3 |= 0, r2 || $(this, e2, t3, 2, 65535, 0), y.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e2, this[t3 + 1] = e2 >>> 8) : H(this, e2, t3, true), t3 + 2;
    }, y.prototype.writeUInt16BE = function(e2, t3, r2) {
      return e2 = +e2, t3 |= 0, r2 || $(this, e2, t3, 2, 65535, 0), y.TYPED_ARRAY_SUPPORT ? (this[t3] = e2 >>> 8, this[t3 + 1] = 255 & e2) : H(this, e2, t3, false), t3 + 2;
    }, y.prototype.writeUInt32LE = function(e2, t3, r2) {
      return e2 = +e2, t3 |= 0, r2 || $(this, e2, t3, 4, 4294967295, 0), y.TYPED_ARRAY_SUPPORT ? (this[t3 + 3] = e2 >>> 24, this[t3 + 2] = e2 >>> 16, this[t3 + 1] = e2 >>> 8, this[t3] = 255 & e2) : X(this, e2, t3, true), t3 + 4;
    }, y.prototype.writeUInt32BE = function(e2, t3, r2) {
      return e2 = +e2, t3 |= 0, r2 || $(this, e2, t3, 4, 4294967295, 0), y.TYPED_ARRAY_SUPPORT ? (this[t3] = e2 >>> 24, this[t3 + 1] = e2 >>> 16, this[t3 + 2] = e2 >>> 8, this[t3 + 3] = 255 & e2) : X(this, e2, t3, false), t3 + 4;
    }, y.prototype.writeIntLE = function(e2, t3, r2, n2) {
      if (e2 = +e2, t3 |= 0, !n2) {
        var u2 = Math.pow(2, 8 * r2 - 1);
        $(this, e2, t3, r2, u2 - 1, -u2);
      }
      var i2 = 0, o2 = 1, a2 = 0;
      for (this[t3] = 255 & e2; ++i2 < r2 && (o2 *= 256); )
        e2 < 0 && a2 === 0 && this[t3 + i2 - 1] !== 0 && (a2 = 1), this[t3 + i2] = (e2 / o2 >> 0) - a2 & 255;
      return t3 + r2;
    }, y.prototype.writeIntBE = function(e2, t3, r2, n2) {
      if (e2 = +e2, t3 |= 0, !n2) {
        var u2 = Math.pow(2, 8 * r2 - 1);
        $(this, e2, t3, r2, u2 - 1, -u2);
      }
      var i2 = r2 - 1, o2 = 1, a2 = 0;
      for (this[t3 + i2] = 255 & e2; --i2 >= 0 && (o2 *= 256); )
        e2 < 0 && a2 === 0 && this[t3 + i2 + 1] !== 0 && (a2 = 1), this[t3 + i2] = (e2 / o2 >> 0) - a2 & 255;
      return t3 + r2;
    }, y.prototype.writeInt8 = function(e2, t3, r2) {
      return e2 = +e2, t3 |= 0, r2 || $(this, e2, t3, 1, 127, -128), y.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), e2 < 0 && (e2 = 255 + e2 + 1), this[t3] = 255 & e2, t3 + 1;
    }, y.prototype.writeInt16LE = function(e2, t3, r2) {
      return e2 = +e2, t3 |= 0, r2 || $(this, e2, t3, 2, 32767, -32768), y.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e2, this[t3 + 1] = e2 >>> 8) : H(this, e2, t3, true), t3 + 2;
    }, y.prototype.writeInt16BE = function(e2, t3, r2) {
      return e2 = +e2, t3 |= 0, r2 || $(this, e2, t3, 2, 32767, -32768), y.TYPED_ARRAY_SUPPORT ? (this[t3] = e2 >>> 8, this[t3 + 1] = 255 & e2) : H(this, e2, t3, false), t3 + 2;
    }, y.prototype.writeInt32LE = function(e2, t3, r2) {
      return e2 = +e2, t3 |= 0, r2 || $(this, e2, t3, 4, 2147483647, -2147483648), y.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e2, this[t3 + 1] = e2 >>> 8, this[t3 + 2] = e2 >>> 16, this[t3 + 3] = e2 >>> 24) : X(this, e2, t3, true), t3 + 4;
    }, y.prototype.writeInt32BE = function(e2, t3, r2) {
      return e2 = +e2, t3 |= 0, r2 || $(this, e2, t3, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), y.TYPED_ARRAY_SUPPORT ? (this[t3] = e2 >>> 24, this[t3 + 1] = e2 >>> 16, this[t3 + 2] = e2 >>> 8, this[t3 + 3] = 255 & e2) : X(this, e2, t3, false), t3 + 4;
    }, y.prototype.writeFloatLE = function(e2, t3, r2) {
      return W(this, e2, t3, true, r2);
    }, y.prototype.writeFloatBE = function(e2, t3, r2) {
      return W(this, e2, t3, false, r2);
    }, y.prototype.writeDoubleLE = function(e2, t3, r2) {
      return J(this, e2, t3, true, r2);
    }, y.prototype.writeDoubleBE = function(e2, t3, r2) {
      return J(this, e2, t3, false, r2);
    }, y.prototype.copy = function(e2, t3, r2, n2) {
      if (r2 || (r2 = 0), n2 || n2 === 0 || (n2 = this.length), t3 >= e2.length && (t3 = e2.length), t3 || (t3 = 0), n2 > 0 && n2 < r2 && (n2 = r2), n2 === r2)
        return 0;
      if (e2.length === 0 || this.length === 0)
        return 0;
      if (t3 < 0)
        throw new RangeError("targetStart out of bounds");
      if (r2 < 0 || r2 >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (n2 < 0)
        throw new RangeError("sourceEnd out of bounds");
      n2 > this.length && (n2 = this.length), e2.length - t3 < n2 - r2 && (n2 = e2.length - t3 + r2);
      var u2, i2 = n2 - r2;
      if (this === e2 && r2 < t3 && t3 < n2)
        for (u2 = i2 - 1; u2 >= 0; --u2)
          e2[u2 + t3] = this[u2 + r2];
      else if (i2 < 1e3 || !y.TYPED_ARRAY_SUPPORT)
        for (u2 = 0; u2 < i2; ++u2)
          e2[u2 + t3] = this[u2 + r2];
      else
        Uint8Array.prototype.set.call(e2, this.subarray(r2, r2 + i2), t3);
      return i2;
    }, y.prototype.fill = function(e2, t3, r2, n2) {
      if (typeof e2 == "string") {
        if (typeof t3 == "string" ? (n2 = t3, t3 = 0, r2 = this.length) : typeof r2 == "string" && (n2 = r2, r2 = this.length), e2.length === 1) {
          var u2 = e2.charCodeAt(0);
          u2 < 256 && (e2 = u2);
        }
        if (n2 !== void 0 && typeof n2 != "string")
          throw new TypeError("encoding must be a string");
        if (typeof n2 == "string" && !y.isEncoding(n2))
          throw new TypeError("Unknown encoding: " + n2);
      } else
        typeof e2 == "number" && (e2 &= 255);
      if (t3 < 0 || this.length < t3 || this.length < r2)
        throw new RangeError("Out of range index");
      if (r2 <= t3)
        return this;
      var i2;
      if (t3 >>>= 0, r2 = r2 === void 0 ? this.length : r2 >>> 0, e2 || (e2 = 0), typeof e2 == "number")
        for (i2 = t3; i2 < r2; ++i2)
          this[i2] = e2;
      else {
        var o2 = k(e2) ? e2 : ee2(new y(e2, n2).toString()), a2 = o2.length;
        for (i2 = 0; i2 < r2 - t3; ++i2)
          this[i2 + t3] = o2[i2 % a2];
      }
      return this;
    };
    var K = /[^+\/0-9A-Za-z-_]/g;
    function Q(e2) {
      return e2 < 16 ? "0" + e2.toString(16) : e2.toString(16);
    }
    function ee2(e2, t3) {
      var r2;
      t3 = t3 || 1 / 0;
      for (var n2 = e2.length, u2 = null, i2 = [], o2 = 0; o2 < n2; ++o2) {
        if ((r2 = e2.charCodeAt(o2)) > 55295 && r2 < 57344) {
          if (!u2) {
            if (r2 > 56319) {
              (t3 -= 3) > -1 && i2.push(239, 191, 189);
              continue;
            }
            if (o2 + 1 === n2) {
              (t3 -= 3) > -1 && i2.push(239, 191, 189);
              continue;
            }
            u2 = r2;
            continue;
          }
          if (r2 < 56320) {
            (t3 -= 3) > -1 && i2.push(239, 191, 189), u2 = r2;
            continue;
          }
          r2 = 65536 + (u2 - 55296 << 10 | r2 - 56320);
        } else
          u2 && (t3 -= 3) > -1 && i2.push(239, 191, 189);
        if (u2 = null, r2 < 128) {
          if ((t3 -= 1) < 0)
            break;
          i2.push(r2);
        } else if (r2 < 2048) {
          if ((t3 -= 2) < 0)
            break;
          i2.push(r2 >> 6 | 192, 63 & r2 | 128);
        } else if (r2 < 65536) {
          if ((t3 -= 3) < 0)
            break;
          i2.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128);
        } else {
          if (!(r2 < 1114112))
            throw new Error("Invalid code point");
          if ((t3 -= 4) < 0)
            break;
          i2.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128);
        }
      }
      return i2;
    }
    function te(e2) {
      return function(e3) {
        var t3, r2, n2, u2, i2, o2;
        s || l();
        var f2 = e3.length;
        if (f2 % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        i2 = e3[f2 - 2] === "=" ? 2 : e3[f2 - 1] === "=" ? 1 : 0, o2 = new c(3 * f2 / 4 - i2), n2 = i2 > 0 ? f2 - 4 : f2;
        var D2 = 0;
        for (t3 = 0, r2 = 0; t3 < n2; t3 += 4, r2 += 3)
          u2 = a[e3.charCodeAt(t3)] << 18 | a[e3.charCodeAt(t3 + 1)] << 12 | a[e3.charCodeAt(t3 + 2)] << 6 | a[e3.charCodeAt(t3 + 3)], o2[D2++] = u2 >> 16 & 255, o2[D2++] = u2 >> 8 & 255, o2[D2++] = 255 & u2;
        return i2 === 2 ? (u2 = a[e3.charCodeAt(t3)] << 2 | a[e3.charCodeAt(t3 + 1)] >> 4, o2[D2++] = 255 & u2) : i2 === 1 && (u2 = a[e3.charCodeAt(t3)] << 10 | a[e3.charCodeAt(t3 + 1)] << 4 | a[e3.charCodeAt(t3 + 2)] >> 2, o2[D2++] = u2 >> 8 & 255, o2[D2++] = 255 & u2), o2;
      }(function(e3) {
        if ((e3 = function(e4) {
          return e4.trim ? e4.trim() : e4.replace(/^\s+|\s+$/g, "");
        }(e3).replace(K, "")).length < 2)
          return "";
        for (; e3.length % 4 != 0; )
          e3 += "=";
        return e3;
      }(e2));
    }
    function re2(e2, t3, r2, n2) {
      for (var u2 = 0; u2 < n2 && !(u2 + r2 >= t3.length || u2 >= e2.length); ++u2)
        t3[u2 + r2] = e2[u2];
      return u2;
    }
    function ne2(e2) {
      return !!e2.constructor && typeof e2.constructor.isBuffer == "function" && e2.constructor.isBuffer(e2);
    }
    function ue() {
      throw new Error("setTimeout has not been defined");
    }
    function ie2() {
      throw new Error("clearTimeout has not been defined");
    }
    var oe = ue, ae = ie2;
    function ce(e2) {
      if (oe === setTimeout)
        return setTimeout(e2, 0);
      if ((oe === ue || !oe) && setTimeout)
        return oe = setTimeout, setTimeout(e2, 0);
      try {
        return oe(e2, 0);
      } catch (t3) {
        try {
          return oe.call(null, e2, 0);
        } catch (t4) {
          return oe.call(this, e2, 0);
        }
      }
    }
    typeof i.setTimeout == "function" && (oe = setTimeout), typeof i.clearTimeout == "function" && (ae = clearTimeout);
    var se, le2 = [], fe = false, De = -1;
    function pe() {
      fe && se && (fe = false, se.length ? le2 = se.concat(le2) : De = -1, le2.length && he());
    }
    function he() {
      if (!fe) {
        var e2 = ce(pe);
        fe = true;
        for (var t3 = le2.length; t3; ) {
          for (se = le2, le2 = []; ++De < t3; )
            se && se[De].run();
          De = -1, t3 = le2.length;
        }
        se = null, fe = false, function(e3) {
          if (ae === clearTimeout)
            return clearTimeout(e3);
          if ((ae === ie2 || !ae) && clearTimeout)
            return ae = clearTimeout, clearTimeout(e3);
          try {
            ae(e3);
          } catch (t4) {
            try {
              return ae.call(null, e3);
            } catch (t5) {
              return ae.call(this, e3);
            }
          }
        }(e2);
      }
    }
    function de(e2, t3) {
      this.fun = e2, this.array = t3;
    }
    de.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    function ge2() {
    }
    var me = ge2, Ee = ge2, ve = ge2, ye = ge2, be = ge2, Ce = ge2, Ae = ge2;
    var we = i.performance || {}, Fe = we.now || we.mozNow || we.msNow || we.oNow || we.webkitNow || function() {
      return new Date().getTime();
    };
    var ke = new Date();
    var Oe = { nextTick: function(e2) {
      var t3 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r2 = 1; r2 < arguments.length; r2++)
          t3[r2 - 1] = arguments[r2];
      le2.push(new de(e2, t3)), le2.length !== 1 || fe || ce(he);
    }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: me, addListener: Ee, once: ve, off: ye, removeListener: be, removeAllListeners: Ce, emit: Ae, binding: function(e2) {
      throw new Error("process.binding is not supported");
    }, cwd: function() {
      return "/";
    }, chdir: function(e2) {
      throw new Error("process.chdir is not supported");
    }, umask: function() {
      return 0;
    }, hrtime: function(e2) {
      var t3 = 1e-3 * Fe.call(we), r2 = Math.floor(t3), n2 = Math.floor(t3 % 1 * 1e9);
      return e2 && (r2 -= e2[0], (n2 -= e2[1]) < 0 && (r2--, n2 += 1e9)), [r2, n2];
    }, platform: "browser", release: {}, config: {}, uptime: function() {
      return (new Date() - ke) / 1e3;
    } }, xe = Oe, Te = typeof Object.create == "function" ? function(e2, t3) {
      e2.super_ = t3, e2.prototype = Object.create(t3.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } });
    } : function(e2, t3) {
      e2.super_ = t3;
      var r2 = function() {
      };
      r2.prototype = t3.prototype, e2.prototype = new r2(), e2.prototype.constructor = e2;
    }, Se = /%[sdj%]/g;
    function Re2(e2) {
      if (!He(e2)) {
        for (var t3 = [], r2 = 0; r2 < arguments.length; r2++)
          t3.push(Pe(arguments[r2]));
        return t3.join(" ");
      }
      r2 = 1;
      for (var n2 = arguments, u2 = n2.length, i2 = String(e2).replace(Se, function(e3) {
        if (e3 === "%%")
          return "%";
        if (r2 >= u2)
          return e3;
        switch (e3) {
          case "%s":
            return String(n2[r2++]);
          case "%d":
            return Number(n2[r2++]);
          case "%j":
            try {
              return JSON.stringify(n2[r2++]);
            } catch (e4) {
              return "[Circular]";
            }
          default:
            return e3;
        }
      }), o2 = n2[r2]; r2 < u2; o2 = n2[++r2])
        Ve(o2) || !Je(o2) ? i2 += " " + o2 : i2 += " " + Pe(o2);
      return i2;
    }
    function Ie(e2, t3) {
      if (Ze(i.process))
        return function() {
          return Ie(e2, t3).apply(this, arguments);
        };
      var r2 = false;
      return function() {
        if (!r2) {
          console.error(t3), r2 = true;
        }
        return e2.apply(this, arguments);
      };
    }
    var Be, Ne = {};
    function Le(e2) {
      if (Ze(Be) && (Be = ""), e2 = e2.toUpperCase(), !Ne[e2])
        if (new RegExp("\\b" + e2 + "\\b", "i").test(Be)) {
          Ne[e2] = function() {
            var t3 = Re2.apply(null, arguments);
            console.error("%s %d: %s", e2, 0, t3);
          };
        } else
          Ne[e2] = function() {
          };
      return Ne[e2];
    }
    function Pe(e2, t3) {
      var r2 = { seen: [], stylize: je };
      return arguments.length >= 3 && (r2.depth = arguments[2]), arguments.length >= 4 && (r2.colors = arguments[3]), Ge(t3) ? r2.showHidden = t3 : t3 && ct(r2, t3), Ze(r2.showHidden) && (r2.showHidden = false), Ze(r2.depth) && (r2.depth = 2), Ze(r2.colors) && (r2.colors = false), Ze(r2.customInspect) && (r2.customInspect = true), r2.colors && (r2.stylize = qe), _e(r2, e2, r2.depth);
    }
    function qe(e2, t3) {
      var r2 = Pe.styles[t3];
      return r2 ? "\x1B[" + Pe.colors[r2][0] + "m" + e2 + "\x1B[" + Pe.colors[r2][1] + "m" : e2;
    }
    function je(e2, t3) {
      return e2;
    }
    function _e(e2, t3, r2) {
      if (e2.customInspect && t3 && et(t3.inspect) && t3.inspect !== Pe && (!t3.constructor || t3.constructor.prototype !== t3)) {
        var n2 = t3.inspect(r2, e2);
        return He(n2) || (n2 = _e(e2, n2, r2)), n2;
      }
      var u2 = function(e3, t4) {
        if (Ze(t4))
          return e3.stylize("undefined", "undefined");
        if (He(t4)) {
          var r3 = "'" + JSON.stringify(t4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return e3.stylize(r3, "string");
        }
        if ($e(t4))
          return e3.stylize("" + t4, "number");
        if (Ge(t4))
          return e3.stylize("" + t4, "boolean");
        if (Ve(t4))
          return e3.stylize("null", "null");
      }(e2, t3);
      if (u2)
        return u2;
      var i2 = Object.keys(t3), o2 = function(e3) {
        var t4 = {};
        return e3.forEach(function(e4, r3) {
          t4[e4] = true;
        }), t4;
      }(i2);
      if (e2.showHidden && (i2 = Object.getOwnPropertyNames(t3)), Qe(t3) && (i2.indexOf("message") >= 0 || i2.indexOf("description") >= 0))
        return Ue(t3);
      if (i2.length === 0) {
        if (et(t3)) {
          var a2 = t3.name ? ": " + t3.name : "";
          return e2.stylize("[Function" + a2 + "]", "special");
        }
        if (We(t3))
          return e2.stylize(RegExp.prototype.toString.call(t3), "regexp");
        if (Ke(t3))
          return e2.stylize(Date.prototype.toString.call(t3), "date");
        if (Qe(t3))
          return Ue(t3);
      }
      var c2, s2 = "", l2 = false, f2 = ["{", "}"];
      (ze(t3) && (l2 = true, f2 = ["[", "]"]), et(t3)) && (s2 = " [Function" + (t3.name ? ": " + t3.name : "") + "]");
      return We(t3) && (s2 = " " + RegExp.prototype.toString.call(t3)), Ke(t3) && (s2 = " " + Date.prototype.toUTCString.call(t3)), Qe(t3) && (s2 = " " + Ue(t3)), i2.length !== 0 || l2 && t3.length != 0 ? r2 < 0 ? We(t3) ? e2.stylize(RegExp.prototype.toString.call(t3), "regexp") : e2.stylize("[Object]", "special") : (e2.seen.push(t3), c2 = l2 ? function(e3, t4, r3, n3, u3) {
        for (var i3 = [], o3 = 0, a3 = t4.length; o3 < a3; ++o3)
          st(t4, String(o3)) ? i3.push(Me(e3, t4, r3, n3, String(o3), true)) : i3.push("");
        return u3.forEach(function(u4) {
          u4.match(/^\d+$/) || i3.push(Me(e3, t4, r3, n3, u4, true));
        }), i3;
      }(e2, t3, r2, o2, i2) : i2.map(function(n3) {
        return Me(e2, t3, r2, o2, n3, l2);
      }), e2.seen.pop(), function(e3, t4, r3) {
        if (e3.reduce(function(e4, t5) {
          return t5.indexOf("\n"), e4 + t5.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0) > 60)
          return r3[0] + (t4 === "" ? "" : t4 + "\n ") + " " + e3.join(",\n  ") + " " + r3[1];
        return r3[0] + t4 + " " + e3.join(", ") + " " + r3[1];
      }(c2, s2, f2)) : f2[0] + s2 + f2[1];
    }
    function Ue(e2) {
      return "[" + Error.prototype.toString.call(e2) + "]";
    }
    function Me(e2, t3, r2, n2, u2, i2) {
      var o2, a2, c2;
      if ((c2 = Object.getOwnPropertyDescriptor(t3, u2) || { value: t3[u2] }).get ? a2 = c2.set ? e2.stylize("[Getter/Setter]", "special") : e2.stylize("[Getter]", "special") : c2.set && (a2 = e2.stylize("[Setter]", "special")), st(n2, u2) || (o2 = "[" + u2 + "]"), a2 || (e2.seen.indexOf(c2.value) < 0 ? (a2 = Ve(r2) ? _e(e2, c2.value, null) : _e(e2, c2.value, r2 - 1)).indexOf("\n") > -1 && (a2 = i2 ? a2.split("\n").map(function(e3) {
        return "  " + e3;
      }).join("\n").substr(2) : "\n" + a2.split("\n").map(function(e3) {
        return "   " + e3;
      }).join("\n")) : a2 = e2.stylize("[Circular]", "special")), Ze(o2)) {
        if (i2 && u2.match(/^\d+$/))
          return a2;
        (o2 = JSON.stringify("" + u2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.substr(1, o2.length - 2), o2 = e2.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = e2.stylize(o2, "string"));
      }
      return o2 + ": " + a2;
    }
    function ze(e2) {
      return Array.isArray(e2);
    }
    function Ge(e2) {
      return typeof e2 == "boolean";
    }
    function Ve(e2) {
      return e2 === null;
    }
    function Ye(e2) {
      return e2 == null;
    }
    function $e(e2) {
      return typeof e2 == "number";
    }
    function He(e2) {
      return typeof e2 == "string";
    }
    function Xe(e2) {
      return typeof e2 == "symbol";
    }
    function Ze(e2) {
      return e2 === void 0;
    }
    function We(e2) {
      return Je(e2) && nt(e2) === "[object RegExp]";
    }
    function Je(e2) {
      return typeof e2 == "object" && e2 !== null;
    }
    function Ke(e2) {
      return Je(e2) && nt(e2) === "[object Date]";
    }
    function Qe(e2) {
      return Je(e2) && (nt(e2) === "[object Error]" || e2 instanceof Error);
    }
    function et(e2) {
      return typeof e2 == "function";
    }
    function tt(e2) {
      return e2 === null || typeof e2 == "boolean" || typeof e2 == "number" || typeof e2 == "string" || typeof e2 == "symbol" || e2 === void 0;
    }
    function rt(e2) {
      return y.isBuffer(e2);
    }
    function nt(e2) {
      return Object.prototype.toString.call(e2);
    }
    function ut(e2) {
      return e2 < 10 ? "0" + e2.toString(10) : e2.toString(10);
    }
    Pe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, Pe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
    var it2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function ot() {
      var e2 = new Date(), t3 = [ut(e2.getHours()), ut(e2.getMinutes()), ut(e2.getSeconds())].join(":");
      return [e2.getDate(), it2[e2.getMonth()], t3].join(" ");
    }
    function at() {
      console.log("%s - %s", ot(), Re2.apply(null, arguments));
    }
    function ct(e2, t3) {
      if (!t3 || !Je(t3))
        return e2;
      for (var r2 = Object.keys(t3), n2 = r2.length; n2--; )
        e2[r2[n2]] = t3[r2[n2]];
      return e2;
    }
    function st(e2, t3) {
      return Object.prototype.hasOwnProperty.call(e2, t3);
    }
    var lt2 = { inherits: Te, _extend: ct, log: at, isBuffer: rt, isPrimitive: tt, isFunction: et, isError: Qe, isDate: Ke, isObject: Je, isRegExp: We, isUndefined: Ze, isSymbol: Xe, isString: He, isNumber: $e, isNullOrUndefined: Ye, isNull: Ve, isBoolean: Ge, isArray: ze, inspect: Pe, deprecate: Ie, format: Re2, debuglog: Le }, ft = t2(Object.freeze({ __proto__: null, format: Re2, deprecate: Ie, debuglog: Le, inspect: Pe, isArray: ze, isBoolean: Ge, isNull: Ve, isNullOrUndefined: Ye, isNumber: $e, isString: He, isSymbol: Xe, isUndefined: Ze, isRegExp: We, isObject: Je, isDate: Ke, isError: Qe, isFunction: et, isPrimitive: tt, isBuffer: rt, log: at, inherits: Te, _extend: ct, default: lt2 })), Dt = { exports: {} };
    typeof Object.create == "function" ? Dt.exports = function(e2, t3) {
      t3 && (e2.super_ = t3, e2.prototype = Object.create(t3.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
    } : Dt.exports = function(e2, t3) {
      if (t3) {
        e2.super_ = t3;
        var r2 = function() {
        };
        r2.prototype = t3.prototype, e2.prototype = new r2(), e2.prototype.constructor = e2;
      }
    };
    try {
      var pt = ft;
      if (typeof pt.inherits != "function")
        throw "";
      u.exports = pt.inherits;
    } catch (e2) {
      u.exports = Dt.exports;
    }
    var ht = r, dt = u.exports, gt2 = function(e2) {
      var t3, r2, n2;
      for (r2 in dt(i2, e2), dt(u2, i2), t3 = i2.prototype)
        (n2 = t3[r2]) && typeof n2 == "object" && (t3[r2] = "concat" in n2 ? n2.concat() : ht(n2));
      return i2;
      function u2(t4) {
        return e2.apply(this, t4);
      }
      function i2() {
        return this instanceof i2 ? e2.apply(this, arguments) : new u2(arguments);
      }
    };
    var mt = function(e2, t3, r2) {
      return function() {
        var n2 = r2 || this, u2 = n2[e2];
        return n2[e2] = !t3, i2;
        function i2() {
          n2[e2] = u2;
        }
      };
    };
    var Et = function(e2) {
      var t3 = String(e2), r2 = [], n2 = /\r?\n|\r/g;
      for (; n2.exec(t3); )
        r2.push(n2.lastIndex);
      return r2.push(t3.length + 1), { toPoint: u2, toPosition: u2, toOffset: function(e3) {
        var t4, n3 = e3 && e3.line, u3 = e3 && e3.column;
        isNaN(n3) || isNaN(u3) || !(n3 - 1 in r2) || (t4 = (r2[n3 - 2] || 0) + u3 - 1 || 0);
        return t4 > -1 && t4 < r2[r2.length - 1] ? t4 : -1;
      } };
      function u2(e3) {
        var t4 = -1;
        if (e3 > -1 && e3 < r2[r2.length - 1]) {
          for (; ++t4 < r2.length; )
            if (r2[t4] > e3)
              return { line: t4 + 1, column: e3 - (r2[t4 - 1] || 0) + 1, offset: e3 };
        }
        return {};
      }
    };
    var vt = function(e2, t3) {
      return function(r2) {
        var n2, u2 = 0, i2 = r2.indexOf(yt), o2 = e2[t3], a2 = [];
        for (; i2 !== -1; )
          a2.push(r2.slice(u2, i2)), u2 = i2 + 1, (n2 = r2.charAt(u2)) && o2.indexOf(n2) !== -1 || a2.push(yt), i2 = r2.indexOf(yt, u2 + 1);
        return a2.push(r2.slice(u2)), a2.join("");
      };
    }, yt = "\\";
    var bt = function(e2) {
      var t3 = typeof e2 == "string" ? e2.charCodeAt(0) : e2;
      return t3 >= 48 && t3 <= 57;
    };
    var Ct = function(e2) {
      var t3 = typeof e2 == "string" ? e2.charCodeAt(0) : e2;
      return t3 >= 97 && t3 <= 122 || t3 >= 65 && t3 <= 90;
    };
    var At = Ct, wt = bt;
    var Ft = { AEli: "\xC6", AElig: "\xC6", AM: "&", AMP: "&", Aacut: "\xC1", Aacute: "\xC1", Abreve: "\u0102", Acir: "\xC2", Acirc: "\xC2", Acy: "\u0410", Afr: "\u{1D504}", Agrav: "\xC0", Agrave: "\xC0", Alpha: "\u0391", Amacr: "\u0100", And: "\u2A53", Aogon: "\u0104", Aopf: "\u{1D538}", ApplyFunction: "\u2061", Arin: "\xC5", Aring: "\xC5", Ascr: "\u{1D49C}", Assign: "\u2254", Atild: "\xC3", Atilde: "\xC3", Aum: "\xC4", Auml: "\xC4", Backslash: "\u2216", Barv: "\u2AE7", Barwed: "\u2306", Bcy: "\u0411", Because: "\u2235", Bernoullis: "\u212C", Beta: "\u0392", Bfr: "\u{1D505}", Bopf: "\u{1D539}", Breve: "\u02D8", Bscr: "\u212C", Bumpeq: "\u224E", CHcy: "\u0427", COP: "\xA9", COPY: "\xA9", Cacute: "\u0106", Cap: "\u22D2", CapitalDifferentialD: "\u2145", Cayleys: "\u212D", Ccaron: "\u010C", Ccedi: "\xC7", Ccedil: "\xC7", Ccirc: "\u0108", Cconint: "\u2230", Cdot: "\u010A", Cedilla: "\xB8", CenterDot: "\xB7", Cfr: "\u212D", Chi: "\u03A7", CircleDot: "\u2299", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", Colon: "\u2237", Colone: "\u2A74", Congruent: "\u2261", Conint: "\u222F", ContourIntegral: "\u222E", Copf: "\u2102", Coproduct: "\u2210", CounterClockwiseContourIntegral: "\u2233", Cross: "\u2A2F", Cscr: "\u{1D49E}", Cup: "\u22D3", CupCap: "\u224D", DD: "\u2145", DDotrahd: "\u2911", DJcy: "\u0402", DScy: "\u0405", DZcy: "\u040F", Dagger: "\u2021", Darr: "\u21A1", Dashv: "\u2AE4", Dcaron: "\u010E", Dcy: "\u0414", Del: "\u2207", Delta: "\u0394", Dfr: "\u{1D507}", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", Diamond: "\u22C4", DifferentialD: "\u2146", Dopf: "\u{1D53B}", Dot: "\xA8", DotDot: "\u20DC", DotEqual: "\u2250", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", Downarrow: "\u21D3", Dscr: "\u{1D49F}", Dstrok: "\u0110", ENG: "\u014A", ET: "\xD0", ETH: "\xD0", Eacut: "\xC9", Eacute: "\xC9", Ecaron: "\u011A", Ecir: "\xCA", Ecirc: "\xCA", Ecy: "\u042D", Edot: "\u0116", Efr: "\u{1D508}", Egrav: "\xC8", Egrave: "\xC8", Element: "\u2208", Emacr: "\u0112", EmptySmallSquare: "\u25FB", EmptyVerySmallSquare: "\u25AB", Eogon: "\u0118", Eopf: "\u{1D53C}", Epsilon: "\u0395", Equal: "\u2A75", EqualTilde: "\u2242", Equilibrium: "\u21CC", Escr: "\u2130", Esim: "\u2A73", Eta: "\u0397", Eum: "\xCB", Euml: "\xCB", Exists: "\u2203", ExponentialE: "\u2147", Fcy: "\u0424", Ffr: "\u{1D509}", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", Fopf: "\u{1D53D}", ForAll: "\u2200", Fouriertrf: "\u2131", Fscr: "\u2131", GJcy: "\u0403", G: ">", GT: ">", Gamma: "\u0393", Gammad: "\u03DC", Gbreve: "\u011E", Gcedil: "\u0122", Gcirc: "\u011C", Gcy: "\u0413", Gdot: "\u0120", Gfr: "\u{1D50A}", Gg: "\u22D9", Gopf: "\u{1D53E}", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", Gt: "\u226B", HARDcy: "\u042A", Hacek: "\u02C7", Hat: "^", Hcirc: "\u0124", Hfr: "\u210C", HilbertSpace: "\u210B", Hopf: "\u210D", HorizontalLine: "\u2500", Hscr: "\u210B", Hstrok: "\u0126", HumpDownHump: "\u224E", HumpEqual: "\u224F", IEcy: "\u0415", IJlig: "\u0132", IOcy: "\u0401", Iacut: "\xCD", Iacute: "\xCD", Icir: "\xCE", Icirc: "\xCE", Icy: "\u0418", Idot: "\u0130", Ifr: "\u2111", Igrav: "\xCC", Igrave: "\xCC", Im: "\u2111", Imacr: "\u012A", ImaginaryI: "\u2148", Implies: "\u21D2", Int: "\u222C", Integral: "\u222B", Intersection: "\u22C2", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", Iogon: "\u012E", Iopf: "\u{1D540}", Iota: "\u0399", Iscr: "\u2110", Itilde: "\u0128", Iukcy: "\u0406", Ium: "\xCF", Iuml: "\xCF", Jcirc: "\u0134", Jcy: "\u0419", Jfr: "\u{1D50D}", Jopf: "\u{1D541}", Jscr: "\u{1D4A5}", Jsercy: "\u0408", Jukcy: "\u0404", KHcy: "\u0425", KJcy: "\u040C", Kappa: "\u039A", Kcedil: "\u0136", Kcy: "\u041A", Kfr: "\u{1D50E}", Kopf: "\u{1D542}", Kscr: "\u{1D4A6}", LJcy: "\u0409", L: "<", LT: "<", Lacute: "\u0139", Lambda: "\u039B", Lang: "\u27EA", Laplacetrf: "\u2112", Larr: "\u219E", Lcaron: "\u013D", Lcedil: "\u013B", Lcy: "\u041B", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", LeftRightArrow: "\u2194", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", Leftarrow: "\u21D0", Leftrightarrow: "\u21D4", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", LessLess: "\u2AA1", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", Lfr: "\u{1D50F}", Ll: "\u22D8", Lleftarrow: "\u21DA", Lmidot: "\u013F", LongLeftArrow: "\u27F5", LongLeftRightArrow: "\u27F7", LongRightArrow: "\u27F6", Longleftarrow: "\u27F8", Longleftrightarrow: "\u27FA", Longrightarrow: "\u27F9", Lopf: "\u{1D543}", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", Lscr: "\u2112", Lsh: "\u21B0", Lstrok: "\u0141", Lt: "\u226A", Map: "\u2905", Mcy: "\u041C", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", MinusPlus: "\u2213", Mopf: "\u{1D544}", Mscr: "\u2133", Mu: "\u039C", NJcy: "\u040A", Nacute: "\u0143", Ncaron: "\u0147", Ncedil: "\u0145", Ncy: "\u041D", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", Nfr: "\u{1D511}", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", Not: "\u2AEC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", Nscr: "\u{1D4A9}", Ntild: "\xD1", Ntilde: "\xD1", Nu: "\u039D", OElig: "\u0152", Oacut: "\xD3", Oacute: "\xD3", Ocir: "\xD4", Ocirc: "\xD4", Ocy: "\u041E", Odblac: "\u0150", Ofr: "\u{1D512}", Ograv: "\xD2", Ograve: "\xD2", Omacr: "\u014C", Omega: "\u03A9", Omicron: "\u039F", Oopf: "\u{1D546}", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", Or: "\u2A54", Oscr: "\u{1D4AA}", Oslas: "\xD8", Oslash: "\xD8", Otild: "\xD5", Otilde: "\xD5", Otimes: "\u2A37", Oum: "\xD6", Ouml: "\xD6", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", PartialD: "\u2202", Pcy: "\u041F", Pfr: "\u{1D513}", Phi: "\u03A6", Pi: "\u03A0", PlusMinus: "\xB1", Poincareplane: "\u210C", Popf: "\u2119", Pr: "\u2ABB", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", Prime: "\u2033", Product: "\u220F", Proportion: "\u2237", Proportional: "\u221D", Pscr: "\u{1D4AB}", Psi: "\u03A8", QUO: '"', QUOT: '"', Qfr: "\u{1D514}", Qopf: "\u211A", Qscr: "\u{1D4AC}", RBarr: "\u2910", RE: "\xAE", REG: "\xAE", Racute: "\u0154", Rang: "\u27EB", Rarr: "\u21A0", Rarrtl: "\u2916", Rcaron: "\u0158", Rcedil: "\u0156", Rcy: "\u0420", Re: "\u211C", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", Rfr: "\u211C", Rho: "\u03A1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", Rightarrow: "\u21D2", Ropf: "\u211D", RoundImplies: "\u2970", Rrightarrow: "\u21DB", Rscr: "\u211B", Rsh: "\u21B1", RuleDelayed: "\u29F4", SHCHcy: "\u0429", SHcy: "\u0428", SOFTcy: "\u042C", Sacute: "\u015A", Sc: "\u2ABC", Scaron: "\u0160", Scedil: "\u015E", Scirc: "\u015C", Scy: "\u0421", Sfr: "\u{1D516}", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", Sigma: "\u03A3", SmallCircle: "\u2218", Sopf: "\u{1D54A}", Sqrt: "\u221A", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", Sscr: "\u{1D4AE}", Star: "\u22C6", Sub: "\u22D0", Subset: "\u22D0", SubsetEqual: "\u2286", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", SuchThat: "\u220B", Sum: "\u2211", Sup: "\u22D1", Superset: "\u2283", SupersetEqual: "\u2287", Supset: "\u22D1", THOR: "\xDE", THORN: "\xDE", TRADE: "\u2122", TSHcy: "\u040B", TScy: "\u0426", Tab: "	", Tau: "\u03A4", Tcaron: "\u0164", Tcedil: "\u0162", Tcy: "\u0422", Tfr: "\u{1D517}", Therefore: "\u2234", Theta: "\u0398", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", Topf: "\u{1D54B}", TripleDot: "\u20DB", Tscr: "\u{1D4AF}", Tstrok: "\u0166", Uacut: "\xDA", Uacute: "\xDA", Uarr: "\u219F", Uarrocir: "\u2949", Ubrcy: "\u040E", Ubreve: "\u016C", Ucir: "\xDB", Ucirc: "\xDB", Ucy: "\u0423", Udblac: "\u0170", Ufr: "\u{1D518}", Ugrav: "\xD9", Ugrave: "\xD9", Umacr: "\u016A", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", Uopf: "\u{1D54C}", UpArrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", UpEquilibrium: "\u296E", UpTee: "\u22A5", UpTeeArrow: "\u21A5", Uparrow: "\u21D1", Updownarrow: "\u21D5", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", Upsilon: "\u03A5", Uring: "\u016E", Uscr: "\u{1D4B0}", Utilde: "\u0168", Uum: "\xDC", Uuml: "\xDC", VDash: "\u22AB", Vbar: "\u2AEB", Vcy: "\u0412", Vdash: "\u22A9", Vdashl: "\u2AE6", Vee: "\u22C1", Verbar: "\u2016", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", Vopf: "\u{1D54D}", Vscr: "\u{1D4B1}", Vvdash: "\u22AA", Wcirc: "\u0174", Wedge: "\u22C0", Wfr: "\u{1D51A}", Wopf: "\u{1D54E}", Wscr: "\u{1D4B2}", Xfr: "\u{1D51B}", Xi: "\u039E", Xopf: "\u{1D54F}", Xscr: "\u{1D4B3}", YAcy: "\u042F", YIcy: "\u0407", YUcy: "\u042E", Yacut: "\xDD", Yacute: "\xDD", Ycirc: "\u0176", Ycy: "\u042B", Yfr: "\u{1D51C}", Yopf: "\u{1D550}", Yscr: "\u{1D4B4}", Yuml: "\u0178", ZHcy: "\u0416", Zacute: "\u0179", Zcaron: "\u017D", Zcy: "\u0417", Zdot: "\u017B", ZeroWidthSpace: "\u200B", Zeta: "\u0396", Zfr: "\u2128", Zopf: "\u2124", Zscr: "\u{1D4B5}", aacut: "\xE1", aacute: "\xE1", abreve: "\u0103", ac: "\u223E", acE: "\u223E\u0333", acd: "\u223F", acir: "\xE2", acirc: "\xE2", acut: "\xB4", acute: "\xB4", acy: "\u0430", aeli: "\xE6", aelig: "\xE6", af: "\u2061", afr: "\u{1D51E}", agrav: "\xE0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", amacr: "\u0101", amalg: "\u2A3F", am: "&", amp: "&", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", aogon: "\u0105", aopf: "\u{1D552}", ap: "\u2248", apE: "\u2A70", apacir: "\u2A6F", ape: "\u224A", apid: "\u224B", apos: "'", approx: "\u2248", approxeq: "\u224A", arin: "\xE5", aring: "\xE5", ascr: "\u{1D4B6}", ast: "*", asymp: "\u2248", asympeq: "\u224D", atild: "\xE3", atilde: "\xE3", aum: "\xE4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", bNot: "\u2AED", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", barvee: "\u22BD", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", beta: "\u03B2", beth: "\u2136", between: "\u226C", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxDL: "\u2557", boxDR: "\u2554", boxDl: "\u2556", boxDr: "\u2553", boxH: "\u2550", boxHD: "\u2566", boxHU: "\u2569", boxHd: "\u2564", boxHu: "\u2567", boxUL: "\u255D", boxUR: "\u255A", boxUl: "\u255C", boxUr: "\u2559", boxV: "\u2551", boxVH: "\u256C", boxVL: "\u2563", boxVR: "\u2560", boxVh: "\u256B", boxVl: "\u2562", boxVr: "\u255F", boxbox: "\u29C9", boxdL: "\u2555", boxdR: "\u2552", boxdl: "\u2510", boxdr: "\u250C", boxh: "\u2500", boxhD: "\u2565", boxhU: "\u2568", boxhd: "\u252C", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxuL: "\u255B", boxuR: "\u2558", boxul: "\u2518", boxur: "\u2514", boxv: "\u2502", boxvH: "\u256A", boxvL: "\u2561", boxvR: "\u255E", boxvh: "\u253C", boxvl: "\u2524", boxvr: "\u251C", bprime: "\u2035", breve: "\u02D8", brvba: "\xA6", brvbar: "\xA6", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", bumpeq: "\u224F", cacute: "\u0107", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", ccaps: "\u2A4D", ccaron: "\u010D", ccedi: "\xE7", ccedil: "\xE7", ccirc: "\u0109", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", cedi: "\xB8", cedil: "\xB8", cemptyv: "\u29B2", cen: "\xA2", cent: "\xA2", centerdot: "\xB7", cfr: "\u{1D520}", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", cir: "\u25CB", cirE: "\u29C3", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledR: "\xAE", circledS: "\u24C8", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", clubs: "\u2663", clubsuit: "\u2663", colon: ":", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", conint: "\u222E", copf: "\u{1D554}", coprod: "\u2210", cop: "\xA9", copy: "\xA9", copysr: "\u2117", crarr: "\u21B5", cross: "\u2717", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cup: "\u222A", cupbrcap: "\u2A48", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curre: "\xA4", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dArr: "\u21D3", dHar: "\u2965", dagger: "\u2020", daleth: "\u2138", darr: "\u2193", dash: "\u2010", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", dcaron: "\u010F", dcy: "\u0434", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", ddotseq: "\u2A77", de: "\xB0", deg: "\xB0", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\u{1D521}", dharl: "\u21C3", dharr: "\u21C2", diam: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divid: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\u{1D555}", dot: "\u02D9", doteq: "\u2250", doteqdot: "\u2251", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", downarrow: "\u2193", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", dscr: "\u{1D4B9}", dscy: "\u0455", dsol: "\u29F6", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", dzcy: "\u045F", dzigrarr: "\u27FF", eDDot: "\u2A77", eDot: "\u2251", eacut: "\xE9", eacute: "\xE9", easter: "\u2A6E", ecaron: "\u011B", ecir: "\xEA", ecirc: "\xEA", ecolon: "\u2255", ecy: "\u044D", edot: "\u0117", ee: "\u2147", efDot: "\u2252", efr: "\u{1D522}", eg: "\u2A9A", egrav: "\xE8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", emptyv: "\u2205", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", eng: "\u014B", ensp: "\u2002", eogon: "\u0119", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", equals: "=", equest: "\u225F", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erDot: "\u2253", erarr: "\u2971", escr: "\u212F", esdot: "\u2250", esim: "\u2242", eta: "\u03B7", et: "\xF0", eth: "\xF0", eum: "\xEB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", expectation: "\u2130", exponentiale: "\u2147", fallingdotseq: "\u2252", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\u{1D523}", filig: "\uFB01", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\u{1D557}", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", fpartint: "\u2A0D", frac1: "\xBC", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac3: "\xBE", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", gE: "\u2267", gEl: "\u2A8C", gacute: "\u01F5", gamma: "\u03B3", gammad: "\u03DD", gap: "\u2A86", gbreve: "\u011F", gcirc: "\u011D", gcy: "\u0433", gdot: "\u0121", ge: "\u2265", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\u{1D524}", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", gjcy: "\u0453", gl: "\u2277", glE: "\u2A92", gla: "\u2AA5", glj: "\u2AA4", gnE: "\u2269", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", gopf: "\u{1D558}", grave: "`", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", g: ">", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", hArr: "\u21D4", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", hardcy: "\u044A", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", hbar: "\u210F", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", horbar: "\u2015", hscr: "\u{1D4BD}", hslash: "\u210F", hstrok: "\u0127", hybull: "\u2043", hyphen: "\u2010", iacut: "\xED", iacute: "\xED", ic: "\u2063", icir: "\xEE", icirc: "\xEE", icy: "\u0438", iecy: "\u0435", iexc: "\xA1", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", igrav: "\xEC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", imacr: "\u012B", image: "\u2111", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", int: "\u222B", intcal: "\u22BA", integers: "\u2124", intercal: "\u22BA", intlarhk: "\u2A17", intprod: "\u2A3C", iocy: "\u0451", iogon: "\u012F", iopf: "\u{1D55A}", iota: "\u03B9", iprod: "\u2A3C", iques: "\xBF", iquest: "\xBF", iscr: "\u{1D4BE}", isin: "\u2208", isinE: "\u22F9", isindot: "\u22F5", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", itilde: "\u0129", iukcy: "\u0456", ium: "\xEF", iuml: "\xEF", jcirc: "\u0135", jcy: "\u0439", jfr: "\u{1D527}", jmath: "\u0237", jopf: "\u{1D55B}", jscr: "\u{1D4BF}", jsercy: "\u0458", jukcy: "\u0454", kappa: "\u03BA", kappav: "\u03F0", kcedil: "\u0137", kcy: "\u043A", kfr: "\u{1D528}", kgreen: "\u0138", khcy: "\u0445", kjcy: "\u045C", kopf: "\u{1D55C}", kscr: "\u{1D4C0}", lAarr: "\u21DA", lArr: "\u21D0", lAtail: "\u291B", lBarr: "\u290E", lE: "\u2266", lEg: "\u2A8B", lHar: "\u2962", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", lambda: "\u03BB", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", laqu: "\xAB", laquo: "\xAB", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", lcedil: "\u013C", lceil: "\u2308", lcub: "{", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", leftarrow: "\u2190", leftarrowtail: "\u21A2", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", leftthreetimes: "\u22CB", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", lessgtr: "\u2276", lesssim: "\u2272", lfisht: "\u297C", lfloor: "\u230A", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnE: "\u2268", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", lstrok: "\u0142", l: "<", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltrPar: "\u2996", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", mDDot: "\u223A", mac: "\xAF", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", mdash: "\u2014", measuredangle: "\u2221", mfr: "\u{1D52A}", mho: "\u2127", micr: "\xB5", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middo: "\xB7", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", mstpos: "\u223E", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nGg: "\u22D9\u0338", nGt: "\u226B\u20D2", nGtv: "\u226B\u0338", nLeftarrow: "\u21CD", nLeftrightarrow: "\u21CE", nLl: "\u22D8\u0338", nLt: "\u226A\u20D2", nLtv: "\u226A\u0338", nRightarrow: "\u21CF", nVDash: "\u22AF", nVdash: "\u22AE", nabla: "\u2207", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbs: "\xA0", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", ncaron: "\u0148", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", neArr: "\u21D7", nearhk: "\u2924", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", nexist: "\u2204", nexists: "\u2204", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", ngsim: "\u2275", ngt: "\u226F", ngtr: "\u226F", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", njcy: "\u045A", nlArr: "\u21CD", nlE: "\u2266\u0338", nlarr: "\u219A", nldr: "\u2025", nle: "\u2270", nleftarrow: "\u219A", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nlsim: "\u2274", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nmid: "\u2224", nopf: "\u{1D55F}", no: "\xAC", not: "\xAC", notin: "\u2209", notinE: "\u22F9\u0338", notindot: "\u22F5\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", ntild: "\xF1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvDash: "\u22AD", nvHarr: "\u2904", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwArr: "\u21D6", nwarhk: "\u2923", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", oS: "\u24C8", oacut: "\xF3", oacute: "\xF3", oast: "\u229B", ocir: "\xF4", ocirc: "\xF4", ocy: "\u043E", odash: "\u229D", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", oelig: "\u0153", ofcir: "\u29BF", ofr: "\u{1D52C}", ogon: "\u02DB", ograv: "\xF2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", omacr: "\u014D", omega: "\u03C9", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", oopf: "\u{1D560}", opar: "\u29B7", operp: "\u29B9", oplus: "\u2295", or: "\u2228", orarr: "\u21BB", ord: "\xBA", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oscr: "\u2134", oslas: "\xF8", oslash: "\xF8", osol: "\u2298", otild: "\xF5", otilde: "\xF5", otimes: "\u2297", otimesas: "\u2A36", oum: "\xF6", ouml: "\xF6", ovbar: "\u233D", par: "\xB6", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", pfr: "\u{1D52D}", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", plusm: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", pointint: "\u2A15", popf: "\u{1D561}", poun: "\xA3", pound: "\xA3", pr: "\u227A", prE: "\u2AB3", prap: "\u2AB7", prcue: "\u227C", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", prime: "\u2032", primes: "\u2119", prnE: "\u2AB5", prnap: "\u2AB9", prnsim: "\u22E8", prod: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", pscr: "\u{1D4C5}", psi: "\u03C8", puncsp: "\u2008", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", qprime: "\u2057", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quo: '"', quot: '"', rAarr: "\u21DB", rArr: "\u21D2", rAtail: "\u291C", rBarr: "\u290F", rHar: "\u2964", race: "\u223D\u0331", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raqu: "\xBB", raquo: "\xBB", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", rcedil: "\u0157", rceil: "\u2309", rcub: "}", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", re: "\xAE", reg: "\xAE", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", rho: "\u03C1", rhov: "\u03F1", rightarrow: "\u2192", rightarrowtail: "\u21A3", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", rightthreetimes: "\u22CC", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", rsaquo: "\u203A", rscr: "\u{1D4C7}", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", sbquo: "\u201A", sc: "\u227B", scE: "\u2AB4", scap: "\u2AB8", scaron: "\u0161", sccue: "\u227D", sce: "\u2AB0", scedil: "\u015F", scirc: "\u015D", scnE: "\u2AB6", scnap: "\u2ABA", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", seArr: "\u21D8", searhk: "\u2925", searr: "\u2198", searrow: "\u2198", sec: "\xA7", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", shchcy: "\u0449", shcy: "\u0448", shortmid: "\u2223", shortparallel: "\u2225", sh: "\xAD", shy: "\xAD", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", square: "\u25A1", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", subE: "\u2AC5", subdot: "\u2ABD", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", sum: "\u2211", sung: "\u266A", sup: "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supE: "\u2AC6", supdot: "\u2ABE", supdsub: "\u2AD8", supe: "\u2287", supedot: "\u2AC4", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swArr: "\u21D9", swarhk: "\u2926", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szli: "\xDF", szlig: "\xDF", target: "\u2316", tau: "\u03C4", tbrk: "\u23B4", tcaron: "\u0165", tcedil: "\u0163", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", thor: "\xFE", thorn: "\xFE", tilde: "\u02DC", time: "\xD7", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\u{1D4C9}", tscy: "\u0446", tshcy: "\u045B", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", uArr: "\u21D1", uHar: "\u2963", uacut: "\xFA", uacute: "\xFA", uarr: "\u2191", ubrcy: "\u045E", ubreve: "\u016D", ucir: "\xFB", ucirc: "\xFB", ucy: "\u0443", udarr: "\u21C5", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", ufr: "\u{1D532}", ugrav: "\xF9", ugrave: "\xF9", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", um: "\xA8", uml: "\xA8", uogon: "\u0173", uopf: "\u{1D566}", uparrow: "\u2191", updownarrow: "\u2195", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", upsi: "\u03C5", upsih: "\u03D2", upsilon: "\u03C5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", urtri: "\u25F9", uscr: "\u{1D4CA}", utdot: "\u22F0", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", uum: "\xFC", uuml: "\xFC", uwangle: "\u29A7", vArr: "\u21D5", vBar: "\u2AE8", vBarv: "\u2AE9", vDash: "\u22A8", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vcy: "\u0432", vdash: "\u22A2", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", vert: "|", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", vzigzag: "\u299A", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", wfr: "\u{1D534}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", yacut: "\xFD", yacute: "\xFD", yacy: "\u044F", ycirc: "\u0177", ycy: "\u044B", ye: "\xA5", yen: "\xA5", yfr: "\u{1D536}", yicy: "\u0457", yopf: "\u{1D56A}", yscr: "\u{1D4CE}", yucy: "\u044E", yum: "\xFF", yuml: "\xFF", zacute: "\u017A", zcaron: "\u017E", zcy: "\u0437", zdot: "\u017C", zeetrf: "\u2128", zeta: "\u03B6", zfr: "\u{1D537}", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" }, kt = function(e2) {
      return !!Ot.call(Ft, e2) && Ft[e2];
    }, Ot = {}.hasOwnProperty;
    var xt = { AElig: "\xC6", AMP: "&", Aacute: "\xC1", Acirc: "\xC2", Agrave: "\xC0", Aring: "\xC5", Atilde: "\xC3", Auml: "\xC4", COPY: "\xA9", Ccedil: "\xC7", ETH: "\xD0", Eacute: "\xC9", Ecirc: "\xCA", Egrave: "\xC8", Euml: "\xCB", GT: ">", Iacute: "\xCD", Icirc: "\xCE", Igrave: "\xCC", Iuml: "\xCF", LT: "<", Ntilde: "\xD1", Oacute: "\xD3", Ocirc: "\xD4", Ograve: "\xD2", Oslash: "\xD8", Otilde: "\xD5", Ouml: "\xD6", QUOT: '"', REG: "\xAE", THORN: "\xDE", Uacute: "\xDA", Ucirc: "\xDB", Ugrave: "\xD9", Uuml: "\xDC", Yacute: "\xDD", aacute: "\xE1", acirc: "\xE2", acute: "\xB4", aelig: "\xE6", agrave: "\xE0", amp: "&", aring: "\xE5", atilde: "\xE3", auml: "\xE4", brvbar: "\xA6", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", eacute: "\xE9", ecirc: "\xEA", egrave: "\xE8", eth: "\xF0", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", iacute: "\xED", icirc: "\xEE", iexcl: "\xA1", igrave: "\xEC", iquest: "\xBF", iuml: "\xEF", laquo: "\xAB", lt: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", ntilde: "\xF1", oacute: "\xF3", ocirc: "\xF4", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", oslash: "\xF8", otilde: "\xF5", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', raquo: "\xBB", reg: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", thorn: "\xFE", times: "\xD7", uacute: "\xFA", ucirc: "\xFB", ugrave: "\xF9", uml: "\xA8", uuml: "\xFC", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" }, Tt = { 0: "\uFFFD", 128: "\u20AC", 130: "\u201A", 131: "\u0192", 132: "\u201E", 133: "\u2026", 134: "\u2020", 135: "\u2021", 136: "\u02C6", 137: "\u2030", 138: "\u0160", 139: "\u2039", 140: "\u0152", 142: "\u017D", 145: "\u2018", 146: "\u2019", 147: "\u201C", 148: "\u201D", 149: "\u2022", 150: "\u2013", 151: "\u2014", 152: "\u02DC", 153: "\u2122", 154: "\u0161", 155: "\u203A", 156: "\u0153", 158: "\u017E", 159: "\u0178" }, St = bt, Rt = function(e2) {
      var t3 = typeof e2 == "string" ? e2.charCodeAt(0) : e2;
      return t3 >= 97 && t3 <= 102 || t3 >= 65 && t3 <= 70 || t3 >= 48 && t3 <= 57;
    }, It = function(e2) {
      return At(e2) || wt(e2);
    }, Bt = kt, Nt = function(e2, t3) {
      var r2, n2, u2 = {};
      t3 || (t3 = {});
      for (n2 in jt)
        r2 = t3[n2], u2[n2] = r2 == null ? jt[n2] : r2;
      (u2.position.indent || u2.position.start) && (u2.indent = u2.position.indent || [], u2.position = u2.position.start);
      return function(e3, t4) {
        var r3, n3, u3, i2, o2, a2, c2, s2, l2, f2, D2, p2, h2, d2, g2, m2, E2, v2, y2, b2 = t4.additional, C3 = t4.nonTerminated, A2 = t4.text, w2 = t4.reference, F2 = t4.warning, k2 = t4.textContext, O2 = t4.referenceContext, x2 = t4.warningContext, T2 = t4.position, S3 = t4.indent || [], R2 = e3.length, I2 = 0, B2 = -1, N2 = T2.column || 1, L2 = T2.line || 1, P2 = "", q2 = [];
        typeof b2 == "string" && (b2 = b2.charCodeAt(0));
        m2 = j2(), s2 = F2 ? _2 : qt, I2--, R2++;
        for (; ++I2 < R2; )
          if (o2 === 10 && (N2 = S3[B2] || 1), (o2 = e3.charCodeAt(I2)) === 38) {
            if ((c2 = e3.charCodeAt(I2 + 1)) === 9 || c2 === 10 || c2 === 12 || c2 === 32 || c2 === 38 || c2 === 60 || c2 != c2 || b2 && c2 === b2) {
              P2 += Pt(o2), N2++;
              continue;
            }
            for (p2 = h2 = I2 + 1, y2 = h2, c2 === 35 ? (y2 = ++p2, (c2 = e3.charCodeAt(y2)) === 88 || c2 === 120 ? (d2 = Ut, y2 = ++p2) : d2 = Mt) : d2 = _t, r3 = "", D2 = "", i2 = "", g2 = Gt2[d2], y2--; ++y2 < R2 && g2(c2 = e3.charCodeAt(y2)); )
              i2 += Pt(c2), d2 === _t && Lt2.call(xt, i2) && (r3 = i2, D2 = xt[i2]);
            (u3 = e3.charCodeAt(y2) === 59) && (y2++, (n3 = d2 === _t && Bt(i2)) && (r3 = i2, D2 = n3)), v2 = 1 + y2 - h2, (u3 || C3) && (i2 ? d2 === _t ? (u3 && !D2 ? s2(5, 1) : (r3 !== i2 && (v2 = 1 + (y2 = p2 + r3.length) - p2, u3 = false), u3 || (l2 = r3 ? 1 : 3, t4.attribute ? (c2 = e3.charCodeAt(y2)) === 61 ? (s2(l2, v2), D2 = null) : It(c2) ? D2 = null : s2(l2, v2) : s2(l2, v2))), a2 = D2) : (u3 || s2(2, v2), Yt(a2 = parseInt(i2, zt[d2])) ? (s2(7, v2), a2 = Pt(65533)) : a2 in Tt ? (s2(6, v2), a2 = Tt[a2]) : (f2 = "", $t(a2) && s2(6, v2), a2 > 65535 && (f2 += Pt((a2 -= 65536) >>> 10 | 55296), a2 = 56320 | 1023 & a2), a2 = f2 + Pt(a2))) : d2 !== _t && s2(4, v2)), a2 ? (U2(), m2 = j2(), I2 = y2 - 1, N2 += y2 - h2 + 1, q2.push(a2), (E2 = j2()).offset++, w2 && w2.call(O2, a2, { start: m2, end: E2 }, e3.slice(h2 - 1, y2)), m2 = E2) : (i2 = e3.slice(h2 - 1, y2), P2 += i2, N2 += i2.length, I2 = y2 - 1);
          } else
            o2 === 10 && (L2++, B2++, N2 = 0), o2 == o2 ? (P2 += Pt(o2), N2++) : U2();
        return q2.join("");
        function j2() {
          return { line: L2, column: N2, offset: I2 + (T2.offset || 0) };
        }
        function _2(e4, t5) {
          var r4 = j2();
          r4.column += t5, r4.offset += t5, F2.call(x2, Vt[e4], r4, e4);
        }
        function U2() {
          P2 && (q2.push(P2), A2 && A2.call(k2, P2, { start: m2, end: j2() }), P2 = "");
        }
      }(e2, u2);
    }, Lt2 = {}.hasOwnProperty, Pt = String.fromCharCode, qt = Function.prototype, jt = { warning: null, reference: null, text: null, warningContext: null, referenceContext: null, textContext: null, position: {}, additional: null, attribute: false, nonTerminated: true }, _t = "named", Ut = "hexadecimal", Mt = "decimal", zt = { hexadecimal: 16, decimal: 10 }, Gt2 = {};
    Gt2.named = It, Gt2[Mt] = St, Gt2[Ut] = Rt;
    var Vt = {};
    function Yt(e2) {
      return e2 >= 55296 && e2 <= 57343 || e2 > 1114111;
    }
    function $t(e2) {
      return e2 >= 1 && e2 <= 8 || e2 === 11 || e2 >= 13 && e2 <= 31 || e2 >= 127 && e2 <= 159 || e2 >= 64976 && e2 <= 65007 || (65535 & e2) == 65535 || (65535 & e2) == 65534;
    }
    Vt[1] = "Named character references must be terminated by a semicolon", Vt[2] = "Numeric character references must be terminated by a semicolon", Vt[3] = "Named character references cannot be empty", Vt[4] = "Numeric character references cannot be empty", Vt[5] = "Named character references must be known", Vt[6] = "Numeric character references cannot be disallowed", Vt[7] = "Numeric character references cannot be outside the permissible Unicode range";
    var Ht = r, Xt = Nt, Zt = function(e2) {
      return r2.raw = n2, r2;
      function t3(t4) {
        for (var r3 = e2.offset, n3 = t4.line, u3 = []; ++n3 && n3 in r3; )
          u3.push((r3[n3] || 0) + 1);
        return { start: t4, indent: u3 };
      }
      function r2(r3, n3, i2) {
        Xt(r3, { position: t3(n3), warning: u2, text: i2, reference: i2, textContext: e2, referenceContext: e2 });
      }
      function n2(e3, r3, n3) {
        return Xt(e3, Ht(n3, { position: t3(r3), warning: u2 }));
      }
      function u2(t4, r3, n3) {
        n3 !== 3 && e2.file.message(t4, r3);
      }
    };
    var Wt = function(e2) {
      return function(t3, r2) {
        var n2, u2, i2, o2, a2, c2 = this, s2 = c2.offset, l2 = [], f2 = c2[e2 + "Methods"], D2 = c2[e2 + "Tokenizers"], p2 = r2.line, h2 = r2.column;
        if (!t3)
          return l2;
        C3.now = m2, C3.file = c2.file, d2("");
        for (; t3; ) {
          for (n2 = -1, u2 = f2.length, o2 = false; ++n2 < u2 && (!(i2 = D2[f2[n2]]) || i2.onlyAtStart && !c2.atStart || i2.notInList && c2.inList || i2.notInBlock && c2.inBlock || i2.notInLink && c2.inLink || (a2 = t3.length, i2.apply(c2, [C3, t3]), !(o2 = a2 !== t3.length))); )
            ;
          o2 || c2.file.fail(new Error("Infinite loop"), C3.now());
        }
        return c2.eof = m2(), l2;
        function d2(e3) {
          for (var t4 = -1, r3 = e3.indexOf("\n"); r3 !== -1; )
            p2++, t4 = r3, r3 = e3.indexOf("\n", r3 + 1);
          t4 === -1 ? h2 += e3.length : h2 = e3.length - t4, p2 in s2 && (t4 !== -1 ? h2 += s2[p2] : h2 <= s2[p2] && (h2 = s2[p2] + 1));
        }
        function g2() {
          var e3 = [], t4 = p2 + 1;
          return function() {
            for (var r3 = p2 + 1; t4 < r3; )
              e3.push((s2[t4] || 0) + 1), t4++;
            return e3;
          };
        }
        function m2() {
          var e3 = { line: p2, column: h2 };
          return e3.offset = c2.toOffset(e3), e3;
        }
        function E2(e3) {
          this.start = e3, this.end = m2();
        }
        function v2(e3) {
          t3.slice(0, e3.length) !== e3 && c2.file.fail(new Error("Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"), m2());
        }
        function y2() {
          var e3 = m2();
          return t4;
          function t4(t5, r3) {
            var n3 = t5.position, u3 = n3 ? n3.start : e3, i3 = [], o3 = n3 && n3.end.line, a3 = e3.line;
            if (t5.position = new E2(u3), n3 && r3 && n3.indent) {
              if (i3 = n3.indent, o3 < a3) {
                for (; ++o3 < a3; )
                  i3.push((s2[o3] || 0) + 1);
                i3.push(e3.column);
              }
              r3 = i3.concat(r3);
            }
            return t5.position.indent = r3 || [], t5;
          }
        }
        function b2(e3, t4) {
          var r3 = t4 ? t4.children : l2, n3 = r3[r3.length - 1];
          return n3 && e3.type === n3.type && (e3.type === "text" || e3.type === "blockquote") && Jt(n3) && Jt(e3) && (e3 = (e3.type === "text" ? Kt : Qt).call(c2, n3, e3)), e3 !== n3 && r3.push(e3), c2.atStart && l2.length !== 0 && c2.exitStart(), e3;
        }
        function C3(e3) {
          var r3 = g2(), n3 = y2(), u3 = m2();
          return v2(e3), i3.reset = o3, o3.test = a3, i3.test = a3, t3 = t3.slice(e3.length), d2(e3), r3 = r3(), i3;
          function i3(e4, t4) {
            return n3(b2(n3(e4), t4), r3);
          }
          function o3() {
            var r4 = i3.apply(null, arguments);
            return p2 = u3.line, h2 = u3.column, t3 = e3 + t3, r4;
          }
          function a3() {
            var r4 = n3({});
            return p2 = u3.line, h2 = u3.column, t3 = e3 + t3, r4.position;
          }
        }
      };
    };
    function Jt(e2) {
      var t3, r2;
      return e2.type !== "text" || !e2.position || (t3 = e2.position.start, r2 = e2.position.end, t3.line !== r2.line || r2.column - t3.column === e2.value.length);
    }
    function Kt(e2, t3) {
      return e2.value += t3.value, e2;
    }
    function Qt(e2, t3) {
      return this.options.commonmark || this.options.gfm ? t3 : (e2.children = e2.children.concat(t3.children), e2);
    }
    var er = ur, tr = ["\\", "`", "*", "{", "}", "[", "]", "(", ")", "#", "+", "-", ".", "!", "_", ">"], rr = tr.concat(["~", "|"]), nr = rr.concat(["\n", '"', "$", "%", "&", "'", ",", "/", ":", ";", "<", "=", "?", "@", "^"]);
    function ur(e2) {
      var t3 = e2 || {};
      return t3.commonmark ? nr : t3.gfm ? rr : tr;
    }
    ur.default = tr, ur.gfm = rr, ur.commonmark = nr;
    var ir = { position: true, gfm: true, commonmark: false, pedantic: false, blocks: ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "meta", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "pre", "section", "source", "title", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"] }, or2 = r, ar = er, cr = ir, sr = function(e2) {
      var t3, r2, n2 = this, u2 = n2.options;
      if (e2 == null)
        e2 = {};
      else {
        if (typeof e2 != "object")
          throw new Error("Invalid value `" + e2 + "` for setting `options`");
        e2 = or2(e2);
      }
      for (t3 in cr) {
        if ((r2 = e2[t3]) == null && (r2 = u2[t3]), t3 !== "blocks" && typeof r2 != "boolean" || t3 === "blocks" && typeof r2 != "object")
          throw new Error("Invalid value `" + r2 + "` for setting `options." + t3 + "`");
        e2[t3] = r2;
      }
      return n2.options = e2, n2.escape = ar(e2), n2;
    };
    function lr(e2) {
      if (e2 == null)
        return fr;
      if (typeof e2 == "string")
        return function(e3) {
          return t3;
          function t3(t4) {
            return Boolean(t4 && t4.type === e3);
          }
        }(e2);
      if (typeof e2 == "object")
        return "length" in e2 ? function(e3) {
          var t3 = [], r2 = -1;
          for (; ++r2 < e3.length; )
            t3[r2] = lr(e3[r2]);
          return n2;
          function n2() {
            for (var e4 = -1; ++e4 < t3.length; )
              if (t3[e4].apply(this, arguments))
                return true;
            return false;
          }
        }(e2) : function(e3) {
          return t3;
          function t3(t4) {
            var r2;
            for (r2 in e3)
              if (t4[r2] !== e3[r2])
                return false;
            return true;
          }
        }(e2);
      if (typeof e2 == "function")
        return e2;
      throw new Error("Expected function, string, or object as test");
    }
    function fr() {
      return true;
    }
    var Dr = Er, pr2 = lr, hr3 = function(e2) {
      return "\x1B[33m" + e2 + "\x1B[39m";
    }, dr = true, gr = "skip", mr = false;
    function Er(e2, t3, r2, n2) {
      var u2, i2;
      typeof t3 == "function" && typeof r2 != "function" && (n2 = r2, r2 = t3, t3 = null), i2 = pr2(t3), u2 = n2 ? -1 : 1, function e3(o2, a2, c2) {
        var s2, l2 = typeof o2 == "object" && o2 !== null ? o2 : {};
        typeof l2.type == "string" && (s2 = typeof l2.tagName == "string" ? l2.tagName : typeof l2.name == "string" ? l2.name : void 0, f2.displayName = "node (" + hr3(l2.type + (s2 ? "<" + s2 + ">" : "")) + ")");
        return f2;
        function f2() {
          var s3, l3, f3 = c2.concat(o2), D2 = [];
          if ((!t3 || i2(o2, a2, c2[c2.length - 1] || null)) && (D2 = function(e4) {
            if (e4 !== null && typeof e4 == "object" && "length" in e4)
              return e4;
            if (typeof e4 == "number")
              return [dr, e4];
            return [e4];
          }(r2(o2, c2)), D2[0] === mr))
            return D2;
          if (o2.children && D2[0] !== gr)
            for (l3 = (n2 ? o2.children.length : -1) + u2; l3 > -1 && l3 < o2.children.length; ) {
              if (s3 = e3(o2.children[l3], l3, f3)(), s3[0] === mr)
                return s3;
              l3 = typeof s3[1] == "number" ? s3[1] : l3 + u2;
            }
          return D2;
        }
      }(e2, null, [])();
    }
    Er.CONTINUE = true, Er.SKIP = gr, Er.EXIT = mr;
    var vr = wr2, yr = Dr, br = yr.CONTINUE, Cr = yr.SKIP, Ar = yr.EXIT;
    function wr2(e2, t3, r2, n2) {
      typeof t3 == "function" && typeof r2 != "function" && (n2 = r2, r2 = t3, t3 = null), yr(e2, t3, function(e3, t4) {
        var n3 = t4[t4.length - 1], u2 = n3 ? n3.children.indexOf(e3) : null;
        return r2(e3, u2, n3);
      }, n2);
    }
    wr2.CONTINUE = br, wr2.SKIP = Cr, wr2.EXIT = Ar;
    var Fr = vr;
    function kr(e2) {
      delete e2.position;
    }
    function Or2(e2) {
      e2.position = void 0;
    }
    var xr = r, Tr = function(e2, t3) {
      return Fr(e2, t3 ? kr : Or2), e2;
    }, Sr = function() {
      var e2, t3 = this, r2 = String(t3.file), n2 = { line: 1, column: 1, offset: 0 }, u2 = xr(n2);
      (r2 = r2.replace(Rr, "\n")).charCodeAt(0) === 65279 && (r2 = r2.slice(1), u2.column++, u2.offset++);
      e2 = { type: "root", children: t3.tokenizeBlock(r2, u2), position: { start: n2, end: t3.eof || xr(n2) } }, t3.options.position || Tr(e2, true);
      return e2;
    }, Rr = /\r\n|\r/g;
    var Ir = /^[ \t]*(\n|$)/, Br = function(e2, t3, r2) {
      var n2, u2 = "", i2 = 0, o2 = t3.length;
      for (; i2 < o2 && (n2 = Ir.exec(t3.slice(i2))) != null; )
        i2 += n2[0].length, u2 += n2[0];
      if (u2 === "")
        return;
      if (r2)
        return true;
      e2(u2);
    };
    var Nr, Lr = "", Pr2 = function(e2, t3) {
      if (typeof e2 != "string")
        throw new TypeError("expected a string");
      if (t3 === 1)
        return e2;
      if (t3 === 2)
        return e2 + e2;
      var r2 = e2.length * t3;
      if (Nr !== e2 || Nr === void 0)
        Nr = e2, Lr = "";
      else if (Lr.length >= r2)
        return Lr.substr(0, r2);
      for (; r2 > Lr.length && t3 > 1; )
        1 & t3 && (Lr += e2), t3 >>= 1, e2 += e2;
      return Lr = (Lr += e2).substr(0, r2);
    };
    var qr = function(e2) {
      return String(e2).replace(/\n+$/, "");
    };
    var jr = qr, _r = function(e2, t3, r2) {
      var n2, u2, i2, o2 = -1, a2 = t3.length, c2 = "", s2 = "", l2 = "", f2 = "";
      for (; ++o2 < a2; )
        if (n2 = t3.charAt(o2), i2)
          if (i2 = false, c2 += l2, s2 += f2, l2 = "", f2 = "", n2 === "\n")
            l2 = n2, f2 = n2;
          else
            for (c2 += n2, s2 += n2; ++o2 < a2; ) {
              if (!(n2 = t3.charAt(o2)) || n2 === "\n") {
                f2 = n2, l2 = n2;
                break;
              }
              c2 += n2, s2 += n2;
            }
        else if (n2 === " " && t3.charAt(o2 + 1) === n2 && t3.charAt(o2 + 2) === n2 && t3.charAt(o2 + 3) === n2)
          l2 += Ur, o2 += 3, i2 = true;
        else if (n2 === "	")
          l2 += n2, i2 = true;
        else {
          for (u2 = ""; n2 === "	" || n2 === " "; )
            u2 += n2, n2 = t3.charAt(++o2);
          if (n2 !== "\n")
            break;
          l2 += u2 + n2, f2 += n2;
        }
      if (s2)
        return !!r2 || e2(c2)({ type: "code", lang: null, meta: null, value: jr(s2) });
    }, Ur = Pr2(" ", 4);
    var Mr = function(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2, f2, D2, p2, h2, d2, g2 = this, m2 = g2.options.gfm, E2 = t3.length + 1, v2 = 0, y2 = "";
      if (!m2)
        return;
      for (; v2 < E2 && ((i2 = t3.charAt(v2)) === Vr || i2 === Gr); )
        y2 += i2, v2++;
      if (h2 = v2, (i2 = t3.charAt(v2)) !== "~" && i2 !== "`")
        return;
      v2++, u2 = i2, n2 = 1, y2 += i2;
      for (; v2 < E2 && (i2 = t3.charAt(v2)) === u2; )
        y2 += i2, n2++, v2++;
      if (n2 < 3)
        return;
      for (; v2 < E2 && ((i2 = t3.charAt(v2)) === Vr || i2 === Gr); )
        y2 += i2, v2++;
      o2 = "", s2 = "";
      for (; v2 < E2 && (i2 = t3.charAt(v2)) !== zr && (u2 !== "`" || i2 !== u2); )
        i2 === Vr || i2 === Gr ? s2 += i2 : (o2 += s2 + i2, s2 = ""), v2++;
      if ((i2 = t3.charAt(v2)) && i2 !== zr)
        return;
      if (r2)
        return true;
      (d2 = e2.now()).column += y2.length, d2.offset += y2.length, y2 += o2, o2 = g2.decode.raw(g2.unescape(o2), d2), s2 && (y2 += s2);
      s2 = "", D2 = "", p2 = "", l2 = "", f2 = "";
      var b2 = true;
      for (; v2 < E2; )
        if (i2 = t3.charAt(v2), l2 += D2, f2 += p2, D2 = "", p2 = "", i2 === zr) {
          for (b2 ? (y2 += i2, b2 = false) : (D2 += i2, p2 += i2), s2 = "", v2++; v2 < E2 && (i2 = t3.charAt(v2)) === Vr; )
            s2 += i2, v2++;
          if (D2 += s2, p2 += s2.slice(h2), !(s2.length >= 4)) {
            for (s2 = ""; v2 < E2 && (i2 = t3.charAt(v2)) === u2; )
              s2 += i2, v2++;
            if (D2 += s2, p2 += s2, !(s2.length < n2)) {
              for (s2 = ""; v2 < E2 && ((i2 = t3.charAt(v2)) === Vr || i2 === Gr); )
                D2 += i2, p2 += i2, v2++;
              if (!i2 || i2 === zr)
                break;
            }
          }
        } else
          l2 += i2, p2 += i2, v2++;
      y2 += l2 + D2, v2 = -1, E2 = o2.length;
      for (; ++v2 < E2; )
        if ((i2 = o2.charAt(v2)) === Vr || i2 === Gr)
          a2 || (a2 = o2.slice(0, v2));
        else if (a2) {
          c2 = o2.slice(v2);
          break;
        }
      return e2(y2)({ type: "code", lang: a2 || o2 || null, meta: c2 || null, value: f2 });
    }, zr = "\n", Gr = "	", Vr = " ";
    var Yr = { exports: {} };
    !function(e2, t3) {
      (t3 = e2.exports = function(e3) {
        return e3.replace(/^\s*|\s*$/g, "");
      }).left = function(e3) {
        return e3.replace(/^\s*/, "");
      }, t3.right = function(e3) {
        return e3.replace(/\s*$/, "");
      };
    }(Yr, Yr.exports);
    var $r = function(e2, t3, r2, n2) {
      var u2, i2, o2 = e2.length, a2 = -1;
      for (; ++a2 < o2; )
        if (u2 = e2[a2], ((i2 = u2[1] || {}).pedantic === void 0 || i2.pedantic === r2.options.pedantic) && (i2.commonmark === void 0 || i2.commonmark === r2.options.commonmark) && t3[u2[0]].apply(r2, n2))
          return true;
      return false;
    };
    var Hr = Yr.exports, Xr = $r, Zr = function(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2, f2, D2 = this, p2 = D2.offset, h2 = D2.blockTokenizers, d2 = D2.interruptBlockquote, g2 = e2.now(), m2 = g2.line, E2 = t3.length, v2 = [], y2 = [], b2 = [], C3 = 0;
      for (; C3 < E2 && ((u2 = t3.charAt(C3)) === " " || u2 === "	"); )
        C3++;
      if (t3.charAt(C3) !== ">")
        return;
      if (r2)
        return true;
      C3 = 0;
      for (; C3 < E2; ) {
        for (o2 = t3.indexOf("\n", C3), s2 = C3, l2 = false, o2 === -1 && (o2 = E2); C3 < E2 && ((u2 = t3.charAt(C3)) === " " || u2 === "	"); )
          C3++;
        if (t3.charAt(C3) === ">" ? (C3++, l2 = true, t3.charAt(C3) === " " && C3++) : C3 = s2, a2 = t3.slice(C3, o2), !l2 && !Hr(a2)) {
          C3 = s2;
          break;
        }
        if (!l2 && (i2 = t3.slice(C3), Xr(d2, h2, D2, [e2, i2, true])))
          break;
        c2 = s2 === C3 ? a2 : t3.slice(s2, o2), b2.push(C3 - s2), v2.push(c2), y2.push(a2), C3 = o2 + 1;
      }
      C3 = -1, E2 = b2.length, n2 = e2(v2.join("\n"));
      for (; ++C3 < E2; )
        p2[m2] = (p2[m2] || 0) + b2[C3], m2++;
      return f2 = D2.enterBlock(), y2 = D2.tokenizeBlock(y2.join("\n"), g2), f2(), n2({ type: "blockquote", children: y2 });
    };
    var Wr = function(e2, t3, r2) {
      var n2, u2, i2, o2 = this.options.pedantic, a2 = t3.length + 1, c2 = -1, s2 = e2.now(), l2 = "", f2 = "";
      for (; ++c2 < a2; ) {
        if ((n2 = t3.charAt(c2)) !== Kr && n2 !== Jr) {
          c2--;
          break;
        }
        l2 += n2;
      }
      i2 = 0;
      for (; ++c2 <= a2; ) {
        if ((n2 = t3.charAt(c2)) !== Qr) {
          c2--;
          break;
        }
        l2 += n2, i2++;
      }
      if (i2 > 6)
        return;
      if (!i2 || !o2 && t3.charAt(c2 + 1) === Qr)
        return;
      a2 = t3.length + 1, u2 = "";
      for (; ++c2 < a2; ) {
        if ((n2 = t3.charAt(c2)) !== Kr && n2 !== Jr) {
          c2--;
          break;
        }
        u2 += n2;
      }
      if (!o2 && u2.length === 0 && n2 && n2 !== "\n")
        return;
      if (r2)
        return true;
      l2 += u2, u2 = "", f2 = "";
      for (; ++c2 < a2 && (n2 = t3.charAt(c2)) && n2 !== "\n"; )
        if (n2 === Kr || n2 === Jr || n2 === Qr) {
          for (; n2 === Kr || n2 === Jr; )
            u2 += n2, n2 = t3.charAt(++c2);
          if (o2 || !f2 || u2 || n2 !== Qr) {
            for (; n2 === Qr; )
              u2 += n2, n2 = t3.charAt(++c2);
            for (; n2 === Kr || n2 === Jr; )
              u2 += n2, n2 = t3.charAt(++c2);
            c2--;
          } else
            f2 += n2;
        } else
          f2 += u2 + n2, u2 = "";
      return s2.column += l2.length, s2.offset += l2.length, e2(l2 += f2 + u2)({ type: "heading", depth: i2, children: this.tokenizeInline(f2, s2) });
    }, Jr = "	", Kr = " ", Qr = "#";
    var en = function(e2, t3, r2) {
      var n2, u2, i2, o2, a2 = -1, c2 = t3.length + 1, s2 = "";
      for (; ++a2 < c2 && ((n2 = t3.charAt(a2)) === "	" || n2 === " "); )
        s2 += n2;
      if (n2 !== "*" && n2 !== "-" && n2 !== "_")
        return;
      u2 = n2, s2 += n2, i2 = 1, o2 = "";
      for (; ++a2 < c2; )
        if ((n2 = t3.charAt(a2)) === u2)
          i2++, s2 += o2 + u2, o2 = "";
        else {
          if (n2 !== " ")
            return i2 >= 3 && (!n2 || n2 === "\n") ? (s2 += o2, !!r2 || e2(s2)({ type: "thematicBreak" })) : void 0;
          o2 += n2;
        }
    };
    var tn = function(e2) {
      var t3, r2 = 0, n2 = 0, u2 = e2.charAt(r2), i2 = {}, o2 = 0;
      for (; u2 === "	" || u2 === " "; ) {
        for (n2 += t3 = u2 === "	" ? 4 : 1, t3 > 1 && (n2 = Math.floor(n2 / t3) * t3); o2 < n2; )
          i2[++o2] = r2;
        u2 = e2.charAt(++r2);
      }
      return { indent: n2, stops: i2 };
    };
    var rn = Yr.exports, nn = Pr2, un = tn, on = function(e2, t3) {
      var r2, n2, u2, i2 = e2.split("\n"), o2 = i2.length + 1, a2 = 1 / 0, c2 = [];
      i2.unshift(nn(" ", t3) + "!");
      for (; o2--; )
        if (n2 = un(i2[o2]), c2[o2] = n2.stops, rn(i2[o2]).length !== 0) {
          if (!n2.indent) {
            a2 = 1 / 0;
            break;
          }
          n2.indent > 0 && n2.indent < a2 && (a2 = n2.indent);
        }
      if (a2 !== 1 / 0)
        for (o2 = i2.length; o2--; ) {
          for (u2 = c2[o2], r2 = a2; r2 && !(r2 in u2); )
            r2--;
          i2[o2] = i2[o2].slice(u2[r2] + 1);
        }
      return i2.shift(), i2.join("\n");
    };
    var an = Yr.exports, cn = Pr2, sn = bt, ln = tn, fn = on, Dn = $r, pn = function(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2, f2, D2, p2, h2, d2, g2, m2, E2, v2, y2, b2, C3, A2, w2, F2, k2 = this, O2 = k2.options.commonmark, x2 = k2.options.pedantic, T2 = k2.blockTokenizers, S3 = k2.interruptList, R2 = 0, I2 = t3.length, B2 = null, N2 = false;
      for (; R2 < I2 && ((o2 = t3.charAt(R2)) === gn || o2 === hn); )
        R2++;
      if ((o2 = t3.charAt(R2)) === "*" || o2 === "+" || o2 === "-")
        a2 = o2, i2 = false;
      else {
        for (i2 = true, u2 = ""; R2 < I2 && (o2 = t3.charAt(R2), sn(o2)); )
          u2 += o2, R2++;
        if (o2 = t3.charAt(R2), !u2 || !(o2 === "." || O2 && o2 === ")"))
          return;
        if (r2 && u2 !== "1")
          return;
        B2 = parseInt(u2, 10), a2 = o2;
      }
      if ((o2 = t3.charAt(++R2)) !== hn && o2 !== gn && (x2 || o2 !== dn && o2 !== ""))
        return;
      if (r2)
        return true;
      R2 = 0, g2 = [], m2 = [], E2 = [];
      for (; R2 < I2; ) {
        for (c2 = t3.indexOf(dn, R2), s2 = R2, l2 = false, F2 = false, c2 === -1 && (c2 = I2), n2 = 0; R2 < I2; ) {
          if ((o2 = t3.charAt(R2)) === gn)
            n2 += 4 - n2 % 4;
          else {
            if (o2 !== hn)
              break;
            n2++;
          }
          R2++;
        }
        if (v2 && n2 >= v2.indent && (F2 = true), o2 = t3.charAt(R2), f2 = null, !F2) {
          if (o2 === "*" || o2 === "+" || o2 === "-")
            f2 = o2, R2++, n2++;
          else {
            for (u2 = ""; R2 < I2 && (o2 = t3.charAt(R2), sn(o2)); )
              u2 += o2, R2++;
            o2 = t3.charAt(R2), R2++, u2 && (o2 === "." || O2 && o2 === ")") && (f2 = o2, n2 += u2.length + 1);
          }
          if (f2)
            if ((o2 = t3.charAt(R2)) === gn)
              n2 += 4 - n2 % 4, R2++;
            else if (o2 === hn) {
              for (w2 = R2 + 4; R2 < w2 && t3.charAt(R2) === hn; )
                R2++, n2++;
              R2 === w2 && t3.charAt(R2) === hn && (R2 -= 3, n2 -= 3);
            } else
              o2 !== dn && o2 !== "" && (f2 = null);
        }
        if (f2) {
          if (!x2 && a2 !== f2)
            break;
          l2 = true;
        } else
          O2 || F2 || t3.charAt(s2) !== hn ? O2 && v2 && (F2 = n2 >= v2.indent || n2 > 4) : F2 = true, l2 = false, R2 = s2;
        if (p2 = t3.slice(s2, c2), D2 = s2 === R2 ? p2 : t3.slice(R2, c2), (f2 === "*" || f2 === "_" || f2 === "-") && T2.thematicBreak.call(k2, e2, p2, true))
          break;
        if (h2 = d2, d2 = !l2 && !an(D2).length, F2 && v2)
          v2.value = v2.value.concat(E2, p2), m2 = m2.concat(E2, p2), E2 = [];
        else if (l2)
          E2.length !== 0 && (N2 = true, v2.value.push(""), v2.trail = E2.concat()), v2 = { value: [p2], indent: n2, trail: [] }, g2.push(v2), m2 = m2.concat(E2, p2), E2 = [];
        else if (d2) {
          if (h2 && !O2)
            break;
          E2.push(p2);
        } else {
          if (h2)
            break;
          if (Dn(S3, T2, k2, [e2, p2, true]))
            break;
          v2.value = v2.value.concat(E2, p2), m2 = m2.concat(E2, p2), E2 = [];
        }
        R2 = c2 + 1;
      }
      C3 = e2(m2.join(dn)).reset({ type: "list", ordered: i2, start: B2, spread: N2, children: [] }), y2 = k2.enterList(), b2 = k2.enterBlock(), R2 = -1, I2 = g2.length;
      for (; ++R2 < I2; )
        v2 = g2[R2].value.join(dn), A2 = e2.now(), e2(v2)(Cn(k2, v2, A2), C3), v2 = g2[R2].trail.join(dn), R2 !== I2 - 1 && (v2 += dn), e2(v2);
      return y2(), b2(), C3;
    }, hn = " ", dn = "\n", gn = "	", mn = /\n\n(?!\s*$)/, En = /^\[([ X\tx])][ \t]/, vn = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/, yn = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/, bn = /^( {1,4}|\t)?/gm;
    function Cn(e2, t3, r2) {
      var n2, u2, i2 = e2.offset, o2 = e2.options.pedantic ? An : wn, a2 = null;
      return t3 = o2.apply(null, arguments), e2.options.gfm && (n2 = t3.match(En)) && (u2 = n2[0].length, a2 = n2[1].toLowerCase() === "x", i2[r2.line] += u2, t3 = t3.slice(u2)), { type: "listItem", spread: mn.test(t3), checked: a2, children: e2.tokenizeBlock(t3, r2) };
    }
    function An(e2, t3, r2) {
      var n2 = e2.offset, u2 = r2.line;
      return t3 = t3.replace(yn, i2), u2 = r2.line, t3.replace(bn, i2);
      function i2(e3) {
        return n2[u2] = (n2[u2] || 0) + e3.length, u2++, "";
      }
    }
    function wn(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2 = e2.offset, f2 = r2.line;
      for (o2 = (t3 = t3.replace(vn, function(e3, t4, r3, o3, a3) {
        u2 = t4 + r3 + o3, i2 = a3, Number(r3) < 10 && u2.length % 2 == 1 && (r3 = hn + r3);
        return (n2 = t4 + cn(hn, r3.length) + o3) + i2;
      })).split(dn), (a2 = fn(t3, ln(n2).indent).split(dn))[0] = i2, l2[f2] = (l2[f2] || 0) + u2.length, f2++, c2 = 0, s2 = o2.length; ++c2 < s2; )
        l2[f2] = (l2[f2] || 0) + o2[c2].length - a2[c2].length, f2++;
      return a2.join(dn);
    }
    var Fn = function(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2 = e2.now(), s2 = t3.length, l2 = -1, f2 = "";
      for (; ++l2 < s2; ) {
        if ((i2 = t3.charAt(l2)) !== " " || l2 >= 3) {
          l2--;
          break;
        }
        f2 += i2;
      }
      n2 = "", u2 = "";
      for (; ++l2 < s2; ) {
        if ((i2 = t3.charAt(l2)) === "\n") {
          l2--;
          break;
        }
        i2 === " " || i2 === "	" ? u2 += i2 : (n2 += u2 + i2, u2 = "");
      }
      if (c2.column += f2.length, c2.offset += f2.length, f2 += n2 + u2, i2 = t3.charAt(++l2), o2 = t3.charAt(++l2), i2 !== "\n" || o2 !== "=" && o2 !== "-")
        return;
      f2 += i2, u2 = o2, a2 = o2 === "=" ? 1 : 2;
      for (; ++l2 < s2; ) {
        if ((i2 = t3.charAt(l2)) !== o2) {
          if (i2 !== "\n")
            return;
          l2--;
          break;
        }
        u2 += i2;
      }
      if (r2)
        return true;
      return e2(f2 + u2)({ type: "heading", depth: a2, children: this.tokenizeInline(n2, c2) });
    };
    var kn = {}, On = `<[A-Za-z][A-Za-z0-9\\-]*(?:\\s+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:\\s*=\\s*(?:[^"'=<>\`\\u0000-\\u0020]+|'[^']*'|"[^"]*"))?)*\\s*\\/?>`, xn = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    kn.openCloseTag = new RegExp("^(?:" + On + "|" + xn + ")"), kn.tag = new RegExp("^(?:" + On + "|" + xn + "|<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->|<[?].*?[?]>|<![A-Za-z]+\\s+[^>]*>|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>)");
    var Tn = kn.openCloseTag, Sn = function(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2 = this.options.blocks.join("|"), f2 = new RegExp("^</?(" + l2 + ")(?=(\\s|/?>|$))", "i"), D2 = t3.length, p2 = 0, h2 = [[Rn, In, true], [Bn, Nn, true], [Ln, Pn, true], [qn, jn, true], [_n, Un, true], [f2, Mn, true], [zn, Mn, false]];
      for (; p2 < D2 && ((o2 = t3.charAt(p2)) === "	" || o2 === " "); )
        p2++;
      if (t3.charAt(p2) !== "<")
        return;
      n2 = (n2 = t3.indexOf("\n", p2 + 1)) === -1 ? D2 : n2, u2 = t3.slice(p2, n2), i2 = -1, a2 = h2.length;
      for (; ++i2 < a2; )
        if (h2[i2][0].test(u2)) {
          c2 = h2[i2];
          break;
        }
      if (!c2)
        return;
      if (r2)
        return c2[2];
      if (p2 = n2, !c2[1].test(u2))
        for (; p2 < D2; ) {
          if (n2 = (n2 = t3.indexOf("\n", p2 + 1)) === -1 ? D2 : n2, u2 = t3.slice(p2 + 1, n2), c2[1].test(u2)) {
            u2 && (p2 = n2);
            break;
          }
          p2 = n2;
        }
      return s2 = t3.slice(0, p2), e2(s2)({ type: "html", value: s2 });
    }, Rn = /^<(script|pre|style)(?=(\s|>|$))/i, In = /<\/(script|pre|style)>/i, Bn = /^<!--/, Nn = /-->/, Ln = /^<\?/, Pn = /\?>/, qn = /^<![A-Za-z]/, jn = />/, _n = /^<!\[CDATA\[/, Un = /]]>/, Mn = /^$/, zn = new RegExp(Tn.source + "\\s*$");
    var Gn = function(e2) {
      return Yn.test(typeof e2 == "number" ? Vn(e2) : e2.charAt(0));
    }, Vn = String.fromCharCode, Yn = /\s/;
    var $n = function(e2) {
      return String(e2).replace(/\s+/g, " ");
    }, Hn = function(e2) {
      return $n(e2).toLowerCase();
    };
    var Xn = Gn, Zn = Hn, Wn = function(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2, f2 = this, D2 = f2.options.commonmark, p2 = 0, h2 = t3.length, d2 = "";
      for (; p2 < h2 && ((o2 = t3.charAt(p2)) === Qn || o2 === Kn); )
        d2 += o2, p2++;
      if ((o2 = t3.charAt(p2)) !== "[")
        return;
      p2++, d2 += o2, i2 = "";
      for (; p2 < h2 && (o2 = t3.charAt(p2)) !== eu; )
        o2 === "\\" && (i2 += o2, p2++, o2 = t3.charAt(p2)), i2 += o2, p2++;
      if (!i2 || t3.charAt(p2) !== eu || t3.charAt(p2 + 1) !== ":")
        return;
      c2 = i2, p2 = (d2 += i2 + eu + ":").length, i2 = "";
      for (; p2 < h2 && ((o2 = t3.charAt(p2)) === Kn || o2 === Qn || o2 === Jn); )
        d2 += o2, p2++;
      if (o2 = t3.charAt(p2), i2 = "", n2 = d2, o2 === "<") {
        for (p2++; p2 < h2 && tu(o2 = t3.charAt(p2)); )
          i2 += o2, p2++;
        if ((o2 = t3.charAt(p2)) === tu.delimiter)
          d2 += "<" + i2 + o2, p2++;
        else {
          if (D2)
            return;
          p2 -= i2.length + 1, i2 = "";
        }
      }
      if (!i2) {
        for (; p2 < h2 && ru(o2 = t3.charAt(p2)); )
          i2 += o2, p2++;
        d2 += i2;
      }
      if (!i2)
        return;
      s2 = i2, i2 = "";
      for (; p2 < h2 && ((o2 = t3.charAt(p2)) === Kn || o2 === Qn || o2 === Jn); )
        i2 += o2, p2++;
      o2 = t3.charAt(p2), a2 = null, o2 === '"' ? a2 = '"' : o2 === "'" ? a2 = "'" : o2 === "(" && (a2 = ")");
      if (a2) {
        if (!i2)
          return;
        for (p2 = (d2 += i2 + o2).length, i2 = ""; p2 < h2 && (o2 = t3.charAt(p2)) !== a2; ) {
          if (o2 === Jn) {
            if (p2++, (o2 = t3.charAt(p2)) === Jn || o2 === a2)
              return;
            i2 += Jn;
          }
          i2 += o2, p2++;
        }
        if ((o2 = t3.charAt(p2)) !== a2)
          return;
        u2 = d2, d2 += i2 + o2, p2++, l2 = i2, i2 = "";
      } else
        i2 = "", p2 = d2.length;
      for (; p2 < h2 && ((o2 = t3.charAt(p2)) === Kn || o2 === Qn); )
        d2 += o2, p2++;
      if (!(o2 = t3.charAt(p2)) || o2 === Jn)
        return !!r2 || (n2 = e2(n2).test().end, s2 = f2.decode.raw(f2.unescape(s2), n2, { nonTerminated: false }), l2 && (u2 = e2(u2).test().end, l2 = f2.decode.raw(f2.unescape(l2), u2)), e2(d2)({ type: "definition", identifier: Zn(c2), label: c2, title: l2 || null, url: s2 }));
    }, Jn = "\n", Kn = "	", Qn = " ", eu = "]";
    function tu(e2) {
      return e2 !== ">" && e2 !== "[" && e2 !== eu;
    }
    function ru(e2) {
      return e2 !== "[" && e2 !== eu && !Xn(e2);
    }
    tu.delimiter = ">";
    var nu2 = Gn, uu = function(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2, f2, D2, p2, h2, d2, g2, m2, E2, v2, y2, b2, C3, A2, w2;
      if (!this.options.gfm)
        return;
      n2 = 0, E2 = 0, c2 = t3.length + 1, s2 = [];
      for (; n2 < c2; ) {
        if (C3 = t3.indexOf(iu, n2), A2 = t3.indexOf("|", n2 + 1), C3 === -1 && (C3 = t3.length), A2 === -1 || A2 > C3) {
          if (E2 < 2)
            return;
          break;
        }
        s2.push(t3.slice(n2, C3)), E2++, n2 = C3 + 1;
      }
      o2 = s2.join(iu), u2 = s2.splice(1, 1)[0] || [], n2 = 0, c2 = u2.length, E2--, i2 = false, p2 = [];
      for (; n2 < c2; ) {
        if ((f2 = u2.charAt(n2)) === "|") {
          if (D2 = null, i2 === false) {
            if (w2 === false)
              return;
          } else
            p2.push(i2), i2 = false;
          w2 = false;
        } else if (f2 === "-")
          D2 = true, i2 = i2 || null;
        else if (f2 === ":")
          i2 = i2 === ou ? "center" : D2 && i2 === null ? "right" : ou;
        else if (!nu2(f2))
          return;
        n2++;
      }
      i2 !== false && p2.push(i2);
      if (p2.length < 1)
        return;
      if (r2)
        return true;
      m2 = -1, y2 = [], b2 = e2(o2).reset({ type: "table", align: p2, children: y2 });
      for (; ++m2 < E2; ) {
        for (v2 = s2[m2], a2 = { type: "tableRow", children: [] }, m2 && e2(iu), e2(v2).reset(a2, b2), c2 = v2.length + 1, n2 = 0, l2 = "", h2 = "", d2 = true; n2 < c2; )
          (f2 = v2.charAt(n2)) !== "	" && f2 !== " " ? (f2 === "" || f2 === "|" ? d2 ? e2(f2) : (!h2 && !f2 || d2 || (o2 = h2, l2.length > 1 && (f2 ? (o2 += l2.slice(0, -1), l2 = l2.charAt(l2.length - 1)) : (o2 += l2, l2 = "")), g2 = e2.now(), e2(o2)({ type: "tableCell", children: this.tokenizeInline(h2, g2) }, a2)), e2(l2 + f2), l2 = "", h2 = "") : (l2 && (h2 += l2, l2 = ""), h2 += f2, f2 === "\\" && n2 !== c2 - 2 && (h2 += v2.charAt(n2 + 1), n2++)), d2 = false, n2++) : (h2 ? l2 += f2 : e2(f2), n2++);
        m2 || e2(iu + u2);
      }
      return b2;
    }, iu = "\n", ou = "left";
    var au = Yr.exports, cu = qr, su = $r, lu = function(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2 = this, s2 = c2.options.commonmark, l2 = c2.blockTokenizers, f2 = c2.interruptParagraph, D2 = t3.indexOf(fu), p2 = t3.length;
      for (; D2 < p2; ) {
        if (D2 === -1) {
          D2 = p2;
          break;
        }
        if (t3.charAt(D2 + 1) === fu)
          break;
        if (s2) {
          for (o2 = 0, n2 = D2 + 1; n2 < p2; ) {
            if ((i2 = t3.charAt(n2)) === "	") {
              o2 = 4;
              break;
            }
            if (i2 !== " ")
              break;
            o2++, n2++;
          }
          if (o2 >= 4 && i2 !== fu) {
            D2 = t3.indexOf(fu, D2 + 1);
            continue;
          }
        }
        if (u2 = t3.slice(D2 + 1), su(f2, l2, c2, [e2, u2, true]))
          break;
        if (n2 = D2, (D2 = t3.indexOf(fu, D2 + 1)) !== -1 && au(t3.slice(n2, D2)) === "") {
          D2 = n2;
          break;
        }
      }
      if (u2 = t3.slice(0, D2), r2)
        return true;
      return a2 = e2.now(), u2 = cu(u2), e2(u2)({ type: "paragraph", children: c2.tokenizeInline(u2, a2) });
    }, fu = "\n";
    var Du = function(e2, t3) {
      return e2.indexOf("\\", t3);
    }, pu = hu;
    hu.locator = Du;
    function hu(e2, t3, r2) {
      var n2, u2;
      if (t3.charAt(0) === "\\" && (n2 = t3.charAt(1), this.escape.indexOf(n2) !== -1))
        return !!r2 || (u2 = n2 === "\n" ? { type: "break" } : { type: "text", value: n2 }, e2("\\" + n2)(u2));
    }
    var du = function(e2, t3) {
      return e2.indexOf("<", t3);
    };
    var gu = Gn, mu2 = Nt, Eu = du, vu = Cu;
    Cu.locator = Eu, Cu.notInLink = true;
    var yu = "mailto:", bu = yu.length;
    function Cu(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2 = this, s2 = "", l2 = t3.length, f2 = 0, D2 = "", p2 = false, h2 = "";
      if (t3.charAt(0) === "<") {
        for (f2++, s2 = "<"; f2 < l2 && (n2 = t3.charAt(f2), !(gu(n2) || n2 === ">" || n2 === "@" || n2 === ":" && t3.charAt(f2 + 1) === "/")); )
          D2 += n2, f2++;
        if (D2) {
          if (h2 += D2, D2 = "", h2 += n2 = t3.charAt(f2), f2++, n2 === "@")
            p2 = true;
          else {
            if (n2 !== ":" || t3.charAt(f2 + 1) !== "/")
              return;
            h2 += "/", f2++;
          }
          for (; f2 < l2 && (n2 = t3.charAt(f2), !gu(n2) && n2 !== ">"); )
            D2 += n2, f2++;
          if (n2 = t3.charAt(f2), D2 && n2 === ">")
            return !!r2 || (i2 = h2 += D2, s2 += h2 + n2, (u2 = e2.now()).column++, u2.offset++, p2 && (h2.slice(0, bu).toLowerCase() === yu ? (i2 = i2.slice(bu), u2.column += bu, u2.offset += bu) : h2 = yu + h2), o2 = c2.inlineTokenizers, c2.inlineTokenizers = { text: o2.text }, a2 = c2.enterLink(), i2 = c2.tokenizeInline(i2, u2), c2.inlineTokenizers = o2, a2(), e2(s2)({ type: "link", title: null, url: mu2(h2, { nonTerminated: false }), children: i2 }));
        }
      }
    }
    var Au = function(e2, t3) {
      var r2, n2 = String(e2), u2 = 0;
      if (typeof t3 != "string")
        throw new Error("Expected character");
      r2 = n2.indexOf(t3);
      for (; r2 !== -1; )
        u2++, r2 = n2.indexOf(t3, r2 + t3.length);
      return u2;
    };
    var wu = function(e2, t3) {
      var r2, n2, u2, i2 = -1;
      if (!this.options.gfm)
        return i2;
      n2 = Fu.length, r2 = -1;
      for (; ++r2 < n2; )
        (u2 = e2.indexOf(Fu[r2], t3)) !== -1 && (i2 === -1 || u2 < i2) && (i2 = u2);
      return i2;
    }, Fu = ["www.", "http://", "https://"];
    var ku = Au, Ou = Nt, xu = bt, Tu = Ct, Su = Gn, Ru = wu, Iu = Bu;
    Bu.locator = Ru, Bu.notInLink = true;
    function Bu(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2, f2, D2, p2, h2, d2, g2, m2 = this, E2 = m2.options.gfm, v2 = m2.inlineTokenizers, y2 = t3.length, b2 = -1, C3 = false;
      if (E2) {
        if (t3.slice(0, 4) === "www.")
          C3 = true, o2 = 4;
        else if (t3.slice(0, 7).toLowerCase() === "http://")
          o2 = 7;
        else {
          if (t3.slice(0, 8).toLowerCase() !== "https://")
            return;
          o2 = 8;
        }
        for (b2 = o2 - 1, i2 = o2, n2 = []; o2 < y2; )
          if ((s2 = t3.charCodeAt(o2)) !== 46) {
            if (!xu(s2) && !Tu(s2) && s2 !== 45 && s2 !== 95)
              break;
            o2++;
          } else {
            if (b2 === o2 - 1)
              break;
            n2.push(o2), b2 = o2, o2++;
          }
        if (s2 === 46 && (n2.pop(), o2--), n2[0] !== void 0 && (u2 = n2.length < 2 ? i2 : n2[n2.length - 2] + 1, t3.slice(u2, o2).indexOf("_") === -1)) {
          if (r2)
            return true;
          for (l2 = o2, a2 = o2; o2 < y2 && (s2 = t3.charCodeAt(o2), !Su(s2) && s2 !== 60); )
            o2++, s2 === 33 || s2 === 42 || s2 === 44 || s2 === 46 || s2 === 58 || s2 === 63 || s2 === 95 || s2 === 126 || (l2 = o2);
          if (o2 = l2, t3.charCodeAt(o2 - 1) === 41)
            for (c2 = t3.slice(a2, o2), f2 = ku(c2, "("), D2 = ku(c2, ")"); D2 > f2; )
              o2 = a2 + c2.lastIndexOf(")"), c2 = t3.slice(a2, o2), D2--;
          if (t3.charCodeAt(o2 - 1) === 59 && (o2--, Tu(t3.charCodeAt(o2 - 1)))) {
            for (l2 = o2 - 2; Tu(t3.charCodeAt(l2)); )
              l2--;
            t3.charCodeAt(l2) === 38 && (o2 = l2);
          }
          return p2 = t3.slice(0, o2), d2 = Ou(p2, { nonTerminated: false }), C3 && (d2 = "http://" + d2), g2 = m2.enterLink(), m2.inlineTokenizers = { text: v2.text }, h2 = m2.tokenizeInline(p2, e2.now()), m2.inlineTokenizers = v2, g2(), e2(p2)({ type: "link", title: null, url: d2, children: h2 });
        }
      }
    }
    var Nu2 = bt, Lu = Ct, Pu = function e2(t3, r2) {
      var n2, u2;
      if (!this.options.gfm)
        return -1;
      if ((n2 = t3.indexOf("@", r2)) === -1)
        return -1;
      if ((u2 = n2) === r2 || !qu(t3.charCodeAt(u2 - 1)))
        return e2.call(this, t3, n2 + 1);
      for (; u2 > r2 && qu(t3.charCodeAt(u2 - 1)); )
        u2--;
      return u2;
    };
    function qu(e2) {
      return Nu2(e2) || Lu(e2) || e2 === 43 || e2 === 45 || e2 === 46 || e2 === 95;
    }
    var ju = Nt, _u = bt, Uu = Ct, Mu2 = Pu, zu = Gu;
    Gu.locator = Mu2, Gu.notInLink = true;
    function Gu(e2, t3, r2) {
      var n2, u2, i2, o2, a2 = this, c2 = a2.options.gfm, s2 = a2.inlineTokenizers, l2 = 0, f2 = t3.length, D2 = -1;
      if (c2) {
        for (n2 = t3.charCodeAt(l2); _u(n2) || Uu(n2) || n2 === 43 || n2 === 45 || n2 === 46 || n2 === 95; )
          n2 = t3.charCodeAt(++l2);
        if (l2 !== 0 && n2 === 64) {
          for (l2++; l2 < f2 && (n2 = t3.charCodeAt(l2), _u(n2) || Uu(n2) || n2 === 45 || n2 === 46 || n2 === 95); )
            l2++, D2 === -1 && n2 === 46 && (D2 = l2);
          if (D2 !== -1 && D2 !== l2 && n2 !== 45 && n2 !== 95)
            return n2 === 46 && l2--, u2 = t3.slice(0, l2), !!r2 || (o2 = a2.enterLink(), a2.inlineTokenizers = { text: s2.text }, i2 = a2.tokenizeInline(u2, e2.now()), a2.inlineTokenizers = s2, o2(), e2(u2)({ type: "link", title: null, url: "mailto:" + ju(u2, { nonTerminated: false }), children: i2 }));
        }
      }
    }
    var Vu = Ct, Yu = du, $u = kn.tag, Hu = Wu;
    Wu.locator = Yu;
    var Xu = /^<a /i, Zu = /^<\/a>/i;
    function Wu(e2, t3, r2) {
      var n2, u2, i2 = this, o2 = t3.length;
      if (!(t3.charAt(0) !== "<" || o2 < 3) && (n2 = t3.charAt(1), (Vu(n2) || n2 === "?" || n2 === "!" || n2 === "/") && (u2 = t3.match($u))))
        return !!r2 || (u2 = u2[0], !i2.inLink && Xu.test(u2) ? i2.inLink = true : i2.inLink && Zu.test(u2) && (i2.inLink = false), e2(u2)({ type: "html", value: u2 }));
    }
    var Ju = function(e2, t3) {
      var r2 = e2.indexOf("[", t3), n2 = e2.indexOf("![", t3);
      if (n2 === -1)
        return r2;
      return r2 < n2 ? r2 : n2;
    };
    var Ku = Gn, Qu = Ju, ei = ui;
    ui.locator = Qu;
    var ti = "(", ri = ")", ni2 = "\\";
    function ui(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2, f2, D2, p2, h2, d2, g2, m2, E2, v2, y2, b2 = this, C3 = "", A2 = 0, w2 = t3.charAt(0), F2 = b2.options.pedantic, k2 = b2.options.commonmark, O2 = b2.options.gfm;
      if (w2 === "!" && (l2 = true, C3 = w2, w2 = t3.charAt(++A2)), w2 === "[" && (l2 || !b2.inLink)) {
        for (C3 += w2, g2 = "", A2++, p2 = t3.length, d2 = 0, (E2 = e2.now()).column += A2, E2.offset += A2; A2 < p2; ) {
          if (c2 = w2 = t3.charAt(A2), w2 === "`") {
            for (u2 = 1; t3.charAt(A2 + 1) === "`"; )
              c2 += w2, A2++, u2++;
            i2 ? u2 >= i2 && (i2 = 0) : i2 = u2;
          } else if (w2 === ni2)
            A2++, c2 += t3.charAt(A2);
          else if (i2 && !O2 || w2 !== "[") {
            if ((!i2 || O2) && w2 === "]") {
              if (!d2) {
                if (t3.charAt(A2 + 1) !== ti)
                  return;
                c2 += ti, n2 = true, A2++;
                break;
              }
              d2--;
            }
          } else
            d2++;
          g2 += c2, c2 = "", A2++;
        }
        if (n2) {
          for (f2 = g2, C3 += g2 + c2, A2++; A2 < p2 && (w2 = t3.charAt(A2), Ku(w2)); )
            C3 += w2, A2++;
          if (g2 = "", o2 = C3, (w2 = t3.charAt(A2)) === "<") {
            for (A2++, o2 += "<"; A2 < p2 && (w2 = t3.charAt(A2)) !== ">"; ) {
              if (k2 && w2 === "\n")
                return;
              g2 += w2, A2++;
            }
            if (t3.charAt(A2) !== ">")
              return;
            C3 += "<" + g2 + ">", m2 = g2, A2++;
          } else {
            for (w2 = null, c2 = ""; A2 < p2 && (w2 = t3.charAt(A2), !c2 || !(w2 === '"' || w2 === "'" || k2 && w2 === ti)); ) {
              if (Ku(w2)) {
                if (!F2)
                  break;
                c2 += w2;
              } else {
                if (w2 === ti)
                  d2++;
                else if (w2 === ri) {
                  if (d2 === 0)
                    break;
                  d2--;
                }
                g2 += c2, c2 = "", w2 === ni2 && (g2 += ni2, w2 = t3.charAt(++A2)), g2 += w2;
              }
              A2++;
            }
            m2 = g2, A2 = (C3 += g2).length;
          }
          for (g2 = ""; A2 < p2 && (w2 = t3.charAt(A2), Ku(w2)); )
            g2 += w2, A2++;
          if (w2 = t3.charAt(A2), C3 += g2, g2 && (w2 === '"' || w2 === "'" || k2 && w2 === ti))
            if (A2++, g2 = "", D2 = w2 === ti ? ri : w2, a2 = C3 += w2, k2) {
              for (; A2 < p2 && (w2 = t3.charAt(A2)) !== D2; )
                w2 === ni2 && (g2 += ni2, w2 = t3.charAt(++A2)), A2++, g2 += w2;
              if ((w2 = t3.charAt(A2)) !== D2)
                return;
              for (h2 = g2, C3 += g2 + w2, A2++; A2 < p2 && (w2 = t3.charAt(A2), Ku(w2)); )
                C3 += w2, A2++;
            } else
              for (c2 = ""; A2 < p2; ) {
                if ((w2 = t3.charAt(A2)) === D2)
                  s2 && (g2 += D2 + c2, c2 = ""), s2 = true;
                else if (s2) {
                  if (w2 === ri) {
                    C3 += g2 + D2 + c2, h2 = g2;
                    break;
                  }
                  Ku(w2) ? c2 += w2 : (g2 += D2 + c2 + w2, c2 = "", s2 = false);
                } else
                  g2 += w2;
                A2++;
              }
          if (t3.charAt(A2) === ri)
            return !!r2 || (C3 += ri, m2 = b2.decode.raw(b2.unescape(m2), e2(o2).test().end, { nonTerminated: false }), h2 && (a2 = e2(a2).test().end, h2 = b2.decode.raw(b2.unescape(h2), a2)), y2 = { type: l2 ? "image" : "link", title: h2 || null, url: m2 }, l2 ? y2.alt = b2.decode.raw(b2.unescape(f2), E2) || null : (v2 = b2.enterLink(), y2.children = b2.tokenizeInline(f2, E2), v2()), e2(C3)(y2));
        }
      }
    }
    var ii2 = Gn, oi = Ju, ai = Hn, ci = hi;
    hi.locator = oi;
    var si = "link", li = "full", fi = "[", Di = "\\", pi2 = "]";
    function hi(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2, f2 = this, D2 = f2.options.commonmark, p2 = t3.charAt(0), h2 = 0, d2 = t3.length, g2 = "", m2 = "", E2 = si, v2 = "shortcut";
      if (p2 === "!" && (E2 = "image", m2 = p2, p2 = t3.charAt(++h2)), p2 === fi) {
        for (h2++, m2 += p2, c2 = "", l2 = 0; h2 < d2; ) {
          if ((p2 = t3.charAt(h2)) === fi)
            s2 = true, l2++;
          else if (p2 === pi2) {
            if (!l2)
              break;
            l2--;
          }
          p2 === Di && (c2 += Di, p2 = t3.charAt(++h2)), c2 += p2, h2++;
        }
        if (g2 = c2, n2 = c2, (p2 = t3.charAt(h2)) === pi2) {
          if (h2++, g2 += p2, c2 = "", !D2)
            for (; h2 < d2 && (p2 = t3.charAt(h2), ii2(p2)); )
              c2 += p2, h2++;
          if ((p2 = t3.charAt(h2)) === fi) {
            for (u2 = "", c2 += p2, h2++; h2 < d2 && (p2 = t3.charAt(h2)) !== fi && p2 !== pi2; )
              p2 === Di && (u2 += Di, p2 = t3.charAt(++h2)), u2 += p2, h2++;
            (p2 = t3.charAt(h2)) === pi2 ? (v2 = u2 ? li : "collapsed", c2 += u2 + p2, h2++) : u2 = "", g2 += c2, c2 = "";
          } else {
            if (!n2)
              return;
            u2 = n2;
          }
          if (v2 === li || !s2)
            return g2 = m2 + g2, E2 === si && f2.inLink ? null : !!r2 || ((i2 = e2.now()).column += m2.length, i2.offset += m2.length, o2 = { type: E2 + "Reference", identifier: ai(u2 = v2 === li ? u2 : n2), label: u2, referenceType: v2 }, E2 === si ? (a2 = f2.enterLink(), o2.children = f2.tokenizeInline(n2, i2), a2()) : o2.alt = f2.decode.raw(f2.unescape(n2), i2) || null, e2(g2)(o2));
        }
      }
    }
    var di = function(e2, t3) {
      var r2 = e2.indexOf("**", t3), n2 = e2.indexOf("__", t3);
      if (n2 === -1)
        return r2;
      if (r2 === -1)
        return n2;
      return n2 < r2 ? n2 : r2;
    };
    var gi = Yr.exports, mi = Gn, Ei = di, vi = yi;
    yi.locator = Ei;
    function yi(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2 = 0, f2 = t3.charAt(l2);
      if (!(f2 !== "*" && f2 !== "_" || t3.charAt(++l2) !== f2 || (u2 = this.options.pedantic, a2 = (i2 = f2) + i2, c2 = t3.length, l2++, o2 = "", f2 = "", u2 && mi(t3.charAt(l2)))))
        for (; l2 < c2; ) {
          if (s2 = f2, !((f2 = t3.charAt(l2)) !== i2 || t3.charAt(l2 + 1) !== i2 || u2 && mi(s2)) && (f2 = t3.charAt(l2 + 2)) !== i2) {
            if (!gi(o2))
              return;
            return !!r2 || ((n2 = e2.now()).column += 2, n2.offset += 2, e2(a2 + o2 + a2)({ type: "strong", children: this.tokenizeInline(o2, n2) }));
          }
          u2 || f2 !== "\\" || (o2 += f2, f2 = t3.charAt(++l2)), o2 += f2, l2++;
        }
    }
    var bi = function(e2) {
      return Ai.test(typeof e2 == "number" ? Ci(e2) : e2.charAt(0));
    }, Ci = String.fromCharCode, Ai = /\w/;
    var wi = function(e2, t3) {
      var r2 = e2.indexOf("*", t3), n2 = e2.indexOf("_", t3);
      if (n2 === -1)
        return r2;
      if (r2 === -1)
        return n2;
      return n2 < r2 ? n2 : r2;
    };
    var Fi = Yr.exports, ki = bi, Oi = Gn, xi2 = wi, Ti = Si;
    Si.locator = xi2;
    function Si(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2 = 0, f2 = t3.charAt(l2);
      if (!(f2 !== "*" && f2 !== "_" || (u2 = this.options.pedantic, a2 = f2, i2 = f2, c2 = t3.length, l2++, o2 = "", f2 = "", u2 && Oi(t3.charAt(l2)))))
        for (; l2 < c2; ) {
          if (s2 = f2, !((f2 = t3.charAt(l2)) !== i2 || u2 && Oi(s2))) {
            if ((f2 = t3.charAt(++l2)) !== i2) {
              if (!Fi(o2) || s2 === i2)
                return;
              if (!u2 && i2 === "_" && ki(f2)) {
                o2 += i2;
                continue;
              }
              return !!r2 || ((n2 = e2.now()).column++, n2.offset++, e2(a2 + o2 + i2)({ type: "emphasis", children: this.tokenizeInline(o2, n2) }));
            }
            o2 += i2;
          }
          u2 || f2 !== "\\" || (o2 += f2, f2 = t3.charAt(++l2)), o2 += f2, l2++;
        }
    }
    var Ri = Gn, Ii = function(e2, t3) {
      return e2.indexOf("~~", t3);
    }, Bi = Li;
    Li.locator = Ii;
    var Ni = "~";
    function Li(e2, t3, r2) {
      var n2, u2, i2, o2 = "", a2 = "", c2 = "", s2 = "";
      if (this.options.gfm && t3.charAt(0) === Ni && t3.charAt(1) === Ni && !Ri(t3.charAt(2)))
        for (n2 = 1, u2 = t3.length, (i2 = e2.now()).column += 2, i2.offset += 2; ++n2 < u2; ) {
          if (!((o2 = t3.charAt(n2)) !== Ni || a2 !== Ni || c2 && Ri(c2)))
            return !!r2 || e2("~~" + s2 + "~~")({ type: "delete", children: this.tokenizeInline(s2, i2) });
          s2 += a2, c2 = a2, a2 = o2;
        }
    }
    var Pi2 = function(e2, t3) {
      return e2.indexOf("`", t3);
    }, qi = ji;
    ji.locator = Pi2;
    function ji(e2, t3, r2) {
      for (var n2, u2, i2, o2, a2, c2, s2 = t3.length, l2 = 0; l2 < s2 && t3.charCodeAt(l2) === 96; )
        l2++;
      if (l2 !== 0 && l2 !== s2) {
        for (n2 = l2, a2 = t3.charCodeAt(l2); l2 < s2; ) {
          if (o2 = a2, a2 = t3.charCodeAt(l2 + 1), o2 === 96) {
            if (u2 === void 0 && (u2 = l2), i2 = l2 + 1, a2 !== 96 && i2 - u2 === n2) {
              c2 = true;
              break;
            }
          } else
            u2 !== void 0 && (u2 = void 0, i2 = void 0);
          l2++;
        }
        if (c2) {
          if (r2)
            return true;
          if (l2 = n2, s2 = u2, o2 = t3.charCodeAt(l2), a2 = t3.charCodeAt(s2 - 1), c2 = false, s2 - l2 > 2 && (o2 === 32 || o2 === 10) && (a2 === 32 || a2 === 10)) {
            for (l2++, s2--; l2 < s2; ) {
              if ((o2 = t3.charCodeAt(l2)) !== 32 && o2 !== 10) {
                c2 = true;
                break;
              }
              l2++;
            }
            c2 === true && (n2++, u2--);
          }
          return e2(t3.slice(0, i2))({ type: "inlineCode", value: t3.slice(n2, u2) });
        }
      }
    }
    var _i = function(e2, t3) {
      var r2 = e2.indexOf("\n", t3);
      for (; r2 > t3 && e2.charAt(r2 - 1) === " "; )
        r2--;
      return r2;
    };
    var Ui = _i, Mi = zi;
    zi.locator = Ui;
    function zi(e2, t3, r2) {
      for (var n2, u2 = t3.length, i2 = -1, o2 = ""; ++i2 < u2; ) {
        if ((n2 = t3.charAt(i2)) === "\n") {
          if (i2 < 2)
            return;
          return !!r2 || e2(o2 += n2)({ type: "break" });
        }
        if (n2 !== " ")
          return;
        o2 += n2;
      }
    }
    var Gi = function(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2, f2, D2, p2 = this;
      if (r2)
        return true;
      n2 = p2.inlineMethods, o2 = n2.length, u2 = p2.inlineTokenizers, i2 = -1, f2 = t3.length;
      for (; ++i2 < o2; )
        (l2 = n2[i2]) !== "text" && u2[l2] && ((s2 = u2[l2].locator) || e2.file.fail("Missing locator: `" + l2 + "`"), (c2 = s2.call(p2, t3, 1)) !== -1 && c2 < f2 && (f2 = c2));
      a2 = t3.slice(0, f2), D2 = e2.now(), p2.decode(a2, D2, function(t4, r3, n3) {
        e2(n3 || t4)({ type: "text", value: t4 });
      });
    };
    var Vi = r, Yi = mt, $i = Et, Hi = vt, Xi2 = Zt, Zi = Wt, Wi = Ji;
    function Ji(e2, t3) {
      this.file = t3, this.offset = {}, this.options = Vi(this.options), this.setOptions({}), this.inList = false, this.inBlock = false, this.inLink = false, this.atStart = true, this.toOffset = $i(t3).toOffset, this.unescape = Hi(this, "escape"), this.decode = Xi2(this);
    }
    var Ki = Ji.prototype;
    function Qi(e2) {
      var t3, r2 = [];
      for (t3 in e2)
        r2.push(t3);
      return r2;
    }
    Ki.setOptions = sr, Ki.parse = Sr, Ki.options = ir, Ki.exitStart = Yi("atStart", true), Ki.enterList = Yi("inList", false), Ki.enterLink = Yi("inLink", false), Ki.enterBlock = Yi("inBlock", false), Ki.interruptParagraph = [["thematicBreak"], ["list"], ["atxHeading"], ["fencedCode"], ["blockquote"], ["html"], ["setextHeading", { commonmark: false }], ["definition", { commonmark: false }]], Ki.interruptList = [["atxHeading", { pedantic: false }], ["fencedCode", { pedantic: false }], ["thematicBreak", { pedantic: false }], ["definition", { commonmark: false }]], Ki.interruptBlockquote = [["indentedCode", { commonmark: true }], ["fencedCode", { commonmark: true }], ["atxHeading", { commonmark: true }], ["setextHeading", { commonmark: true }], ["thematicBreak", { commonmark: true }], ["html", { commonmark: true }], ["list", { commonmark: true }], ["definition", { commonmark: false }]], Ki.blockTokenizers = { blankLine: Br, indentedCode: _r, fencedCode: Mr, blockquote: Zr, atxHeading: Wr, thematicBreak: en, list: pn, setextHeading: Fn, html: Sn, definition: Wn, table: uu, paragraph: lu }, Ki.inlineTokenizers = { escape: pu, autoLink: vu, url: Iu, email: zu, html: Hu, link: ei, reference: ci, strong: vi, emphasis: Ti, deletion: Bi, code: qi, break: Mi, text: Gi }, Ki.blockMethods = Qi(Ki.blockTokenizers), Ki.inlineMethods = Qi(Ki.inlineTokenizers), Ki.tokenizeBlock = Zi("block"), Ki.tokenizeInline = Zi("inline"), Ki.tokenizeFactory = Zi;
    var eo = gt2, to = r, ro = Wi, no = uo;
    function uo(e2) {
      var t3 = this.data("settings"), r2 = eo(ro);
      r2.prototype.options = to(r2.prototype.options, t3, e2), this.Parser = r2;
    }
    uo.Parser = ro;
    var io = function(e2) {
      if (e2)
        throw e2;
    };
    var oo = function(e2) {
      return e2 != null && e2.constructor != null && typeof e2.constructor.isBuffer == "function" && e2.constructor.isBuffer(e2);
    }, ao = Object.prototype.hasOwnProperty, co = Object.prototype.toString, so = Object.defineProperty, lo = Object.getOwnPropertyDescriptor, fo = function(e2) {
      return typeof Array.isArray == "function" ? Array.isArray(e2) : co.call(e2) === "[object Array]";
    }, Do = function(e2) {
      if (!e2 || co.call(e2) !== "[object Object]")
        return false;
      var t3, r2 = ao.call(e2, "constructor"), n2 = e2.constructor && e2.constructor.prototype && ao.call(e2.constructor.prototype, "isPrototypeOf");
      if (e2.constructor && !r2 && !n2)
        return false;
      for (t3 in e2)
        ;
      return t3 === void 0 || ao.call(e2, t3);
    }, po = function(e2, t3) {
      so && t3.name === "__proto__" ? so(e2, t3.name, { enumerable: true, configurable: true, value: t3.newValue, writable: true }) : e2[t3.name] = t3.newValue;
    }, ho = function(e2, t3) {
      if (t3 === "__proto__") {
        if (!ao.call(e2, t3))
          return;
        if (lo)
          return lo(e2, t3).value;
      }
      return e2[t3];
    }, go = [].slice, mo = function(e2, t3) {
      var r2;
      return function() {
        var t4, i2 = go.call(arguments, 0), o2 = e2.length > i2.length;
        o2 && i2.push(n2);
        try {
          t4 = e2.apply(null, i2);
        } catch (e3) {
          if (o2 && r2)
            throw e3;
          return n2(e3);
        }
        o2 || (t4 && typeof t4.then == "function" ? t4.then(u2, n2) : t4 instanceof Error ? n2(t4) : u2(t4));
      };
      function n2() {
        r2 || (r2 = true, t3.apply(null, arguments));
      }
      function u2(e3) {
        n2(null, e3);
      }
    };
    var Eo = mo, vo = bo;
    bo.wrap = Eo;
    var yo = [].slice;
    function bo() {
      var e2 = [], t3 = { run: function() {
        var t4 = -1, r2 = yo.call(arguments, 0, -1), n2 = arguments[arguments.length - 1];
        if (typeof n2 != "function")
          throw new Error("Expected function as last argument, not " + n2);
        function u2(i2) {
          var o2 = e2[++t4], a2 = yo.call(arguments, 0), c2 = a2.slice(1), s2 = r2.length, l2 = -1;
          if (i2)
            n2(i2);
          else {
            for (; ++l2 < s2; )
              c2[l2] !== null && c2[l2] !== void 0 || (c2[l2] = r2[l2]);
            r2 = c2, o2 ? Eo(o2, u2).apply(null, r2) : n2.apply(null, [null].concat(r2));
          }
        }
        u2.apply(null, [null].concat(r2));
      }, use: function(r2) {
        if (typeof r2 != "function")
          throw new Error("Expected `fn` to be a function, not " + r2);
        return e2.push(r2), t3;
      } };
      return t3;
    }
    var Co = {}.hasOwnProperty;
    function Ao(e2) {
      return e2 && typeof e2 == "object" || (e2 = {}), Fo(e2.line) + ":" + Fo(e2.column);
    }
    function wo(e2) {
      return e2 && typeof e2 == "object" || (e2 = {}), Ao(e2.start) + "-" + Ao(e2.end);
    }
    function Fo(e2) {
      return e2 && typeof e2 == "number" ? e2 : 1;
    }
    var ko = function(e2) {
      if (!e2 || typeof e2 != "object")
        return "";
      if (Co.call(e2, "position") || Co.call(e2, "type"))
        return wo(e2.position);
      if (Co.call(e2, "start") || Co.call(e2, "end"))
        return wo(e2);
      if (Co.call(e2, "line") || Co.call(e2, "column"))
        return Ao(e2);
      return "";
    }, Oo = So;
    function xo() {
    }
    xo.prototype = Error.prototype, So.prototype = new xo();
    var To = So.prototype;
    function So(e2, t3, r2) {
      var n2, u2, i2;
      typeof t3 == "string" && (r2 = t3, t3 = null), n2 = function(e3) {
        var t4, r3 = [null, null];
        typeof e3 == "string" && ((t4 = e3.indexOf(":")) === -1 ? r3[1] = e3 : (r3[0] = e3.slice(0, t4), r3[1] = e3.slice(t4 + 1)));
        return r3;
      }(r2), u2 = ko(t3) || "1:1", i2 = { start: { line: null, column: null }, end: { line: null, column: null } }, t3 && t3.position && (t3 = t3.position), t3 && (t3.start ? (i2 = t3, t3 = t3.start) : i2.start = t3), e2.stack && (this.stack = e2.stack, e2 = e2.message), this.message = e2, this.name = u2, this.reason = e2, this.line = t3 ? t3.line : null, this.column = t3 ? t3.column : null, this.location = i2, this.source = n2[0], this.ruleId = n2[1];
    }
    function Ro(e2, t3) {
      for (var r2 = 0, n2 = e2.length - 1; n2 >= 0; n2--) {
        var u2 = e2[n2];
        u2 === "." ? e2.splice(n2, 1) : u2 === ".." ? (e2.splice(n2, 1), r2++) : r2 && (e2.splice(n2, 1), r2--);
      }
      if (t3)
        for (; r2--; r2)
          e2.unshift("..");
      return e2;
    }
    To.file = "", To.name = "", To.reason = "", To.message = "", To.stack = "", To.fatal = null, To.column = null, To.line = null;
    var Io = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Bo = function(e2) {
      return Io.exec(e2).slice(1);
    };
    function No() {
      for (var e2 = "", t3 = false, r2 = arguments.length - 1; r2 >= -1 && !t3; r2--) {
        var n2 = r2 >= 0 ? arguments[r2] : "/";
        if (typeof n2 != "string")
          throw new TypeError("Arguments to path.resolve must be strings");
        n2 && (e2 = n2 + "/" + e2, t3 = n2.charAt(0) === "/");
      }
      return e2 = Ro(Go(e2.split("/"), function(e3) {
        return !!e3;
      }), !t3).join("/"), (t3 ? "/" : "") + e2 || ".";
    }
    function Lo(e2) {
      var t3 = Po(e2), r2 = Vo(e2, -1) === "/";
      return e2 = Ro(Go(e2.split("/"), function(e3) {
        return !!e3;
      }), !t3).join("/"), e2 || t3 || (e2 = "."), e2 && r2 && (e2 += "/"), (t3 ? "/" : "") + e2;
    }
    function Po(e2) {
      return e2.charAt(0) === "/";
    }
    function qo() {
      var e2 = Array.prototype.slice.call(arguments, 0);
      return Lo(Go(e2, function(e3, t3) {
        if (typeof e3 != "string")
          throw new TypeError("Arguments to path.join must be strings");
        return e3;
      }).join("/"));
    }
    function jo(e2, t3) {
      function r2(e3) {
        for (var t4 = 0; t4 < e3.length && e3[t4] === ""; t4++)
          ;
        for (var r3 = e3.length - 1; r3 >= 0 && e3[r3] === ""; r3--)
          ;
        return t4 > r3 ? [] : e3.slice(t4, r3 - t4 + 1);
      }
      e2 = No(e2).substr(1), t3 = No(t3).substr(1);
      for (var n2 = r2(e2.split("/")), u2 = r2(t3.split("/")), i2 = Math.min(n2.length, u2.length), o2 = i2, a2 = 0; a2 < i2; a2++)
        if (n2[a2] !== u2[a2]) {
          o2 = a2;
          break;
        }
      var c2 = [];
      for (a2 = o2; a2 < n2.length; a2++)
        c2.push("..");
      return (c2 = c2.concat(u2.slice(o2))).join("/");
    }
    function _o(e2) {
      var t3 = Bo(e2), r2 = t3[0], n2 = t3[1];
      return r2 || n2 ? (n2 && (n2 = n2.substr(0, n2.length - 1)), r2 + n2) : ".";
    }
    function Uo(e2, t3) {
      var r2 = Bo(e2)[2];
      return t3 && r2.substr(-1 * t3.length) === t3 && (r2 = r2.substr(0, r2.length - t3.length)), r2;
    }
    function Mo(e2) {
      return Bo(e2)[3];
    }
    var zo = { extname: Mo, basename: Uo, dirname: _o, sep: "/", delimiter: ":", relative: jo, join: qo, isAbsolute: Po, normalize: Lo, resolve: No };
    function Go(e2, t3) {
      if (e2.filter)
        return e2.filter(t3);
      for (var r2 = [], n2 = 0; n2 < e2.length; n2++)
        t3(e2[n2], n2, e2) && r2.push(e2[n2]);
      return r2;
    }
    var Vo = "ab".substr(-1) === "b" ? function(e2, t3, r2) {
      return e2.substr(t3, r2);
    } : function(e2, t3, r2) {
      return t3 < 0 && (t3 = e2.length + t3), e2.substr(t3, r2);
    }, Yo = t2(Object.freeze({ __proto__: null, resolve: No, normalize: Lo, isAbsolute: Po, join: qo, relative: jo, sep: "/", delimiter: ":", dirname: _o, basename: Uo, extname: Mo, default: zo })), $o = xe, Ho = oo, Xo = Jo, Zo = {}.hasOwnProperty, Wo = ["history", "path", "basename", "stem", "extname", "dirname"];
    function Jo(e2) {
      var t3, r2;
      if (e2) {
        if (typeof e2 == "string" || Ho(e2))
          e2 = { contents: e2 };
        else if ("message" in e2 && "messages" in e2)
          return e2;
      } else
        e2 = {};
      if (!(this instanceof Jo))
        return new Jo(e2);
      for (this.data = {}, this.messages = [], this.history = [], this.cwd = $o.cwd(), r2 = -1; ++r2 < Wo.length; )
        t3 = Wo[r2], Zo.call(e2, t3) && (this[t3] = e2[t3]);
      for (t3 in e2)
        Wo.indexOf(t3) < 0 && (this[t3] = e2[t3]);
    }
    function Ko(e2, t3) {
      if (e2 && e2.indexOf(Yo.sep) > -1)
        throw new Error("`" + t3 + "` cannot be a path: did not expect `" + Yo.sep + "`");
    }
    function Qo(e2, t3) {
      if (!e2)
        throw new Error("`" + t3 + "` cannot be empty");
    }
    function ea(e2, t3) {
      if (!e2)
        throw new Error("Setting `" + t3 + "` requires `path` to be set too");
    }
    Jo.prototype.toString = function(e2) {
      return (this.contents || "").toString(e2);
    }, Object.defineProperty(Jo.prototype, "path", { get: function() {
      return this.history[this.history.length - 1];
    }, set: function(e2) {
      Qo(e2, "path"), this.path !== e2 && this.history.push(e2);
    } }), Object.defineProperty(Jo.prototype, "dirname", { get: function() {
      return typeof this.path == "string" ? Yo.dirname(this.path) : void 0;
    }, set: function(e2) {
      ea(this.path, "dirname"), this.path = Yo.join(e2 || "", this.basename);
    } }), Object.defineProperty(Jo.prototype, "basename", { get: function() {
      return typeof this.path == "string" ? Yo.basename(this.path) : void 0;
    }, set: function(e2) {
      Qo(e2, "basename"), Ko(e2, "basename"), this.path = Yo.join(this.dirname || "", e2);
    } }), Object.defineProperty(Jo.prototype, "extname", { get: function() {
      return typeof this.path == "string" ? Yo.extname(this.path) : void 0;
    }, set: function(e2) {
      if (Ko(e2, "extname"), ea(this.path, "extname"), e2) {
        if (e2.charCodeAt(0) !== 46)
          throw new Error("`extname` must start with `.`");
        if (e2.indexOf(".", 1) > -1)
          throw new Error("`extname` cannot contain multiple dots");
      }
      this.path = Yo.join(this.dirname, this.stem + (e2 || ""));
    } }), Object.defineProperty(Jo.prototype, "stem", { get: function() {
      return typeof this.path == "string" ? Yo.basename(this.path, this.extname) : void 0;
    }, set: function(e2) {
      Qo(e2, "stem"), Ko(e2, "stem"), this.path = Yo.join(this.dirname || "", e2 + (this.extname || ""));
    } });
    var ta = Oo, ra = Xo, na = ra;
    ra.prototype.message = function(e2, t3, r2) {
      var n2 = new ta(e2, t3, r2);
      this.path && (n2.name = this.path + ":" + n2.name, n2.file = this.path);
      return n2.fatal = false, this.messages.push(n2), n2;
    }, ra.prototype.info = function() {
      var e2 = this.message.apply(this, arguments);
      return e2.fatal = null, e2;
    }, ra.prototype.fail = function() {
      var e2 = this.message.apply(this, arguments);
      throw e2.fatal = true, e2;
    };
    var ua = io, ia = oo, oa = function e2() {
      var t3, r2, n2, u2, i2, o2, a2 = arguments[0], c2 = 1, s2 = arguments.length, l2 = false;
      for (typeof a2 == "boolean" && (l2 = a2, a2 = arguments[1] || {}, c2 = 2), (a2 == null || typeof a2 != "object" && typeof a2 != "function") && (a2 = {}); c2 < s2; ++c2)
        if ((t3 = arguments[c2]) != null)
          for (r2 in t3)
            n2 = ho(a2, r2), a2 !== (u2 = ho(t3, r2)) && (l2 && u2 && (Do(u2) || (i2 = fo(u2))) ? (i2 ? (i2 = false, o2 = n2 && fo(n2) ? n2 : []) : o2 = n2 && Do(n2) ? n2 : {}, po(a2, { name: r2, newValue: e2(l2, o2, u2) })) : u2 !== void 0 && po(a2, { name: r2, newValue: u2 }));
      return a2;
    }, aa = (e2) => {
      if (Object.prototype.toString.call(e2) !== "[object Object]")
        return false;
      const t3 = Object.getPrototypeOf(e2);
      return t3 === null || t3 === Object.prototype;
    }, ca = vo, sa = na, la = function e2() {
      var t3, r2 = [], n2 = ca(), u2 = {}, i2 = -1;
      return o2.data = function(e3, r3) {
        if (typeof e3 == "string")
          return arguments.length === 2 ? (ma("data", t3), u2[e3] = r3, o2) : Da.call(u2, e3) && u2[e3] || null;
        if (e3)
          return ma("data", t3), u2 = e3, o2;
        return u2;
      }, o2.freeze = a2, o2.attachers = r2, o2.use = function(e3) {
        var n3;
        if (ma("use", t3), e3 == null)
          ;
        else if (typeof e3 == "function")
          l3.apply(null, arguments);
        else {
          if (typeof e3 != "object")
            throw new Error("Expected usable value, not `" + e3 + "`");
          "length" in e3 ? s3(e3) : i3(e3);
        }
        n3 && (u2.settings = oa(u2.settings || {}, n3));
        return o2;
        function i3(e4) {
          s3(e4.plugins), e4.settings && (n3 = oa(n3 || {}, e4.settings));
        }
        function a3(e4) {
          if (typeof e4 == "function")
            l3(e4);
          else {
            if (typeof e4 != "object")
              throw new Error("Expected usable value, not `" + e4 + "`");
            "length" in e4 ? l3.apply(null, e4) : i3(e4);
          }
        }
        function s3(e4) {
          var t4 = -1;
          if (e4 == null)
            ;
          else {
            if (typeof e4 != "object" || !("length" in e4))
              throw new Error("Expected a list of plugins, not `" + e4 + "`");
            for (; ++t4 < e4.length; )
              a3(e4[t4]);
          }
        }
        function l3(e4, t4) {
          var n4 = c2(e4);
          n4 ? (aa(n4[1]) && aa(t4) && (t4 = oa(true, n4[1], t4)), n4[1] = t4) : r2.push(fa.call(arguments));
        }
      }, o2.parse = function(e3) {
        var t4, r3 = sa(e3);
        if (a2(), da("parse", t4 = o2.Parser), ha(t4, "parse"))
          return new t4(String(r3), r3).parse();
        return t4(String(r3), r3);
      }, o2.stringify = function(e3, t4) {
        var r3, n3 = sa(t4);
        if (a2(), ga("stringify", r3 = o2.Compiler), Ea(e3), ha(r3, "compile"))
          return new r3(e3, n3).compile();
        return r3(e3, n3);
      }, o2.run = s2, o2.runSync = function(e3, t4) {
        var r3, n3;
        return s2(e3, t4, u3), va("runSync", "run", n3), r3;
        function u3(e4, t5) {
          n3 = true, r3 = t5, ua(e4);
        }
      }, o2.process = l2, o2.processSync = f2, o2;
      function o2() {
        for (var t4 = e2(), n3 = -1; ++n3 < r2.length; )
          t4.use.apply(null, r2[n3]);
        return t4.data(oa(true, {}, u2)), t4;
      }
      function a2() {
        var e3, u3;
        if (t3)
          return o2;
        for (; ++i2 < r2.length; )
          (e3 = r2[i2])[1] !== false && (e3[1] === true && (e3[1] = void 0), typeof (u3 = e3[0].apply(o2, e3.slice(1))) == "function" && n2.use(u3));
        return t3 = true, i2 = 1 / 0, o2;
      }
      function c2(e3) {
        for (var t4 = -1; ++t4 < r2.length; )
          if (r2[t4][0] === e3)
            return r2[t4];
      }
      function s2(e3, t4, r3) {
        if (Ea(e3), a2(), r3 || typeof t4 != "function" || (r3 = t4, t4 = null), !r3)
          return new Promise(u3);
        function u3(u4, i3) {
          n2.run(e3, sa(t4), function(t5, n3, o3) {
            n3 = n3 || e3, t5 ? i3(t5) : u4 ? u4(n3) : r3(null, n3, o3);
          });
        }
        u3(null, r3);
      }
      function l2(e3, t4) {
        if (a2(), da("process", o2.Parser), ga("process", o2.Compiler), !t4)
          return new Promise(r3);
        function r3(r4, n3) {
          var u3 = sa(e3);
          pa.run(o2, { file: u3 }, function(e4) {
            e4 ? n3(e4) : r4 ? r4(u3) : t4(null, u3);
          });
        }
        r3(null, t4);
      }
      function f2(e3) {
        var t4, r3;
        return a2(), da("processSync", o2.Parser), ga("processSync", o2.Compiler), l2(t4 = sa(e3), function(e4) {
          r3 = true, ua(e4);
        }), va("processSync", "process", r3), t4;
      }
    }().freeze(), fa = [].slice, Da = {}.hasOwnProperty, pa = ca().use(function(e2, t3) {
      t3.tree = e2.parse(t3.file);
    }).use(function(e2, t3, r2) {
      e2.run(t3.tree, t3.file, function(e3, n2, u2) {
        e3 ? r2(e3) : (t3.tree = n2, t3.file = u2, r2());
      });
    }).use(function(e2, t3) {
      var r2 = e2.stringify(t3.tree, t3.file);
      r2 == null || (typeof r2 == "string" || ia(r2) ? t3.file.contents = r2 : t3.file.result = r2);
    });
    function ha(e2, t3) {
      return typeof e2 == "function" && e2.prototype && (function(e3) {
        var t4;
        for (t4 in e3)
          return true;
        return false;
      }(e2.prototype) || t3 in e2.prototype);
    }
    function da(e2, t3) {
      if (typeof t3 != "function")
        throw new Error("Cannot `" + e2 + "` without `Parser`");
    }
    function ga(e2, t3) {
      if (typeof t3 != "function")
        throw new Error("Cannot `" + e2 + "` without `Compiler`");
    }
    function ma(e2, t3) {
      if (t3)
        throw new Error("Cannot invoke `" + e2 + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
    }
    function Ea(e2) {
      if (!e2 || typeof e2.type != "string")
        throw new Error("Expected node, got `" + e2 + "`");
    }
    function va(e2, t3, r2) {
      if (!r2)
        throw new Error("`" + e2 + "` finished async. Use `" + t3 + "` instead");
    }
    var ya = {};
    ya.isRemarkParser = function(e2) {
      return Boolean(e2 && e2.prototype && e2.prototype.blockTokenizers);
    }, ya.isRemarkCompiler = function(e2) {
      return Boolean(e2 && e2.prototype && e2.prototype.visitors);
    };
    var ba = ya, Ca = function(e2) {
      const t3 = this.Parser, r2 = this.Compiler;
      ba.isRemarkParser(t3) && function(e3, t4) {
        const r3 = e3.prototype, n2 = r3.inlineMethods;
        function u2(e4, t5) {
          return e4.indexOf("$", t5);
        }
        function i2(e4, r4, n3) {
          const u3 = r4.length;
          let i3, o2, a2, c2, s2, l2, f2, D2 = false, p2 = false, h2 = 0;
          if (r4.charCodeAt(h2) === 92 && (p2 = true, h2++), r4.charCodeAt(h2) === Aa) {
            if (h2++, p2)
              return !!n3 || e4(r4.slice(0, h2))({ type: "text", value: "$" });
            if (r4.charCodeAt(h2) === Aa && (D2 = true, h2++), a2 = r4.charCodeAt(h2), a2 !== 32 && a2 !== 9) {
              for (c2 = h2; h2 < u3; ) {
                if (o2 = a2, a2 = r4.charCodeAt(h2 + 1), o2 === Aa) {
                  if (i3 = r4.charCodeAt(h2 - 1), i3 !== 32 && i3 !== 9 && (a2 != a2 || a2 < 48 || a2 > 57) && (!D2 || a2 === Aa)) {
                    s2 = h2 - 1, h2++, D2 && h2++, l2 = h2;
                    break;
                  }
                } else
                  o2 === 92 && (h2++, a2 = r4.charCodeAt(h2 + 1));
                h2++;
              }
              if (l2 !== void 0)
                return !!n3 || (f2 = r4.slice(c2, s2 + 1), e4(r4.slice(0, l2))({ type: "inlineMath", value: f2, data: { hName: "span", hProperties: { className: wa.concat(D2 && t4.inlineMathDouble ? [Fa] : []) }, hChildren: [{ type: "text", value: f2 }] } }));
            }
          }
        }
        i2.locator = u2, r3.inlineTokenizers.math = i2, n2.splice(n2.indexOf("text"), 0, "math");
      }(t3, e2);
      ba.isRemarkCompiler(r2) && function(e3) {
        function t4(e4) {
          let t5 = "$";
          return (e4.data && e4.data.hProperties && e4.data.hProperties.className || []).includes(Fa) && (t5 = "$$"), t5 + e4.value + t5;
        }
        e3.prototype.visitors.inlineMath = t4;
      }(r2);
    };
    const Aa = 36, wa = ["math", "math-inline"], Fa = "math-display";
    const ka = ya;
    var Oa = function() {
      const e2 = this.Parser, t3 = this.Compiler;
      ka.isRemarkParser(e2) && function(e3) {
        const t4 = e3.prototype, r2 = t4.blockMethods, n2 = t4.interruptParagraph, u2 = t4.interruptList, i2 = t4.interruptBlockquote;
        function o2(e4, t5, r3) {
          var n3 = t5.length, u3 = 0;
          let i3, o3, a2, c2, s2, l2, f2, D2, p2, h2, d2;
          for (; u3 < n3 && t5.charCodeAt(u3) === xa; )
            u3++;
          for (s2 = u3; u3 < n3 && t5.charCodeAt(u3) === Ta; )
            u3++;
          if (l2 = u3 - s2, !(l2 < 2)) {
            for (; u3 < n3 && t5.charCodeAt(u3) === xa; )
              u3++;
            for (f2 = u3; u3 < n3; ) {
              if (i3 = t5.charCodeAt(u3), i3 === Ta)
                return;
              if (i3 === 10)
                break;
              u3++;
            }
            if (t5.charCodeAt(u3) === 10) {
              if (r3)
                return true;
              for (o3 = [], f2 !== u3 && o3.push(t5.slice(f2, u3)), u3++, a2 = t5.indexOf(Sa, u3 + 1), a2 = a2 === -1 ? n3 : a2; u3 < n3; ) {
                for (D2 = false, h2 = u3, d2 = a2, c2 = a2, p2 = 0; c2 > h2 && t5.charCodeAt(c2 - 1) === xa; )
                  c2--;
                for (; c2 > h2 && t5.charCodeAt(c2 - 1) === Ta; )
                  p2++, c2--;
                for (l2 <= p2 && t5.indexOf("$", h2) === c2 && (D2 = true, d2 = c2); h2 <= d2 && h2 - u3 < s2 && t5.charCodeAt(h2) === xa; )
                  h2++;
                if (D2)
                  for (; d2 > h2 && t5.charCodeAt(d2 - 1) === xa; )
                    d2--;
                if (D2 && h2 === d2 || o3.push(t5.slice(h2, d2)), D2)
                  break;
                u3 = a2 + 1, a2 = t5.indexOf(Sa, u3 + 1), a2 = a2 === -1 ? n3 : a2;
              }
              return o3 = o3.join("\n"), e4(t5.slice(0, a2))({ type: "math", value: o3, data: { hName: "div", hProperties: { className: Ra.concat() }, hChildren: [{ type: "text", value: o3 }] } });
            }
          }
        }
        t4.blockTokenizers.math = o2, r2.splice(r2.indexOf("fencedCode") + 1, 0, "math"), n2.splice(n2.indexOf("fencedCode") + 1, 0, ["math"]), u2.splice(u2.indexOf("fencedCode") + 1, 0, ["math"]), i2.splice(i2.indexOf("fencedCode") + 1, 0, ["math"]);
      }(e2);
      ka.isRemarkCompiler(t3) && function(e3) {
        function t4(e4) {
          return "$$\n" + e4.value + "\n$$";
        }
        e3.prototype.visitors.math = t4;
      }(t3);
    };
    const xa = 32, Ta = 36, Sa = "\n", Ra = ["math", "math-display"];
    const Ia = Ca, Ba = Oa;
    var Na = function(e2) {
      var t3 = e2 || {};
      Ba.call(this, t3), Ia.call(this, t3);
    };
    var La = function(e2) {
      var t3 = this.Parser, r2 = this.Compiler;
      (function(e3) {
        return Boolean(e3 && e3.prototype && e3.prototype.blockTokenizers);
      })(t3) && function(e3, t4) {
        var r3, n2 = t4 || {}, u2 = e3.prototype, i2 = u2.blockTokenizers, o2 = u2.inlineTokenizers, a2 = u2.blockMethods, c2 = u2.inlineMethods, s2 = i2.definition, l2 = o2.reference, f2 = [], D2 = -1, p2 = a2.length;
        for (; ++D2 < p2; )
          (r3 = a2[D2]) !== "newline" && r3 !== "indentedCode" && r3 !== "paragraph" && r3 !== "footnoteDefinition" && f2.push([r3]);
        f2.push(["footnoteDefinition"]), n2.inlineNotes && (za(c2, "reference", "inlineNote"), o2.inlineNote = g2);
        function h2(e4, t5, r4) {
          for (var n3, u3, o3, a3, c3, s3, l3, f3, D3, p3, h3, d3, g3, m3 = this, E3 = m3.interruptFootnoteDefinition, v3 = m3.offset, y3 = t5.length + 1, b2 = 0, C3 = []; b2 < y3 && ((a3 = t5.charCodeAt(b2)) === 9 || a3 === qa); )
            b2++;
          if (t5.charCodeAt(b2++) === ja && t5.charCodeAt(b2++) === Ua) {
            for (u3 = b2; b2 < y3; ) {
              if ((a3 = t5.charCodeAt(b2)) != a3 || a3 === Pa || a3 === 9 || a3 === qa)
                return;
              if (a3 === _a) {
                o3 = b2, b2++;
                break;
              }
              b2++;
            }
            if (o3 !== void 0 && u3 !== o3 && t5.charCodeAt(b2++) === 58) {
              if (r4)
                return true;
              for (n3 = t5.slice(u3, o3), c3 = e4.now(), D3 = 0, p3 = 0, h3 = b2, d3 = []; b2 < y3; ) {
                if ((a3 = t5.charCodeAt(b2)) != a3 || a3 === Pa)
                  g3 = { start: D3, contentStart: h3 || b2, contentEnd: b2, end: b2 }, d3.push(g3), a3 === Pa && (D3 = b2 + 1, p3 = 0, h3 = void 0, g3.end = D3);
                else if (p3 !== void 0)
                  if (a3 === qa || a3 === 9)
                    (p3 += a3 === qa ? 1 : 4 - p3 % 4) > 4 && (p3 = void 0, h3 = b2);
                  else {
                    if (p3 < 4 && g3 && (g3.contentStart === g3.contentEnd || Ga(E3, i2, m3, [e4, t5.slice(b2, 1024), true])))
                      break;
                    p3 = void 0, h3 = b2;
                  }
                b2++;
              }
              for (b2 = -1, y3 = d3.length; y3 > 0 && (g3 = d3[y3 - 1]).contentStart === g3.contentEnd; )
                y3--;
              for (s3 = e4(t5.slice(0, g3.contentEnd)); ++b2 < y3; )
                g3 = d3[b2], v3[c3.line + b2] = (v3[c3.line + b2] || 0) + (g3.contentStart - g3.start), C3.push(t5.slice(g3.contentStart, g3.end));
              return l3 = m3.enterBlock(), f3 = m3.tokenizeBlock(C3.join(""), c3), l3(), s3({ type: "footnoteDefinition", identifier: n3.toLowerCase(), label: n3, children: f3 });
            }
          }
        }
        function d2(e4, t5, r4) {
          var n3, u3, i3, o3, a3 = t5.length + 1, c3 = 0;
          if (t5.charCodeAt(c3++) === ja && t5.charCodeAt(c3++) === Ua) {
            for (u3 = c3; c3 < a3; ) {
              if ((o3 = t5.charCodeAt(c3)) != o3 || o3 === Pa || o3 === 9 || o3 === qa)
                return;
              if (o3 === _a) {
                i3 = c3, c3++;
                break;
              }
              c3++;
            }
            if (i3 !== void 0 && u3 !== i3)
              return !!r4 || (n3 = t5.slice(u3, i3), e4(t5.slice(0, c3))({ type: "footnoteReference", identifier: n3.toLowerCase(), label: n3 }));
          }
        }
        function g2(e4, t5, r4) {
          var n3, u3, i3, o3, a3, c3, s3, l3 = this, f3 = t5.length + 1, D3 = 0, p3 = 0;
          if (t5.charCodeAt(D3++) === Ua && t5.charCodeAt(D3++) === ja) {
            for (i3 = D3; D3 < f3; ) {
              if ((u3 = t5.charCodeAt(D3)) != u3)
                return;
              if (c3 === void 0)
                if (u3 === 92)
                  D3 += 2;
                else if (u3 === ja)
                  p3++, D3++;
                else if (u3 === _a) {
                  if (p3 === 0) {
                    o3 = D3, D3++;
                    break;
                  }
                  p3--, D3++;
                } else if (u3 === Ma) {
                  for (a3 = D3, c3 = 1; t5.charCodeAt(a3 + c3) === Ma; )
                    c3++;
                  D3 += c3;
                } else
                  D3++;
              else if (u3 === Ma) {
                for (a3 = D3, s3 = 1; t5.charCodeAt(a3 + s3) === Ma; )
                  s3++;
                D3 += s3, c3 === s3 && (c3 = void 0), s3 = void 0;
              } else
                D3++;
            }
            if (o3 !== void 0)
              return !!r4 || ((n3 = e4.now()).column += 2, n3.offset += 2, e4(t5.slice(0, D3))({ type: "footnote", children: l3.tokenizeInline(t5.slice(i3, o3), n3) }));
          }
        }
        function m2(e4, t5, r4) {
          var n3 = 0;
          if (t5.charCodeAt(n3) === 33 && n3++, t5.charCodeAt(n3) === ja && t5.charCodeAt(n3 + 1) !== Ua)
            return l2.call(this, e4, t5, r4);
        }
        function E2(e4, t5, r4) {
          for (var n3 = 0, u3 = t5.charCodeAt(n3); u3 === qa || u3 === 9; )
            u3 = t5.charCodeAt(++n3);
          if (u3 === ja && t5.charCodeAt(n3 + 1) !== Ua)
            return s2.call(this, e4, t5, r4);
        }
        function v2(e4, t5) {
          return e4.indexOf("[", t5);
        }
        function y2(e4, t5) {
          return e4.indexOf("^[", t5);
        }
        za(a2, "definition", "footnoteDefinition"), za(c2, "reference", "footnoteCall"), i2.definition = E2, i2.footnoteDefinition = h2, o2.footnoteCall = d2, o2.reference = m2, u2.interruptFootnoteDefinition = f2, m2.locator = l2.locator, d2.locator = v2, g2.locator = y2;
      }(t3, e2);
      (function(e3) {
        return Boolean(e3 && e3.prototype && e3.prototype.visitors);
      })(r2) && function(e3) {
        var t4 = e3.prototype.visitors, r3 = "    ";
        function n2(e4) {
          return "^[" + this.all(e4).join("") + "]";
        }
        function u2(e4) {
          return "[^" + (e4.label || e4.identifier) + "]";
        }
        function i2(e4) {
          for (var t5, n3 = this.all(e4).join("\n\n").split("\n"), u3 = 0, i3 = n3.length; ++u3 < i3; )
            (t5 = n3[u3]) !== "" && (n3[u3] = r3 + t5);
          return "[^" + (e4.label || e4.identifier) + "]: " + n3.join("\n");
        }
        t4.footnote = n2, t4.footnoteReference = u2, t4.footnoteDefinition = i2;
      }(r2);
    }, Pa = 10, qa = 32, ja = 91, _a = 93, Ua = 94, Ma = 96;
    function za(e2, t3, r2) {
      e2.splice(e2.indexOf(t3), 0, r2);
    }
    function Ga(e2, t3, r2, n2) {
      for (var u2 = e2.length, i2 = -1; ++i2 < u2; )
        if (t3[e2[i2][0]].apply(r2, n2))
          return true;
      return false;
    }
    const Va = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
    var Ya = function(e2) {
      const t3 = e2.match(Va);
      if (!t3)
        return { content: e2 };
      const { startDelimiter: r2, language: n2, value: u2 = "", endDelimiter: i2 } = t3.groups;
      let o2 = n2.trim() || "yaml";
      if (r2 === "+++" && (o2 = "toml"), o2 !== "yaml" && r2 !== i2)
        return { content: e2 };
      const [a2] = t3;
      return { frontMatter: { type: "front-matter", lang: o2, value: u2, startDelimiter: r2, endDelimiter: i2, raw: a2.replace(/\n$/, "") }, content: a2.replace(/[^\n]/g, " ") + e2.slice(a2.length) };
    };
    const $a = Ya, Ha = ["format", "prettier"];
    function Xa(e2) {
      const t3 = "@(".concat(Ha.join("|"), ")"), r2 = new RegExp(["<!--\\s*".concat(t3, "\\s*-->"), "{\\s*\\/\\*\\s*".concat(t3, "\\s*\\*\\/\\s*}"), "<!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*".concat(t3, "[^\\S\n]*($|\n)[\\s\\S]*\n.*-->")].join("|"), "m"), n2 = e2.match(r2);
      return n2 && n2.index === 0;
    }
    var Za = { startWithPragma: Xa, hasPragma: (e2) => Xa($a(e2).content.trimStart()), insertPragma: (e2) => {
      const t3 = $a(e2), r2 = "<!-- @".concat(Ha[0], " -->");
      return t3.frontMatter ? "".concat(t3.frontMatter.raw, "\n\n").concat(r2, "\n\n").concat(t3.content) : "".concat(r2, "\n\n").concat(t3.content);
    } };
    var Wa = { locStart: function(e2) {
      return e2.position.start.offset;
    }, locEnd: function(e2) {
      return e2.position.end.offset;
    } };
    const Ja = /^import\s/, Ka = /^export\s/, Qa = /^{\s*\/\*(.*)\*\/\s*}/, ec = (e2) => Ja.test(e2), tc = (e2) => Ka.test(e2), rc = (e2, t3) => {
      const r2 = t3.indexOf("\n\n"), n2 = t3.slice(0, r2);
      if (tc(n2) || ec(n2))
        return e2(n2)({ type: tc(n2) ? "export" : "import", value: n2 });
    }, nc = (e2, t3) => {
      const r2 = Qa.exec(t3);
      if (r2)
        return e2(r2[0])({ type: "esComment", value: r2[1].trim() });
    };
    rc.locator = (e2) => tc(e2) || ec(e2) ? -1 : 1, nc.locator = (e2, t3) => e2.indexOf("{", t3);
    var uc = { esSyntax: function() {
      const { Parser: e2 } = this, { blockTokenizers: t3, blockMethods: r2, inlineTokenizers: n2, inlineMethods: u2 } = e2.prototype;
      t3.esSyntax = rc, n2.esComment = nc, r2.splice(r2.indexOf("paragraph"), 0, "esSyntax"), u2.splice(u2.indexOf("text"), 0, "esComment");
    }, BLOCKS_REGEX: "[a-z][a-z0-9]*(\\.[a-z][a-z0-9]*)*|", COMMENT_REGEX: /<!---->|<!---?[^>-](?:-?[^-])*-->/ }, ic2 = { exports: {} };
    const oc = function() {
      let { onlyFirst: e2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const t3 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(t3, e2 ? void 0 : "g");
    };
    var ac2 = { exports: {} };
    const cc = (e2) => !Number.isNaN(e2) && (e2 >= 4352 && (e2 <= 4447 || e2 === 9001 || e2 === 9002 || 11904 <= e2 && e2 <= 12871 && e2 !== 12351 || 12880 <= e2 && e2 <= 19903 || 19968 <= e2 && e2 <= 42182 || 43360 <= e2 && e2 <= 43388 || 44032 <= e2 && e2 <= 55203 || 63744 <= e2 && e2 <= 64255 || 65040 <= e2 && e2 <= 65049 || 65072 <= e2 && e2 <= 65131 || 65281 <= e2 && e2 <= 65376 || 65504 <= e2 && e2 <= 65510 || 110592 <= e2 && e2 <= 110593 || 127488 <= e2 && e2 <= 127569 || 131072 <= e2 && e2 <= 262141));
    ac2.exports = cc, ac2.exports.default = cc;
    const sc2 = (e2) => typeof e2 == "string" ? e2.replace(oc(), "") : e2, lc = ac2.exports, fc = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    }, Dc = (e2) => {
      if (typeof e2 != "string" || e2.length === 0)
        return 0;
      if ((e2 = sc2(e2)).length === 0)
        return 0;
      e2 = e2.replace(fc(), "  ");
      let t3 = 0;
      for (let r2 = 0; r2 < e2.length; r2++) {
        const n2 = e2.codePointAt(r2);
        n2 <= 31 || n2 >= 127 && n2 <= 159 || (n2 >= 768 && n2 <= 879 || (n2 > 65535 && r2++, t3 += lc(n2) ? 2 : 1));
      }
      return t3;
    };
    ic2.exports = Dc, ic2.exports.default = Dc;
    var pc = (e2) => e2[e2.length - 1];
    function hc(e2, t3) {
      if (e2 == null)
        return {};
      var r2, n2, u2 = function(e3, t4) {
        if (e3 == null)
          return {};
        var r3, n3, u3 = {}, i3 = Object.keys(e3);
        for (n3 = 0; n3 < i3.length; n3++)
          r3 = i3[n3], t4.indexOf(r3) >= 0 || (u3[r3] = e3[r3]);
        return u3;
      }(e2, t3);
      if (Object.getOwnPropertySymbols) {
        var i2 = Object.getOwnPropertySymbols(e2);
        for (n2 = 0; n2 < i2.length; n2++)
          r2 = i2[n2], t3.indexOf(r2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, r2) && (u2[r2] = e2[r2]);
      }
      return u2;
    }
    function dc(e2, t3) {
      return t3 || (t3 = e2.slice(0)), Object.freeze(Object.defineProperties(e2, { raw: { value: Object.freeze(t3) } }));
    }
    var gc = function(e2) {
      return e2 && e2.Math == Math && e2;
    }, mc = gc(typeof globalThis == "object" && globalThis) || gc(typeof window == "object" && window) || gc(typeof self == "object" && self) || gc(typeof e == "object" && e) || function() {
      return this;
    }() || Function("return this")(), Ec = {}, vc = function(e2) {
      try {
        return !!e2();
      } catch (e3) {
        return true;
      }
    }, yc = !vc(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] != 7;
    }), bc = Function.prototype.call, Cc = bc.bind ? bc.bind(bc) : function() {
      return bc.apply(bc, arguments);
    }, Ac = {}, wc = {}.propertyIsEnumerable, Fc = Object.getOwnPropertyDescriptor, kc = Fc && !wc.call({ 1: 2 }, 1);
    Ac.f = kc ? function(e2) {
      var t3 = Fc(this, e2);
      return !!t3 && t3.enumerable;
    } : wc;
    var Oc, xc, Tc = function(e2, t3) {
      return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t3 };
    }, Sc2 = Function.prototype, Rc = Sc2.bind, Ic = Sc2.call, Bc = Rc && Rc.bind(Ic), Nc = Rc ? function(e2) {
      return e2 && Bc(Ic, e2);
    } : function(e2) {
      return e2 && function() {
        return Ic.apply(e2, arguments);
      };
    }, Lc = Nc, Pc = Lc({}.toString), qc = Lc("".slice), jc = function(e2) {
      return qc(Pc(e2), 8, -1);
    }, _c = Nc, Uc = vc, Mc = jc, zc = mc.Object, Gc = _c("".split), Vc = Uc(function() {
      return !zc("z").propertyIsEnumerable(0);
    }) ? function(e2) {
      return Mc(e2) == "String" ? Gc(e2, "") : zc(e2);
    } : zc, Yc = mc.TypeError, $c = function(e2) {
      if (e2 == null)
        throw Yc("Can't call method on " + e2);
      return e2;
    }, Hc = Vc, Xc = $c, Zc = function(e2) {
      return Hc(Xc(e2));
    }, Wc = function(e2) {
      return typeof e2 == "function";
    }, Jc = Wc, Kc = function(e2) {
      return typeof e2 == "object" ? e2 !== null : Jc(e2);
    }, Qc = mc, es = Wc, ts = function(e2) {
      return es(e2) ? e2 : void 0;
    }, rs = function(e2, t3) {
      return arguments.length < 2 ? ts(Qc[e2]) : Qc[e2] && Qc[e2][t3];
    }, ns = Nc({}.isPrototypeOf), us = rs("navigator", "userAgent") || "", is = mc, os = us, as = is.process, cs = is.Deno, ss = as && as.versions || cs && cs.version, ls = ss && ss.v8;
    ls && (xc = (Oc = ls.split("."))[0] > 0 && Oc[0] < 4 ? 1 : +(Oc[0] + Oc[1])), !xc && os && (!(Oc = os.match(/Edge\/(\d+)/)) || Oc[1] >= 74) && (Oc = os.match(/Chrome\/(\d+)/)) && (xc = +Oc[1]);
    var fs = xc, Ds = fs, ps = vc, hs = !!Object.getOwnPropertySymbols && !ps(function() {
      var e2 = Symbol();
      return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && Ds && Ds < 41;
    }), ds = hs && !Symbol.sham && typeof Symbol.iterator == "symbol", gs = rs, ms = Wc, Es = ns, vs = ds, ys = mc.Object, bs = vs ? function(e2) {
      return typeof e2 == "symbol";
    } : function(e2) {
      var t3 = gs("Symbol");
      return ms(t3) && Es(t3.prototype, ys(e2));
    }, Cs = mc.String, As = function(e2) {
      try {
        return Cs(e2);
      } catch (e3) {
        return "Object";
      }
    }, ws = Wc, Fs = As, ks = mc.TypeError, Os = function(e2) {
      if (ws(e2))
        return e2;
      throw ks(Fs(e2) + " is not a function");
    }, xs = Os, Ts = function(e2, t3) {
      var r2 = e2[t3];
      return r2 == null ? void 0 : xs(r2);
    }, Ss = Cc, Rs = Wc, Is = Kc, Bs = mc.TypeError, Ns = { exports: {} }, Ls = mc, Ps = Object.defineProperty, qs = function(e2, t3) {
      try {
        Ps(Ls, e2, { value: t3, configurable: true, writable: true });
      } catch (r2) {
        Ls[e2] = t3;
      }
      return t3;
    }, js = qs, _s = "__core-js_shared__", Us = mc[_s] || js(_s, {}), Ms = Us;
    (Ns.exports = function(e2, t3) {
      return Ms[e2] || (Ms[e2] = t3 !== void 0 ? t3 : {});
    })("versions", []).push({ version: "3.19.1", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
    var zs = $c, Gs = mc.Object, Vs = function(e2) {
      return Gs(zs(e2));
    }, Ys = Vs, $s = Nc({}.hasOwnProperty), Hs = Object.hasOwn || function(e2, t3) {
      return $s(Ys(e2), t3);
    }, Xs = Nc, Zs = 0, Ws = Math.random(), Js = Xs(1 .toString), Ks = function(e2) {
      return "Symbol(" + (e2 === void 0 ? "" : e2) + ")_" + Js(++Zs + Ws, 36);
    }, Qs = mc, el2 = Ns.exports, tl = Hs, rl = Ks, nl = hs, ul = ds, il = el2("wks"), ol = Qs.Symbol, al = ol && ol.for, cl = ul ? ol : ol && ol.withoutSetter || rl, sl = function(e2) {
      if (!tl(il, e2) || !nl && typeof il[e2] != "string") {
        var t3 = "Symbol." + e2;
        nl && tl(ol, e2) ? il[e2] = ol[e2] : il[e2] = ul && al ? al(t3) : cl(t3);
      }
      return il[e2];
    }, ll2 = Cc, fl = Kc, Dl = bs, pl = Ts, hl = function(e2, t3) {
      var r2, n2;
      if (t3 === "string" && Rs(r2 = e2.toString) && !Is(n2 = Ss(r2, e2)))
        return n2;
      if (Rs(r2 = e2.valueOf) && !Is(n2 = Ss(r2, e2)))
        return n2;
      if (t3 !== "string" && Rs(r2 = e2.toString) && !Is(n2 = Ss(r2, e2)))
        return n2;
      throw Bs("Can't convert object to primitive value");
    }, dl = sl, gl2 = mc.TypeError, ml = dl("toPrimitive"), El = function(e2, t3) {
      if (!fl(e2) || Dl(e2))
        return e2;
      var r2, n2 = pl(e2, ml);
      if (n2) {
        if (t3 === void 0 && (t3 = "default"), r2 = ll2(n2, e2, t3), !fl(r2) || Dl(r2))
          return r2;
        throw gl2("Can't convert object to primitive value");
      }
      return t3 === void 0 && (t3 = "number"), hl(e2, t3);
    }, vl = bs, yl = function(e2) {
      var t3 = El(e2, "string");
      return vl(t3) ? t3 : t3 + "";
    }, bl = Kc, Cl = mc.document, Al = bl(Cl) && bl(Cl.createElement), wl = function(e2) {
      return Al ? Cl.createElement(e2) : {};
    }, Fl = !yc && !vc(function() {
      return Object.defineProperty(wl("div"), "a", { get: function() {
        return 7;
      } }).a != 7;
    }), kl = yc, Ol = Cc, xl = Ac, Tl = Tc, Sl = Zc, Rl = yl, Il = Hs, Bl = Fl, Nl = Object.getOwnPropertyDescriptor;
    Ec.f = kl ? Nl : function(e2, t3) {
      if (e2 = Sl(e2), t3 = Rl(t3), Bl)
        try {
          return Nl(e2, t3);
        } catch (e3) {
        }
      if (Il(e2, t3))
        return Tl(!Ol(xl.f, e2, t3), e2[t3]);
    };
    var Ll2 = {}, Pl = mc, ql = Kc, jl = Pl.String, _l = Pl.TypeError, Ul = function(e2) {
      if (ql(e2))
        return e2;
      throw _l(jl(e2) + " is not an object");
    }, Ml = yc, zl = Fl, Gl = Ul, Vl = yl, Yl = mc.TypeError, $l = Object.defineProperty;
    Ll2.f = Ml ? $l : function(e2, t3, r2) {
      if (Gl(e2), t3 = Vl(t3), Gl(r2), zl)
        try {
          return $l(e2, t3, r2);
        } catch (e3) {
        }
      if ("get" in r2 || "set" in r2)
        throw Yl("Accessors not supported");
      return "value" in r2 && (e2[t3] = r2.value), e2;
    };
    var Hl = Ll2, Xl = Tc, Zl = yc ? function(e2, t3, r2) {
      return Hl.f(e2, t3, Xl(1, r2));
    } : function(e2, t3, r2) {
      return e2[t3] = r2, e2;
    }, Wl = { exports: {} }, Jl = Wc, Kl = Us, Ql = Nc(Function.toString);
    Jl(Kl.inspectSource) || (Kl.inspectSource = function(e2) {
      return Ql(e2);
    });
    var ef, tf, rf, nf = Kl.inspectSource, uf = Wc, of = nf, af2 = mc.WeakMap, cf = uf(af2) && /native code/.test(of(af2)), sf = Ns.exports, lf = Ks, ff = sf("keys"), Df = {}, pf = cf, hf = mc, df = Nc, gf = Kc, mf = Zl, Ef = Hs, vf = Us, yf = function(e2) {
      return ff[e2] || (ff[e2] = lf(e2));
    }, bf = Df, Cf = "Object already initialized", Af = hf.TypeError, wf = hf.WeakMap;
    if (pf || vf.state) {
      var Ff = vf.state || (vf.state = new wf()), kf = df(Ff.get), Of = df(Ff.has), xf = df(Ff.set);
      ef = function(e2, t3) {
        if (Of(Ff, e2))
          throw new Af(Cf);
        return t3.facade = e2, xf(Ff, e2, t3), t3;
      }, tf = function(e2) {
        return kf(Ff, e2) || {};
      }, rf = function(e2) {
        return Of(Ff, e2);
      };
    } else {
      var Tf = yf("state");
      bf[Tf] = true, ef = function(e2, t3) {
        if (Ef(e2, Tf))
          throw new Af(Cf);
        return t3.facade = e2, mf(e2, Tf, t3), t3;
      }, tf = function(e2) {
        return Ef(e2, Tf) ? e2[Tf] : {};
      }, rf = function(e2) {
        return Ef(e2, Tf);
      };
    }
    var Sf = { set: ef, get: tf, has: rf, enforce: function(e2) {
      return rf(e2) ? tf(e2) : ef(e2, {});
    }, getterFor: function(e2) {
      return function(t3) {
        var r2;
        if (!gf(t3) || (r2 = tf(t3)).type !== e2)
          throw Af("Incompatible receiver, " + e2 + " required");
        return r2;
      };
    } }, Rf = yc, If = Hs, Bf = Function.prototype, Nf = Rf && Object.getOwnPropertyDescriptor, Lf = If(Bf, "name"), Pf = Lf && function() {
    }.name === "something", qf = Lf && (!Rf || Rf && Nf(Bf, "name").configurable), jf = mc, _f = Wc, Uf = Hs, Mf = Zl, zf = qs, Gf = nf, Vf = { EXISTS: Lf, PROPER: Pf, CONFIGURABLE: qf }.CONFIGURABLE, Yf = Sf.get, $f = Sf.enforce, Hf = String(String).split("String");
    (Wl.exports = function(e2, t3, r2, n2) {
      var u2, i2 = !!n2 && !!n2.unsafe, o2 = !!n2 && !!n2.enumerable, a2 = !!n2 && !!n2.noTargetGet, c2 = n2 && n2.name !== void 0 ? n2.name : t3;
      _f(r2) && (String(c2).slice(0, 7) === "Symbol(" && (c2 = "[" + String(c2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Uf(r2, "name") || Vf && r2.name !== c2) && Mf(r2, "name", c2), (u2 = $f(r2)).source || (u2.source = Hf.join(typeof c2 == "string" ? c2 : ""))), e2 !== jf ? (i2 ? !a2 && e2[t3] && (o2 = true) : delete e2[t3], o2 ? e2[t3] = r2 : Mf(e2, t3, r2)) : o2 ? e2[t3] = r2 : zf(t3, r2);
    })(Function.prototype, "toString", function() {
      return _f(this) && Yf(this).source || Gf(this);
    });
    var Xf = {}, Zf = Math.ceil, Wf = Math.floor, Jf = function(e2) {
      var t3 = +e2;
      return t3 != t3 || t3 === 0 ? 0 : (t3 > 0 ? Wf : Zf)(t3);
    }, Kf = Jf, Qf = Math.max, eD = Math.min, tD = Jf, rD = Math.min, nD = function(e2) {
      return e2 > 0 ? rD(tD(e2), 9007199254740991) : 0;
    }, uD = function(e2) {
      return nD(e2.length);
    }, iD = Zc, oD = function(e2, t3) {
      var r2 = Kf(e2);
      return r2 < 0 ? Qf(r2 + t3, 0) : eD(r2, t3);
    }, aD = uD, cD = function(e2) {
      return function(t3, r2, n2) {
        var u2, i2 = iD(t3), o2 = aD(i2), a2 = oD(n2, o2);
        if (e2 && r2 != r2) {
          for (; o2 > a2; )
            if ((u2 = i2[a2++]) != u2)
              return true;
        } else
          for (; o2 > a2; a2++)
            if ((e2 || a2 in i2) && i2[a2] === r2)
              return e2 || a2 || 0;
        return !e2 && -1;
      };
    }, sD = { includes: cD(true), indexOf: cD(false) }, lD = Hs, fD = Zc, DD2 = sD.indexOf, pD = Df, hD = Nc([].push), dD = function(e2, t3) {
      var r2, n2 = fD(e2), u2 = 0, i2 = [];
      for (r2 in n2)
        !lD(pD, r2) && lD(n2, r2) && hD(i2, r2);
      for (; t3.length > u2; )
        lD(n2, r2 = t3[u2++]) && (~DD2(i2, r2) || hD(i2, r2));
      return i2;
    }, gD = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype");
    Xf.f = Object.getOwnPropertyNames || function(e2) {
      return dD(e2, gD);
    };
    var mD = {};
    mD.f = Object.getOwnPropertySymbols;
    var ED = rs, vD = Xf, yD = mD, bD = Ul, CD = Nc([].concat), AD = ED("Reflect", "ownKeys") || function(e2) {
      var t3 = vD.f(bD(e2)), r2 = yD.f;
      return r2 ? CD(t3, r2(e2)) : t3;
    }, wD = Hs, FD = AD, kD = Ec, OD = Ll2, xD = vc, TD = Wc, SD = /#|\.prototype\./, RD = function(e2, t3) {
      var r2 = BD[ID(e2)];
      return r2 == LD || r2 != ND && (TD(t3) ? xD(t3) : !!t3);
    }, ID = RD.normalize = function(e2) {
      return String(e2).replace(SD, ".").toLowerCase();
    }, BD = RD.data = {}, ND = RD.NATIVE = "N", LD = RD.POLYFILL = "P", PD = RD, qD = mc, jD = Ec.f, _D = Zl, UD = Wl.exports, MD = qs, zD = function(e2, t3) {
      for (var r2 = FD(t3), n2 = OD.f, u2 = kD.f, i2 = 0; i2 < r2.length; i2++) {
        var o2 = r2[i2];
        wD(e2, o2) || n2(e2, o2, u2(t3, o2));
      }
    }, GD = PD, VD = function(e2, t3) {
      var r2, n2, u2, i2, o2, a2 = e2.target, c2 = e2.global, s2 = e2.stat;
      if (r2 = c2 ? qD : s2 ? qD[a2] || MD(a2, {}) : (qD[a2] || {}).prototype)
        for (n2 in t3) {
          if (i2 = t3[n2], u2 = e2.noTargetGet ? (o2 = jD(r2, n2)) && o2.value : r2[n2], !GD(c2 ? n2 : a2 + (s2 ? "." : "#") + n2, e2.forced) && u2 !== void 0) {
            if (typeof i2 == typeof u2)
              continue;
            zD(i2, u2);
          }
          (e2.sham || u2 && u2.sham) && _D(i2, "sham", true), UD(r2, n2, i2, e2);
        }
    }, YD = jc, $D = Array.isArray || function(e2) {
      return YD(e2) == "Array";
    }, HD = Os, XD = Nc(Nc.bind), ZD = function(e2, t3) {
      return HD(e2), t3 === void 0 ? e2 : XD ? XD(e2, t3) : function() {
        return e2.apply(t3, arguments);
      };
    }, WD = $D, JD = uD, KD = ZD, QD = mc.TypeError, ep = function(e2, t3, r2, n2, u2, i2, o2, a2) {
      for (var c2, s2, l2 = u2, f2 = 0, D2 = !!o2 && KD(o2, a2); f2 < n2; ) {
        if (f2 in r2) {
          if (c2 = D2 ? D2(r2[f2], f2, t3) : r2[f2], i2 > 0 && WD(c2))
            s2 = JD(c2), l2 = ep(e2, t3, c2, s2, l2, i2 - 1) - 1;
          else {
            if (l2 >= 9007199254740991)
              throw QD("Exceed the acceptable array length");
            e2[l2] = c2;
          }
          l2++;
        }
        f2++;
      }
      return l2;
    }, tp = ep, rp = {};
    rp[sl("toStringTag")] = "z";
    var np = mc, up = String(rp) === "[object z]", ip = Wc, op = jc, ap2 = sl("toStringTag"), cp = np.Object, sp = op(function() {
      return arguments;
    }()) == "Arguments", lp = up ? op : function(e2) {
      var t3, r2, n2;
      return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (r2 = function(e3, t4) {
        try {
          return e3[t4];
        } catch (e4) {
        }
      }(t3 = cp(e2), ap2)) == "string" ? r2 : sp ? op(t3) : (n2 = op(t3)) == "Object" && ip(t3.callee) ? "Arguments" : n2;
    }, fp = Nc, Dp = vc, pp = Wc, hp = lp, dp = nf, gp = function() {
    }, mp2 = [], Ep = rs("Reflect", "construct"), vp = /^\s*(?:class|function)\b/, yp = fp(vp.exec), bp = !vp.exec(gp), Cp = function(e2) {
      if (!pp(e2))
        return false;
      try {
        return Ep(gp, mp2, e2), true;
      } catch (e3) {
        return false;
      }
    }, Ap = !Ep || Dp(function() {
      var e2;
      return Cp(Cp.call) || !Cp(Object) || !Cp(function() {
        e2 = true;
      }) || e2;
    }) ? function(e2) {
      if (!pp(e2))
        return false;
      switch (hp(e2)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      return bp || !!yp(vp, dp(e2));
    } : Cp, wp2 = mc, Fp = $D, kp = Ap, Op = Kc, xp = sl("species"), Tp = wp2.Array, Sp = function(e2) {
      var t3;
      return Fp(e2) && (t3 = e2.constructor, (kp(t3) && (t3 === Tp || Fp(t3.prototype)) || Op(t3) && (t3 = t3[xp]) === null) && (t3 = void 0)), t3 === void 0 ? Tp : t3;
    }, Rp = tp, Ip = Os, Bp = Vs, Np = uD, Lp = function(e2, t3) {
      return new (Sp(e2))(t3 === 0 ? 0 : t3);
    };
    VD({ target: "Array", proto: true }, { flatMap: function(e2) {
      var t3, r2 = Bp(this), n2 = Np(r2);
      return Ip(e2), (t3 = Lp(r2, 0)).length = Rp(t3, r2, r2, n2, 0, 1, e2, arguments.length > 1 ? arguments[1] : void 0), t3;
    } });
    var Pp = lp, qp = mc.String, jp = Nc([].slice), _p = Math.floor, Up = function(e2, t3) {
      var r2 = e2.length, n2 = _p(r2 / 2);
      return r2 < 8 ? Mp(e2, t3) : zp(e2, Up(jp(e2, 0, n2), t3), Up(jp(e2, n2), t3), t3);
    }, Mp = function(e2, t3) {
      for (var r2, n2, u2 = e2.length, i2 = 1; i2 < u2; ) {
        for (n2 = i2, r2 = e2[i2]; n2 && t3(e2[n2 - 1], r2) > 0; )
          e2[n2] = e2[--n2];
        n2 !== i2++ && (e2[n2] = r2);
      }
      return e2;
    }, zp = function(e2, t3, r2, n2) {
      for (var u2 = t3.length, i2 = r2.length, o2 = 0, a2 = 0; o2 < u2 || a2 < i2; )
        e2[o2 + a2] = o2 < u2 && a2 < i2 ? n2(t3[o2], r2[a2]) <= 0 ? t3[o2++] : r2[a2++] : o2 < u2 ? t3[o2++] : r2[a2++];
      return e2;
    }, Gp = Up, Vp = vc, Yp = us.match(/firefox\/(\d+)/i), $p = !!Yp && +Yp[1], Hp = /MSIE|Trident/.test(us), Xp = us.match(/AppleWebKit\/(\d+)\./), Zp = !!Xp && +Xp[1], Wp = VD, Jp = Nc, Kp = Os, Qp = Vs, eh = uD, th = function(e2) {
      if (Pp(e2) === "Symbol")
        throw TypeError("Cannot convert a Symbol value to a string");
      return qp(e2);
    }, rh = vc, nh = Gp, uh = function(e2, t3) {
      var r2 = [][e2];
      return !!r2 && Vp(function() {
        r2.call(null, t3 || function() {
          throw 1;
        }, 1);
      });
    }, ih = $p, oh = Hp, ah = fs, ch = Zp, sh = [], lh = Jp(sh.sort), fh = Jp(sh.push), Dh = rh(function() {
      sh.sort(void 0);
    }), ph = rh(function() {
      sh.sort(null);
    }), hh = uh("sort"), dh = !rh(function() {
      if (ah)
        return ah < 70;
      if (!(ih && ih > 3)) {
        if (oh)
          return true;
        if (ch)
          return ch < 603;
        var e2, t3, r2, n2, u2 = "";
        for (e2 = 65; e2 < 76; e2++) {
          switch (t3 = String.fromCharCode(e2), e2) {
            case 66:
            case 69:
            case 70:
            case 72:
              r2 = 3;
              break;
            case 68:
            case 71:
              r2 = 4;
              break;
            default:
              r2 = 2;
          }
          for (n2 = 0; n2 < 47; n2++)
            sh.push({ k: t3 + n2, v: r2 });
        }
        for (sh.sort(function(e3, t4) {
          return t4.v - e3.v;
        }), n2 = 0; n2 < sh.length; n2++)
          t3 = sh[n2].k.charAt(0), u2.charAt(u2.length - 1) !== t3 && (u2 += t3);
        return u2 !== "DGBEFHACIJK";
      }
    });
    Wp({ target: "Array", proto: true, forced: Dh || !ph || !hh || !dh }, { sort: function(e2) {
      e2 !== void 0 && Kp(e2);
      var t3 = Qp(this);
      if (dh)
        return e2 === void 0 ? lh(t3) : lh(t3, e2);
      var r2, n2, u2 = [], i2 = eh(t3);
      for (n2 = 0; n2 < i2; n2++)
        n2 in t3 && fh(u2, t3[n2]);
      for (nh(u2, function(e3) {
        return function(t4, r3) {
          return r3 === void 0 ? -1 : t4 === void 0 ? 1 : e3 !== void 0 ? +e3(t4, r3) || 0 : th(t4) > th(r3) ? 1 : -1;
        };
      }(e2)), r2 = u2.length, n2 = 0; n2 < r2; )
        t3[n2] = u2[n2++];
      for (; n2 < i2; )
        delete t3[n2++];
      return t3;
    } });
    var gh = {}, mh = gh, Eh = sl("iterator"), vh = Array.prototype, yh = lp, bh = Ts, Ch = gh, Ah = sl("iterator"), wh = function(e2) {
      if (e2 != null)
        return bh(e2, Ah) || bh(e2, "@@iterator") || Ch[yh(e2)];
    }, Fh = Cc, kh = Os, Oh = Ul, xh = As, Th = wh, Sh = mc.TypeError, Rh = Cc, Ih = Ul, Bh = Ts, Nh = ZD, Lh = Cc, Ph = Ul, qh = As, jh = function(e2) {
      return e2 !== void 0 && (mh.Array === e2 || vh[Eh] === e2);
    }, _h = uD, Uh = ns, Mh = function(e2, t3) {
      var r2 = arguments.length < 2 ? Th(e2) : t3;
      if (kh(r2))
        return Oh(Fh(r2, e2));
      throw Sh(xh(e2) + " is not iterable");
    }, zh = wh, Gh = function(e2, t3, r2) {
      var n2, u2;
      Ih(e2);
      try {
        if (!(n2 = Bh(e2, "return"))) {
          if (t3 === "throw")
            throw r2;
          return r2;
        }
        n2 = Rh(n2, e2);
      } catch (e3) {
        u2 = true, n2 = e3;
      }
      if (t3 === "throw")
        throw r2;
      if (u2)
        throw n2;
      return Ih(n2), r2;
    }, Vh = mc.TypeError, Yh = function(e2, t3) {
      this.stopped = e2, this.result = t3;
    }, $h = Yh.prototype, Hh = yl, Xh = Ll2, Zh = Tc, Wh = function(e2, t3, r2) {
      var n2, u2, i2, o2, a2, c2, s2, l2 = r2 && r2.that, f2 = !(!r2 || !r2.AS_ENTRIES), D2 = !(!r2 || !r2.IS_ITERATOR), p2 = !(!r2 || !r2.INTERRUPTED), h2 = Nh(t3, l2), d2 = function(e3) {
        return n2 && Gh(n2, "normal", e3), new Yh(true, e3);
      }, g2 = function(e3) {
        return f2 ? (Ph(e3), p2 ? h2(e3[0], e3[1], d2) : h2(e3[0], e3[1])) : p2 ? h2(e3, d2) : h2(e3);
      };
      if (D2)
        n2 = e2;
      else {
        if (!(u2 = zh(e2)))
          throw Vh(qh(e2) + " is not iterable");
        if (jh(u2)) {
          for (i2 = 0, o2 = _h(e2); o2 > i2; i2++)
            if ((a2 = g2(e2[i2])) && Uh($h, a2))
              return a2;
          return new Yh(false);
        }
        n2 = Mh(e2, u2);
      }
      for (c2 = n2.next; !(s2 = Lh(c2, n2)).done; ) {
        try {
          a2 = g2(s2.value);
        } catch (e3) {
          Gh(n2, "throw", e3);
        }
        if (typeof a2 == "object" && a2 && Uh($h, a2))
          return a2;
      }
      return new Yh(false);
    }, Jh = function(e2, t3, r2) {
      var n2 = Hh(t3);
      n2 in e2 ? Xh.f(e2, n2, Zh(0, r2)) : e2[n2] = r2;
    };
    VD({ target: "Object", stat: true }, { fromEntries: function(e2) {
      var t3 = {};
      return Wh(e2, function(e3, r2) {
        Jh(t3, e3, r2);
      }, { AS_ENTRIES: true }), t3;
    } });
    const Kh = typeof xe == "object" && xe.env && xe.env.NODE_DEBUG && /\bsemver\b/i.test(xe.env.NODE_DEBUG) ? function() {
      for (var e2 = arguments.length, t3 = new Array(e2), r2 = 0; r2 < e2; r2++)
        t3[r2] = arguments[r2];
      return console.error("SEMVER", ...t3);
    } : () => {
    };
    var Qh = Kh;
    var ed = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 }, td = { exports: {} };
    !function(e2, t3) {
      const { MAX_SAFE_COMPONENT_LENGTH: r2 } = ed, n2 = Qh, u2 = (t3 = e2.exports = {}).re = [], i2 = t3.src = [], o2 = t3.t = {};
      let a2 = 0;
      const c2 = (e3, t4, r3) => {
        const c3 = a2++;
        n2(c3, t4), o2[e3] = c3, i2[c3] = t4, u2[c3] = new RegExp(t4, r3 ? "g" : void 0);
      };
      c2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), c2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), c2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), c2("MAINVERSION", "(".concat(i2[o2.NUMERICIDENTIFIER], ")\\.") + "(".concat(i2[o2.NUMERICIDENTIFIER], ")\\.") + "(".concat(i2[o2.NUMERICIDENTIFIER], ")")), c2("MAINVERSIONLOOSE", "(".concat(i2[o2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i2[o2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i2[o2.NUMERICIDENTIFIERLOOSE], ")")), c2("PRERELEASEIDENTIFIER", "(?:".concat(i2[o2.NUMERICIDENTIFIER], "|").concat(i2[o2.NONNUMERICIDENTIFIER], ")")), c2("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(i2[o2.NUMERICIDENTIFIERLOOSE], "|").concat(i2[o2.NONNUMERICIDENTIFIER], ")")), c2("PRERELEASE", "(?:-(".concat(i2[o2.PRERELEASEIDENTIFIER], "(?:\\.").concat(i2[o2.PRERELEASEIDENTIFIER], ")*))")), c2("PRERELEASELOOSE", "(?:-?(".concat(i2[o2.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(i2[o2.PRERELEASEIDENTIFIERLOOSE], ")*))")), c2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), c2("BUILD", "(?:\\+(".concat(i2[o2.BUILDIDENTIFIER], "(?:\\.").concat(i2[o2.BUILDIDENTIFIER], ")*))")), c2("FULLPLAIN", "v?".concat(i2[o2.MAINVERSION]).concat(i2[o2.PRERELEASE], "?").concat(i2[o2.BUILD], "?")), c2("FULL", "^".concat(i2[o2.FULLPLAIN], "$")), c2("LOOSEPLAIN", "[v=\\s]*".concat(i2[o2.MAINVERSIONLOOSE]).concat(i2[o2.PRERELEASELOOSE], "?").concat(i2[o2.BUILD], "?")), c2("LOOSE", "^".concat(i2[o2.LOOSEPLAIN], "$")), c2("GTLT", "((?:<|>)?=?)"), c2("XRANGEIDENTIFIERLOOSE", "".concat(i2[o2.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), c2("XRANGEIDENTIFIER", "".concat(i2[o2.NUMERICIDENTIFIER], "|x|X|\\*")), c2("XRANGEPLAIN", "[v=\\s]*(".concat(i2[o2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i2[o2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i2[o2.XRANGEIDENTIFIER], ")") + "(?:".concat(i2[o2.PRERELEASE], ")?").concat(i2[o2.BUILD], "?") + ")?)?"), c2("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(i2[o2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i2[o2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i2[o2.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(i2[o2.PRERELEASELOOSE], ")?").concat(i2[o2.BUILD], "?") + ")?)?"), c2("XRANGE", "^".concat(i2[o2.GTLT], "\\s*").concat(i2[o2.XRANGEPLAIN], "$")), c2("XRANGELOOSE", "^".concat(i2[o2.GTLT], "\\s*").concat(i2[o2.XRANGEPLAINLOOSE], "$")), c2("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(r2, "})") + "(?:\\.(\\d{1,".concat(r2, "}))?") + "(?:\\.(\\d{1,".concat(r2, "}))?") + "(?:$|[^\\d])"), c2("COERCERTL", i2[o2.COERCE], true), c2("LONETILDE", "(?:~>?)"), c2("TILDETRIM", "(\\s*)".concat(i2[o2.LONETILDE], "\\s+"), true), t3.tildeTrimReplace = "$1~", c2("TILDE", "^".concat(i2[o2.LONETILDE]).concat(i2[o2.XRANGEPLAIN], "$")), c2("TILDELOOSE", "^".concat(i2[o2.LONETILDE]).concat(i2[o2.XRANGEPLAINLOOSE], "$")), c2("LONECARET", "(?:\\^)"), c2("CARETTRIM", "(\\s*)".concat(i2[o2.LONECARET], "\\s+"), true), t3.caretTrimReplace = "$1^", c2("CARET", "^".concat(i2[o2.LONECARET]).concat(i2[o2.XRANGEPLAIN], "$")), c2("CARETLOOSE", "^".concat(i2[o2.LONECARET]).concat(i2[o2.XRANGEPLAINLOOSE], "$")), c2("COMPARATORLOOSE", "^".concat(i2[o2.GTLT], "\\s*(").concat(i2[o2.LOOSEPLAIN], ")$|^$")), c2("COMPARATOR", "^".concat(i2[o2.GTLT], "\\s*(").concat(i2[o2.FULLPLAIN], ")$|^$")), c2("COMPARATORTRIM", "(\\s*)".concat(i2[o2.GTLT], "\\s*(").concat(i2[o2.LOOSEPLAIN], "|").concat(i2[o2.XRANGEPLAIN], ")"), true), t3.comparatorTrimReplace = "$1$2$3", c2("HYPHENRANGE", "^\\s*(".concat(i2[o2.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(i2[o2.XRANGEPLAIN], ")") + "\\s*$"), c2("HYPHENRANGELOOSE", "^\\s*(".concat(i2[o2.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(i2[o2.XRANGEPLAINLOOSE], ")") + "\\s*$"), c2("STAR", "(<|>)?=?\\s*\\*"), c2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), c2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
    }(td, td.exports);
    const rd = ["includePrerelease", "loose", "rtl"];
    var nd = (e2) => e2 ? typeof e2 != "object" ? { loose: true } : rd.filter((t3) => e2[t3]).reduce((e3, t3) => (e3[t3] = true, e3), {}) : {};
    const ud = /^[0-9]+$/, id2 = (e2, t3) => {
      const r2 = ud.test(e2), n2 = ud.test(t3);
      return r2 && n2 && (e2 = +e2, t3 = +t3), e2 === t3 ? 0 : r2 && !n2 ? -1 : n2 && !r2 ? 1 : e2 < t3 ? -1 : 1;
    };
    var od = { compareIdentifiers: id2, rcompareIdentifiers: (e2, t3) => id2(t3, e2) };
    const ad = Qh, { MAX_LENGTH: cd, MAX_SAFE_INTEGER: sd } = ed, { re: ld, t: fd } = td.exports, Dd = nd, { compareIdentifiers: pd } = od;
    class hd {
      constructor(e2, t3) {
        if (t3 = Dd(t3), e2 instanceof hd) {
          if (e2.loose === !!t3.loose && e2.includePrerelease === !!t3.includePrerelease)
            return e2;
          e2 = e2.version;
        } else if (typeof e2 != "string")
          throw new TypeError("Invalid Version: ".concat(e2));
        if (e2.length > cd)
          throw new TypeError("version is longer than ".concat(cd, " characters"));
        ad("SemVer", e2, t3), this.options = t3, this.loose = !!t3.loose, this.includePrerelease = !!t3.includePrerelease;
        const r2 = e2.trim().match(t3.loose ? ld[fd.LOOSE] : ld[fd.FULL]);
        if (!r2)
          throw new TypeError("Invalid Version: ".concat(e2));
        if (this.raw = e2, this.major = +r2[1], this.minor = +r2[2], this.patch = +r2[3], this.major > sd || this.major < 0)
          throw new TypeError("Invalid major version");
        if (this.minor > sd || this.minor < 0)
          throw new TypeError("Invalid minor version");
        if (this.patch > sd || this.patch < 0)
          throw new TypeError("Invalid patch version");
        r2[4] ? this.prerelease = r2[4].split(".").map((e3) => {
          if (/^[0-9]+$/.test(e3)) {
            const t4 = +e3;
            if (t4 >= 0 && t4 < sd)
              return t4;
          }
          return e3;
        }) : this.prerelease = [], this.build = r2[5] ? r2[5].split(".") : [], this.format();
      }
      format() {
        return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
      }
      toString() {
        return this.version;
      }
      compare(e2) {
        if (ad("SemVer.compare", this.version, this.options, e2), !(e2 instanceof hd)) {
          if (typeof e2 == "string" && e2 === this.version)
            return 0;
          e2 = new hd(e2, this.options);
        }
        return e2.version === this.version ? 0 : this.compareMain(e2) || this.comparePre(e2);
      }
      compareMain(e2) {
        return e2 instanceof hd || (e2 = new hd(e2, this.options)), pd(this.major, e2.major) || pd(this.minor, e2.minor) || pd(this.patch, e2.patch);
      }
      comparePre(e2) {
        if (e2 instanceof hd || (e2 = new hd(e2, this.options)), this.prerelease.length && !e2.prerelease.length)
          return -1;
        if (!this.prerelease.length && e2.prerelease.length)
          return 1;
        if (!this.prerelease.length && !e2.prerelease.length)
          return 0;
        let t3 = 0;
        do {
          const r2 = this.prerelease[t3], n2 = e2.prerelease[t3];
          if (ad("prerelease compare", t3, r2, n2), r2 === void 0 && n2 === void 0)
            return 0;
          if (n2 === void 0)
            return 1;
          if (r2 === void 0)
            return -1;
          if (r2 !== n2)
            return pd(r2, n2);
        } while (++t3);
      }
      compareBuild(e2) {
        e2 instanceof hd || (e2 = new hd(e2, this.options));
        let t3 = 0;
        do {
          const r2 = this.build[t3], n2 = e2.build[t3];
          if (ad("prerelease compare", t3, r2, n2), r2 === void 0 && n2 === void 0)
            return 0;
          if (n2 === void 0)
            return 1;
          if (r2 === void 0)
            return -1;
          if (r2 !== n2)
            return pd(r2, n2);
        } while (++t3);
      }
      inc(e2, t3) {
        switch (e2) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t3);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t3);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", t3), this.inc("pre", t3);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", t3), this.inc("pre", t3);
            break;
          case "major":
            this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++, this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0)
              this.prerelease = [0];
            else {
              let e3 = this.prerelease.length;
              for (; --e3 >= 0; )
                typeof this.prerelease[e3] == "number" && (this.prerelease[e3]++, e3 = -2);
              e3 === -1 && this.prerelease.push(0);
            }
            t3 && (this.prerelease[0] === t3 ? isNaN(this.prerelease[1]) && (this.prerelease = [t3, 0]) : this.prerelease = [t3, 0]);
            break;
          default:
            throw new Error("invalid increment argument: ".concat(e2));
        }
        return this.format(), this.raw = this.version, this;
      }
    }
    const dd2 = hd;
    var gd = (e2, t3, r2) => new dd2(e2, r2).compare(new dd2(t3, r2));
    const md = gd;
    var Ed = (e2, t3, r2) => md(e2, t3, r2) < 0;
    const vd = gd;
    var yd, bd, Cd, Ad, wd, Fd, kd = (e2, t3, r2) => vd(e2, t3, r2) >= 0, Od = { exports: {} };
    !function(e2, t3) {
      function r2() {
        for (var e3 = [], t4 = 0; t4 < arguments.length; t4++)
          e3[t4] = arguments[t4];
      }
      function n2() {
        return typeof WeakMap != "undefined" ? /* @__PURE__ */ new WeakMap() : { add: r2, delete: r2, get: r2, set: r2, has: function(e3) {
          return false;
        } };
      }
      Object.defineProperty(t3, "__esModule", { value: true }), t3.outdent = void 0;
      var u2 = Object.prototype.hasOwnProperty, i2 = function(e3, t4) {
        return u2.call(e3, t4);
      };
      function o2(e3, t4) {
        for (var r3 in t4)
          i2(t4, r3) && (e3[r3] = t4[r3]);
        return e3;
      }
      var a2 = /^[ \t]*(?:\r\n|\r|\n)/, c2 = /(?:\r\n|\r|\n)[ \t]*$/, s2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, f2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
      function D2(e3, t4, r3) {
        var n3 = 0, u3 = e3[0].match(l2);
        u3 && (n3 = u3[1].length);
        var i3 = new RegExp("(\\r\\n|\\r|\\n).{0," + n3 + "}", "g");
        t4 && (e3 = e3.slice(1));
        var o3 = r3.newline, s3 = r3.trimLeadingNewline, f3 = r3.trimTrailingNewline, D3 = typeof o3 == "string", p3 = e3.length;
        return e3.map(function(e4, t5) {
          return e4 = e4.replace(i3, "$1"), t5 === 0 && s3 && (e4 = e4.replace(a2, "")), t5 === p3 - 1 && f3 && (e4 = e4.replace(c2, "")), D3 && (e4 = e4.replace(/\r\n|\n|\r/g, function(e5) {
            return o3;
          })), e4;
        });
      }
      function p2(e3, t4) {
        for (var r3 = "", n3 = 0, u3 = e3.length; n3 < u3; n3++)
          r3 += e3[n3], n3 < u3 - 1 && (r3 += t4[n3]);
        return r3;
      }
      function h2(e3) {
        return i2(e3, "raw") && i2(e3, "length");
      }
      var d2 = function e3(t4) {
        var r3 = n2(), u3 = n2(), i3 = o2(function n3(i4) {
          for (var a3 = [], c3 = 1; c3 < arguments.length; c3++)
            a3[c3 - 1] = arguments[c3];
          if (h2(i4)) {
            var l3 = i4, g2 = (a3[0] === n3 || a3[0] === d2) && f2.test(l3[0]) && s2.test(l3[1]), m2 = g2 ? u3 : r3, E2 = m2.get(l3);
            if (E2 || (E2 = D2(l3, g2, t4), m2.set(l3, E2)), a3.length === 0)
              return E2[0];
            var v2 = p2(E2, g2 ? a3.slice(1) : a3);
            return v2;
          }
          return e3(o2(o2({}, t4), i4 || {}));
        }, { string: function(e4) {
          return D2([e4], false, t4)[0];
        } });
        return i3;
      }({ trimLeadingNewline: true, trimTrailingNewline: true });
      t3.outdent = d2, t3.default = d2;
      try {
        e2.exports = d2, Object.defineProperty(d2, "__esModule", { value: true }), d2.default = d2, d2.outdent = d2;
      } catch (e3) {
      }
    }(Od, Od.exports);
    const { outdent: xd } = Od.exports, Td = "Config", Sd = "Editor", Rd = "Other", Id = "Global", Bd = "Special", Nd = { cursorOffset: { since: "1.4.0", category: Bd, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: xd(yd || (yd = dc(["\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "]))), cliCategory: Sd }, endOfLine: { since: "1.15.0", category: Id, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: xd(bd || (bd = dc(["\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "]))) }] }, filepath: { since: "1.4.0", category: Bd, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: Rd, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: Bd, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: Rd }, parser: { since: "0.0.10", category: Id, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: Id, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: Td }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: Id, description: xd(Cd || (Cd = dc(["\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "]))), exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin-search-dir", cliCategory: Td }, printWidth: { since: "0.0.0", category: Id, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: Bd, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: xd(Ad || (Ad = dc(["\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))), cliCategory: Sd }, rangeStart: { since: "1.4.0", category: Bd, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: xd(wd || (wd = dc(["\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))), cliCategory: Sd }, requirePragma: { since: "1.7.0", category: Bd, type: "boolean", default: false, description: xd(Fd || (Fd = dc(["\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "]))), cliCategory: Rd }, tabWidth: { type: "int", category: Id, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: Id, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: Id, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
    const Ld = ["cliName", "cliCategory", "cliDescription"], Pd = { compare: gd, lt: Ed, gte: kd }, qd = (e2, t3) => Object.entries(e2).map((e3) => {
      let [r2, n2] = e3;
      return Object.assign({ [t3]: r2 }, n2);
    }), jd = "2.5.1", _d = { CATEGORY_CONFIG: Td, CATEGORY_EDITOR: Sd, CATEGORY_FORMAT: "Format", CATEGORY_OTHER: Rd, CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: Id, CATEGORY_SPECIAL: Bd, options: Nd }.options;
    function Ud(e2, t3, r2) {
      const n2 = new Set(e2.choices.map((e3) => e3.value));
      for (const u2 of t3)
        if (u2.parsers) {
          for (const t4 of u2.parsers)
            if (!n2.has(t4)) {
              n2.add(t4);
              const i2 = r2.find((e3) => e3.parsers && e3.parsers[t4]);
              let o2 = u2.name;
              i2 && i2.name && (o2 += " (plugin: ".concat(i2.name, ")")), e2.choices.push({ value: t4, description: o2 });
            }
        }
    }
    var Md = { getSupportInfo: function() {
      let { plugins: e2 = [], showUnreleased: t3 = false, showDeprecated: r2 = false, showInternal: n2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const u2 = jd.split("-", 1)[0], i2 = e2.flatMap((e3) => e3.languages || []).filter(a2), o2 = qd(Object.assign({}, ...e2.map((e3) => {
        let { options: t4 } = e3;
        return t4;
      }), _d), "name").filter((e3) => a2(e3) && c2(e3)).sort((e3, t4) => e3.name === t4.name ? 0 : e3.name < t4.name ? -1 : 1).map(s2).map((t4) => {
        t4 = Object.assign({}, t4), Array.isArray(t4.default) && (t4.default = t4.default.length === 1 ? t4.default[0].value : t4.default.filter(a2).sort((e3, t5) => Pd.compare(t5.since, e3.since))[0].value), Array.isArray(t4.choices) && (t4.choices = t4.choices.filter((e3) => a2(e3) && c2(e3)), t4.name === "parser" && Ud(t4, i2, e2));
        const r3 = Object.fromEntries(e2.filter((e3) => e3.defaultOptions && e3.defaultOptions[t4.name] !== void 0).map((e3) => [e3.name, e3.defaultOptions[t4.name]]));
        return Object.assign(Object.assign({}, t4), {}, { pluginDefaults: r3 });
      });
      return { languages: i2, options: o2 };
      function a2(e3) {
        return t3 || !("since" in e3) || e3.since && Pd.gte(u2, e3.since);
      }
      function c2(e3) {
        return r2 || !("deprecated" in e3) || e3.deprecated && Pd.lt(u2, e3.deprecated);
      }
      function s2(e3) {
        if (n2)
          return e3;
        return hc(e3, Ld);
      }
    } };
    const zd = ic2.exports, Gd = (e2) => {
      if (typeof e2 != "string")
        throw new TypeError("Expected a string");
      return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }, Vd = pc, { getSupportInfo: Yd } = Md, $d = /[^\x20-\x7F]/;
    function Hd(e2) {
      return (t3, r2, n2) => {
        const u2 = n2 && n2.backwards;
        if (r2 === false)
          return false;
        const { length: i2 } = t3;
        let o2 = r2;
        for (; o2 >= 0 && o2 < i2; ) {
          const r3 = t3.charAt(o2);
          if (e2 instanceof RegExp) {
            if (!e2.test(r3))
              return o2;
          } else if (!e2.includes(r3))
            return o2;
          u2 ? o2-- : o2++;
        }
        return (o2 === -1 || o2 === i2) && o2;
      };
    }
    const Xd = Hd(/\s/), Zd = Hd(" 	"), Wd = Hd(",; 	"), Jd = Hd(/[^\n\r]/);
    function Kd(e2, t3) {
      if (t3 === false)
        return false;
      if (e2.charAt(t3) === "/" && e2.charAt(t3 + 1) === "*") {
        for (let r2 = t3 + 2; r2 < e2.length; ++r2)
          if (e2.charAt(r2) === "*" && e2.charAt(r2 + 1) === "/")
            return r2 + 2;
      }
      return t3;
    }
    function Qd(e2, t3) {
      return t3 !== false && (e2.charAt(t3) === "/" && e2.charAt(t3 + 1) === "/" ? Jd(e2, t3) : t3);
    }
    function eg2(e2, t3, r2) {
      const n2 = r2 && r2.backwards;
      if (t3 === false)
        return false;
      const u2 = e2.charAt(t3);
      if (n2) {
        if (e2.charAt(t3 - 1) === "\r" && u2 === "\n")
          return t3 - 2;
        if (u2 === "\n" || u2 === "\r" || u2 === "\u2028" || u2 === "\u2029")
          return t3 - 1;
      } else {
        if (u2 === "\r" && e2.charAt(t3 + 1) === "\n")
          return t3 + 2;
        if (u2 === "\n" || u2 === "\r" || u2 === "\u2028" || u2 === "\u2029")
          return t3 + 1;
      }
      return t3;
    }
    function tg(e2, t3) {
      let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const n2 = Zd(e2, r2.backwards ? t3 - 1 : t3, r2), u2 = eg2(e2, n2, r2);
      return n2 !== u2;
    }
    function rg(e2, t3) {
      let r2 = null, n2 = t3;
      for (; n2 !== r2; )
        r2 = n2, n2 = Wd(e2, n2), n2 = Kd(e2, n2), n2 = Zd(e2, n2);
      return n2 = Qd(e2, n2), n2 = eg2(e2, n2), n2 !== false && tg(e2, n2);
    }
    function ng(e2, t3) {
      let r2 = null, n2 = t3;
      for (; n2 !== r2; )
        r2 = n2, n2 = Zd(e2, n2), n2 = Kd(e2, n2), n2 = Qd(e2, n2), n2 = eg2(e2, n2);
      return n2;
    }
    function ug(e2, t3, r2) {
      return ng(e2, r2(t3));
    }
    function ig(e2, t3) {
      let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n2 = 0;
      for (let u2 = r2; u2 < e2.length; ++u2)
        e2[u2] === "	" ? n2 = n2 + t3 - n2 % t3 : n2++;
      return n2;
    }
    function og(e2, t3) {
      const r2 = { quote: '"', regex: /"/g, escaped: "&quot;" }, n2 = { quote: "'", regex: /'/g, escaped: "&apos;" }, u2 = t3 === "'" ? n2 : r2, i2 = u2 === n2 ? r2 : n2;
      let o2 = u2;
      if (e2.includes(u2.quote) || e2.includes(i2.quote)) {
        o2 = (e2.match(u2.regex) || []).length > (e2.match(i2.regex) || []).length ? i2 : u2;
      }
      return o2;
    }
    function ag(e2, t3, r2) {
      const n2 = t3 === '"' ? "'" : '"', u2 = e2.replace(/\\(.)|(["'])/gs, (e3, u3, i2) => u3 === n2 ? u3 : i2 === t3 ? "\\" + i2 : i2 || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(u3) ? u3 : "\\" + u3));
      return t3 + u2 + t3;
    }
    function cg(e2, t3) {
      (e2.comments || (e2.comments = [])).push(t3), t3.printed = false, t3.nodeDescription = function(e3) {
        const t4 = e3.type || e3.kind || "(unknown type)";
        let r2 = String(e3.name || e3.id && (typeof e3.id == "object" ? e3.id.name : e3.id) || e3.key && (typeof e3.key == "object" ? e3.key.name : e3.key) || e3.value && (typeof e3.value == "object" ? "" : String(e3.value)) || e3.operator || "");
        r2.length > 20 && (r2 = r2.slice(0, 19) + "\u2026");
        return t4 + (r2 ? " " + r2 : "");
      }(e2);
    }
    var sg = { inferParserByLanguage: function(e2, t3) {
      const { languages: r2 } = Yd({ plugins: t3.plugins }), n2 = r2.find((t4) => {
        let { name: r3 } = t4;
        return r3.toLowerCase() === e2;
      }) || r2.find((t4) => {
        let { aliases: r3 } = t4;
        return Array.isArray(r3) && r3.includes(e2);
      }) || r2.find((t4) => {
        let { extensions: r3 } = t4;
        return Array.isArray(r3) && r3.includes(".".concat(e2));
      });
      return n2 && n2.parsers[0];
    }, getStringWidth: function(e2) {
      return e2 ? $d.test(e2) ? zd(e2) : e2.length : 0;
    }, getMaxContinuousCount: function(e2, t3) {
      const r2 = e2.match(new RegExp("(".concat(Gd(t3), ")+"), "g"));
      return r2 === null ? 0 : r2.reduce((e3, r3) => Math.max(e3, r3.length / t3.length), 0);
    }, getMinNotPresentContinuousCount: function(e2, t3) {
      const r2 = e2.match(new RegExp("(".concat(Gd(t3), ")+"), "g"));
      if (r2 === null)
        return 0;
      const n2 = /* @__PURE__ */ new Map();
      let u2 = 0;
      for (const e3 of r2) {
        const r3 = e3.length / t3.length;
        n2.set(r3, true), r3 > u2 && (u2 = r3);
      }
      for (let e3 = 1; e3 < u2; e3++)
        if (!n2.get(e3))
          return e3;
      return u2 + 1;
    }, getPenultimate: (e2) => e2[e2.length - 2], getLast: Vd, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: ng, getNextNonSpaceNonCommentCharacterIndex: ug, getNextNonSpaceNonCommentCharacter: function(e2, t3, r2) {
      return e2.charAt(ug(e2, t3, r2));
    }, skip: Hd, skipWhitespace: Xd, skipSpaces: Zd, skipToLineEnd: Wd, skipEverythingButNewLine: Jd, skipInlineComment: Kd, skipTrailingComment: Qd, skipNewline: eg2, isNextLineEmptyAfterIndex: rg, isNextLineEmpty: function(e2, t3, r2) {
      return rg(e2, r2(t3));
    }, isPreviousLineEmpty: function(e2, t3, r2) {
      let n2 = r2(t3) - 1;
      return n2 = Zd(e2, n2, { backwards: true }), n2 = eg2(e2, n2, { backwards: true }), n2 = Zd(e2, n2, { backwards: true }), n2 !== eg2(e2, n2, { backwards: true });
    }, hasNewline: tg, hasNewlineInRange: function(e2, t3, r2) {
      for (let n2 = t3; n2 < r2; ++n2)
        if (e2.charAt(n2) === "\n")
          return true;
      return false;
    }, hasSpaces: function(e2, t3) {
      let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const n2 = Zd(e2, r2.backwards ? t3 - 1 : t3, r2);
      return n2 !== t3;
    }, getAlignmentSize: ig, getIndentSize: function(e2, t3) {
      const r2 = e2.lastIndexOf("\n");
      return r2 === -1 ? 0 : ig(e2.slice(r2 + 1).match(/^[\t ]*/)[0], t3);
    }, getPreferredQuote: og, printString: function(e2, t3) {
      const r2 = e2.slice(1, -1);
      return ag(r2, t3.parser === "json" || t3.parser === "json5" && t3.quoteProps === "preserve" && !t3.singleQuote ? '"' : t3.__isInHtmlAttribute ? "'" : og(r2, t3.singleQuote ? "'" : '"').quote, !(t3.parser === "css" || t3.parser === "less" || t3.parser === "scss" || t3.__embeddedInHtml));
    }, printNumber: function(e2) {
      return e2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
    }, makeString: ag, addLeadingComment: function(e2, t3) {
      t3.leading = true, t3.trailing = false, cg(e2, t3);
    }, addDanglingComment: function(e2, t3, r2) {
      t3.leading = false, t3.trailing = false, r2 && (t3.marker = r2), cg(e2, t3);
    }, addTrailingComment: function(e2, t3) {
      t3.leading = false, t3.trailing = true, cg(e2, t3);
    }, isFrontMatterNode: function(e2) {
      return e2 && e2.type === "front-matter";
    }, getShebang: function(e2) {
      if (!e2.startsWith("#!"))
        return "";
      const t3 = e2.indexOf("\n");
      return t3 === -1 ? e2 : e2.slice(0, t3);
    }, isNonEmptyArray: function(e2) {
      return Array.isArray(e2) && e2.length > 0;
    }, createGroupIdMapper: function(e2) {
      const t3 = /* @__PURE__ */ new WeakMap();
      return function(r2) {
        return t3.has(r2) || t3.set(r2, Symbol(e2)), t3.get(r2);
      };
    } };
    const { getLast: lg2 } = sg, { locStart: fg, locEnd: Dg } = Wa, { cjkPattern: pg, kPattern: hg, punctuationPattern: dg } = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" }, gg2 = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], mg = [...gg2, "tableCell", "paragraph", "heading"], Eg = new RegExp(hg), vg = new RegExp(dg);
    function yg(e2, t3) {
      const [, r2, n2, u2] = t3.slice(e2.position.start.offset, e2.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
      return { numberText: r2, marker: n2, leadingSpaces: u2 };
    }
    var bg = { mapAst: function(e2, t3) {
      return function e3(r2, n2, u2) {
        const i2 = Object.assign({}, t3(r2, n2, u2));
        return i2.children && (i2.children = i2.children.map((t4, r3) => e3(t4, r3, [i2, ...u2]))), i2;
      }(e2, null, []);
    }, splitText: function(e2, t3) {
      const r2 = "non-cjk", n2 = "cj-letter", u2 = "cjk-punctuation", i2 = [], o2 = (t3.proseWrap === "preserve" ? e2 : e2.replace(new RegExp("(".concat(pg, ")\n(").concat(pg, ")"), "g"), "$1$2")).split(/([\t\n ]+)/);
      for (const [e3, t4] of o2.entries()) {
        if (e3 % 2 == 1) {
          i2.push({ type: "whitespace", value: /\n/.test(t4) ? "\n" : " " });
          continue;
        }
        if ((e3 === 0 || e3 === o2.length - 1) && t4 === "")
          continue;
        const c2 = t4.split(new RegExp("(".concat(pg, ")")));
        for (const [e4, t5] of c2.entries())
          (e4 !== 0 && e4 !== c2.length - 1 || t5 !== "") && (e4 % 2 != 0 ? a2(vg.test(t5) ? { type: "word", value: t5, kind: u2, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: t5, kind: Eg.test(t5) ? "k-letter" : n2, hasLeadingPunctuation: false, hasTrailingPunctuation: false }) : t5 !== "" && a2({ type: "word", value: t5, kind: r2, hasLeadingPunctuation: vg.test(t5[0]), hasTrailingPunctuation: vg.test(lg2(t5)) }));
      }
      return i2;
      function a2(e3) {
        const t4 = lg2(i2);
        var o3, a3;
        t4 && t4.type === "word" && (t4.kind === r2 && e3.kind === n2 && !t4.hasTrailingPunctuation || t4.kind === n2 && e3.kind === r2 && !e3.hasLeadingPunctuation ? i2.push({ type: "whitespace", value: " " }) : (o3 = r2, a3 = u2, t4.kind === o3 && e3.kind === a3 || t4.kind === a3 && e3.kind === o3 || [t4.value, e3.value].some((e4) => /\u3000/.test(e4)) || i2.push({ type: "whitespace", value: "" }))), i2.push(e3);
      }
    }, punctuationPattern: dg, getFencedCodeBlockValue: function(e2, t3) {
      const { value: r2 } = e2;
      return e2.position.end.offset === t3.length && r2.endsWith("\n") && t3.endsWith("\n") ? r2.slice(0, -1) : r2;
    }, getOrderedListItemInfo: yg, hasGitDiffFriendlyOrderedList: function(e2, t3) {
      if (!e2.ordered)
        return false;
      if (e2.children.length < 2)
        return false;
      const r2 = Number(yg(e2.children[0], t3.originalText).numberText), n2 = Number(yg(e2.children[1], t3.originalText).numberText);
      if (r2 === 0 && e2.children.length > 2) {
        const r3 = Number(yg(e2.children[2], t3.originalText).numberText);
        return n2 === 1 && r3 === 1;
      }
      return n2 === 1;
    }, INLINE_NODE_TYPES: gg2, INLINE_NODE_WRAPPER_TYPES: mg, isAutolink: function(e2) {
      if (!e2 || e2.type !== "link" || e2.children.length !== 1)
        return false;
      const t3 = e2.children[0];
      return t3 && fg(e2) === fg(t3) && Dg(e2) === Dg(t3);
    } };
    const Cg = uc, { mapAst: Ag, INLINE_NODE_WRAPPER_TYPES: wg } = bg;
    var Fg = function() {
      return (e2) => Ag(e2, (e3, t3, r2) => {
        let [n2] = r2;
        return e3.type !== "html" || Cg.COMMENT_REGEX.test(e3.value) || wg.includes(n2.type) ? e3 : Object.assign(Object.assign({}, e3), {}, { type: "jsx" });
      });
    };
    const kg = Ya;
    var Og = function() {
      const e2 = this.Parser.prototype;
      function t3(e3, t4) {
        const r2 = kg(t4);
        if (r2.frontMatter)
          return e3(r2.frontMatter.raw)(r2.frontMatter);
      }
      e2.blockMethods = ["frontMatter", ...e2.blockMethods], e2.blockTokenizers.frontMatter = t3, t3.onlyAtStart = true;
    };
    var xg = function() {
      const e2 = this.Parser.prototype, t3 = e2.inlineMethods;
      function r2(e3, t4) {
        const r3 = t4.match(/^({%.*?%}|{{.*?}})/s);
        if (r3)
          return e3(r3[0])({ type: "liquidNode", value: r3[0] });
      }
      t3.splice(t3.indexOf("text"), 0, "liquid"), e2.inlineTokenizers.liquid = r2, r2.locator = function(e3, t4) {
        return e3.indexOf("{", t4);
      };
    };
    var Tg = function() {
      const e2 = "wikiLink", t3 = /^\[\[(?<linkContents>.+?)]]/s, r2 = this.Parser.prototype, n2 = r2.inlineMethods;
      function u2(r3, n3) {
        const u3 = t3.exec(n3);
        if (u3) {
          const t4 = u3.groups.linkContents.trim();
          return r3(u3[0])({ type: e2, value: t4 });
        }
      }
      n2.splice(n2.indexOf("link"), 0, e2), r2.inlineTokenizers.wikiLink = u2, u2.locator = function(e3, t4) {
        return e3.indexOf("[", t4);
      };
    };
    var Sg = function() {
      const e2 = this.Parser.prototype, t3 = e2.blockTokenizers.list;
      function r2(e3, t4, r3) {
        return t4.type === "listItem" && (t4.loose = t4.spread || e3.charAt(e3.length - 1) === "\n", t4.loose && (r3.loose = true)), t4;
      }
      e2.blockTokenizers.list = function(e3, n2, u2) {
        function i2(t4) {
          const n3 = e3(t4);
          function u3(e4, u4) {
            return n3(r2(t4, e4, u4), u4);
          }
          return u3.reset = function(e4, u4) {
            return n3.reset(r2(t4, e4, u4), u4);
          }, u3;
        }
        return i2.now = e3.now, t3.call(this, i2, n2, u2);
      };
    };
    const Rg = no, Ig = la, Bg = Na, Ng = La, Lg = Za, { locStart: Pg, locEnd: qg } = Wa, jg = uc, _g = Fg, Ug = Og, Mg = xg, zg = Tg, Gg2 = Sg;
    function Vg(e2) {
      let { isMDX: t3 } = e2;
      return (e3) => {
        const r2 = Ig().use(Rg, Object.assign({ commonmark: true }, t3 && { blocks: [jg.BLOCKS_REGEX] })).use(Ng).use(Ug).use(Bg).use(t3 ? jg.esSyntax : Yg).use(Mg).use(t3 ? _g : Yg).use(zg).use(Gg2);
        return r2.runSync(r2.parse(e3));
      };
    }
    function Yg(e2) {
      return e2;
    }
    const $g = { astFormat: "mdast", hasPragma: Lg.hasPragma, locStart: Pg, locEnd: qg }, Hg = Object.assign(Object.assign({}, $g), {}, { parse: Vg({ isMDX: false }) });
    return { parsers: { remark: Hg, markdown: Hg, mdx: Object.assign(Object.assign({}, $g), {}, { parse: Vg({ isMDX: true }) }) } };
  });
})(parserMarkdown$1);
var parserMarkdown = /* @__PURE__ */ getDefaultExportFromCjs(parserMarkdown$1.exports);
const prettierConfig = {
  parser: "markdown",
  plugins: [parserMarkdown]
};
var HotKeyTypes = /* @__PURE__ */ ((HotKeyTypes2) => {
  HotKeyTypes2["ctrlS"] = "Ctrl-s";
  HotKeyTypes2["ctrlB"] = "Ctrl-b";
  HotKeyTypes2["ctrl1"] = "Ctrl-1";
  HotKeyTypes2["ctrl2"] = "Ctrl-2";
  HotKeyTypes2["ctrl3"] = "Ctrl-3";
  HotKeyTypes2["ctrl4"] = "Ctrl-4";
  HotKeyTypes2["ctrl5"] = "Ctrl-5";
  HotKeyTypes2["ctrl6"] = "Ctrl-6";
  HotKeyTypes2["ctrlAltT"] = "Ctrl-Alt-t";
  HotKeyTypes2["ctrlAltM"] = "Ctrl-Alt-m";
  HotKeyTypes2["ctrlAltP"] = "Ctrl-Alt-p";
  HotKeyTypes2["ctrlAltB"] = "Ctrl-Alt-b";
  HotKeyTypes2["ctrlAltI"] = "Ctrl-Alt-i";
  HotKeyTypes2["ctrlAltL"] = "Ctrl-Alt-l";
  HotKeyTypes2["ctrlAltH"] = "Ctrl-Alt-h";
  HotKeyTypes2["ctrlAltQ"] = "Ctrl-Alt-q";
  HotKeyTypes2["shiftAltO"] = "Shift-Alt-o";
  HotKeyTypes2["shiftAltU"] = "Shift-Alt-u";
  HotKeyTypes2["shiftAltT"] = "Shift-Alt-t";
  HotKeyTypes2["shiftAltI"] = "Shift-Alt-i";
  HotKeyTypes2["shiftAltB"] = "Shift-Alt-b";
  HotKeyTypes2["shiftAltL"] = "Shift-Alt-l";
  HotKeyTypes2["F11"] = "F11";
  return HotKeyTypes2;
})(HotKeyTypes || {});
const defaultOptions = {
  initValue: ""
};
class MarkdownEditor extends BaseEditor {
  constructor(id2, options) {
    super(options == null ? void 0 : options.config);
    __publicField(this, "options", defaultOptions);
    __publicField(this, "hotKey", (type, value, view) => {
    });
    const box = this.$$(id2);
    if (!box) {
      return;
    }
    if (options) {
      this.options = Object.assign({}, this.options, options);
    }
    this.box = box;
    const ctrlSHandler = {
      key: "Ctrl-s",
      mac: "Cmd-s",
      preventDefault: true,
      run: (view) => {
        const value = view.state.doc.toString();
        this.hotKey("Ctrl-s", value, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrlSHandler);
    const ctrlBHandler = {
      key: "Ctrl-b",
      mac: "Cmd-b",
      preventDefault: true,
      run: (view) => {
        const value = view.state.doc.toString();
        const _value = this.prettier.format(value, prettierConfig);
        this.setValue(_value);
        this.hotKey("Ctrl-b", {
          old: value,
          value: _value
        }, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrlBHandler);
    const ctrl1Handler = {
      key: "Ctrl-1",
      mac: "Cmd-1",
      preventDefault: true,
      run: (view) => {
        this.toggleInsertLineStart("# ");
        this.hotKey("Ctrl-1", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrl1Handler);
    const ctrl2Handler = {
      key: "Ctrl-2",
      mac: "Cmd-2",
      preventDefault: true,
      run: (view) => {
        this.toggleInsertLineStart("## ");
        this.hotKey("Ctrl-2", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrl2Handler);
    const ctrl3Handler = {
      key: "Ctrl-3",
      mac: "Cmd-3",
      preventDefault: true,
      run: (view) => {
        this.toggleInsertLineStart("### ");
        this.hotKey("Ctrl-3", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrl3Handler);
    const ctrl4Handler = {
      key: "Ctrl-4",
      mac: "Cmd-4",
      preventDefault: true,
      run: (view) => {
        this.toggleInsertLineStart("##### ");
        this.hotKey("Ctrl-4", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrl4Handler);
    const ctrl5Handler = {
      key: "Ctrl-5",
      mac: "Cmd-5",
      preventDefault: true,
      run: (view) => {
        this.toggleInsertLineStart("##### ");
        this.hotKey("Ctrl-5", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrl5Handler);
    const ctrl6Handler = {
      key: "Ctrl-6",
      mac: "Cmd-6",
      preventDefault: true,
      run: (view) => {
        this.toggleInsertLineStart("###### ");
        this.hotKey("Ctrl-6", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrl6Handler);
    const ctrlAltMHandler = {
      key: "Ctrl-Alt-m",
      mac: "Cmd-Alt-m",
      preventDefault: true,
      run: (view) => {
        this.hotKey("Ctrl-Alt-m", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrlAltMHandler);
    const ctrlAltTHandler = {
      key: "Ctrl-Alt-t",
      mac: "Cmd-Alt-t",
      preventDefault: true,
      run: (view) => {
        this.hotKey("Ctrl-Alt-t", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrlAltTHandler);
    const ctrlAltPHandler = {
      key: "Ctrl-Alt-p",
      mac: "Cmd-Alt-p",
      preventDefault: true,
      run: (view) => {
        this.hotKey("Ctrl-Alt-p", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrlAltPHandler);
    const ctrlAltBHandler = {
      key: "Ctrl-Alt-b",
      mac: "Cmd-Alt-b",
      preventDefault: true,
      run: (view) => {
        this.toggleAroundSelection("**", "**");
        this.hotKey("Ctrl-Alt-b", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrlAltBHandler);
    const ctrlAltIHandler = {
      key: "Ctrl-Alt-i",
      mac: "Cmd-Alt-i",
      preventDefault: true,
      run: (view) => {
        this.toggleAroundSelection("*", "*");
        this.hotKey("Ctrl-Alt-i", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrlAltIHandler);
    const ctrlAltLHandler = {
      key: "Ctrl-Alt-l",
      mac: "Cmd-Alt-l",
      preventDefault: true,
      run: (view) => {
        this.toggleAroundSelection("~~", "~~");
        this.hotKey("Ctrl-Alt-l", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrlAltLHandler);
    const ctrlAltHHandler = {
      key: "Ctrl-Alt-h",
      mac: "Cmd-Alt-h",
      preventDefault: true,
      run: (view) => {
        this.insertLineAfterCursor("\n---\n");
        this.hotKey("Ctrl-Alt-h", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrlAltHHandler);
    const ctrlAltQHandler = {
      key: "Ctrl-Alt-q",
      mac: "Cmd-Alt-q",
      preventDefault: true,
      run: (view) => {
        this.insertStartPerLine("> ");
        this.hotKey("Ctrl-Alt-q", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(ctrlAltQHandler);
    const shiftAltOHandler = {
      key: "Shift-Alt-o",
      mac: "Shift-Alt-o",
      preventDefault: true,
      run: (view) => {
        this.insertStartPerLine("{num}. ");
        this.hotKey("Shift-Alt-o", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(shiftAltOHandler);
    const shiftAltUHandler = {
      key: "Shift-Alt-u",
      mac: "Shift-Alt-u",
      preventDefault: true,
      run: (view) => {
        this.insertStartPerLine("- ");
        this.hotKey("Shift-Alt-u", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(shiftAltUHandler);
    const shiftAltTHandler = {
      key: "Shift-Alt-t",
      mac: "Shift-Alt-t",
      preventDefault: true,
      run: (view) => {
        this.insertStartPerLine("- [ ] ");
        this.hotKey("Shift-Alt-t", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(shiftAltTHandler);
    const shiftAltIHandler = {
      key: "Shift-Alt-i",
      mac: "Shift-Alt-i",
      preventDefault: true,
      run: (view) => {
        this.toggleAroundSelection("`", "`");
        this.hotKey("Shift-Alt-i", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(shiftAltIHandler);
    const shiftAltBHandler = {
      key: "Shift-Alt-b",
      mac: "Shift-Alt-b",
      preventDefault: true,
      run: (view) => {
        this.insertLineAfterCursor("```\n```");
        this.setCursor(-4, -4);
        this.hotKey("Shift-Alt-b", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(shiftAltBHandler);
    const shiftAltLHandler = {
      key: "Shift-Alt-l",
      mac: "Shift-Alt-l",
      preventDefault: true,
      run: (view) => {
        this.insertLink();
        this.hotKey("Shift-Alt-l", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(shiftAltLHandler);
    const f11Handler = {
      key: "F11",
      mac: "F11",
      preventDefault: true,
      run: (view) => {
        this.hotKey("F11", null, view);
        return false;
      }
    };
    this.hotKeyMaps.push(f11Handler);
    const hotKeyMaps = [...this.hotKeyMaps];
    this.extensions.push(keymap.of(hotKeyMaps));
    const javascript2 = new LanguageSupport(jsxLanguage);
    const css2 = new LanguageSupport(cssLanguage);
    const json = new LanguageSupport(jsonLanguage);
    const html2 = new LanguageSupport(htmlLanguage, [css2, javascript2]);
    this.extensions.push(markdown({
      base: markdownLanguage,
      codeLanguages: [
        LanguageDescription.of({
          name: "javascript",
          alias: ["js", "jsx"],
          async load() {
            return javascript2;
          }
        }),
        LanguageDescription.of({
          name: "json",
          async load() {
            return json;
          }
        }),
        LanguageDescription.of({
          name: "html",
          alias: ["htm"],
          async load() {
            return html2;
          }
        }),
        LanguageDescription.of({
          name: "css",
          async load() {
            return css2;
          }
        })
      ]
    }));
    this.state = EditorState.create({
      doc: this.options.initValue,
      extensions: this.extensions
    });
    this.view = new EditorView({
      state: this.state,
      parent: this.box
    });
  }
  insertLineStart(insertion) {
    const view = this.view;
    const state = view.state;
    const tr = state.update(state.changeByRange((range2) => {
      const line = state.doc.lineAt(range2.from);
      const text3 = state.sliceDoc(line.from, line.to);
      console.log(line);
      return {
        changes: {
          from: line.from,
          to: line.to,
          insert: `${insertion}${text3}`
        },
        range: EditorSelection.range(line.from + insertion.length, line.to + insertion.length)
      };
    }));
    view.dispatch(tr);
    view.focus();
  }
  removeLineStart(insertion) {
    const { view } = this;
    if (view) {
      const state = view.state;
      const tr = state.update(state.changeByRange((range2) => {
        const line = state.doc.lineAt(range2.from);
        let text3 = state.sliceDoc(line.from, line.to);
        text3 = text3.replace(new RegExp(`^${this.regExpcharacterEscape(insertion)}`), "");
        return {
          changes: {
            from: line.from,
            to: line.to,
            insert: text3
          },
          range: EditorSelection.range(line.from, line.to - insertion.length)
        };
      }));
      view.dispatch(tr);
      view.focus();
    }
  }
  toggleInsertLineStart(insertion) {
    const { view } = this;
    if (view) {
      const state = view.state;
      state.selection.ranges.map((range2) => {
        const line = state.doc.lineAt(range2.from);
        const selectionText = state.sliceDoc(line.from, line.to);
        const hasInsertion = new RegExp(`^${this.regExpcharacterEscape(insertion)}`).test(selectionText);
        if (hasInsertion) {
          this.removeLineStart(insertion);
        } else {
          this.insertLineStart(insertion);
        }
      });
    }
  }
  insertAroundSelection(startInsertion, endInsertion) {
    const { view } = this;
    if (view) {
      const state = view.state;
      const tr = state.update(state.changeByRange((range2) => {
        const text3 = state.sliceDoc(range2.from, range2.to);
        return {
          changes: {
            from: range2.from,
            to: range2.to,
            insert: `${startInsertion}${text3}${endInsertion}`
          },
          range: EditorSelection.range(range2.from + startInsertion.length, range2.to + startInsertion.length)
        };
      }));
      view.dispatch(tr);
      view.focus();
    }
  }
  removeAroundSelection(startInsertion, endInsertion) {
    const { view } = this;
    if (view) {
      const state = view.state;
      const tr = state.update(state.changeByRange((range2) => {
        const from = range2.from - startInsertion.length;
        const to = range2.to + endInsertion.length;
        let text3 = state.sliceDoc(from, to);
        text3 = text3.replace(new RegExp(`^${this.regExpcharacterEscape(startInsertion)}`), "");
        text3 = text3.replace(new RegExp(`${this.regExpcharacterEscape(endInsertion)}$`), "");
        return {
          changes: {
            from,
            to,
            insert: text3
          },
          range: EditorSelection.range(from, to - startInsertion.length - endInsertion.length)
        };
      }));
      view.dispatch(tr);
      view.focus();
    }
  }
  toggleAroundSelection(startInsertion, endInsertion) {
    const { view } = this;
    if (view) {
      const state = view.state;
      state.selection.ranges.map((range2) => {
        const selectionText = state.sliceDoc(range2.from - startInsertion.length, range2.to + endInsertion.length);
        const hasStartInsertion = new RegExp(`^${this.regExpcharacterEscape(startInsertion)}`).test(selectionText);
        const hasEndInsertion = new RegExp(`${this.regExpcharacterEscape(endInsertion)}$`).test(selectionText);
        if (hasStartInsertion && hasEndInsertion) {
          this.removeAroundSelection(startInsertion, endInsertion);
        } else {
          this.insertAroundSelection(startInsertion, endInsertion);
        }
      });
    }
  }
  insertAroundLine(beforeInsertion, afterInsertion) {
    const { view } = this;
    if (view) {
      const state = view.state;
      const tr = state.update(state.changeByRange((range2) => {
        const text3 = state.sliceDoc(range2.from, range2.to);
        const from = range2.from + beforeInsertion.length + 2;
        const to = from;
        return {
          changes: {
            from: range2.from,
            to: range2.to,
            insert: `

${beforeInsertion}${text3 ? "\n" : ""}${text3}
${afterInsertion}

`
          },
          range: EditorSelection.range(from, to)
        };
      }));
      view.dispatch(tr);
      view.focus();
    }
  }
  insertLineAfterCursor(insertion) {
    const { view } = this;
    if (view) {
      const state = view.state;
      const tr = state.update(state.changeByRange((range2) => {
        const _insertion = `
${insertion}
`;
        const to = range2.to;
        return {
          changes: {
            from: to,
            to,
            insert: _insertion
          },
          range: EditorSelection.range(to + _insertion.length - 1, to + _insertion.length - 1)
        };
      }));
      view.dispatch(tr);
      view.focus();
    }
  }
  insertStartPerLine(insertion) {
    const { view } = this;
    if (view) {
      const state = view.state;
      const tr = state.update(state.changeByRange((range2) => {
        const text3 = state.sliceDoc(range2.from, range2.to);
        const textLines = text3.split("\n");
        let offset = 0;
        textLines.forEach((textLine, index2) => {
          const _insertion = insertion.replace(/\{num\}/g, (index2 + 1).toString());
          offset += _insertion.length;
          textLines[index2] = _insertion + textLine;
        });
        const newText = textLines.join("\n");
        return {
          changes: {
            from: range2.from,
            to: range2.to,
            insert: newText
          },
          range: EditorSelection.range(range2.from, range2.to + offset)
        };
      }));
      view.dispatch(tr);
      view.focus();
    }
  }
  insertMedia(url, desc = "") {
    const { view } = this;
    const state = view.state;
    const tr = state.update(state.changeByRange((range2) => {
      const insertion = `![${desc}](${url})`;
      return {
        changes: {
          from: range2.from,
          to: range2.to,
          insert: insertion
        },
        range: EditorSelection.range(range2.to + insertion.length, range2.to + insertion.length)
      };
    }));
    view.dispatch(tr);
    view.focus();
  }
  insertTable(cols, rows) {
    let text3 = "";
    for (let row = 0; row < rows; row++) {
      let cText = "|";
      let dText = row === 0 ? "|" : "";
      for (let col = 0; col < cols; col++) {
        cText += "     |";
        if (row === 0) {
          dText += " --- |";
        }
      }
      text3 += cText + "\n";
      if (row === 0) {
        text3 += dText + "\n";
      }
    }
    this.insertLineAfterCursor(text3);
  }
  insertLink(url = "", title = "") {
    const { view } = this;
    const state = view.state;
    const tr = state.update(state.changeByRange((range2) => {
      let text3 = state.sliceDoc(range2.from, range2.to);
      text3 = text3 || title;
      const _url = url || "https://";
      const insertion = `[${text3}](${_url} "${text3}")`;
      const offset = range2.from + text3.length + _url.length + 3;
      return {
        changes: {
          from: range2.from,
          to: range2.to,
          insert: insertion
        },
        range: EditorSelection.range(offset, offset)
      };
    }));
    view.dispatch(tr);
    view.focus();
  }
}
var index_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main = defineComponent({
  name: "MarkdownEditor",
  props: {
    modelValue: {
      type: String,
      default: ""
    },
    config: {
      type: Object,
      default: () => {
        return {};
      }
    },
    helper: {
      type: Object,
      default: () => {
        return {
          theme: true
        };
      }
    }
  },
  components: {
    EditorDialog,
    EditorUpload,
    EditorTable,
    EditorPreview,
    EditorHelper
  },
  emits: ["ready", "update:modelValue", "change", "focus", "blur", "selectionChange", "hotKey"],
  setup(props, ctx) {
    var _a;
    const prefix = "totonoo-markdown-editor-";
    const id2 = v4();
    const rootBox = ref();
    let editor;
    const uploadVisible = ref(false);
    const uploadDone = (url, desc) => {
      uploadVisible.value = false;
      editor.insertMedia(url, desc);
    };
    const tableVisible = ref(false);
    const tableDone = (cols, rows) => {
      tableVisible.value = false;
      editor.insertTable(cols, rows);
    };
    const previewVisible = ref(false);
    const previewDone = (cols, rows) => {
      previewVisible.value = false;
      editor.insertTable(cols, rows);
    };
    const isFullscreen = ref(false);
    const theme2 = ref(((_a = props.config) == null ? void 0 : _a.theme) || "light");
    watch(() => props.modelValue, (val) => {
      if (editor && editor.getValue() !== val) {
        editor.setValue(val);
      }
    });
    onMounted(() => {
      nextTick(() => {
        editor = new MarkdownEditor(`#${prefix + id2}`, {
          initValue: props.modelValue
        });
        editor.events.change = (update, value) => {
          ctx.emit("update:modelValue", value);
          ctx.emit("change", value, update);
        };
        editor.events.blur = (update, value) => {
          ctx.emit("blur", value, update);
        };
        editor.events.focus = (update, value) => {
          ctx.emit("focus", value, update);
        };
        editor.events.selectionChange = (update, line) => {
          ctx.emit("selectionChange", line, update);
        };
        editor.hotKey = (type, value, view) => {
          switch (type) {
            case HotKeyTypes.ctrlAltM: {
              uploadVisible.value = true;
              break;
            }
            case HotKeyTypes.ctrlAltT: {
              tableVisible.value = true;
              break;
            }
            case HotKeyTypes.ctrlAltP: {
              previewVisible.value = true;
              break;
            }
            case HotKeyTypes.F11: {
              isFullscreen.value = !isFullscreen.value;
              break;
            }
          }
          ctx.emit("hotKey", {
            type,
            value,
            view
          });
        };
      });
    });
    return {
      id: prefix + id2,
      rootBox,
      uploadVisible,
      uploadDone,
      tableVisible,
      tableDone,
      previewVisible,
      previewDone,
      isFullscreen,
      theme: theme2,
      themeChange(theme22) {
        const _theme = theme22 === "dark" ? editor.themeDark : editor.themeLight;
        const _parent = editor.box.parentElement;
        editor.view.dispatch({
          effects: editor.theme.reconfigure(_theme)
        });
        if (_parent) {
          if (theme22 === "dark") {
            _parent.classList.add("dark");
          } else {
            _parent.classList.remove("dark");
          }
        }
      }
    };
  }
});
const _hoisted_1 = ["id"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_editor_upload = resolveComponent("editor-upload");
  const _component_editor_dialog = resolveComponent("editor-dialog");
  const _component_editor_table = resolveComponent("editor-table");
  const _component_editor_preview = resolveComponent("editor-preview");
  const _component_editor_helper = resolveComponent("editor-helper");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["totonoo-markdown-editor", [_ctx.isFullscreen ? "editor-fullscreen" : ""]]),
    ref: "rootBox"
  }, [
    createElementVNode("div", {
      id: _ctx.id,
      class: "content"
    }, null, 8, _hoisted_1),
    createVNode(_component_editor_dialog, {
      modelValue: _ctx.uploadVisible,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.uploadVisible = $event),
      title: "\u5A92\u4F53\u8D44\u6E90"
    }, {
      default: withCtx(() => [
        createVNode(_component_editor_upload, { onDone: _ctx.uploadDone }, null, 8, ["onDone"])
      ]),
      _: 1
    }, 8, ["modelValue"]),
    createVNode(_component_editor_dialog, {
      modelValue: _ctx.tableVisible,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.tableVisible = $event),
      title: "\u63D2\u5165\u8868\u683C"
    }, {
      default: withCtx(() => [
        createVNode(_component_editor_table, { onDone: _ctx.tableDone }, null, 8, ["onDone"])
      ]),
      _: 1
    }, 8, ["modelValue"]),
    createVNode(_component_editor_dialog, {
      modelValue: _ctx.previewVisible,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.previewVisible = $event),
      title: "\u9884\u89C8",
      width: "760px"
    }, {
      default: withCtx(() => [
        createVNode(_component_editor_preview, {
          root: _ctx.rootBox,
          modelValue: _ctx.modelValue,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.modelValue = $event)
        }, null, 8, ["root", "modelValue"])
      ]),
      _: 1
    }, 8, ["modelValue"]),
    createVNode(_component_editor_helper, {
      modelValue: _ctx.theme,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.theme = $event),
      helper: _ctx.helper,
      onThemeChange: _ctx.themeChange
    }, null, 8, ["modelValue", "helper", "onThemeChange"])
  ], 2);
}
var index = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-0c422a8e"]]);
export { index as MarkdownEditor };
